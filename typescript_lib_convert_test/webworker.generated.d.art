/////////////////////////////

/// Worker APIs

/////////////////////////////

тип AddEventListenerOptions = интерфейс
{
  once: ДаНет

  passive: ДаНет

  signal: AbortSignal
}


тип AesCbcParams = интерфейс
{
  iv: BufferSource
}


тип AesCtrParams = интерфейс
{
  counter: BufferSource

  length: Число
}


тип AesDerivedKeyParams = интерфейс
{
  length: Число
}


тип AesGcmParams = интерфейс
{
  additionalData: BufferSource

  iv: BufferSource

  tagLength: Число
}


тип AesKeyAlgorithm = интерфейс
{
  length: Число
}


тип AesKeyGenParams = интерфейс
{
  length: Число
}


тип Algorithm = интерфейс
{
  name: Текст
}


тип AudioConfiguration = интерфейс
{
  bitrate: Число

  channels: Текст

  contentType: Текст

  samplerate: Число

  spatialRendering: ДаНет
}


тип AvcEncoderConfig = интерфейс
{
  format: AvcBitstreamFormat
}


тип BlobPropertyBag = интерфейс
{
  endings: EndingType

  type: Текст
}


тип CSSMatrixComponentOptions = интерфейс
{
  is2D: ДаНет
}


тип CSSNumericType = интерфейс
{
  angle: Число

  flex: Число

  frequency: Число

  length: Число

  percent: Число

  percentHint: CSSNumericBaseType

  resolution: Число

  time: Число
}


тип CacheQueryOptions = интерфейс
{
  ignoreMethod: ДаНет

  ignoreSearch: ДаНет

  ignoreVary: ДаНет
}


тип ClientQueryOptions = интерфейс
{
  includeUncontrolled: ДаНет

  type: ClientTypes
}


тип CloseEventInit = интерфейс
{
  code: Число

  reason: Текст

  wasClean: ДаНет
}


тип CryptoKeyPair = интерфейс
{
  privateKey: CryptoKey

  publicKey: CryptoKey
}


тип CustomEventInit<T> = интерфейс
{
  detail: T
}


тип DOMMatrix2DInit = интерфейс
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m21: Число

  m22: Число

  m41: Число

  m42: Число
}


тип DOMMatrixInit = интерфейс
{
  is2D: ДаНет

  m13: Число

  m14: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m43: Число

  m44: Число
}


тип DOMPointInit = интерфейс
{
  w: Число

  x: Число

  y: Число

  z: Число
}


тип DOMQuadInit = интерфейс
{
  p1: DOMPointInit

  p2: DOMPointInit

  p3: DOMPointInit

  p4: DOMPointInit
}


тип DOMRectInit = интерфейс
{
  height: Число

  width: Число

  x: Число

  y: Число
}


тип EcKeyGenParams = интерфейс
{
  namedCurve: NamedCurve
}


тип EcKeyImportParams = интерфейс
{
  namedCurve: NamedCurve
}


тип EcdhKeyDeriveParams = интерфейс
{
  public: CryptoKey
}


тип EcdsaParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип EncodedVideoChunkInit = интерфейс
{
  data: BufferSource

  duration: Число

  timestamp: Число

  type: EncodedVideoChunkType
}


тип EncodedVideoChunkMetadata = интерфейс
{
  decoderConfig: VideoDecoderConfig
}


тип ErrorEventInit = интерфейс
{
  colno: Число

  error: /*(!) any */ Объект?

  filename: Текст

  lineno: Число

  message: Текст
}


тип EventInit = интерфейс
{
  bubbles: ДаНет

  cancelable: ДаНет

  composed: ДаНет
}


тип EventListenerOptions = интерфейс
{
  capture: ДаНет
}


тип EventSourceInit = интерфейс
{
  withCredentials: ДаНет
}


тип ExtendableEventInit = интерфейс
{

}


тип ExtendableMessageEventInit = интерфейс
{
  data: /*(!) any */ Объект?

  lastEventId: Текст

  origin: Текст

  ports: Список<MessagePort>

  source: Client | ServiceWorker | MessagePort | пусто
}


тип FetchEventInit = интерфейс
{
  clientId: Текст

  handled: Promise<пусто>

  preloadResponse: Promise</*(!) any */ Объект?>

  replacesClientId: Текст

  request: Request

  resultingClientId: Текст
}


тип FilePropertyBag = интерфейс
{
  lastModified: Число
}


тип FileSystemCreateWritableOptions = интерфейс
{
  keepExistingData: ДаНет
}


тип FileSystemGetDirectoryOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemGetFileOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemReadWriteOptions = интерфейс
{
  at: Число
}


тип FileSystemRemoveOptions = интерфейс
{
  recursive: ДаНет
}


тип FontFaceDescriptors = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  featureSettings: Текст

  lineGapOverride: Текст

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant: Текст

  weight: Текст
}


тип FontFaceSetLoadEventInit = интерфейс
{
  fontfaces: Список<FontFace>
}


тип GetNotificationOptions = интерфейс
{
  tag: Текст
}


тип HkdfParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  info: BufferSource

  salt: BufferSource
}


тип HmacImportParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип HmacKeyGenParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип IDBDatabaseInfo = интерфейс
{
  name: Текст

  version: Число
}


тип IDBIndexParameters = интерфейс
{
  multiEntry: ДаНет

  unique: ДаНет
}


тип IDBObjectStoreParameters = интерфейс
{
  autoIncrement: ДаНет

  keyPath: Текст | Список<Текст> | пусто
}


тип IDBTransactionOptions = интерфейс
{
  durability: IDBTransactionDurability
}


тип IDBVersionChangeEventInit = интерфейс
{
  newVersion: Число?FUCKFUCK

  oldVersion: Число
}


тип ImageBitmapOptions = интерфейс
{
  colorSpaceConversion: ColorSpaceConversion

  imageOrientation: ImageOrientation

  premultiplyAlpha: PremultiplyAlpha

  resizeHeight: Число

  resizeQuality: ResizeQuality

  resizeWidth: Число
}


тип ImageBitmapRenderingContextSettings = интерфейс
{
  alpha: ДаНет
}


тип ImageDataSettings = интерфейс
{
  colorSpace: PredefinedColorSpace
}


тип ImageEncodeOptions = интерфейс
{
  quality: Число

  type: Текст
}


тип ImportMeta = интерфейс
{
  url: Текст
}


тип JsonWebKey = интерфейс
{
  alg: Текст

  crv: Текст

  d: Текст

  dp: Текст

  dq: Текст

  e: Текст

  ext: ДаНет

  k: Текст

  key_ops: Список<Текст>

  kty: Текст

  n: Текст

  oth: Список<RsaOtherPrimesInfo>

  p: Текст

  q: Текст

  qi: Текст

  use: Текст

  x: Текст

  y: Текст
}


тип KeyAlgorithm = интерфейс
{
  name: Текст
}


тип LockInfo = интерфейс
{
  clientId: Текст

  mode: LockMode

  name: Текст
}


тип LockManagerSnapshot = интерфейс
{
  held: Список<LockInfo>

  pending: Список<LockInfo>
}


тип LockOptions = интерфейс
{
  ifAvailable: ДаНет

  mode: LockMode

  signal: AbortSignal

  steal: ДаНет
}


тип MediaCapabilitiesDecodingInfo = интерфейс
{
  configuration: MediaDecodingConfiguration
}


тип MediaCapabilitiesEncodingInfo = интерфейс
{
  configuration: MediaEncodingConfiguration
}


тип MediaCapabilitiesInfo = интерфейс
{
  powerEfficient: ДаНет

  smooth: ДаНет

  supported: ДаНет
}


тип MediaConfiguration = интерфейс
{
  audio: AudioConfiguration

  video: VideoConfiguration
}


тип MediaDecodingConfiguration = интерфейс
{
  type: MediaDecodingType
}


тип MediaEncodingConfiguration = интерфейс
{
  type: MediaEncodingType
}


тип MessageEventInit<T> = интерфейс
{
  data: T

  lastEventId: Текст

  origin: Текст

  ports: Список<MessagePort>

  source: MessageEventSource?FUCKFUCK
}


тип MultiCacheQueryOptions = интерфейс
{
  cacheName: Текст
}


тип NavigationPreloadState = интерфейс
{
  enabled: ДаНет

  headerValue: Текст
}


тип NotificationAction = интерфейс
{
  action: Текст

  icon: Текст

  title: Текст
}


тип NotificationEventInit = интерфейс
{
  action: Текст

  notification: Notification
}


тип NotificationOptions = интерфейс
{
  actions: Список<NotificationAction>

  badge: Текст

  body: Текст

  data: /*(!) any */ Объект?

  dir: NotificationDirection

  icon: Текст

  image: Текст

  lang: Текст

  renotify: ДаНет

  requireInteraction: ДаНет

  silent: ДаНет?FUCKFUCK

  tag: Текст

  timestamp: EpochTimeStamp

  vibrate: VibratePattern
}


тип Pbkdf2Params = интерфейс
{
  hash: HashAlgorithmIdentifier

  iterations: Число

  salt: BufferSource
}


тип PerformanceMarkOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  startTime: DOMHighResTimeStamp
}


тип PerformanceMeasureOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  duration: DOMHighResTimeStamp

  end: Текст | DOMHighResTimeStamp

  start: Текст | DOMHighResTimeStamp
}


тип PerformanceObserverInit = интерфейс
{
  buffered: ДаНет

  entryTypes: Список<Текст>

  type: Текст
}


тип PermissionDescriptor = интерфейс
{
  name: PermissionName
}


тип PlaneLayout = интерфейс
{
  offset: Число

  stride: Число
}


тип ProgressEventInit = интерфейс
{
  lengthComputable: ДаНет

  loaded: Число

  total: Число
}


тип PromiseRejectionEventInit = интерфейс
{
  promise: Promise</*(!) any */ Объект?>

  reason: /*(!) any */ Объект?
}


тип PushEventInit = интерфейс
{
  data: PushMessageDataInit
}


тип PushSubscriptionJSON = интерфейс
{
  endpoint: Текст

  expirationTime: EpochTimeStamp?FUCKFUCK

  keys: Record<Текст, Текст>
}


тип PushSubscriptionOptionsInit = интерфейс
{
  applicationServerKey: BufferSource | Текст | пусто

  userVisibleOnly: ДаНет
}


тип QueuingStrategy<T> = интерфейс
{
  highWaterMark: Число

  size: QueuingStrategySize<T>
}


тип QueuingStrategyInit = интерфейс
{
  highWaterMark: Число
}


тип RTCEncodedAudioFrameMetadata = интерфейс
{
  contributingSources: Список<Число>

  synchronizationSource: Число
}


тип RTCEncodedVideoFrameMetadata = интерфейс
{
  dependencies: Список<Число>

  frameId: Число

  height: Число

  spatialIndex: Число

  synchronizationSource: Число

  temporalIndex: Число

  width: Число
}


тип ReadableStreamGetReaderOptions = интерфейс
{
  mode: ReadableStreamReaderMode
}


тип ReadableStreamReadDoneResult<T> = интерфейс
{
  done: да

  value: T
}


тип ReadableStreamReadValueResult<T> = интерфейс
{
  done: нет

  value: T
}


тип ReadableWritablePair<R, W> = интерфейс
{
  readable: ReadableStream<R>

  writable: WritableStream<W>
}


тип RegistrationOptions = интерфейс
{
  scope: Текст

  type: WorkerType

  updateViaCache: ServiceWorkerUpdateViaCache
}


тип ReportingObserverOptions = интерфейс
{
  buffered: ДаНет

  types: Список<Текст>
}


тип RequestInit = интерфейс
{
  body: BodyInit?FUCKFUCK

  cache: RequestCache

  credentials: RequestCredentials

  headers: HeadersInit

  integrity: Текст

  keepalive: ДаНет

  method: Текст

  mode: RequestMode

  redirect: RequestRedirect

  referrer: Текст

  referrerPolicy: ReferrerPolicy

  signal: AbortSignal?FUCKFUCK

  window: пусто
}


тип ResponseInit = интерфейс
{
  headers: HeadersInit

  status: Число

  statusText: Текст
}


тип RsaHashedImportParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип RsaHashedKeyGenParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип RsaKeyGenParams = интерфейс
{
  modulusLength: Число

  publicExponent: BigInteger
}


тип RsaOaepParams = интерфейс
{
  label: BufferSource
}


тип RsaOtherPrimesInfo = интерфейс
{
  d: Текст

  r: Текст

  t: Текст
}


тип RsaPssParams = интерфейс
{
  saltLength: Число
}


тип SecurityPolicyViolationEventInit = интерфейс
{
  blockedURI: Текст

  columnNumber: Число

  disposition: SecurityPolicyViolationEventDisposition

  documentURI: Текст

  effectiveDirective: Текст

  lineNumber: Число

  originalPolicy: Текст

  referrer: Текст

  sample: Текст

  sourceFile: Текст

  statusCode: Число

  violatedDirective: Текст
}


тип StorageEstimate = интерфейс
{
  quota: Число

  usage: Число
}


тип StreamPipeOptions = интерфейс
{
  preventAbort: ДаНет

  preventCancel: ДаНет

  preventClose: ДаНет

  signal: AbortSignal
}


тип StructuredSerializeOptions = интерфейс
{
  transfer: Список<Transferable>
}


тип TextDecodeOptions = интерфейс
{
  stream: ДаНет
}


тип TextDecoderOptions = интерфейс
{
  fatal: ДаНет

  ignoreBOM: ДаНет
}


тип TextEncoderEncodeIntoResult = интерфейс
{
  read: Число

  written: Число
}


тип Transformer<I, O> = интерфейс
{
  flush: TransformerFlushCallback<O>

  readableType: пусто

  start: TransformerStartCallback<O>

  transform: TransformerTransformCallback<I, O>

  writableType: пусто
}


тип UnderlyingByteSource = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableByteStreamController): Ничего | PromiseLike<Ничего>

  start: операция(controller: ReadableByteStreamController): /*(!) any */ Объект?

  type: "bytes"
}


тип UnderlyingDefaultSource<R> = интерфейс
{
  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableStreamDefaultController<R>): Ничего | PromiseLike<Ничего>

  start: операция(controller: ReadableStreamDefaultController<R>): /*(!) any */ Объект?

  type: пусто
}


тип UnderlyingSink<W> = интерфейс
{
  abort: UnderlyingSinkAbortCallback

  close: UnderlyingSinkCloseCallback

  start: UnderlyingSinkStartCallback

  type: пусто

  write: UnderlyingSinkWriteCallback<W>
}


тип UnderlyingSource<R> = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: UnderlyingSourcePullCallback<R>

  start: UnderlyingSourceStartCallback<R>

  type: ReadableStreamType
}


тип VideoColorSpaceInit = интерфейс
{
  fullRange: ДаНет?FUCKFUCK

  matrix: VideoMatrixCoefficients?FUCKFUCK

  primaries: VideoColorPrimaries?FUCKFUCK

  transfer: VideoTransferCharacteristics?FUCKFUCK
}


тип VideoConfiguration = интерфейс
{
  bitrate: Число

  colorGamut: ColorGamut

  contentType: Текст

  framerate: Число

  hdrMetadataType: HdrMetadataType

  height: Число

  scalabilityMode: Текст

  transferFunction: TransferFunction

  width: Число
}


тип VideoDecoderConfig = интерфейс
{
  codec: Текст

  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  description: BufferSource

  displayAspectHeight: Число

  displayAspectWidth: Число

  hardwareAcceleration: HardwareAcceleration

  optimizeForLatency: ДаНет
}


тип VideoDecoderInit = интерфейс
{
  error: WebCodecsErrorCallback

  output: VideoFrameOutputCallback
}


тип VideoDecoderSupport = интерфейс
{
  config: VideoDecoderConfig

  supported: ДаНет
}


тип VideoEncoderConfig = интерфейс
{
  alpha: AlphaOption

  avc: AvcEncoderConfig

  bitrate: Число

  bitrateMode: VideoEncoderBitrateMode

  codec: Текст

  displayHeight: Число

  displayWidth: Число

  framerate: Число

  hardwareAcceleration: HardwareAcceleration

  height: Число

  latencyMode: LatencyMode

  scalabilityMode: Текст

  width: Число
}


тип VideoEncoderEncodeOptions = интерфейс
{
  keyFrame: ДаНет
}


тип VideoEncoderInit = интерфейс
{
  error: WebCodecsErrorCallback

  output: EncodedVideoChunkOutputCallback
}


тип VideoEncoderSupport = интерфейс
{
  config: VideoEncoderConfig

  supported: ДаНет
}


тип VideoFrameBufferInit = интерфейс
{
  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  displayHeight: Число

  displayWidth: Число

  duration: Число

  format: VideoPixelFormat

  layout: Список<PlaneLayout>

  timestamp: Число

  visibleRect: DOMRectInit
}


тип VideoFrameCopyToOptions = интерфейс
{
  layout: Список<PlaneLayout>

  rect: DOMRectInit
}


тип VideoFrameInit = интерфейс
{
  alpha: AlphaOption

  displayHeight: Число

  displayWidth: Число

  duration: Число

  timestamp: Число

  visibleRect: DOMRectInit
}


тип WebGLContextAttributes = интерфейс
{
  alpha: ДаНет

  antialias: ДаНет

  depth: ДаНет

  desynchronized: ДаНет

  failIfMajorPerformanceCaveat: ДаНет

  powerPreference: WebGLPowerPreference

  premultipliedAlpha: ДаНет

  preserveDrawingBuffer: ДаНет

  stencil: ДаНет
}


тип WebGLContextEventInit = интерфейс
{
  statusMessage: Текст
}


тип WebTransportCloseInfo = интерфейс
{
  closeCode: Число

  reason: Текст
}


тип WebTransportErrorOptions = интерфейс
{
  source: WebTransportErrorSource

  streamErrorCode: Число?FUCKFUCK
}


тип WebTransportHash = интерфейс
{
  algorithm: Текст

  value: BufferSource
}


тип WebTransportOptions = интерфейс
{
  allowPooling: ДаНет

  congestionControl: WebTransportCongestionControl

  requireUnreliable: ДаНет

  serverCertificateHashes: Список<WebTransportHash>
}


тип WebTransportSendStreamOptions = интерфейс
{
  sendOrder: Число?FUCKFUCK
}


тип WorkerOptions = интерфейс
{
  credentials: RequestCredentials

  name: Текст

  type: WorkerType
}


тип WriteParams = интерфейс
{
  data: BufferSource | Blob | Текст | пусто

  position: Число?FUCKFUCK

  size: Число?FUCKFUCK

  type: WriteCommandType
}


/**
* The ANGLE_instanced_arrays extension is part of the WebGL API and allows to draw the same object, or groups of similar objects multiple times, if they share the same vertex data, primitive count and type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ANGLE_instanced_arrays)
*/

тип ANGLE_instanced_arrays = интерфейс
{
  операция drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei)

  операция drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei)

  операция vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint)

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE
}


/**
* A controller object that allows you to abort one or more DOM requests as and when desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)
*/

тип AbortController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ AbortController: объект { prototype: AbortController; при создании()/*(!) no_type */ Объект? }


тип AbortSignalEventMap = интерфейс
{
  "abort": Event
}


/**
* A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)
*/

тип AbortSignal = интерфейс
{
  защищено 
  aborted: ДаНет

  onabort: операция(this: AbortSignal, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  reason: /*(!) any */ Объект?

  операция throwIfAborted()

  операция addEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AbortSignal: объект { prototype: AbortSignal; при создании()/*(!) no_type */ Объект?; операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): AbortSignal; операция timeout(milliseconds: Число): AbortSignal }


тип AbstractWorkerEventMap = интерфейс
{
  "error": ErrorEvent
}


тип AbstractWorker = интерфейс
{
  onerror: операция(this: AbstractWorker, ev: ErrorEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


тип AnimationFrameProvider = интерфейс
{
  операция cancelAnimationFrame(handle: Число)

  операция requestAnimationFrame(callback: FrameRequestCallback): Число
}


/**
* A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)
*/

тип Blob = интерфейс
{
  защищено 
  size: Число

  защищено 
  type: Текст

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция slice(start: Число?FUCKFUCK = пусто, end: Число?FUCKFUCK = пусто, contentType: Текст?FUCKFUCK = пусто): Blob

  операция stream(): ReadableStream<Uint8Array>

  операция text(): Promise<Текст>
}


внешнее
/*(!) var */ Blob: объект { prototype: Blob; при создании(blobParts: Список<BlobPart>?FUCKFUCK = пусто, options: BlobPropertyBag?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип Body = интерфейс
{
  защищено 
  body: ReadableStream<Uint8Array>?FUCKFUCK

  защищено 
  bodyUsed: ДаНет

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция blob(): Promise<Blob>

  операция formData(): Promise<FormData>

  операция json(): Promise</*(!) any */ Объект?>

  операция text(): Promise<Текст>
}


тип BroadcastChannelEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BroadcastChannel) */

тип BroadcastChannel = интерфейс
{
  защищено 
  name: Текст

  onmessage: операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция postMessage(message: /*(!) any */ Объект?)

  операция addEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ BroadcastChannel: объект { prototype: BroadcastChannel; при создании(name: Текст)/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)
*/

тип ByteLengthQueuingStrategy = интерфейс
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize<ArrayBufferView>
}


внешнее
/*(!) var */ ByteLengthQueuingStrategy: объект { prototype: ByteLengthQueuingStrategy; при создании(init: QueuingStrategyInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSImageValue) */

тип CSSImageValue = интерфейс
{

}


внешнее
/*(!) var */ CSSImageValue: объект { prototype: CSSImageValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeywordValue) */

тип CSSKeywordValue = интерфейс
{
  value: Текст
}


внешнее
/*(!) var */ CSSKeywordValue: объект { prototype: CSSKeywordValue; при создании(value: Текст)/*(!) no_type */ Объект? }


тип CSSMathClamp = интерфейс
{
  защищено 
  lower: CSSNumericValue

  защищено 
  upper: CSSNumericValue

  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathClamp: объект { prototype: CSSMathClamp; при создании(lower: CSSNumberish, value: CSSNumberish, upper: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathInvert) */

тип CSSMathInvert = интерфейс
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathInvert: объект { prototype: CSSMathInvert; при создании(arg: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMax) */

тип CSSMathMax = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMax: объект { prototype: CSSMathMax; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMin) */

тип CSSMathMin = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMin: объект { prototype: CSSMathMin; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathNegate) */

тип CSSMathNegate = интерфейс
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathNegate: объект { prototype: CSSMathNegate; при создании(arg: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathProduct) */

тип CSSMathProduct = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathProduct: объект { prototype: CSSMathProduct; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathSum) */

тип CSSMathSum = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathSum: объект { prototype: CSSMathSum; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathValue) */

тип CSSMathValue = интерфейс
{
  защищено 
  operator: CSSMathOperator
}


внешнее
/*(!) var */ CSSMathValue: объект { prototype: CSSMathValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMatrixComponent) */

тип CSSMatrixComponent = интерфейс
{
  matrix: DOMMatrix
}


внешнее
/*(!) var */ CSSMatrixComponent: объект { prototype: CSSMatrixComponent; при создании(matrix: DOMMatrixReadOnly, options: CSSMatrixComponentOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericArray) */

тип CSSNumericArray = интерфейс
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSNumericValue, key: Число, parent: CSSNumericArray), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSNumericValue*/
}


внешнее
/*(!) var */ CSSNumericArray: объект { prototype: CSSNumericArray; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericValue) */

тип CSSNumericValue = интерфейс
{
  #js.МассивПараметров
  операция add(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция div(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция equals(value: Список<CSSNumberish>): ДаНет

  #js.МассивПараметров
  операция max(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция min(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция mul(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция sub(values: Список<CSSNumberish>): CSSNumericValue

  операция to(unit: Текст): CSSUnitValue

  #js.МассивПараметров
  операция toSum(units: Список<Текст>): CSSMathSum

  операция type(): CSSNumericType
}


внешнее
/*(!) var */ CSSNumericValue: объект { prototype: CSSNumericValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPerspective) */

тип CSSPerspective = интерфейс
{
  length: CSSPerspectiveValue
}


внешнее
/*(!) var */ CSSPerspective: объект { prototype: CSSPerspective; при создании(length: CSSPerspectiveValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRotate) */

тип CSSRotate = интерфейс
{
  angle: CSSNumericValue

  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSRotate: объект { prototype: CSSRotate; при создании(angle: CSSNumericValue)/*(!) no_type */ Объект?; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish, angle: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSScale) */

тип CSSScale = интерфейс
{
  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSScale: объект { prototype: CSSScale; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkew) */

тип CSSSkew = интерфейс
{
  ax: CSSNumericValue

  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkew: объект { prototype: CSSSkew; при создании(ax: CSSNumericValue, ay: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewX) */

тип CSSSkewX = интерфейс
{
  ax: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewX: объект { prototype: CSSSkewX; при создании(ax: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewY) */

тип CSSSkewY = интерфейс
{
  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewY: объект { prototype: CSSSkewY; при создании(ay: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleValue) */

тип CSSStyleValue = интерфейс
{
  операция toString(): Текст
}


внешнее
/*(!) var */ CSSStyleValue: объект { prototype: CSSStyleValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformComponent) */

тип CSSTransformComponent = интерфейс
{
  is2D: ДаНет

  операция toMatrix(): DOMMatrix

  операция toString(): Текст
}


внешнее
/*(!) var */ CSSTransformComponent: объект { prototype: CSSTransformComponent; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformValue) */

тип CSSTransformValue = интерфейс
{
  защищено 
  is2D: ДаНет

  защищено 
  length: Число

  операция toMatrix(): DOMMatrix

  операция forEach(callbackfn: операция(value: CSSTransformComponent, key: Число, parent: CSSTransformValue), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSTransformComponent*/
}


внешнее
/*(!) var */ CSSTransformValue: объект { prototype: CSSTransformValue; при создании(transforms: Список<CSSTransformComponent>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTranslate) */

тип CSSTranslate = интерфейс
{
  x: CSSNumericValue

  y: CSSNumericValue

  z: CSSNumericValue
}


внешнее
/*(!) var */ CSSTranslate: объект { prototype: CSSTranslate; при создании(x: CSSNumericValue, y: CSSNumericValue, z: CSSNumericValue?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnitValue) */

тип CSSUnitValue = интерфейс
{
  защищено 
  unit: Текст

  value: Число
}


внешнее
/*(!) var */ CSSUnitValue: объект { prototype: CSSUnitValue; при создании(value: Число, unit: Текст)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnparsedValue) */

тип CSSUnparsedValue = интерфейс
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSUnparsedSegment, key: Число, parent: CSSUnparsedValue), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSUnparsedSegment*/
}


внешнее
/*(!) var */ CSSUnparsedValue: объект { prototype: CSSUnparsedValue; при создании(members: Список<CSSUnparsedSegment>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSVariableReferenceValue) */

тип CSSVariableReferenceValue = интерфейс
{
  защищено 
  fallback: CSSUnparsedValue?FUCKFUCK

  variable: Текст
}


внешнее
/*(!) var */ CSSVariableReferenceValue: объект { prototype: CSSVariableReferenceValue; при создании(variable: Текст, fallback: CSSUnparsedValue?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Provides a storage mechanism for Request / Response object pairs that are cached, for example as part of the ServiceWorker life cycle. Note that the Cache interface is exposed to windowed scopes as well as workers. You don't have to use it in conjunction with service workers, even though it is defined in the service worker spec.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache)
*/

тип Cache = интерфейс
{
  операция add(request: RequestInfo | URL): Promise<Ничего>

  операция addAll(requests: Список<RequestInfo>): Promise<Ничего>

  операция delete(request: RequestInfo | URL, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ДаНет>

  операция keys(request: RequestInfo | URL | пусто = пусто, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ReadonlyArray<Request>>

  операция match(request: RequestInfo | URL, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<Response?FUCKFUCK>

  операция matchAll(request: RequestInfo | URL | пусто = пусто, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ReadonlyArray<Response>>

  операция put(request: RequestInfo | URL, response: Response): Promise<Ничего>
}


внешнее
/*(!) var */ Cache: объект { prototype: Cache; при создании()/*(!) no_type */ Объект? }


/**
* The storage for Cache objects.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage)
*/

тип CacheStorage = интерфейс
{
  операция delete(cacheName: Текст): Promise<ДаНет>

  операция has(cacheName: Текст): Promise<ДаНет>

  операция keys(): Promise<Список<Текст>>

  операция match(request: RequestInfo | URL, options: MultiCacheQueryOptions?FUCKFUCK = пусто): Promise<Response?FUCKFUCK>

  операция open(cacheName: Текст): Promise<Cache>
}


внешнее
/*(!) var */ CacheStorage: объект { prototype: CacheStorage; при создании()/*(!) no_type */ Объект? }


тип CanvasCompositing = интерфейс
{
  globalAlpha: Число

  globalCompositeOperation: GlobalCompositeOperation
}


тип CanvasDrawImage = интерфейс
{
  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число)

  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число, dw: Число, dh: Число)

  операция drawImage(image: CanvasImageSource, sx: Число, sy: Число, sw: Число, sh: Число, dx: Число, dy: Число, dw: Число, dh: Число)
}


тип CanvasDrawPath = интерфейс
{
  операция beginPath()

  операция clip(fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция clip(path: Path2D, fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция fill(fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция fill(path: Path2D, fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция isPointInPath(x: Число, y: Число, fillRule: CanvasFillRule?FUCKFUCK = пусто): ДаНет

  операция isPointInPath(path: Path2D, x: Число, y: Число, fillRule: CanvasFillRule?FUCKFUCK = пусто): ДаНет

  операция isPointInStroke(x: Число, y: Число): ДаНет

  операция isPointInStroke(path: Path2D, x: Число, y: Число): ДаНет

  операция stroke()

  операция stroke(path: Path2D)
}


тип CanvasFillStrokeStyles = интерфейс
{
  fillStyle: Текст | CanvasGradient | CanvasPattern

  strokeStyle: Текст | CanvasGradient | CanvasPattern

  операция createConicGradient(startAngle: Число, x: Число, y: Число): CanvasGradient

  операция createLinearGradient(x0: Число, y0: Число, x1: Число, y1: Число): CanvasGradient

  операция createPattern(image: CanvasImageSource, repetition: Текст?FUCKFUCK): CanvasPattern?FUCKFUCK

  операция createRadialGradient(x0: Число, y0: Число, r0: Число, x1: Число, y1: Число, r1: Число): CanvasGradient
}


тип CanvasFilters = интерфейс
{
  filter: Текст
}


/**
* An opaque object describing a gradient. It is returned by the methods CanvasRenderingContext2D.createLinearGradient() or CanvasRenderingContext2D.createRadialGradient().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasGradient)
*/

тип CanvasGradient = интерфейс
{
  операция addColorStop(offset: Число, color: Текст)
}


внешнее
/*(!) var */ CanvasGradient: объект { prototype: CanvasGradient; при создании()/*(!) no_type */ Объект? }


тип CanvasImageData = интерфейс
{
  операция createImageData(sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто): ImageData

  операция createImageData(imagedata: ImageData): ImageData

  операция getImageData(sx: Число, sy: Число, sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто): ImageData

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число)

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число, dirtyX: Число, dirtyY: Число, dirtyWidth: Число, dirtyHeight: Число)
}


тип CanvasImageSmoothing = интерфейс
{
  imageSmoothingEnabled: ДаНет

  imageSmoothingQuality: ImageSmoothingQuality
}


тип CanvasPath = интерфейс
{
  операция arc(x: Число, y: Число, radius: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет?FUCKFUCK = пусто)

  операция arcTo(x1: Число, y1: Число, x2: Число, y2: Число, radius: Число)

  операция bezierCurveTo(cp1x: Число, cp1y: Число, cp2x: Число, cp2y: Число, x: Число, y: Число)

  операция closePath()

  операция ellipse(x: Число, y: Число, radiusX: Число, radiusY: Число, rotation: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет?FUCKFUCK = пусто)

  операция lineTo(x: Число, y: Число)

  операция moveTo(x: Число, y: Число)

  операция quadraticCurveTo(cpx: Число, cpy: Число, x: Число, y: Число)

  операция rect(x: Число, y: Число, w: Число, h: Число)

  операция roundRect(x: Число, y: Число, w: Число, h: Число, radii: Число | DOMPointInit | Список<Число | DOMPointInit> | пусто = пусто)
}


тип CanvasPathDrawingStyles = интерфейс
{
  lineCap: CanvasLineCap

  lineDashOffset: Число

  lineJoin: CanvasLineJoin

  lineWidth: Число

  miterLimit: Число

  операция getLineDash(): Список<Число>

  операция setLineDash(segments: Список<Число>)
}


/**
* An opaque object describing a pattern, based on an image, a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasPattern)
*/

тип CanvasPattern = интерфейс
{
  операция setTransform(transform: DOMMatrix2DInit?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ CanvasPattern: объект { prototype: CanvasPattern; при создании()/*(!) no_type */ Объект? }


тип CanvasRect = интерфейс
{
  операция clearRect(x: Число, y: Число, w: Число, h: Число)

  операция fillRect(x: Число, y: Число, w: Число, h: Число)

  операция strokeRect(x: Число, y: Число, w: Число, h: Число)
}


тип CanvasShadowStyles = интерфейс
{
  shadowBlur: Число

  shadowColor: Текст

  shadowOffsetX: Число

  shadowOffsetY: Число
}


тип CanvasState = интерфейс
{
  операция reset()

  операция restore()

  операция save()
}


тип CanvasText = интерфейс
{
  операция fillText(text: Текст, x: Число, y: Число, maxWidth: Число?FUCKFUCK = пусто)

  операция measureText(text: Текст): TextMetrics

  операция strokeText(text: Текст, x: Число, y: Число, maxWidth: Число?FUCKFUCK = пусто)
}


тип CanvasTextDrawingStyles = интерфейс
{
  direction: CanvasDirection

  font: Текст

  fontKerning: CanvasFontKerning

  textAlign: CanvasTextAlign

  textBaseline: CanvasTextBaseline
}


тип CanvasTransform = интерфейс
{
  операция getTransform(): DOMMatrix

  операция resetTransform()

  операция rotate(angle: Число)

  операция scale(x: Число, y: Число)

  операция setTransform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция setTransform(transform: DOMMatrix2DInit?FUCKFUCK = пусто)

  операция transform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция translate(x: Число, y: Число)
}


/**
* The Client interface represents an executable context such as a Worker, or a SharedWorker. Window clients are represented by the more-specific WindowClient. You can get Client/WindowClient objects from methods such as Clients.matchAll() and Clients.get().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Client)
*/

тип Client = интерфейс
{
  защищено 
  frameType: FrameType

  защищено 
  id: Текст

  защищено 
  type: ClientTypes

  защищено 
  url: Текст

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ Client: объект { prototype: Client; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to Client objects. Access it via self.clients within a service worker.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Clients)
*/

тип Clients = интерфейс
{
  операция claim(): Promise<Ничего>

  операция get(id: Текст): Promise<Client?FUCKFUCK>

  операция matchAll<T = ClientQueryOptions>(options: T?FUCKFUCK = пусто): Promise<ReadonlyArray</*(!) T["type"] extends "window" ? WindowClient : Client */ Объект?>>

  операция openWindow(url: Текст | URL): Promise<WindowClient?FUCKFUCK>
}


внешнее
/*(!) var */ Clients: объект { prototype: Clients; при создании()/*(!) no_type */ Объект? }


/**
* A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)
*/

тип CloseEvent = интерфейс
{
  защищено 
  code: Число

  защищено 
  reason: Текст

  защищено 
  wasClean: ДаНет
}


внешнее
/*(!) var */ CloseEvent: объект { prototype: CloseEvent; при создании(type: Текст, eventInitDict: CloseEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */

тип CompressionStream = интерфейс
{

}


внешнее
/*(!) var */ CompressionStream: объект { prototype: CompressionStream; при создании(format: CompressionFormat)/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)
*/

тип CountQueuingStrategy = интерфейс
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize
}


внешнее
/*(!) var */ CountQueuingStrategy: объект { prototype: CountQueuingStrategy; при создании(init: QueuingStrategyInit)/*(!) no_type */ Объект? }


/**
* Basic cryptography features available in the current context. It allows access to a cryptographically strong random number generator and to cryptographic primitives.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto)
*/

тип Crypto = интерфейс
{
  защищено 
  subtle: SubtleCrypto

  операция getRandomValues<T = ArrayBufferView?FUCKFUCK>(array: T): T

  операция randomUUID(): /*(!) `${string}-${string}-${string}-${string}-${string}` */ Объект?
}


внешнее
/*(!) var */ Crypto: объект { prototype: Crypto; при создании()/*(!) no_type */ Объект? }


/**
* The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)
*/

тип CryptoKey = интерфейс
{
  защищено 
  algorithm: KeyAlgorithm

  защищено 
  extractable: ДаНет

  защищено 
  type: KeyType

  защищено 
  usages: Список<KeyUsage>
}


внешнее
/*(!) var */ CryptoKey: объект { prototype: CryptoKey; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */

тип CustomEvent<T> = интерфейс
{
  защищено 
  detail: T

  операция initCustomEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто, detail: T?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ CustomEvent: объект { prototype: CustomEvent; при создании(type: Текст, eventInitDict: CustomEventInit<T>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)
*/

тип DOMException = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  name: Текст

  защищено 
  INDEX_SIZE_ERR: 1

  защищено 
  DOMSTRING_SIZE_ERR: 2

  защищено 
  HIERARCHY_REQUEST_ERR: 3

  защищено 
  WRONG_DOCUMENT_ERR: 4

  защищено 
  INVALID_CHARACTER_ERR: 5

  защищено 
  NO_DATA_ALLOWED_ERR: 6

  защищено 
  NO_MODIFICATION_ALLOWED_ERR: 7

  защищено 
  NOT_FOUND_ERR: 8

  защищено 
  NOT_SUPPORTED_ERR: 9

  защищено 
  INUSE_ATTRIBUTE_ERR: 10

  защищено 
  INVALID_STATE_ERR: 11

  защищено 
  SYNTAX_ERR: 12

  защищено 
  INVALID_MODIFICATION_ERR: 13

  защищено 
  NAMESPACE_ERR: 14

  защищено 
  INVALID_ACCESS_ERR: 15

  защищено 
  VALIDATION_ERR: 16

  защищено 
  TYPE_MISMATCH_ERR: 17

  защищено 
  SECURITY_ERR: 18

  защищено 
  NETWORK_ERR: 19

  защищено 
  ABORT_ERR: 20

  защищено 
  URL_MISMATCH_ERR: 21

  защищено 
  QUOTA_EXCEEDED_ERR: 22

  защищено 
  TIMEOUT_ERR: 23

  защищено 
  INVALID_NODE_TYPE_ERR: 24

  защищено 
  DATA_CLONE_ERR: 25
}


внешнее
/*(!) var */ DOMException: объект { prototype: DOMException; при создании(message: Текст?FUCKFUCK = пусто, name: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  INDEX_SIZE_ERR: 1; защищено  DOMSTRING_SIZE_ERR: 2; защищено  HIERARCHY_REQUEST_ERR: 3; защищено  WRONG_DOCUMENT_ERR: 4; защищено  INVALID_CHARACTER_ERR: 5; защищено  NO_DATA_ALLOWED_ERR: 6; защищено  NO_MODIFICATION_ALLOWED_ERR: 7; защищено  NOT_FOUND_ERR: 8; защищено  NOT_SUPPORTED_ERR: 9; защищено  INUSE_ATTRIBUTE_ERR: 10; защищено  INVALID_STATE_ERR: 11; защищено  SYNTAX_ERR: 12; защищено  INVALID_MODIFICATION_ERR: 13; защищено  NAMESPACE_ERR: 14; защищено  INVALID_ACCESS_ERR: 15; защищено  VALIDATION_ERR: 16; защищено  TYPE_MISMATCH_ERR: 17; защищено  SECURITY_ERR: 18; защищено  NETWORK_ERR: 19; защищено  ABORT_ERR: 20; защищено  URL_MISMATCH_ERR: 21; защищено  QUOTA_EXCEEDED_ERR: 22; защищено  TIMEOUT_ERR: 23; защищено  INVALID_NODE_TYPE_ERR: 24; защищено  DATA_CLONE_ERR: 25 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrix) */

тип DOMMatrix = интерфейс
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m13: Число

  m14: Число

  m21: Число

  m22: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m41: Число

  m42: Число

  m43: Число

  m44: Число

  операция invertSelf(): DOMMatrix

  операция multiplySelf(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция preMultiplySelf(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция rotateAxisAngleSelf(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, angle: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateFromVectorSelf(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateSelf(rotX: Число?FUCKFUCK = пусто, rotY: Число?FUCKFUCK = пусто, rotZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale3dSelf(scale: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scaleSelf(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто, scaleZ: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewXSelf(sx: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewYSelf(sy: Число?FUCKFUCK = пусто): DOMMatrix

  операция translateSelf(tx: Число?FUCKFUCK = пусто, ty: Число?FUCKFUCK = пусто, tz: Число?FUCKFUCK = пусто): DOMMatrix
}


внешнее
/*(!) var */ DOMMatrix: объект { prototype: DOMMatrix; при создании(init: Текст | Список<Число> | пусто = пусто)/*(!) no_type */ Объект?; операция fromFloat32Array(array32: Float32Array): DOMMatrix; операция fromFloat64Array(array64: Float64Array): DOMMatrix; операция fromMatrix(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrixReadOnly) */

тип DOMMatrixReadOnly = интерфейс
{
  защищено 
  a: Число

  защищено 
  b: Число

  защищено 
  c: Число

  защищено 
  d: Число

  защищено 
  e: Число

  защищено 
  f: Число

  защищено 
  is2D: ДаНет

  защищено 
  isIdentity: ДаНет

  защищено 
  m11: Число

  защищено 
  m12: Число

  защищено 
  m13: Число

  защищено 
  m14: Число

  защищено 
  m21: Число

  защищено 
  m22: Число

  защищено 
  m23: Число

  защищено 
  m24: Число

  защищено 
  m31: Число

  защищено 
  m32: Число

  защищено 
  m33: Число

  защищено 
  m34: Число

  защищено 
  m41: Число

  защищено 
  m42: Число

  защищено 
  m43: Число

  защищено 
  m44: Число

  операция flipX(): DOMMatrix

  операция flipY(): DOMMatrix

  операция inverse(): DOMMatrix

  операция multiply(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция rotate(rotX: Число?FUCKFUCK = пусто, rotY: Число?FUCKFUCK = пусто, rotZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateAxisAngle(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, angle: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateFromVector(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто, scaleZ: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale3d(scale: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scaleNonUniform(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewX(sx: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewY(sy: Число?FUCKFUCK = пусто): DOMMatrix

  операция toFloat32Array(): Float32Array

  операция toFloat64Array(): Float64Array

  операция toJSON(): /*(!) any */ Объект?

  операция transformPoint(point: DOMPointInit?FUCKFUCK = пусто): DOMPoint

  операция translate(tx: Число?FUCKFUCK = пусто, ty: Число?FUCKFUCK = пусто, tz: Число?FUCKFUCK = пусто): DOMMatrix
}


внешнее
/*(!) var */ DOMMatrixReadOnly: объект { prototype: DOMMatrixReadOnly; при создании(init: Текст | Список<Число> | пусто = пусто)/*(!) no_type */ Объект?; операция fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly; операция fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly; операция fromMatrix(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrixReadOnly }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPoint) */

тип DOMPoint = интерфейс
{
  w: Число

  x: Число

  y: Число

  z: Число
}


внешнее
/*(!) var */ DOMPoint: объект { prototype: DOMPoint; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, w: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromPoint(other: DOMPointInit?FUCKFUCK = пусто): DOMPoint }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPointReadOnly) */

тип DOMPointReadOnly = интерфейс
{
  защищено 
  w: Число

  защищено 
  x: Число

  защищено 
  y: Число

  защищено 
  z: Число

  операция matrixTransform(matrix: DOMMatrixInit?FUCKFUCK = пусто): DOMPoint

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMPointReadOnly: объект { prototype: DOMPointReadOnly; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, w: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromPoint(other: DOMPointInit?FUCKFUCK = пусто): DOMPointReadOnly }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMQuad) */

тип DOMQuad = интерфейс
{
  защищено 
  p1: DOMPoint

  защищено 
  p2: DOMPoint

  защищено 
  p3: DOMPoint

  защищено 
  p4: DOMPoint

  операция getBounds(): DOMRect

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMQuad: объект { prototype: DOMQuad; при создании(p1: DOMPointInit?FUCKFUCK = пусто, p2: DOMPointInit?FUCKFUCK = пусто, p3: DOMPointInit?FUCKFUCK = пусто, p4: DOMPointInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromQuad(other: DOMQuadInit?FUCKFUCK = пусто): DOMQuad; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMQuad }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */

тип DOMRect = интерфейс
{
  height: Число

  width: Число

  x: Число

  y: Число
}


внешнее
/*(!) var */ DOMRect: объект { prototype: DOMRect; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, width: Число?FUCKFUCK = пусто, height: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMRect }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */

тип DOMRectReadOnly = интерфейс
{
  защищено 
  bottom: Число

  защищено 
  height: Число

  защищено 
  left: Число

  защищено 
  right: Число

  защищено 
  top: Число

  защищено 
  width: Число

  защищено 
  x: Число

  защищено 
  y: Число

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMRectReadOnly: объект { prototype: DOMRectReadOnly; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, width: Число?FUCKFUCK = пусто, height: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMRectReadOnly }


/**
* A type returned by some APIs which contains a list of DOMString (strings).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringList)
*/

тип DOMStringList = интерфейс
{
  защищено 
  length: Число

  операция contains(string: Текст): ДаНет

  операция item(index: Число): Текст?FUCKFUCK

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ DOMStringList: объект { prototype: DOMStringList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */

тип DecompressionStream = интерфейс
{

}


внешнее
/*(!) var */ DecompressionStream: объект { prototype: DecompressionStream; при создании(format: CompressionFormat)/*(!) no_type */ Объект? }


тип DedicatedWorkerGlobalScopeEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* (the Worker global scope) is accessible through the self keyword. Some additional global functions, namespaces objects, and constructors, not typically associated with the worker global scope, but available on it, are listed in the JavaScript Reference. See also: Functions available to workers.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope)
*/

тип DedicatedWorkerGlobalScope = интерфейс
{
  защищено 
  name: Текст

  onmessage: операция(this: DedicatedWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: DedicatedWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof DedicatedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: DedicatedWorkerGlobalScope, ev: /*(!) DedicatedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof DedicatedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: DedicatedWorkerGlobalScope, ev: /*(!) DedicatedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ DedicatedWorkerGlobalScope: объект { prototype: DedicatedWorkerGlobalScope; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_blend_minmax) */

тип EXT_blend_minmax = интерфейс
{
  защищено 
  MIN_EXT: 0x8007

  защищено 
  MAX_EXT: 0x8008
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_float) */

тип EXT_color_buffer_float = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_half_float) */

тип EXT_color_buffer_half_float = интерфейс
{
  защищено 
  RGBA16F_EXT: 0x881A

  защищено 
  RGB16F_EXT: 0x881B

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_float_blend) */

тип EXT_float_blend = интерфейс
{

}


/**
* The EXT_frag_depth extension is part of the WebGL API and enables to set a depth value of a fragment from within the fragment shader.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_frag_depth)
*/

тип EXT_frag_depth = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_sRGB) */

тип EXT_sRGB = интерфейс
{
  защищено 
  SRGB_EXT: 0x8C40

  защищено 
  SRGB_ALPHA_EXT: 0x8C42

  защищено 
  SRGB8_ALPHA8_EXT: 0x8C43

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_shader_texture_lod) */

тип EXT_shader_texture_lod = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_bptc) */

тип EXT_texture_compression_bptc = интерфейс
{
  защищено 
  COMPRESSED_RGBA_BPTC_UNORM_EXT: 0x8E8C

  защищено 
  COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: 0x8E8D

  защищено 
  COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: 0x8E8E

  защищено 
  COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: 0x8E8F
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_rgtc) */

тип EXT_texture_compression_rgtc = интерфейс
{
  защищено 
  COMPRESSED_RED_RGTC1_EXT: 0x8DBB

  защищено 
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8DBC

  защищено 
  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8DBD

  защищено 
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8DBE
}


/**
* The EXT_texture_filter_anisotropic extension is part of the WebGL API and exposes two constants for anisotropic filtering (AF).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_filter_anisotropic)
*/

тип EXT_texture_filter_anisotropic = интерфейс
{
  защищено 
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE

  защищено 
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_norm16) */

тип EXT_texture_norm16 = интерфейс
{
  защищено 
  R16_EXT: 0x822A

  защищено 
  RG16_EXT: 0x822C

  защищено 
  RGB16_EXT: 0x8054

  защищено 
  RGBA16_EXT: 0x805B

  защищено 
  R16_SNORM_EXT: 0x8F98

  защищено 
  RG16_SNORM_EXT: 0x8F99

  защищено 
  RGB16_SNORM_EXT: 0x8F9A

  защищено 
  RGBA16_SNORM_EXT: 0x8F9B
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EncodedVideoChunk) */

тип EncodedVideoChunk = интерфейс
{
  защищено 
  byteLength: Число

  защищено 
  duration: Число?FUCKFUCK

  защищено 
  timestamp: Число

  защищено 
  type: EncodedVideoChunkType

  операция copyTo(destination: BufferSource)
}


внешнее
/*(!) var */ EncodedVideoChunk: объект { prototype: EncodedVideoChunk; при создании(init: EncodedVideoChunkInit)/*(!) no_type */ Объект? }


/**
* Events providing information related to errors in scripts or in files.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)
*/

тип ErrorEvent = интерфейс
{
  защищено 
  colno: Число

  защищено 
  error: /*(!) any */ Объект?

  защищено 
  filename: Текст

  защищено 
  lineno: Число

  защищено 
  message: Текст
}


внешнее
/*(!) var */ ErrorEvent: объект { prototype: ErrorEvent; при создании(type: Текст, eventInitDict: ErrorEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An event which takes place in the DOM.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)
*/

тип Event = интерфейс
{
  защищено 
  bubbles: ДаНет

  cancelBubble: ДаНет

  защищено 
  cancelable: ДаНет

  защищено 
  composed: ДаНет

  защищено 
  currentTarget: EventTarget?FUCKFUCK

  защищено 
  defaultPrevented: ДаНет

  защищено 
  eventPhase: Число

  защищено 
  isTrusted: ДаНет

  returnValue: ДаНет

  защищено 
  srcElement: EventTarget?FUCKFUCK

  защищено 
  target: EventTarget?FUCKFUCK

  защищено 
  timeStamp: DOMHighResTimeStamp

  защищено 
  type: Текст

  операция composedPath(): Список<EventTarget>

  операция initEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто)

  операция preventDefault()

  операция stopImmediatePropagation()

  операция stopPropagation()

  защищено 
  NONE: 0

  защищено 
  CAPTURING_PHASE: 1

  защищено 
  AT_TARGET: 2

  защищено 
  BUBBLING_PHASE: 3
}


внешнее
/*(!) var */ Event: объект { prototype: Event; при создании(type: Текст, eventInitDict: EventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  NONE: 0; защищено  CAPTURING_PHASE: 1; защищено  AT_TARGET: 2; защищено  BUBBLING_PHASE: 3 }


тип EventListener = интерфейс
{
  /*(!) (evt: Event): void*/
}


тип EventListenerObject = интерфейс
{
  операция handleEvent(object: Event)
}


тип EventSourceEventMap = интерфейс
{
  "error": Event

  "message": MessageEvent

  "open": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource) */

тип EventSource = интерфейс
{
  onerror: операция(this: EventSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: EventSource, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onopen: операция(this: EventSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: Число

  защищено 
  url: Текст

  защищено 
  withCredentials: ДаНет

  операция close()

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSED: 2

  операция addEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ EventSource: объект { prototype: EventSource; при создании(url: Текст | URL, eventSourceInitDict: EventSourceInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSED: 2 }


/**
* EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)
*/

тип EventTarget = интерфейс
{
  операция addEventListener(type: Текст, callback: EventListenerOrEventListenerObject?FUCKFUCK, options: AddEventListenerOptions | ДаНет | пусто = пусто)

  операция dispatchEvent(event: Event): ДаНет

  операция removeEventListener(type: Текст, callback: EventListenerOrEventListenerObject?FUCKFUCK, options: EventListenerOptions | ДаНет | пусто = пусто)
}


внешнее
/*(!) var */ EventTarget: объект { prototype: EventTarget; при создании()/*(!) no_type */ Объект? }


/**
* Extends the lifetime of the install and activate events dispatched on the global scope as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched until it upgrades database schemas and deletes the outdated cache entries.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent)
*/

тип ExtendableEvent = интерфейс
{
  операция waitUntil(f: Promise</*(!) any */ Объект?>)
}


внешнее
/*(!) var */ ExtendableEvent: объект { prototype: ExtendableEvent; при создании(type: Текст, eventInitDict: ExtendableEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This ServiceWorker API interface represents the event object of a message event fired on a service worker (when a channel message is received on the ServiceWorkerGlobalScope from another context) — extends the lifetime of such events.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableMessageEvent)
*/

тип ExtendableMessageEvent = интерфейс
{
  защищено 
  data: /*(!) any */ Объект?

  защищено 
  lastEventId: Текст

  защищено 
  origin: Текст

  защищено 
  ports: ReadonlyArray<MessagePort>

  защищено 
  source: Client | ServiceWorker | MessagePort | пусто
}


внешнее
/*(!) var */ ExtendableMessageEvent: объект { prototype: ExtendableMessageEvent; при создании(type: Текст, eventInitDict: ExtendableMessageEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This is the event type for fetch events dispatched on the service worker global scope. It contains information about the fetch, including the request and how the receiver will treat the response. It provides the event.respondWith() method, which allows us to provide a response to this fetch.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent)
*/

тип FetchEvent = интерфейс
{
  защищено 
  clientId: Текст

  защищено 
  handled: Promise<пусто>

  защищено 
  preloadResponse: Promise</*(!) any */ Объект?>

  защищено 
  request: Request

  защищено 
  resultingClientId: Текст

  операция respondWith(r: Response | PromiseLike<Response>)
}


внешнее
/*(!) var */ FetchEvent: объект { prototype: FetchEvent; при создании(type: Текст, eventInitDict: FetchEventInit)/*(!) no_type */ Объект? }


/**
* Provides information about files and allows JavaScript in a web page to access their content.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)
*/

тип File = интерфейс
{
  защищено 
  lastModified: Число

  защищено 
  name: Текст

  защищено 
  webkitRelativePath: Текст
}


внешнее
/*(!) var */ File: объект { prototype: File; при создании(fileBits: Список<BlobPart>, fileName: Текст, options: FilePropertyBag?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An object of this type is returned by the files property of the HTML <input> element; this lets you access the list of files selected with the <input type="file"> element. It's also used for a list of files dropped into web content when using the drag and drop API; see the DataTransfer object for details on this usage.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileList)
*/

тип FileList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): File?FUCKFUCK

  /*(!) [index: number]: File*/
}


внешнее
/*(!) var */ FileList: объект { prototype: FileList; при создании()/*(!) no_type */ Объект? }


тип FileReaderEventMap = интерфейс
{
  "abort": ProgressEvent<FileReader>

  "error": ProgressEvent<FileReader>

  "load": ProgressEvent<FileReader>

  "loadend": ProgressEvent<FileReader>

  "loadstart": ProgressEvent<FileReader>

  "progress": ProgressEvent<FileReader>
}


/**
* Lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileReader)
*/

тип FileReader = интерфейс
{
  защищено 
  error: DOMException?FUCKFUCK

  onabort: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onload: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onloadend: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onloadstart: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onprogress: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: /*(!) typeof FileReader.EMPTY */ Объект? | /*(!) typeof FileReader.LOADING */ Объект? | /*(!) typeof FileReader.DONE */ Объект?

  защищено 
  result: Текст | ArrayBuffer | пусто

  операция abort()

  операция readAsArrayBuffer(blob: Blob)

  операция readAsBinaryString(blob: Blob)

  операция readAsDataURL(blob: Blob)

  операция readAsText(blob: Blob, encoding: Текст?FUCKFUCK = пусто)

  защищено 
  EMPTY: 0

  защищено 
  LOADING: 1

  защищено 
  DONE: 2

  операция addEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ FileReader: объект { prototype: FileReader; при создании()/*(!) no_type */ Объект?; защищено  EMPTY: 0; защищено  LOADING: 1; защищено  DONE: 2 }


/**
* Allows to read File or Blob objects in a synchronous way.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileReaderSync)
*/

тип FileReaderSync = интерфейс
{
  операция readAsArrayBuffer(blob: Blob): ArrayBuffer

  операция readAsBinaryString(blob: Blob): Текст

  операция readAsDataURL(blob: Blob): Текст

  операция readAsText(blob: Blob, encoding: Текст?FUCKFUCK = пусто): Текст
}


внешнее
/*(!) var */ FileReaderSync: объект { prototype: FileReaderSync; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryHandle)
*/

тип FileSystemDirectoryHandle = интерфейс
{
  защищено 
  kind: "directory"

  операция getDirectoryHandle(name: Текст, options: FileSystemGetDirectoryOptions?FUCKFUCK = пусто): Promise<FileSystemDirectoryHandle>

  операция getFileHandle(name: Текст, options: FileSystemGetFileOptions?FUCKFUCK = пусто): Promise<FileSystemFileHandle>

  операция removeEntry(name: Текст, options: FileSystemRemoveOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция resolve(possibleDescendant: FileSystemHandle): Promise<Список<Текст>?FUCKFUCK>
}


внешнее
/*(!) var */ FileSystemDirectoryHandle: объект { prototype: FileSystemDirectoryHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemFileHandle)
*/

тип FileSystemFileHandle = интерфейс
{
  защищено 
  kind: "file"

  операция createSyncAccessHandle(): Promise<FileSystemSyncAccessHandle>

  операция createWritable(options: FileSystemCreateWritableOptions?FUCKFUCK = пусто): Promise<FileSystemWritableFileStream>

  операция getFile(): Promise<File>
}


внешнее
/*(!) var */ FileSystemFileHandle: объект { prototype: FileSystemFileHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemHandle)
*/

тип FileSystemHandle = интерфейс
{
  защищено 
  kind: FileSystemHandleKind

  защищено 
  name: Текст

  операция isSameEntry(other: FileSystemHandle): Promise<ДаНет>
}


внешнее
/*(!) var */ FileSystemHandle: объект { prototype: FileSystemHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemSyncAccessHandle)
*/

тип FileSystemSyncAccessHandle = интерфейс
{
  операция close()

  операция flush()

  операция getSize(): Число

  операция read(buffer: AllowSharedBufferSource, options: FileSystemReadWriteOptions?FUCKFUCK = пусто): Число

  операция truncate(newSize: Число)

  операция write(buffer: AllowSharedBufferSource, options: FileSystemReadWriteOptions?FUCKFUCK = пусто): Число
}


внешнее
/*(!) var */ FileSystemSyncAccessHandle: объект { prototype: FileSystemSyncAccessHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemWritableFileStream)
*/

тип FileSystemWritableFileStream = интерфейс
{
  операция seek(position: Число): Promise<Ничего>

  операция truncate(size: Число): Promise<Ничего>

  операция write(data: FileSystemWriteChunkType): Promise<Ничего>
}


внешнее
/*(!) var */ FileSystemWritableFileStream: объект { prototype: FileSystemWritableFileStream; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFace) */

тип FontFace = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  family: Текст

  featureSettings: Текст

  lineGapOverride: Текст

  защищено 
  loaded: Promise<FontFace>

  защищено 
  status: FontFaceLoadStatus

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant: Текст

  weight: Текст

  операция load(): Promise<FontFace>
}


внешнее
/*(!) var */ FontFace: объект { prototype: FontFace; при создании(family: Текст, source: Текст | BinaryData, descriptors: FontFaceDescriptors?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип FontFaceSetEventMap = интерфейс
{
  "loading": Event

  "loadingdone": Event

  "loadingerror": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSet) */

тип FontFaceSet = интерфейс
{
  onloading: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadingdone: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadingerror: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ready: Promise<FontFaceSet>

  защищено 
  status: FontFaceSetLoadStatus

  операция check(font: Текст, text: Текст?FUCKFUCK = пусто): ДаНет

  операция load(font: Текст, text: Текст?FUCKFUCK = пусто): Promise<Список<FontFace>>

  операция forEach(callbackfn: операция(value: FontFace, key: FontFace, parent: FontFaceSet), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ FontFaceSet: объект { prototype: FontFaceSet; при создании(initialFaces: Список<FontFace>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSetLoadEvent) */

тип FontFaceSetLoadEvent = интерфейс
{
  защищено 
  fontfaces: ReadonlyArray<FontFace>
}


внешнее
/*(!) var */ FontFaceSetLoadEvent: объект { prototype: FontFaceSetLoadEvent; при создании(type: Текст, eventInitDict: FontFaceSetLoadEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип FontFaceSource = интерфейс
{
  защищено 
  fonts: FontFaceSet
}


/**
* Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)
*/

тип FormData = интерфейс
{
  операция append(name: Текст, value: Текст | Blob)

  операция append(name: Текст, value: Текст)

  операция append(name: Текст, blobValue: Blob, filename: Текст?FUCKFUCK = пусто)

  операция delete(name: Текст)

  операция get(name: Текст): FormDataEntryValue?FUCKFUCK

  операция getAll(name: Текст): Список<FormDataEntryValue>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Текст | Blob)

  операция set(name: Текст, value: Текст)

  операция set(name: Текст, blobValue: Blob, filename: Текст?FUCKFUCK = пусто)

  операция forEach(callbackfn: операция(value: FormDataEntryValue, key: Текст, parent: FormData), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FormData: объект { prototype: FormData; при создании()/*(!) no_type */ Объект? }


тип GenericTransformStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


/**
* This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)
*/

тип Headers = интерфейс
{
  операция append(name: Текст, value: Текст)

  операция delete(name: Текст)

  операция get(name: Текст): Текст?FUCKFUCK

  операция getSetCookie(): Список<Текст>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Текст)

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: Headers), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ Headers: объект { prototype: Headers; при создании(init: HeadersInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursor)
*/

тип IDBCursor = интерфейс
{
  защищено 
  direction: IDBCursorDirection

  защищено 
  key: IDBValidKey

  защищено 
  primaryKey: IDBValidKey

  защищено 
  request: IDBRequest

  защищено 
  source: IDBObjectStore | IDBIndex

  операция advance(count: Число)

  операция continue(key: IDBValidKey?FUCKFUCK = пусто)

  операция continuePrimaryKey(key: IDBValidKey, primaryKey: IDBValidKey)

  операция delete(): IDBRequest<пусто>

  операция update(value: /*(!) any */ Объект?): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBCursor: объект { prototype: IDBCursor; при создании()/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database. It is the same as the IDBCursor, except that it includes the value property.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursorWithValue)
*/

тип IDBCursorWithValue = интерфейс
{
  защищено 
  value: /*(!) any */ Объект?
}


внешнее
/*(!) var */ IDBCursorWithValue: объект { prototype: IDBCursorWithValue; при создании()/*(!) no_type */ Объект? }


тип IDBDatabaseEventMap = интерфейс
{
  "abort": Event

  "close": Event

  "error": Event

  "versionchange": IDBVersionChangeEvent
}


/**
* This IndexedDB API interface provides a connection to a database; you can use an IDBDatabase object to open a transaction on your database then create, manipulate, and delete objects (data) in that database. The interface provides the only way to get and manage versions of the database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase)
*/

тип IDBDatabase = интерфейс
{
  защищено 
  name: Текст

  защищено 
  objectStoreNames: DOMStringList

  onabort: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onversionchange: операция(this: IDBDatabase, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  version: Число

  операция close()

  операция createObjectStore(name: Текст, options: IDBObjectStoreParameters?FUCKFUCK = пусто): IDBObjectStore

  операция deleteObjectStore(name: Текст)

  операция transaction(storeNames: Текст | Список<Текст>, mode: IDBTransactionMode?FUCKFUCK = пусто, options: IDBTransactionOptions?FUCKFUCK = пусто): IDBTransaction

  операция addEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBDatabase: объект { prototype: IDBDatabase; при создании()/*(!) no_type */ Объект? }


/**
* In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBFactory)
*/

тип IDBFactory = интерфейс
{
  операция cmp(first: /*(!) any */ Объект?, second: /*(!) any */ Объект?): Число

  операция databases(): Promise<Список<IDBDatabaseInfo>>

  операция deleteDatabase(name: Текст): IDBOpenDBRequest

  операция open(name: Текст, version: Число?FUCKFUCK = пусто): IDBOpenDBRequest
}


внешнее
/*(!) var */ IDBFactory: объект { prototype: IDBFactory; при создании()/*(!) no_type */ Объект? }


/**
* IDBIndex interface of the IndexedDB API provides asynchronous access to an index in a database. An index is a kind of object store for looking up records in another object store, called the referenced object store. You use this interface to retrieve data.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBIndex)
*/

тип IDBIndex = интерфейс
{
  защищено 
  keyPath: Текст | Список<Текст>

  защищено 
  multiEntry: ДаНет

  name: Текст

  защищено 
  objectStore: IDBObjectStore

  защищено 
  unique: ДаНет

  операция count(query: IDBValidKey | IDBKeyRange | пусто = пусто): IDBRequest<Число>

  операция get(query: IDBValidKey | IDBKeyRange): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey?FUCKFUCK>

  операция openCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursorWithValue?FUCKFUCK>

  операция openKeyCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursor?FUCKFUCK>
}


внешнее
/*(!) var */ IDBIndex: объект { prototype: IDBIndex; при создании()/*(!) no_type */ Объект? }


/**
* A key range can be a single value or a range with upper and lower bounds or endpoints. If the key range has both upper and lower bounds, then it is bounded; if it has no bounds, it is unbounded. A bounded key range can either be open (the endpoints are excluded) or closed (the endpoints are included). To retrieve all keys within a certain range, you can use the following code constructs:
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBKeyRange)
*/

тип IDBKeyRange = интерфейс
{
  защищено 
  lower: /*(!) any */ Объект?

  защищено 
  lowerOpen: ДаНет

  защищено 
  upper: /*(!) any */ Объект?

  защищено 
  upperOpen: ДаНет

  операция includes(key: /*(!) any */ Объект?): ДаНет
}


внешнее
/*(!) var */ IDBKeyRange: объект { prototype: IDBKeyRange; при создании()/*(!) no_type */ Объект?; операция bound(lower: /*(!) any */ Объект?, upper: /*(!) any */ Объект?, lowerOpen: ДаНет?FUCKFUCK = пусто, upperOpen: ДаНет?FUCKFUCK = пусто): IDBKeyRange; операция lowerBound(lower: /*(!) any */ Объект?, open: ДаНет?FUCKFUCK = пусто): IDBKeyRange; операция only(value: /*(!) any */ Объект?): IDBKeyRange; операция upperBound(upper: /*(!) any */ Объект?, open: ДаНет?FUCKFUCK = пусто): IDBKeyRange }


/**
* This example shows a variety of different uses of object stores, from updating the data structure with IDBObjectStore.createIndex inside an onupgradeneeded function, to adding a new item to our object store with IDBObjectStore.add. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore)
*/

тип IDBObjectStore = интерфейс
{
  защищено 
  autoIncrement: ДаНет

  защищено 
  indexNames: DOMStringList

  защищено 
  keyPath: Текст | Список<Текст>

  name: Текст

  защищено 
  transaction: IDBTransaction

  операция add(value: /*(!) any */ Объект?, key: IDBValidKey?FUCKFUCK = пусто): IDBRequest<IDBValidKey>

  операция clear(): IDBRequest<пусто>

  операция count(query: IDBValidKey | IDBKeyRange | пусто = пусто): IDBRequest<Число>

  операция createIndex(name: Текст, keyPath: Текст | Список<Текст>, options: IDBIndexParameters?FUCKFUCK = пусто): IDBIndex

  операция delete(query: IDBValidKey | IDBKeyRange): IDBRequest<пусто>

  операция deleteIndex(name: Текст)

  операция get(query: IDBValidKey | IDBKeyRange): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey?FUCKFUCK>

  операция index(name: Текст): IDBIndex

  операция openCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursorWithValue?FUCKFUCK>

  операция openKeyCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursor?FUCKFUCK>

  операция put(value: /*(!) any */ Объект?, key: IDBValidKey?FUCKFUCK = пусто): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBObjectStore: объект { prototype: IDBObjectStore; при создании()/*(!) no_type */ Объект? }


тип IDBOpenDBRequestEventMap = интерфейс
{
  "blocked": IDBVersionChangeEvent

  "upgradeneeded": IDBVersionChangeEvent
}


/**
* Also inherits methods from its parents IDBRequest and EventTarget.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBOpenDBRequest)
*/

тип IDBOpenDBRequest = интерфейс
{
  onblocked: операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  onupgradeneeded: операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBOpenDBRequest: объект { prototype: IDBOpenDBRequest; при создании()/*(!) no_type */ Объект? }


тип IDBRequestEventMap = интерфейс
{
  "error": Event

  "success": Event
}


/**
* The request object does not initially contain any information about the result of the operation, but once information becomes available, an event is fired on the request, and the information becomes available through the properties of the IDBRequest instance.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBRequest)
*/

тип IDBRequest<T> = интерфейс
{
  защищено 
  error: DOMException?FUCKFUCK

  onerror: операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsuccess: операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: IDBRequestReadyState

  защищено 
  result: T

  защищено 
  source: IDBObjectStore | IDBIndex | IDBCursor

  защищено 
  transaction: IDBTransaction?FUCKFUCK

  операция addEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBRequest: объект { prototype: IDBRequest; при создании()/*(!) no_type */ Объект? }


тип IDBTransactionEventMap = интерфейс
{
  "abort": Event

  "complete": Event

  "error": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBTransaction) */

тип IDBTransaction = интерфейс
{
  защищено 
  db: IDBDatabase

  защищено 
  durability: IDBTransactionDurability

  защищено 
  error: DOMException?FUCKFUCK

  защищено 
  mode: IDBTransactionMode

  защищено 
  objectStoreNames: DOMStringList

  onabort: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncomplete: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция abort()

  операция commit()

  операция objectStore(name: Текст): IDBObjectStore

  операция addEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBTransaction: объект { prototype: IDBTransaction; при создании()/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface indicates that the version of the database has changed, as the result of an IDBOpenDBRequest.onupgradeneeded event handler function.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBVersionChangeEvent)
*/

тип IDBVersionChangeEvent = интерфейс
{
  защищено 
  newVersion: Число?FUCKFUCK

  защищено 
  oldVersion: Число
}


внешнее
/*(!) var */ IDBVersionChangeEvent: объект { prototype: IDBVersionChangeEvent; при создании(type: Текст, eventInitDict: IDBVersionChangeEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmap) */

тип ImageBitmap = интерфейс
{
  защищено 
  height: Число

  защищено 
  width: Число

  операция close()
}


внешнее
/*(!) var */ ImageBitmap: объект { prototype: ImageBitmap; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmapRenderingContext) */

тип ImageBitmapRenderingContext = интерфейс
{
  операция transferFromImageBitmap(bitmap: ImageBitmap?FUCKFUCK)
}


внешнее
/*(!) var */ ImageBitmapRenderingContext: объект { prototype: ImageBitmapRenderingContext; при создании()/*(!) no_type */ Объект? }


/**
* The underlying pixel data of an area of a <canvas> element. It is created using the ImageData() constructor or creator methods on the CanvasRenderingContext2D object associated with a canvas: createImageData() and getImageData(). It can also be used to set a part of the canvas by using putImageData().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageData)
*/

тип ImageData = интерфейс
{
  защищено 
  colorSpace: PredefinedColorSpace

  защищено 
  data: Uint8ClampedArray

  защищено 
  height: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ ImageData: объект { prototype: ImageData; при создании(sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(data: Uint8ClampedArray, sw: Число, sh: Число?FUCKFUCK = пусто, settings: ImageDataSettings?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/KHR_parallel_shader_compile) */

тип KHR_parallel_shader_compile = интерфейс
{
  защищено 
  COMPLETION_STATUS_KHR: 0x91B1
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Lock)
*/

тип Lock = интерфейс
{
  защищено 
  mode: LockMode

  защищено 
  name: Текст
}


внешнее
/*(!) var */ Lock: объект { prototype: Lock; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/LockManager)
*/

тип LockManager = интерфейс
{
  операция query(): Promise<LockManagerSnapshot>

  операция request(name: Текст, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>

  операция request(name: Текст, options: LockOptions, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>
}


внешнее
/*(!) var */ LockManager: объект { prototype: LockManager; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaCapabilities) */

тип MediaCapabilities = интерфейс
{
  операция decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>

  операция encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesEncodingInfo>
}


внешнее
/*(!) var */ MediaCapabilities: объект { prototype: MediaCapabilities; при создании()/*(!) no_type */ Объект? }


/**
* This Channel Messaging API interface allows us to create a new message channel and send data through it via its two MessagePort properties.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel)
*/

тип MessageChannel = интерфейс
{
  защищено 
  port1: MessagePort

  защищено 
  port2: MessagePort
}


внешнее
/*(!) var */ MessageChannel: объект { prototype: MessageChannel; при создании()/*(!) no_type */ Объект? }


/**
* A message received by a target object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)
*/

тип MessageEvent<T> = интерфейс
{
  защищено 
  data: T

  защищено 
  lastEventId: Текст

  защищено 
  origin: Текст

  защищено 
  ports: ReadonlyArray<MessagePort>

  защищено 
  source: MessageEventSource?FUCKFUCK

  операция initMessageEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто, data: /*(!) any */ Объект??FUCKFUCK = пусто, origin: Текст?FUCKFUCK = пусто, lastEventId: Текст?FUCKFUCK = пусто, source: MessageEventSource?FUCKFUCK = пусто, ports: Список<MessagePort>?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MessageEvent: объект { prototype: MessageEvent; при создании(type: Текст, eventInitDict: MessageEventInit<T>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип MessagePortEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Channel Messaging API interface represents one of the two ports of a MessageChannel, allowing messages to be sent from one port and listening out for them arriving at the other.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort)
*/

тип MessagePort = интерфейс
{
  onmessage: операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция start()

  операция addEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MessagePort: объект { prototype: MessagePort; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NavigationPreloadManager)
*/

тип NavigationPreloadManager = интерфейс
{
  операция disable(): Promise<Ничего>

  операция enable(): Promise<Ничего>

  операция getState(): Promise<NavigationPreloadState>

  операция setHeaderValue(value: Текст): Promise<Ничего>
}


внешнее
/*(!) var */ NavigationPreloadManager: объект { prototype: NavigationPreloadManager; при создании()/*(!) no_type */ Объект? }


/** Available only in secure contexts. */

тип NavigatorBadge = интерфейс
{
  операция clearAppBadge(): Promise<Ничего>

  операция setAppBadge(contents: Число?FUCKFUCK = пусто): Promise<Ничего>
}


тип NavigatorConcurrentHardware = интерфейс
{
  защищено 
  hardwareConcurrency: Число
}


тип NavigatorID = интерфейс
{
  защищено 
  appCodeName: Текст

  защищено 
  appName: Текст

  защищено 
  appVersion: Текст

  защищено 
  platform: Текст

  защищено 
  product: Текст

  защищено 
  userAgent: Текст
}


тип NavigatorLanguage = интерфейс
{
  защищено 
  language: Текст

  защищено 
  languages: ReadonlyArray<Текст>
}


/** Available only in secure contexts. */

тип NavigatorLocks = интерфейс
{
  защищено 
  locks: LockManager
}


тип NavigatorOnLine = интерфейс
{
  защищено 
  onLine: ДаНет
}


/** Available only in secure contexts. */

тип NavigatorStorage = интерфейс
{
  защищено 
  storage: StorageManager
}


тип NotificationEventMap = интерфейс
{
  "click": Event

  "close": Event

  "error": Event

  "show": Event
}


/**
* This Notifications API interface is used to configure and display desktop notifications to the user.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Notification)
*/

тип Notification = интерфейс
{
  защищено 
  body: Текст

  защищено 
  data: /*(!) any */ Объект?

  защищено 
  dir: NotificationDirection

  защищено 
  icon: Текст

  защищено 
  lang: Текст

  onclick: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onshow: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  silent: ДаНет?FUCKFUCK

  защищено 
  tag: Текст

  защищено 
  title: Текст

  операция close()

  операция addEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Notification: объект { prototype: Notification; при создании(title: Текст, options: NotificationOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  permission: NotificationPermission }


/**
* The parameter passed into the onnotificationclick handler, the NotificationEvent interface represents a notification click event that is dispatched on the ServiceWorkerGlobalScope of a ServiceWorker.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NotificationEvent)
*/

тип NotificationEvent = интерфейс
{
  защищено 
  action: Текст

  защищено 
  notification: Notification
}


внешнее
/*(!) var */ NotificationEvent: объект { prototype: NotificationEvent; при создании(type: Текст, eventInitDict: NotificationEventInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_draw_buffers_indexed) */

тип OES_draw_buffers_indexed = интерфейс
{
  операция blendEquationSeparateiOES(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum)

  операция blendEquationiOES(buf: GLuint, mode: GLenum)

  операция blendFuncSeparateiOES(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция blendFunciOES(buf: GLuint, src: GLenum, dst: GLenum)

  операция colorMaskiOES(buf: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean)

  операция disableiOES(target: GLenum, index: GLuint)

  операция enableiOES(target: GLenum, index: GLuint)
}


/**
* The OES_element_index_uint extension is part of the WebGL API and adds support for gl.UNSIGNED_INT types to WebGLRenderingContext.drawElements().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_element_index_uint)
*/

тип OES_element_index_uint = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_fbo_render_mipmap) */

тип OES_fbo_render_mipmap = интерфейс
{

}


/**
* The OES_standard_derivatives extension is part of the WebGL API and adds the GLSL derivative functions dFdx, dFdy, and fwidth.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_standard_derivatives)
*/

тип OES_standard_derivatives = интерфейс
{
  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B
}


/**
* The OES_texture_float extension is part of the WebGL API and exposes floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float)
*/

тип OES_texture_float = интерфейс
{

}


/**
* The OES_texture_float_linear extension is part of the WebGL API and allows linear filtering with floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float_linear)
*/

тип OES_texture_float_linear = интерфейс
{

}


/**
* The OES_texture_half_float extension is part of the WebGL API and adds texture formats with 16- (aka half float) and 32-bit floating-point components.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float)
*/

тип OES_texture_half_float = интерфейс
{
  защищено 
  HALF_FLOAT_OES: 0x8D61
}


/**
* The OES_texture_half_float_linear extension is part of the WebGL API and allows linear filtering with half floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float_linear)
*/

тип OES_texture_half_float_linear = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_vertex_array_object) */

тип OES_vertex_array_object = интерфейс
{
  операция bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK)

  операция createVertexArrayOES(): WebGLVertexArrayObjectOES?FUCKFUCK

  операция deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK)

  операция isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK): GLboolean

  защищено 
  VERTEX_ARRAY_BINDING_OES: 0x85B5
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OVR_multiview2) */

тип OVR_multiview2 = интерфейс
{
  операция framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint, baseViewIndex: GLint, numViews: GLsizei)

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR: 0x9630

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: 0x9632

  защищено 
  MAX_VIEWS_OVR: 0x9631

  защищено 
  FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: 0x9633
}


тип OffscreenCanvasEventMap = интерфейс
{
  "contextlost": Event

  "contextrestored": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvas) */

тип OffscreenCanvas = интерфейс
{
  height: Число

  oncontextlost: операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncontextrestored: операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект??FUCKFUCK

  width: Число

  операция convertToBlob(options: ImageEncodeOptions?FUCKFUCK = пусто): Promise<Blob>

  операция getContext(contextId: "2d", options: /*(!) any */ Объект??FUCKFUCK = пусто): OffscreenCanvasRenderingContext2D?FUCKFUCK

  операция getContext(contextId: "bitmaprenderer", options: /*(!) any */ Объект??FUCKFUCK = пусто): ImageBitmapRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl", options: /*(!) any */ Объект??FUCKFUCK = пусто): WebGLRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl2", options: /*(!) any */ Объект??FUCKFUCK = пусто): WebGL2RenderingContext?FUCKFUCK

  операция getContext(contextId: OffscreenRenderingContextId, options: /*(!) any */ Объект??FUCKFUCK = пусто): OffscreenRenderingContext?FUCKFUCK

  операция transferToImageBitmap(): ImageBitmap

  операция addEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ OffscreenCanvas: объект { prototype: OffscreenCanvas; при создании(width: Число, height: Число)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvasRenderingContext2D) */

тип OffscreenCanvasRenderingContext2D = интерфейс
{
  защищено 
  canvas: OffscreenCanvas

  операция commit()
}


внешнее
/*(!) var */ OffscreenCanvasRenderingContext2D: объект { prototype: OffscreenCanvasRenderingContext2D; при создании()/*(!) no_type */ Объект? }


/**
* This Canvas 2D API interface is used to declare a path that can then be used on a CanvasRenderingContext2D object. The path methods of the CanvasRenderingContext2D interface are also present on this interface, which gives you the convenience of being able to retain and replay your path whenever desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Path2D)
*/

тип Path2D = интерфейс
{
  операция addPath(path: Path2D, transform: DOMMatrix2DInit?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ Path2D: объект { prototype: Path2D; при создании(path: Path2D | Текст | пусто = пусто)/*(!) no_type */ Объект? }


тип PerformanceEventMap = интерфейс
{
  "resourcetimingbufferfull": Event
}


/**
* Provides access to performance-related information for the current page. It's part of the High Resolution Time API, but is enhanced by the Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Performance)
*/

тип Performance = интерфейс
{
  onresourcetimingbufferfull: операция(this: Performance, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  timeOrigin: DOMHighResTimeStamp

  операция clearMarks(markName: Текст?FUCKFUCK = пусто)

  операция clearMeasures(measureName: Текст?FUCKFUCK = пусто)

  операция clearResourceTimings()

  операция getEntries(): PerformanceEntryList

  операция getEntriesByName(name: Текст, type: Текст?FUCKFUCK = пусто): PerformanceEntryList

  операция getEntriesByType(type: Текст): PerformanceEntryList

  операция mark(markName: Текст, markOptions: PerformanceMarkOptions?FUCKFUCK = пусто): PerformanceMark

  операция measure(measureName: Текст, startOrMeasureOptions: Текст | PerformanceMeasureOptions | пусто = пусто, endMark: Текст?FUCKFUCK = пусто): PerformanceMeasure

  операция now(): DOMHighResTimeStamp

  операция setResourceTimingBufferSize(maxSize: Число)

  операция toJSON(): /*(!) any */ Объект?

  операция addEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Performance: объект { prototype: Performance; при создании()/*(!) no_type */ Объект? }


/**
* Encapsulates a single performance metric that is part of the performance timeline. A performance entry can be directly created by making a performance mark or measure (for example by calling the mark() method) at an explicit point in an application. Performance entries are also created in indirect ways such as loading a resource (such as an image).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry)
*/

тип PerformanceEntry = интерфейс
{
  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  entryType: Текст

  защищено 
  name: Текст

  защищено 
  startTime: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceEntry: объект { prototype: PerformanceEntry; при создании()/*(!) no_type */ Объект? }


/**
* PerformanceMark is an abstract interface for PerformanceEntry objects with an entryType of "mark". Entries of this type are created by calling performance.mark() to add a named DOMHighResTimeStamp (the mark) to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMark)
*/

тип PerformanceMark = интерфейс
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMark: объект { prototype: PerformanceMark; при создании(markName: Текст, markOptions: PerformanceMarkOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* PerformanceMeasure is an abstract interface for PerformanceEntry objects with an entryType of "measure". Entries of this type are created by calling performance.measure() to add a named DOMHighResTimeStamp (the measure) between two marks to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMeasure)
*/

тип PerformanceMeasure = интерфейс
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMeasure: объект { prototype: PerformanceMeasure; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) */

тип PerformanceObserver = интерфейс
{
  операция disconnect()

  операция observe(options: PerformanceObserverInit?FUCKFUCK = пусто)

  операция takeRecords(): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserver: объект { prototype: PerformanceObserver; при создании(callback: PerformanceObserverCallback)/*(!) no_type */ Объект?; защищено  supportedEntryTypes: ReadonlyArray<Текст> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserverEntryList) */

тип PerformanceObserverEntryList = интерфейс
{
  операция getEntries(): PerformanceEntryList

  операция getEntriesByName(name: Текст, type: Текст?FUCKFUCK = пусто): PerformanceEntryList

  операция getEntriesByType(type: Текст): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserverEntryList: объект { prototype: PerformanceObserverEntryList; при создании()/*(!) no_type */ Объект? }


/**
* Enables retrieval and analysis of detailed network timing data regarding the loading of an application's resources. An application can use the timing metrics to determine, for example, the length of time it takes to fetch a specific resource, such as an XMLHttpRequest, <SVG>, image, or script.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming)
*/

тип PerformanceResourceTiming = интерфейс
{
  защищено 
  connectEnd: DOMHighResTimeStamp

  защищено 
  connectStart: DOMHighResTimeStamp

  защищено 
  decodedBodySize: Число

  защищено 
  domainLookupEnd: DOMHighResTimeStamp

  защищено 
  domainLookupStart: DOMHighResTimeStamp

  защищено 
  encodedBodySize: Число

  защищено 
  fetchStart: DOMHighResTimeStamp

  защищено 
  initiatorType: Текст

  защищено 
  nextHopProtocol: Текст

  защищено 
  redirectEnd: DOMHighResTimeStamp

  защищено 
  redirectStart: DOMHighResTimeStamp

  защищено 
  requestStart: DOMHighResTimeStamp

  защищено 
  responseEnd: DOMHighResTimeStamp

  защищено 
  responseStart: DOMHighResTimeStamp

  защищено 
  secureConnectionStart: DOMHighResTimeStamp

  защищено 
  serverTiming: ReadonlyArray<PerformanceServerTiming>

  защищено 
  transferSize: Число

  защищено 
  workerStart: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceResourceTiming: объект { prototype: PerformanceResourceTiming; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceServerTiming) */

тип PerformanceServerTiming = интерфейс
{
  защищено 
  description: Текст

  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  name: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceServerTiming: объект { prototype: PerformanceServerTiming; при создании()/*(!) no_type */ Объект? }


тип PermissionStatusEventMap = интерфейс
{
  "change": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PermissionStatus) */

тип PermissionStatus = интерфейс
{
  защищено 
  name: Текст

  onchange: операция(this: PermissionStatus, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: PermissionState

  операция addEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ PermissionStatus: объект { prototype: PermissionStatus; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Permissions) */

тип Permissions = интерфейс
{
  операция query(permissionDesc: PermissionDescriptor): Promise<PermissionStatus>
}


внешнее
/*(!) var */ Permissions: объект { prototype: Permissions; при создании()/*(!) no_type */ Объект? }


/**
* Events measuring progress of an underlying process, like an HTTP request (for an XMLHttpRequest, or the loading of the underlying resource of an <img>, <audio>, <video>, <style> or <link>).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent)
*/

тип ProgressEvent<T = EventTarget> = интерфейс
{
  защищено 
  lengthComputable: ДаНет

  защищено 
  loaded: Число

  защищено 
  target: T?FUCKFUCK

  защищено 
  total: Число
}


внешнее
/*(!) var */ ProgressEvent: объект { prototype: ProgressEvent; при создании(type: Текст, eventInitDict: ProgressEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */

тип PromiseRejectionEvent = интерфейс
{
  защищено 
  promise: Promise</*(!) any */ Объект?>

  защищено 
  reason: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PromiseRejectionEvent: объект { prototype: PromiseRejectionEvent; при создании(type: Текст, eventInitDict: PromiseRejectionEventInit)/*(!) no_type */ Объект? }


/**
* This Push API interface represents a push message that has been received. This event is sent to the global scope of a ServiceWorker. It contains the information sent from an application server to a PushSubscription.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushEvent)
*/

тип PushEvent = интерфейс
{
  защищено 
  data: PushMessageData?FUCKFUCK
}


внешнее
/*(!) var */ PushEvent: объект { prototype: PushEvent; при создании(type: Текст, eventInitDict: PushEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Push API interface provides a way to receive notifications from third-party servers as well as request URLs for push notifications.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushManager)
*/

тип PushManager = интерфейс
{
  операция getSubscription(): Promise<PushSubscription?FUCKFUCK>

  операция permissionState(options: PushSubscriptionOptionsInit?FUCKFUCK = пусто): Promise<PermissionState>

  операция subscribe(options: PushSubscriptionOptionsInit?FUCKFUCK = пусто): Promise<PushSubscription>
}


внешнее
/*(!) var */ PushManager: объект { prototype: PushManager; при создании()/*(!) no_type */ Объект?; защищено  supportedContentEncodings: ReadonlyArray<Текст> }


/**
* This Push API interface provides methods which let you retrieve the push data sent by a server in various formats.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushMessageData)
*/

тип PushMessageData = интерфейс
{
  операция arrayBuffer(): ArrayBuffer

  операция blob(): Blob

  операция json(): /*(!) any */ Объект?

  операция text(): Текст
}


внешнее
/*(!) var */ PushMessageData: объект { prototype: PushMessageData; при создании()/*(!) no_type */ Объект? }


/**
* This Push API interface provides a subcription's URL endpoint and allows unsubscription from a push service.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscription)
*/

тип PushSubscription = интерфейс
{
  защищено 
  endpoint: Текст

  защищено 
  expirationTime: EpochTimeStamp?FUCKFUCK

  защищено 
  options: PushSubscriptionOptions

  операция getKey(name: PushEncryptionKeyName): ArrayBuffer?FUCKFUCK

  операция toJSON(): PushSubscriptionJSON

  операция unsubscribe(): Promise<ДаНет>
}


внешнее
/*(!) var */ PushSubscription: объект { prototype: PushSubscription; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscriptionOptions)
*/

тип PushSubscriptionOptions = интерфейс
{
  защищено 
  applicationServerKey: ArrayBuffer?FUCKFUCK

  защищено 
  userVisibleOnly: ДаНет
}


внешнее
/*(!) var */ PushSubscriptionOptions: объект { prototype: PushSubscriptionOptions; при создании()/*(!) no_type */ Объект? }


тип RTCEncodedAudioFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  операция getMetadata(): RTCEncodedAudioFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedAudioFrame: объект { prototype: RTCEncodedAudioFrame; при создании()/*(!) no_type */ Объект? }


тип RTCEncodedVideoFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  защищено 
  type: RTCEncodedVideoFrameType

  операция getMetadata(): RTCEncodedVideoFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedVideoFrame: объект { prototype: RTCEncodedVideoFrame; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */

тип ReadableByteStreamController = интерфейс
{
  защищено 
  byobRequest: ReadableStreamBYOBRequest?FUCKFUCK

  защищено 
  desiredSize: Число?FUCKFUCK

  операция close()

  операция enqueue(chunk: ArrayBufferView)

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ ReadableByteStreamController: объект { prototype: ReadableByteStreamController; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)
*/

тип ReadableStream<R> = интерфейс
{
  защищено 
  locked: ДаНет

  операция cancel(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция getReader(options: объект { mode: "byob" }): ReadableStreamBYOBReader

  операция getReader(): ReadableStreamDefaultReader<R>

  операция getReader(options: ReadableStreamGetReaderOptions?FUCKFUCK = пусто): ReadableStreamReader<R>

  операция pipeThrough<T>(transform: ReadableWritablePair<T, R>, options: StreamPipeOptions?FUCKFUCK = пусто): ReadableStream<T>

  операция pipeTo(destination: WritableStream<R>, options: StreamPipeOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция tee(): объект { _0: ReadableStream<R>, _1: ReadableStream<R> }
}


внешнее
/*(!) var */ ReadableStream: объект { prototype: ReadableStream; при создании(underlyingSource: UnderlyingByteSource, strategy: объект { highWaterMark: Число }?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(underlyingSource: UnderlyingDefaultSource<R>, strategy: QueuingStrategy<R>?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(underlyingSource: UnderlyingSource<R>?FUCKFUCK = пусто, strategy: QueuingStrategy<R>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */

тип ReadableStreamBYOBReader = интерфейс
{
  операция read<T = ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamBYOBReader: объект { prototype: ReadableStreamBYOBReader; при создании(stream: ReadableStream)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */

тип ReadableStreamBYOBRequest = интерфейс
{
  защищено 
  view: ArrayBufferView?FUCKFUCK

  операция respond(bytesWritten: Число)

  операция respondWithNewView(view: ArrayBufferView)
}


внешнее
/*(!) var */ ReadableStreamBYOBRequest: объект { prototype: ReadableStreamBYOBRequest; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */

тип ReadableStreamDefaultController<R> = интерфейс
{
  защищено 
  desiredSize: Число?FUCKFUCK

  операция close()

  операция enqueue(chunk: R?FUCKFUCK = пусто)

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ ReadableStreamDefaultController: объект { prototype: ReadableStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */

тип ReadableStreamDefaultReader<R> = интерфейс
{
  операция read(): Promise<ReadableStreamReadResult<R>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamDefaultReader: объект { prototype: ReadableStreamDefaultReader; при создании(stream: ReadableStream<R>)/*(!) no_type */ Объект? }


тип ReadableStreamGenericReader = интерфейс
{
  защищено 
  closed: Promise<пусто>

  операция cancel(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Report) */

тип Report = интерфейс
{
  защищено 
  body: ReportBody?FUCKFUCK

  защищено 
  type: Текст

  защищено 
  url: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ Report: объект { prototype: Report; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportBody) */

тип ReportBody = интерфейс
{
  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ ReportBody: объект { prototype: ReportBody; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportingObserver) */

тип ReportingObserver = интерфейс
{
  операция disconnect()

  операция observe()

  операция takeRecords(): ReportList
}


внешнее
/*(!) var */ ReportingObserver: объект { prototype: ReportingObserver; при создании(callback: ReportingObserverCallback, options: ReportingObserverOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Fetch API interface represents a resource request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)
*/

тип Request = интерфейс
{
  защищено 
  cache: RequestCache

  защищено 
  credentials: RequestCredentials

  защищено 
  destination: RequestDestination

  защищено 
  headers: Headers

  защищено 
  integrity: Текст

  защищено 
  keepalive: ДаНет

  защищено 
  method: Текст

  защищено 
  mode: RequestMode

  защищено 
  redirect: RequestRedirect

  защищено 
  referrer: Текст

  защищено 
  referrerPolicy: ReferrerPolicy

  защищено 
  signal: AbortSignal

  защищено 
  url: Текст

  операция clone(): Request
}


внешнее
/*(!) var */ Request: объект { prototype: Request; при создании(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Fetch API interface represents the response to a request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)
*/

тип Response = интерфейс
{
  защищено 
  headers: Headers

  защищено 
  ok: ДаНет

  защищено 
  redirected: ДаНет

  защищено 
  status: Число

  защищено 
  statusText: Текст

  защищено 
  type: ResponseType

  защищено 
  url: Текст

  операция clone(): Response
}


внешнее
/*(!) var */ Response: объект { prototype: Response; при создании(body: BodyInit?FUCKFUCK = пусто, init: ResponseInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция error(): Response; операция json(data: /*(!) any */ Объект?, init: ResponseInit?FUCKFUCK = пусто): Response; операция redirect(url: Текст | URL, status: Число?FUCKFUCK = пусто): Response }


/**
* Inherits from Event, and represents the event object of an event sent on a document or worker when its content security policy is violated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SecurityPolicyViolationEvent)
*/

тип SecurityPolicyViolationEvent = интерфейс
{
  защищено 
  blockedURI: Текст

  защищено 
  columnNumber: Число

  защищено 
  disposition: SecurityPolicyViolationEventDisposition

  защищено 
  documentURI: Текст

  защищено 
  effectiveDirective: Текст

  защищено 
  lineNumber: Число

  защищено 
  originalPolicy: Текст

  защищено 
  referrer: Текст

  защищено 
  sample: Текст

  защищено 
  sourceFile: Текст

  защищено 
  statusCode: Число

  защищено 
  violatedDirective: Текст
}


внешнее
/*(!) var */ SecurityPolicyViolationEvent: объект { prototype: SecurityPolicyViolationEvent; при создании(type: Текст, eventInitDict: SecurityPolicyViolationEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип ServiceWorkerEventMap = интерфейс
{
  "statechange": Event
}


/**
* This ServiceWorker API interface provides a reference to a service worker. Multiple browsing contexts (e.g. pages, workers, etc.) can be associated with the same service worker, each through a unique ServiceWorker object.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorker)
*/

тип ServiceWorker = интерфейс
{
  onstatechange: операция(this: ServiceWorker, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  scriptURL: Текст

  защищено 
  state: ServiceWorkerState

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorker: объект { prototype: ServiceWorker; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerContainerEventMap = интерфейс
{
  "controllerchange": Event

  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* The ServiceWorkerContainer interface of the ServiceWorker API provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister and update service workers, and access the state of service workers and their registrations.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerContainer)
*/

тип ServiceWorkerContainer = интерфейс
{
  защищено 
  controller: ServiceWorker?FUCKFUCK

  oncontrollerchange: операция(this: ServiceWorkerContainer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ready: Promise<ServiceWorkerRegistration>

  операция getRegistration(clientURL: Текст | URL | пусто = пусто): Promise<ServiceWorkerRegistration?FUCKFUCK>

  операция getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>

  операция register(scriptURL: Текст | URL, options: RegistrationOptions?FUCKFUCK = пусто): Promise<ServiceWorkerRegistration>

  операция startMessages()

  операция addEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorkerContainer: объект { prototype: ServiceWorkerContainer; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerGlobalScopeEventMap = интерфейс
{
  "activate": ExtendableEvent

  "fetch": FetchEvent

  "install": ExtendableEvent

  "message": ExtendableMessageEvent

  "messageerror": MessageEvent

  "notificationclick": NotificationEvent

  "notificationclose": NotificationEvent

  "push": PushEvent

  "pushsubscriptionchange": Event
}


/**
* This ServiceWorker API interface represents the global execution context of a service worker.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope)
*/

тип ServiceWorkerGlobalScope = интерфейс
{
  защищено 
  clients: Clients

  onactivate: операция(this: ServiceWorkerGlobalScope, ev: ExtendableEvent): /*(!) any */ Объект??FUCKFUCK

  onfetch: операция(this: ServiceWorkerGlobalScope, ev: FetchEvent): /*(!) any */ Объект??FUCKFUCK

  oninstall: операция(this: ServiceWorkerGlobalScope, ev: ExtendableEvent): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: ServiceWorkerGlobalScope, ev: ExtendableMessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: ServiceWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onnotificationclick: операция(this: ServiceWorkerGlobalScope, ev: NotificationEvent): /*(!) any */ Объект??FUCKFUCK

  onnotificationclose: операция(this: ServiceWorkerGlobalScope, ev: NotificationEvent): /*(!) any */ Объект??FUCKFUCK

  onpush: операция(this: ServiceWorkerGlobalScope, ev: PushEvent): /*(!) any */ Объект??FUCKFUCK

  onpushsubscriptionchange: операция(this: ServiceWorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  registration: ServiceWorkerRegistration

  защищено 
  serviceWorker: ServiceWorker

  операция skipWaiting(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof ServiceWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerGlobalScope, ev: /*(!) ServiceWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerGlobalScope, ev: /*(!) ServiceWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorkerGlobalScope: объект { prototype: ServiceWorkerGlobalScope; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerRegistrationEventMap = интерфейс
{
  "updatefound": Event
}


/**
* This ServiceWorker API interface represents the service worker registration. You register a service worker to control one or more pages that share the same origin.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration)
*/

тип ServiceWorkerRegistration = интерфейс
{
  защищено 
  active: ServiceWorker?FUCKFUCK

  защищено 
  installing: ServiceWorker?FUCKFUCK

  защищено 
  navigationPreload: NavigationPreloadManager

  onupdatefound: операция(this: ServiceWorkerRegistration, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  pushManager: PushManager

  защищено 
  scope: Текст

  защищено 
  updateViaCache: ServiceWorkerUpdateViaCache

  защищено 
  waiting: ServiceWorker?FUCKFUCK

  операция getNotifications(filter: GetNotificationOptions?FUCKFUCK = пусто): Promise<Список<Notification>>

  операция showNotification(title: Текст, options: NotificationOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция unregister(): Promise<ДаНет>

  операция update(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorkerRegistration: объект { prototype: ServiceWorkerRegistration; при создании()/*(!) no_type */ Объект? }


тип SharedWorkerGlobalScopeEventMap = интерфейс
{
  "connect": MessageEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SharedWorkerGlobalScope) */

тип SharedWorkerGlobalScope = интерфейс
{
  защищено 
  name: Текст

  onconnect: операция(this: SharedWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция addEventListener<K = /*(!) keyof SharedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: SharedWorkerGlobalScope, ev: /*(!) SharedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SharedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: SharedWorkerGlobalScope, ev: /*(!) SharedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SharedWorkerGlobalScope: объект { prototype: SharedWorkerGlobalScope; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StorageManager)
*/

тип StorageManager = интерфейс
{
  операция estimate(): Promise<StorageEstimate>

  операция getDirectory(): Promise<FileSystemDirectoryHandle>

  операция persisted(): Promise<ДаНет>
}


внешнее
/*(!) var */ StorageManager: объект { prototype: StorageManager; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StylePropertyMapReadOnly) */

тип StylePropertyMapReadOnly = интерфейс
{
  защищено 
  size: Число

  операция get(property: Текст): CSSStyleValue?FUCKFUCK

  операция getAll(property: Текст): Список<CSSStyleValue>

  операция has(property: Текст): ДаНет

  операция forEach(callbackfn: операция(value: Список<CSSStyleValue>, key: Текст, parent: StylePropertyMapReadOnly), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ StylePropertyMapReadOnly: объект { prototype: StylePropertyMapReadOnly; при создании()/*(!) no_type */ Объект? }


/**
* This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)
*/

тип SubtleCrypto = интерфейс
{
  операция decrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция deriveBits(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, length: Число): Promise<ArrayBuffer>

  операция deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>

  операция encrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>

  операция exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>

  операция exportKey(format: KeyFormat, key: CryptoKey): Promise<ArrayBuffer | JsonWebKey>

  операция generateKey(algorithm: "Ed25519", extractable: ДаНет, keyUsages: ReadonlyArray<"sign" | "verify">): Promise<CryptoKeyPair>

  операция generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>

  операция generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция generateKey(algorithm: AlgorithmIdentifier, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKeyPair | CryptoKey>

  операция importKey(format: "jwk", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция importKey(format: Exclude<KeyFormat, "jwk">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция sign(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция verify(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<ДаНет>

  операция wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<ArrayBuffer>
}


внешнее
/*(!) var */ SubtleCrypto: объект { prototype: SubtleCrypto; при создании()/*(!) no_type */ Объект? }


/**
* A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)
*/

тип TextDecoder = интерфейс
{
  операция decode(input: AllowSharedBufferSource?FUCKFUCK = пусто, options: TextDecodeOptions?FUCKFUCK = пусто): Текст
}


внешнее
/*(!) var */ TextDecoder: объект { prototype: TextDecoder; при создании(label: Текст?FUCKFUCK = пусто, options: TextDecoderOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип TextDecoderCommon = интерфейс
{
  защищено 
  encoding: Текст

  защищено 
  fatal: ДаНет

  защищено 
  ignoreBOM: ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */

тип TextDecoderStream = интерфейс
{
  защищено 
  readable: ReadableStream<Текст>

  защищено 
  writable: WritableStream<BufferSource>
}


внешнее
/*(!) var */ TextDecoderStream: объект { prototype: TextDecoderStream; при создании(label: Текст?FUCKFUCK = пусто, options: TextDecoderOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)
*/

тип TextEncoder = интерфейс
{
  операция encode(input: Текст?FUCKFUCK = пусто): Uint8Array

  операция encodeInto(source: Текст, destination: Uint8Array): TextEncoderEncodeIntoResult
}


внешнее
/*(!) var */ TextEncoder: объект { prototype: TextEncoder; при создании()/*(!) no_type */ Объект? }


тип TextEncoderCommon = интерфейс
{
  защищено 
  encoding: Текст
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */

тип TextEncoderStream = интерфейс
{
  защищено 
  readable: ReadableStream<Uint8Array>

  защищено 
  writable: WritableStream<Текст>
}


внешнее
/*(!) var */ TextEncoderStream: объект { prototype: TextEncoderStream; при создании()/*(!) no_type */ Объект? }


/**
* The dimensions of a piece of text in the canvas, as created by the CanvasRenderingContext2D.measureText() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextMetrics)
*/

тип TextMetrics = интерфейс
{
  защищено 
  actualBoundingBoxAscent: Число

  защищено 
  actualBoundingBoxDescent: Число

  защищено 
  actualBoundingBoxLeft: Число

  защищено 
  actualBoundingBoxRight: Число

  защищено 
  fontBoundingBoxAscent: Число

  защищено 
  fontBoundingBoxDescent: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ TextMetrics: объект { prototype: TextMetrics; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */

тип TransformStream<I, O> = интерфейс
{
  защищено 
  readable: ReadableStream<O>

  защищено 
  writable: WritableStream<I>
}


внешнее
/*(!) var */ TransformStream: объект { prototype: TransformStream; при создании(transformer: Transformer<I, O>?FUCKFUCK = пусто, writableStrategy: QueuingStrategy<I>?FUCKFUCK = пусто, readableStrategy: QueuingStrategy<O>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */

тип TransformStreamDefaultController<O> = интерфейс
{
  защищено 
  desiredSize: Число?FUCKFUCK

  операция enqueue(chunk: O?FUCKFUCK = пусто)

  операция error(reason: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция terminate()
}


внешнее
/*(!) var */ TransformStreamDefaultController: объект { prototype: TransformStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/**
* The URL interface represents an object providing static methods used for creating object URLs.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)
*/

тип URL = интерфейс
{
  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  password: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  защищено 
  searchParams: URLSearchParams

  username: Текст

  операция toJSON(): Текст
}


внешнее
/*(!) var */ URL: объект { prototype: URL; при создании(url: Текст | URL, base: Текст | URL | пусто = пусто)/*(!) no_type */ Объект?; операция canParse(url: Текст | URL, base: Текст?FUCKFUCK = пусто): ДаНет; операция createObjectURL(obj: Blob): Текст; операция revokeObjectURL(url: Текст) }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */

тип URLSearchParams = интерфейс
{
  защищено 
  size: Число

  операция append(name: Текст, value: Текст)

  операция delete(name: Текст, value: Текст?FUCKFUCK = пусто)

  операция get(name: Текст): Текст?FUCKFUCK

  операция getAll(name: Текст): Список<Текст>

  операция has(name: Текст, value: Текст?FUCKFUCK = пусто): ДаНет

  операция set(name: Текст, value: Текст)

  операция sort()

  операция toString(): Текст

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: URLSearchParams), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ URLSearchParams: объект { prototype: URLSearchParams; при создании(init: Список<Список<Текст>> | Record<Текст, Текст> | Текст | URLSearchParams | пусто = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoColorSpace) */

тип VideoColorSpace = интерфейс
{
  защищено 
  fullRange: ДаНет?FUCKFUCK

  защищено 
  matrix: VideoMatrixCoefficients?FUCKFUCK

  защищено 
  primaries: VideoColorPrimaries?FUCKFUCK

  защищено 
  transfer: VideoTransferCharacteristics?FUCKFUCK

  операция toJSON(): VideoColorSpaceInit
}


внешнее
/*(!) var */ VideoColorSpace: объект { prototype: VideoColorSpace; при создании(init: VideoColorSpaceInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип VideoDecoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoDecoder)
*/

тип VideoDecoder = интерфейс
{
  защищено 
  decodeQueueSize: Число

  ondequeue: операция(this: VideoDecoder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoDecoderConfig)

  операция decode(chunk: EncodedVideoChunk)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VideoDecoder: объект { prototype: VideoDecoder; при создании(init: VideoDecoderInit)/*(!) no_type */ Объект?; операция isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport> }


тип VideoEncoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoEncoder)
*/

тип VideoEncoder = интерфейс
{
  защищено 
  encodeQueueSize: Число

  ondequeue: операция(this: VideoEncoder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoEncoderConfig)

  операция encode(frame: VideoFrame, options: VideoEncoderEncodeOptions?FUCKFUCK = пусто)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VideoEncoder: объект { prototype: VideoEncoder; при создании(init: VideoEncoderInit)/*(!) no_type */ Объект?; операция isConfigSupported(config: VideoEncoderConfig): Promise<VideoEncoderSupport> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoFrame) */

тип VideoFrame = интерфейс
{
  защищено 
  codedHeight: Число

  защищено 
  codedRect: DOMRectReadOnly?FUCKFUCK

  защищено 
  codedWidth: Число

  защищено 
  colorSpace: VideoColorSpace

  защищено 
  displayHeight: Число

  защищено 
  displayWidth: Число

  защищено 
  duration: Число?FUCKFUCK

  защищено 
  format: VideoPixelFormat?FUCKFUCK

  защищено 
  timestamp: Число

  защищено 
  visibleRect: DOMRectReadOnly?FUCKFUCK

  операция allocationSize(options: VideoFrameCopyToOptions?FUCKFUCK = пусто): Число

  операция clone(): VideoFrame

  операция close()

  операция copyTo(destination: BufferSource, options: VideoFrameCopyToOptions?FUCKFUCK = пусто): Promise<Список<PlaneLayout>>
}


внешнее
/*(!) var */ VideoFrame: объект { prototype: VideoFrame; при создании(image: CanvasImageSource, init: VideoFrameInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(data: BufferSource, init: VideoFrameBufferInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_color_buffer_float) */

тип WEBGL_color_buffer_float = интерфейс
{
  защищено 
  RGBA32F_EXT: 0x8814

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_astc) */

тип WEBGL_compressed_texture_astc = интерфейс
{
  операция getSupportedProfiles(): Список<Текст>

  защищено 
  COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93B0

  защищено 
  COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93B1

  защищено 
  COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93B2

  защищено 
  COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93B3

  защищено 
  COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93B4

  защищено 
  COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93B5

  защищено 
  COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93B6

  защищено 
  COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93B7

  защищено 
  COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93B8

  защищено 
  COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93B9

  защищено 
  COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93BA

  защищено 
  COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93BB

  защищено 
  COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93BC

  защищено 
  COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93BD

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93D0

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93D1

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93D2

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93D3

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93D4

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93D5

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93D6

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93D7

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93D8

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93D9

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93DA

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93DB

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93DC

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93DD
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc) */

тип WEBGL_compressed_texture_etc = интерфейс
{
  защищено 
  COMPRESSED_R11_EAC: 0x9270

  защищено 
  COMPRESSED_SIGNED_R11_EAC: 0x9271

  защищено 
  COMPRESSED_RG11_EAC: 0x9272

  защищено 
  COMPRESSED_SIGNED_RG11_EAC: 0x9273

  защищено 
  COMPRESSED_RGB8_ETC2: 0x9274

  защищено 
  COMPRESSED_SRGB8_ETC2: 0x9275

  защищено 
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276

  защищено 
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277

  защищено 
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc1) */

тип WEBGL_compressed_texture_etc1 = интерфейс
{
  защищено 
  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_pvrtc) */

тип WEBGL_compressed_texture_pvrtc = интерфейс
{
  защищено 
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00

  защищено 
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01

  защищено 
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02

  защищено 
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03
}


/**
* The WEBGL_compressed_texture_s3tc extension is part of the WebGL API and exposes four S3TC compressed texture formats.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc)
*/

тип WEBGL_compressed_texture_s3tc = интерфейс
{
  защищено 
  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0

  защищено 
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1

  защищено 
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2

  защищено 
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc_srgb) */

тип WEBGL_compressed_texture_s3tc_srgb = интерфейс
{
  защищено 
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8C4C

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8C4D

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8C4E

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8C4F
}


/**
* The WEBGL_debug_renderer_info extension is part of the WebGL API and exposes two constants with information about the graphics driver for debugging purposes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_renderer_info)
*/

тип WEBGL_debug_renderer_info = интерфейс
{
  защищено 
  UNMASKED_VENDOR_WEBGL: 0x9245

  защищено 
  UNMASKED_RENDERER_WEBGL: 0x9246
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_shaders) */

тип WEBGL_debug_shaders = интерфейс
{
  операция getTranslatedShaderSource(shader: WebGLShader): Текст
}


/**
* The WEBGL_depth_texture extension is part of the WebGL API and defines 2D depth and depth-stencil textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_depth_texture)
*/

тип WEBGL_depth_texture = интерфейс
{
  защищено 
  UNSIGNED_INT_24_8_WEBGL: 0x84FA
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers) */

тип WEBGL_draw_buffers = интерфейс
{
  операция drawBuffersWEBGL(buffers: Список<GLenum>)

  защищено 
  COLOR_ATTACHMENT0_WEBGL: 0x8CE0

  защищено 
  COLOR_ATTACHMENT1_WEBGL: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2_WEBGL: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3_WEBGL: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4_WEBGL: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5_WEBGL: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6_WEBGL: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7_WEBGL: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8_WEBGL: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9_WEBGL: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10_WEBGL: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11_WEBGL: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12_WEBGL: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13_WEBGL: 0x8CED

  защищено 
  COLOR_ATTACHMENT14_WEBGL: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15_WEBGL: 0x8CEF

  защищено 
  DRAW_BUFFER0_WEBGL: 0x8825

  защищено 
  DRAW_BUFFER1_WEBGL: 0x8826

  защищено 
  DRAW_BUFFER2_WEBGL: 0x8827

  защищено 
  DRAW_BUFFER3_WEBGL: 0x8828

  защищено 
  DRAW_BUFFER4_WEBGL: 0x8829

  защищено 
  DRAW_BUFFER5_WEBGL: 0x882A

  защищено 
  DRAW_BUFFER6_WEBGL: 0x882B

  защищено 
  DRAW_BUFFER7_WEBGL: 0x882C

  защищено 
  DRAW_BUFFER8_WEBGL: 0x882D

  защищено 
  DRAW_BUFFER9_WEBGL: 0x882E

  защищено 
  DRAW_BUFFER10_WEBGL: 0x882F

  защищено 
  DRAW_BUFFER11_WEBGL: 0x8830

  защищено 
  DRAW_BUFFER12_WEBGL: 0x8831

  защищено 
  DRAW_BUFFER13_WEBGL: 0x8832

  защищено 
  DRAW_BUFFER14_WEBGL: 0x8833

  защищено 
  DRAW_BUFFER15_WEBGL: 0x8834

  защищено 
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF

  защищено 
  MAX_DRAW_BUFFERS_WEBGL: 0x8824
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_lose_context) */

тип WEBGL_lose_context = интерфейс
{
  операция loseContext()

  операция restoreContext()
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw) */

тип WEBGL_multi_draw = интерфейс
{
  операция multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array | Список<GLint>, firstsOffset: GLuint, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, instanceCountsList: Int32Array | Список<GLsizei>, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array | Список<GLint>, firstsOffset: GLuint, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | Список<GLsizei>, offsetsOffset: GLuint, instanceCountsList: Int32Array | Список<GLsizei>, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | Список<GLsizei>, offsetsOffset: GLuint, drawcount: GLsizei)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext) */

тип WebGL2RenderingContext = интерфейс
{

}


внешнее
/*(!) var */ WebGL2RenderingContext: объект { prototype: WebGL2RenderingContext; при создании()/*(!) no_type */ Объект?; защищено  READ_BUFFER: 0x0C02; защищено  UNPACK_ROW_LENGTH: 0x0CF2; защищено  UNPACK_SKIP_ROWS: 0x0CF3; защищено  UNPACK_SKIP_PIXELS: 0x0CF4; защищено  PACK_ROW_LENGTH: 0x0D02; защищено  PACK_SKIP_ROWS: 0x0D03; защищено  PACK_SKIP_PIXELS: 0x0D04; защищено  COLOR: 0x1800; защищено  DEPTH: 0x1801; защищено  STENCIL: 0x1802; защищено  RED: 0x1903; защищено  RGB8: 0x8051; защищено  RGBA8: 0x8058; защищено  RGB10_A2: 0x8059; защищено  TEXTURE_BINDING_3D: 0x806A; защищено  UNPACK_SKIP_IMAGES: 0x806D; защищено  UNPACK_IMAGE_HEIGHT: 0x806E; защищено  TEXTURE_3D: 0x806F; защищено  TEXTURE_WRAP_R: 0x8072; защищено  MAX_3D_TEXTURE_SIZE: 0x8073; защищено  UNSIGNED_INT_2_10_10_10_REV: 0x8368; защищено  MAX_ELEMENTS_VERTICES: 0x80E8; защищено  MAX_ELEMENTS_INDICES: 0x80E9; защищено  TEXTURE_MIN_LOD: 0x813A; защищено  TEXTURE_MAX_LOD: 0x813B; защищено  TEXTURE_BASE_LEVEL: 0x813C; защищено  TEXTURE_MAX_LEVEL: 0x813D; защищено  MIN: 0x8007; защищено  MAX: 0x8008; защищено  DEPTH_COMPONENT24: 0x81A6; защищено  MAX_TEXTURE_LOD_BIAS: 0x84FD; защищено  TEXTURE_COMPARE_MODE: 0x884C; защищено  TEXTURE_COMPARE_FUNC: 0x884D; защищено  CURRENT_QUERY: 0x8865; защищено  QUERY_RESULT: 0x8866; защищено  QUERY_RESULT_AVAILABLE: 0x8867; защищено  STREAM_READ: 0x88E1; защищено  STREAM_COPY: 0x88E2; защищено  STATIC_READ: 0x88E5; защищено  STATIC_COPY: 0x88E6; защищено  DYNAMIC_READ: 0x88E9; защищено  DYNAMIC_COPY: 0x88EA; защищено  MAX_DRAW_BUFFERS: 0x8824; защищено  DRAW_BUFFER0: 0x8825; защищено  DRAW_BUFFER1: 0x8826; защищено  DRAW_BUFFER2: 0x8827; защищено  DRAW_BUFFER3: 0x8828; защищено  DRAW_BUFFER4: 0x8829; защищено  DRAW_BUFFER5: 0x882A; защищено  DRAW_BUFFER6: 0x882B; защищено  DRAW_BUFFER7: 0x882C; защищено  DRAW_BUFFER8: 0x882D; защищено  DRAW_BUFFER9: 0x882E; защищено  DRAW_BUFFER10: 0x882F; защищено  DRAW_BUFFER11: 0x8830; защищено  DRAW_BUFFER12: 0x8831; защищено  DRAW_BUFFER13: 0x8832; защищено  DRAW_BUFFER14: 0x8833; защищено  DRAW_BUFFER15: 0x8834; защищено  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49; защищено  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A; защищено  SAMPLER_3D: 0x8B5F; защищено  SAMPLER_2D_SHADOW: 0x8B62; защищено  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B; защищено  PIXEL_PACK_BUFFER: 0x88EB; защищено  PIXEL_UNPACK_BUFFER: 0x88EC; защищено  PIXEL_PACK_BUFFER_BINDING: 0x88ED; защищено  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF; защищено  FLOAT_MAT2x3: 0x8B65; защищено  FLOAT_MAT2x4: 0x8B66; защищено  FLOAT_MAT3x2: 0x8B67; защищено  FLOAT_MAT3x4: 0x8B68; защищено  FLOAT_MAT4x2: 0x8B69; защищено  FLOAT_MAT4x3: 0x8B6A; защищено  SRGB: 0x8C40; защищено  SRGB8: 0x8C41; защищено  SRGB8_ALPHA8: 0x8C43; защищено  COMPARE_REF_TO_TEXTURE: 0x884E; защищено  RGBA32F: 0x8814; защищено  RGB32F: 0x8815; защищено  RGBA16F: 0x881A; защищено  RGB16F: 0x881B; защищено  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD; защищено  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF; защищено  MIN_PROGRAM_TEXEL_OFFSET: 0x8904; защищено  MAX_PROGRAM_TEXEL_OFFSET: 0x8905; защищено  MAX_VARYING_COMPONENTS: 0x8B4B; защищено  TEXTURE_2D_ARRAY: 0x8C1A; защищено  TEXTURE_BINDING_2D_ARRAY: 0x8C1D; защищено  R11F_G11F_B10F: 0x8C3A; защищено  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B; защищено  RGB9_E5: 0x8C3D; защищено  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E; защищено  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80; защищено  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83; защищено  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84; защищено  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85; защищено  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88; защищено  RASTERIZER_DISCARD: 0x8C89; защищено  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B; защищено  INTERLEAVED_ATTRIBS: 0x8C8C; защищено  SEPARATE_ATTRIBS: 0x8C8D; защищено  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E; защищено  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F; защищено  RGBA32UI: 0x8D70; защищено  RGB32UI: 0x8D71; защищено  RGBA16UI: 0x8D76; защищено  RGB16UI: 0x8D77; защищено  RGBA8UI: 0x8D7C; защищено  RGB8UI: 0x8D7D; защищено  RGBA32I: 0x8D82; защищено  RGB32I: 0x8D83; защищено  RGBA16I: 0x8D88; защищено  RGB16I: 0x8D89; защищено  RGBA8I: 0x8D8E; защищено  RGB8I: 0x8D8F; защищено  RED_INTEGER: 0x8D94; защищено  RGB_INTEGER: 0x8D98; защищено  RGBA_INTEGER: 0x8D99; защищено  SAMPLER_2D_ARRAY: 0x8DC1; защищено  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4; защищено  SAMPLER_CUBE_SHADOW: 0x8DC5; защищено  UNSIGNED_INT_VEC2: 0x8DC6; защищено  UNSIGNED_INT_VEC3: 0x8DC7; защищено  UNSIGNED_INT_VEC4: 0x8DC8; защищено  INT_SAMPLER_2D: 0x8DCA; защищено  INT_SAMPLER_3D: 0x8DCB; защищено  INT_SAMPLER_CUBE: 0x8DCC; защищено  INT_SAMPLER_2D_ARRAY: 0x8DCF; защищено  UNSIGNED_INT_SAMPLER_2D: 0x8DD2; защищено  UNSIGNED_INT_SAMPLER_3D: 0x8DD3; защищено  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4; защищено  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7; защищено  DEPTH_COMPONENT32F: 0x8CAC; защищено  DEPTH32F_STENCIL8: 0x8CAD; защищено  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD; защищено  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210; защищено  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211; защищено  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212; защищено  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213; защищено  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214; защищено  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215; защищено  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216; защищено  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217; защищено  FRAMEBUFFER_DEFAULT: 0x8218; защищено  UNSIGNED_INT_24_8: 0x84FA; защищено  DEPTH24_STENCIL8: 0x88F0; защищено  UNSIGNED_NORMALIZED: 0x8C17; защищено  DRAW_FRAMEBUFFER_BINDING: 0x8CA6; защищено  READ_FRAMEBUFFER: 0x8CA8; защищено  DRAW_FRAMEBUFFER: 0x8CA9; защищено  READ_FRAMEBUFFER_BINDING: 0x8CAA; защищено  RENDERBUFFER_SAMPLES: 0x8CAB; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4; защищено  MAX_COLOR_ATTACHMENTS: 0x8CDF; защищено  COLOR_ATTACHMENT1: 0x8CE1; защищено  COLOR_ATTACHMENT2: 0x8CE2; защищено  COLOR_ATTACHMENT3: 0x8CE3; защищено  COLOR_ATTACHMENT4: 0x8CE4; защищено  COLOR_ATTACHMENT5: 0x8CE5; защищено  COLOR_ATTACHMENT6: 0x8CE6; защищено  COLOR_ATTACHMENT7: 0x8CE7; защищено  COLOR_ATTACHMENT8: 0x8CE8; защищено  COLOR_ATTACHMENT9: 0x8CE9; защищено  COLOR_ATTACHMENT10: 0x8CEA; защищено  COLOR_ATTACHMENT11: 0x8CEB; защищено  COLOR_ATTACHMENT12: 0x8CEC; защищено  COLOR_ATTACHMENT13: 0x8CED; защищено  COLOR_ATTACHMENT14: 0x8CEE; защищено  COLOR_ATTACHMENT15: 0x8CEF; защищено  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56; защищено  MAX_SAMPLES: 0x8D57; защищено  HALF_FLOAT: 0x140B; защищено  RG: 0x8227; защищено  RG_INTEGER: 0x8228; защищено  R8: 0x8229; защищено  RG8: 0x822B; защищено  R16F: 0x822D; защищено  R32F: 0x822E; защищено  RG16F: 0x822F; защищено  RG32F: 0x8230; защищено  R8I: 0x8231; защищено  R8UI: 0x8232; защищено  R16I: 0x8233; защищено  R16UI: 0x8234; защищено  R32I: 0x8235; защищено  R32UI: 0x8236; защищено  RG8I: 0x8237; защищено  RG8UI: 0x8238; защищено  RG16I: 0x8239; защищено  RG16UI: 0x823A; защищено  RG32I: 0x823B; защищено  RG32UI: 0x823C; защищено  VERTEX_ARRAY_BINDING: 0x85B5; защищено  R8_SNORM: 0x8F94; защищено  RG8_SNORM: 0x8F95; защищено  RGB8_SNORM: 0x8F96; защищено  RGBA8_SNORM: 0x8F97; защищено  SIGNED_NORMALIZED: 0x8F9C; защищено  COPY_READ_BUFFER: 0x8F36; защищено  COPY_WRITE_BUFFER: 0x8F37; защищено  COPY_READ_BUFFER_BINDING: 0x8F36; защищено  COPY_WRITE_BUFFER_BINDING: 0x8F37; защищено  UNIFORM_BUFFER: 0x8A11; защищено  UNIFORM_BUFFER_BINDING: 0x8A28; защищено  UNIFORM_BUFFER_START: 0x8A29; защищено  UNIFORM_BUFFER_SIZE: 0x8A2A; защищено  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B; защищено  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D; защищено  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E; защищено  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F; защищено  MAX_UNIFORM_BLOCK_SIZE: 0x8A30; защищено  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31; защищено  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33; защищено  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34; защищено  ACTIVE_UNIFORM_BLOCKS: 0x8A36; защищено  UNIFORM_TYPE: 0x8A37; защищено  UNIFORM_SIZE: 0x8A38; защищено  UNIFORM_BLOCK_INDEX: 0x8A3A; защищено  UNIFORM_OFFSET: 0x8A3B; защищено  UNIFORM_ARRAY_STRIDE: 0x8A3C; защищено  UNIFORM_MATRIX_STRIDE: 0x8A3D; защищено  UNIFORM_IS_ROW_MAJOR: 0x8A3E; защищено  UNIFORM_BLOCK_BINDING: 0x8A3F; защищено  UNIFORM_BLOCK_DATA_SIZE: 0x8A40; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43; защищено  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44; защищено  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46; защищено  INVALID_INDEX: 0xFFFFFFFF; защищено  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122; защищено  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125; защищено  MAX_SERVER_WAIT_TIMEOUT: 0x9111; защищено  OBJECT_TYPE: 0x9112; защищено  SYNC_CONDITION: 0x9113; защищено  SYNC_STATUS: 0x9114; защищено  SYNC_FLAGS: 0x9115; защищено  SYNC_FENCE: 0x9116; защищено  SYNC_GPU_COMMANDS_COMPLETE: 0x9117; защищено  UNSIGNALED: 0x9118; защищено  SIGNALED: 0x9119; защищено  ALREADY_SIGNALED: 0x911A; защищено  TIMEOUT_EXPIRED: 0x911B; защищено  CONDITION_SATISFIED: 0x911C; защищено  WAIT_FAILED: 0x911D; защищено  SYNC_FLUSH_COMMANDS_BIT: 0x00000001; защищено  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE; защищено  ANY_SAMPLES_PASSED: 0x8C2F; защищено  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A; защищено  SAMPLER_BINDING: 0x8919; защищено  RGB10_A2UI: 0x906F; защищено  INT_2_10_10_10_REV: 0x8D9F; защищено  TRANSFORM_FEEDBACK: 0x8E22; защищено  TRANSFORM_FEEDBACK_PAUSED: 0x8E23; защищено  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24; защищено  TRANSFORM_FEEDBACK_BINDING: 0x8E25; защищено  TEXTURE_IMMUTABLE_FORMAT: 0x912F; защищено  MAX_ELEMENT_INDEX: 0x8D6B; защищено  TEXTURE_IMMUTABLE_LEVELS: 0x82DF; защищено  TIMEOUT_IGNORED: -1; защищено  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGL2RenderingContextBase = интерфейс
{
  операция beginQuery(target: GLenum, query: WebGLQuery)

  операция beginTransformFeedback(primitiveMode: GLenum)

  операция bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer?FUCKFUCK)

  операция bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer?FUCKFUCK, offset: GLintptr, size: GLsizeiptr)

  операция bindSampler(unit: GLuint, sampler: WebGLSampler?FUCKFUCK)

  операция bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback?FUCKFUCK)

  операция bindVertexArray(array: WebGLVertexArrayObject?FUCKFUCK)

  операция blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum)

  операция clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint)

  операция clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr)

  операция copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createQuery(): WebGLQuery?FUCKFUCK

  операция createSampler(): WebGLSampler?FUCKFUCK

  операция createTransformFeedback(): WebGLTransformFeedback?FUCKFUCK

  операция createVertexArray(): WebGLVertexArrayObject?FUCKFUCK

  операция deleteQuery(query: WebGLQuery?FUCKFUCK)

  операция deleteSampler(sampler: WebGLSampler?FUCKFUCK)

  операция deleteSync(sync: WebGLSync?FUCKFUCK)

  операция deleteTransformFeedback(tf: WebGLTransformFeedback?FUCKFUCK)

  операция deleteVertexArray(vertexArray: WebGLVertexArrayObject?FUCKFUCK)

  операция drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei)

  операция drawBuffers(buffers: Список<GLenum>)

  операция drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei)

  операция drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr)

  операция endQuery(target: GLenum)

  операция endTransformFeedback()

  операция fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync?FUCKFUCK

  операция framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint, layer: GLint)

  операция getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): Текст?FUCKFUCK

  операция getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getActiveUniforms(program: WebGLProgram, uniformIndices: Список<GLuint>, pname: GLenum): /*(!) any */ Объект?

  операция getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint?FUCKFUCK = пусто, length: GLuint?FUCKFUCK = пусто)

  операция getFragDataLocation(program: WebGLProgram, name: Текст): GLint

  операция getIndexedParameter(target: GLenum, index: GLuint): /*(!) any */ Объект?

  операция getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getQuery(target: GLenum, pname: GLenum): WebGLQuery?FUCKFUCK

  операция getQueryParameter(query: WebGLQuery, pname: GLenum): /*(!) any */ Объект?

  операция getSamplerParameter(sampler: WebGLSampler, pname: GLenum): /*(!) any */ Объект?

  операция getSyncParameter(sync: WebGLSync, pname: GLenum): /*(!) any */ Объект?

  операция getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getUniformBlockIndex(program: WebGLProgram, uniformBlockName: Текст): GLuint

  операция getUniformIndices(program: WebGLProgram, uniformNames: Список<Текст>): Список<GLuint>?FUCKFUCK

  операция invalidateFramebuffer(target: GLenum, attachments: Список<GLenum>)

  операция invalidateSubFramebuffer(target: GLenum, attachments: Список<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция isQuery(query: WebGLQuery?FUCKFUCK): GLboolean

  операция isSampler(sampler: WebGLSampler?FUCKFUCK): GLboolean

  операция isSync(sync: WebGLSync?FUCKFUCK): GLboolean

  операция isTransformFeedback(tf: WebGLTransformFeedback?FUCKFUCK): GLboolean

  операция isVertexArray(vertexArray: WebGLVertexArrayObject?FUCKFUCK): GLboolean

  операция pauseTransformFeedback()

  операция readBuffer(src: GLenum)

  операция renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция resumeTransformFeedback()

  операция samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat)

  операция samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView?FUCKFUCK)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView?FUCKFUCK, srcOffset: GLuint?FUCKFUCK = пусто)

  операция transformFeedbackVaryings(program: WebGLProgram, varyings: Список<Текст>, bufferMode: GLenum)

  операция uniform1ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint)

  операция uniform1uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint)

  операция uniform2uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint, v2: GLuint)

  операция uniform3uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint)

  операция uniform4uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint)

  операция uniformMatrix2x3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix2x4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3x2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3x4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4x2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4x3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция vertexAttribDivisor(index: GLuint, divisor: GLuint)

  операция vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint)

  операция vertexAttribI4iv(index: GLuint, values: Int32List)

  операция vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint)

  операция vertexAttribI4uiv(index: GLuint, values: Uint32List)

  операция vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr)

  операция waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64)

  защищено 
  READ_BUFFER: 0x0C02

  защищено 
  UNPACK_ROW_LENGTH: 0x0CF2

  защищено 
  UNPACK_SKIP_ROWS: 0x0CF3

  защищено 
  UNPACK_SKIP_PIXELS: 0x0CF4

  защищено 
  PACK_ROW_LENGTH: 0x0D02

  защищено 
  PACK_SKIP_ROWS: 0x0D03

  защищено 
  PACK_SKIP_PIXELS: 0x0D04

  защищено 
  COLOR: 0x1800

  защищено 
  DEPTH: 0x1801

  защищено 
  STENCIL: 0x1802

  защищено 
  RED: 0x1903

  защищено 
  RGB8: 0x8051

  защищено 
  RGBA8: 0x8058

  защищено 
  RGB10_A2: 0x8059

  защищено 
  TEXTURE_BINDING_3D: 0x806A

  защищено 
  UNPACK_SKIP_IMAGES: 0x806D

  защищено 
  UNPACK_IMAGE_HEIGHT: 0x806E

  защищено 
  TEXTURE_3D: 0x806F

  защищено 
  TEXTURE_WRAP_R: 0x8072

  защищено 
  MAX_3D_TEXTURE_SIZE: 0x8073

  защищено 
  UNSIGNED_INT_2_10_10_10_REV: 0x8368

  защищено 
  MAX_ELEMENTS_VERTICES: 0x80E8

  защищено 
  MAX_ELEMENTS_INDICES: 0x80E9

  защищено 
  TEXTURE_MIN_LOD: 0x813A

  защищено 
  TEXTURE_MAX_LOD: 0x813B

  защищено 
  TEXTURE_BASE_LEVEL: 0x813C

  защищено 
  TEXTURE_MAX_LEVEL: 0x813D

  защищено 
  MIN: 0x8007

  защищено 
  MAX: 0x8008

  защищено 
  DEPTH_COMPONENT24: 0x81A6

  защищено 
  MAX_TEXTURE_LOD_BIAS: 0x84FD

  защищено 
  TEXTURE_COMPARE_MODE: 0x884C

  защищено 
  TEXTURE_COMPARE_FUNC: 0x884D

  защищено 
  CURRENT_QUERY: 0x8865

  защищено 
  QUERY_RESULT: 0x8866

  защищено 
  QUERY_RESULT_AVAILABLE: 0x8867

  защищено 
  STREAM_READ: 0x88E1

  защищено 
  STREAM_COPY: 0x88E2

  защищено 
  STATIC_READ: 0x88E5

  защищено 
  STATIC_COPY: 0x88E6

  защищено 
  DYNAMIC_READ: 0x88E9

  защищено 
  DYNAMIC_COPY: 0x88EA

  защищено 
  MAX_DRAW_BUFFERS: 0x8824

  защищено 
  DRAW_BUFFER0: 0x8825

  защищено 
  DRAW_BUFFER1: 0x8826

  защищено 
  DRAW_BUFFER2: 0x8827

  защищено 
  DRAW_BUFFER3: 0x8828

  защищено 
  DRAW_BUFFER4: 0x8829

  защищено 
  DRAW_BUFFER5: 0x882A

  защищено 
  DRAW_BUFFER6: 0x882B

  защищено 
  DRAW_BUFFER7: 0x882C

  защищено 
  DRAW_BUFFER8: 0x882D

  защищено 
  DRAW_BUFFER9: 0x882E

  защищено 
  DRAW_BUFFER10: 0x882F

  защищено 
  DRAW_BUFFER11: 0x8830

  защищено 
  DRAW_BUFFER12: 0x8831

  защищено 
  DRAW_BUFFER13: 0x8832

  защищено 
  DRAW_BUFFER14: 0x8833

  защищено 
  DRAW_BUFFER15: 0x8834

  защищено 
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49

  защищено 
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A

  защищено 
  SAMPLER_3D: 0x8B5F

  защищено 
  SAMPLER_2D_SHADOW: 0x8B62

  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B

  защищено 
  PIXEL_PACK_BUFFER: 0x88EB

  защищено 
  PIXEL_UNPACK_BUFFER: 0x88EC

  защищено 
  PIXEL_PACK_BUFFER_BINDING: 0x88ED

  защищено 
  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF

  защищено 
  FLOAT_MAT2x3: 0x8B65

  защищено 
  FLOAT_MAT2x4: 0x8B66

  защищено 
  FLOAT_MAT3x2: 0x8B67

  защищено 
  FLOAT_MAT3x4: 0x8B68

  защищено 
  FLOAT_MAT4x2: 0x8B69

  защищено 
  FLOAT_MAT4x3: 0x8B6A

  защищено 
  SRGB: 0x8C40

  защищено 
  SRGB8: 0x8C41

  защищено 
  SRGB8_ALPHA8: 0x8C43

  защищено 
  COMPARE_REF_TO_TEXTURE: 0x884E

  защищено 
  RGBA32F: 0x8814

  защищено 
  RGB32F: 0x8815

  защищено 
  RGBA16F: 0x881A

  защищено 
  RGB16F: 0x881B

  защищено 
  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD

  защищено 
  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF

  защищено 
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904

  защищено 
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905

  защищено 
  MAX_VARYING_COMPONENTS: 0x8B4B

  защищено 
  TEXTURE_2D_ARRAY: 0x8C1A

  защищено 
  TEXTURE_BINDING_2D_ARRAY: 0x8C1D

  защищено 
  R11F_G11F_B10F: 0x8C3A

  защищено 
  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B

  защищено 
  RGB9_E5: 0x8C3D

  защищено 
  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80

  защищено 
  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85

  защищено 
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88

  защищено 
  RASTERIZER_DISCARD: 0x8C89

  защищено 
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B

  защищено 
  INTERLEAVED_ATTRIBS: 0x8C8C

  защищено 
  SEPARATE_ATTRIBS: 0x8C8D

  защищено 
  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F

  защищено 
  RGBA32UI: 0x8D70

  защищено 
  RGB32UI: 0x8D71

  защищено 
  RGBA16UI: 0x8D76

  защищено 
  RGB16UI: 0x8D77

  защищено 
  RGBA8UI: 0x8D7C

  защищено 
  RGB8UI: 0x8D7D

  защищено 
  RGBA32I: 0x8D82

  защищено 
  RGB32I: 0x8D83

  защищено 
  RGBA16I: 0x8D88

  защищено 
  RGB16I: 0x8D89

  защищено 
  RGBA8I: 0x8D8E

  защищено 
  RGB8I: 0x8D8F

  защищено 
  RED_INTEGER: 0x8D94

  защищено 
  RGB_INTEGER: 0x8D98

  защищено 
  RGBA_INTEGER: 0x8D99

  защищено 
  SAMPLER_2D_ARRAY: 0x8DC1

  защищено 
  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4

  защищено 
  SAMPLER_CUBE_SHADOW: 0x8DC5

  защищено 
  UNSIGNED_INT_VEC2: 0x8DC6

  защищено 
  UNSIGNED_INT_VEC3: 0x8DC7

  защищено 
  UNSIGNED_INT_VEC4: 0x8DC8

  защищено 
  INT_SAMPLER_2D: 0x8DCA

  защищено 
  INT_SAMPLER_3D: 0x8DCB

  защищено 
  INT_SAMPLER_CUBE: 0x8DCC

  защищено 
  INT_SAMPLER_2D_ARRAY: 0x8DCF

  защищено 
  UNSIGNED_INT_SAMPLER_2D: 0x8DD2

  защищено 
  UNSIGNED_INT_SAMPLER_3D: 0x8DD3

  защищено 
  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4

  защищено 
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7

  защищено 
  DEPTH_COMPONENT32F: 0x8CAC

  защищено 
  DEPTH32F_STENCIL8: 0x8CAD

  защищено 
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211

  защищено 
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212

  защищено 
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213

  защищено 
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214

  защищено 
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215

  защищено 
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216

  защищено 
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217

  защищено 
  FRAMEBUFFER_DEFAULT: 0x8218

  защищено 
  UNSIGNED_INT_24_8: 0x84FA

  защищено 
  DEPTH24_STENCIL8: 0x88F0

  защищено 
  UNSIGNED_NORMALIZED: 0x8C17

  защищено 
  DRAW_FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  READ_FRAMEBUFFER: 0x8CA8

  защищено 
  DRAW_FRAMEBUFFER: 0x8CA9

  защищено 
  READ_FRAMEBUFFER_BINDING: 0x8CAA

  защищено 
  RENDERBUFFER_SAMPLES: 0x8CAB

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4

  защищено 
  MAX_COLOR_ATTACHMENTS: 0x8CDF

  защищено 
  COLOR_ATTACHMENT1: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13: 0x8CED

  защищено 
  COLOR_ATTACHMENT14: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15: 0x8CEF

  защищено 
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56

  защищено 
  MAX_SAMPLES: 0x8D57

  защищено 
  HALF_FLOAT: 0x140B

  защищено 
  RG: 0x8227

  защищено 
  RG_INTEGER: 0x8228

  защищено 
  R8: 0x8229

  защищено 
  RG8: 0x822B

  защищено 
  R16F: 0x822D

  защищено 
  R32F: 0x822E

  защищено 
  RG16F: 0x822F

  защищено 
  RG32F: 0x8230

  защищено 
  R8I: 0x8231

  защищено 
  R8UI: 0x8232

  защищено 
  R16I: 0x8233

  защищено 
  R16UI: 0x8234

  защищено 
  R32I: 0x8235

  защищено 
  R32UI: 0x8236

  защищено 
  RG8I: 0x8237

  защищено 
  RG8UI: 0x8238

  защищено 
  RG16I: 0x8239

  защищено 
  RG16UI: 0x823A

  защищено 
  RG32I: 0x823B

  защищено 
  RG32UI: 0x823C

  защищено 
  VERTEX_ARRAY_BINDING: 0x85B5

  защищено 
  R8_SNORM: 0x8F94

  защищено 
  RG8_SNORM: 0x8F95

  защищено 
  RGB8_SNORM: 0x8F96

  защищено 
  RGBA8_SNORM: 0x8F97

  защищено 
  SIGNED_NORMALIZED: 0x8F9C

  защищено 
  COPY_READ_BUFFER: 0x8F36

  защищено 
  COPY_WRITE_BUFFER: 0x8F37

  защищено 
  COPY_READ_BUFFER_BINDING: 0x8F36

  защищено 
  COPY_WRITE_BUFFER_BINDING: 0x8F37

  защищено 
  UNIFORM_BUFFER: 0x8A11

  защищено 
  UNIFORM_BUFFER_BINDING: 0x8A28

  защищено 
  UNIFORM_BUFFER_START: 0x8A29

  защищено 
  UNIFORM_BUFFER_SIZE: 0x8A2A

  защищено 
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B

  защищено 
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D

  защищено 
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E

  защищено 
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F

  защищено 
  MAX_UNIFORM_BLOCK_SIZE: 0x8A30

  защищено 
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31

  защищено 
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33

  защищено 
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34

  защищено 
  ACTIVE_UNIFORM_BLOCKS: 0x8A36

  защищено 
  UNIFORM_TYPE: 0x8A37

  защищено 
  UNIFORM_SIZE: 0x8A38

  защищено 
  UNIFORM_BLOCK_INDEX: 0x8A3A

  защищено 
  UNIFORM_OFFSET: 0x8A3B

  защищено 
  UNIFORM_ARRAY_STRIDE: 0x8A3C

  защищено 
  UNIFORM_MATRIX_STRIDE: 0x8A3D

  защищено 
  UNIFORM_IS_ROW_MAJOR: 0x8A3E

  защищено 
  UNIFORM_BLOCK_BINDING: 0x8A3F

  защищено 
  UNIFORM_BLOCK_DATA_SIZE: 0x8A40

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46

  защищено 
  INVALID_INDEX: 0xFFFFFFFF

  защищено 
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122

  защищено 
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125

  защищено 
  MAX_SERVER_WAIT_TIMEOUT: 0x9111

  защищено 
  OBJECT_TYPE: 0x9112

  защищено 
  SYNC_CONDITION: 0x9113

  защищено 
  SYNC_STATUS: 0x9114

  защищено 
  SYNC_FLAGS: 0x9115

  защищено 
  SYNC_FENCE: 0x9116

  защищено 
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117

  защищено 
  UNSIGNALED: 0x9118

  защищено 
  SIGNALED: 0x9119

  защищено 
  ALREADY_SIGNALED: 0x911A

  защищено 
  TIMEOUT_EXPIRED: 0x911B

  защищено 
  CONDITION_SATISFIED: 0x911C

  защищено 
  WAIT_FAILED: 0x911D

  защищено 
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE

  защищено 
  ANY_SAMPLES_PASSED: 0x8C2F

  защищено 
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A

  защищено 
  SAMPLER_BINDING: 0x8919

  защищено 
  RGB10_A2UI: 0x906F

  защищено 
  INT_2_10_10_10_REV: 0x8D9F

  защищено 
  TRANSFORM_FEEDBACK: 0x8E22

  защищено 
  TRANSFORM_FEEDBACK_PAUSED: 0x8E23

  защищено 
  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24

  защищено 
  TRANSFORM_FEEDBACK_BINDING: 0x8E25

  защищено 
  TEXTURE_IMMUTABLE_FORMAT: 0x912F

  защищено 
  MAX_ELEMENT_INDEX: 0x8D6B

  защищено 
  TEXTURE_IMMUTABLE_LEVELS: 0x82DF

  защищено 
  TIMEOUT_IGNORED: -1

  защищено 
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247
}


тип WebGL2RenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, srcData: BufferSource?FUCKFUCK, usage: GLenum)

  операция bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length: GLuint?FUCKFUCK = пусто)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: BufferSource)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: ArrayBufferView, srcOffset: GLuint, length: GLuint?FUCKFUCK = пусто)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView?FUCKFUCK)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, offset: GLintptr)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView, dstOffset: GLuint)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция uniform1fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform1iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)
}


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getActiveAttrib() and WebGLRenderingContext.getActiveUniform() methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLActiveInfo)
*/

тип WebGLActiveInfo = интерфейс
{
  защищено 
  name: Текст

  защищено 
  size: GLint

  защищено 
  type: GLenum
}


внешнее
/*(!) var */ WebGLActiveInfo: объект { prototype: WebGLActiveInfo; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents an opaque buffer object storing data such as vertices or colors.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLBuffer)
*/

тип WebGLBuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLBuffer: объект { prototype: WebGLBuffer; при создании()/*(!) no_type */ Объект? }


/**
* The WebContextEvent interface is part of the WebGL API and is an interface for an event that is generated in response to a status change to the WebGL rendering context.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLContextEvent)
*/

тип WebGLContextEvent = интерфейс
{
  защищено 
  statusMessage: Текст
}


внешнее
/*(!) var */ WebGLContextEvent: объект { prototype: WebGLContextEvent; при создании(type: Текст, eventInit: WebGLContextEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents a collection of buffers that serve as a rendering destination.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLFramebuffer)
*/

тип WebGLFramebuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLFramebuffer: объект { prototype: WebGLFramebuffer; при создании()/*(!) no_type */ Объект? }


/**
* The WebGLProgram is part of the WebGL API and is a combination of two compiled WebGLShaders consisting of a vertex shader and a fragment shader (both written in GLSL).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLProgram)
*/

тип WebGLProgram = интерфейс
{

}


внешнее
/*(!) var */ WebGLProgram: объект { prototype: WebGLProgram; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLQuery) */

тип WebGLQuery = интерфейс
{

}


внешнее
/*(!) var */ WebGLQuery: объект { prototype: WebGLQuery; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents a buffer that can contain an image, or can be source or target of an rendering operation.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderbuffer)
*/

тип WebGLRenderbuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLRenderbuffer: объект { prototype: WebGLRenderbuffer; при создании()/*(!) no_type */ Объект? }


/**
* Provides an interface to the OpenGL ES 2.0 graphics rendering context for the drawing surface of an HTML <canvas> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext)
*/

тип WebGLRenderingContext = интерфейс
{

}


внешнее
/*(!) var */ WebGLRenderingContext: объект { prototype: WebGLRenderingContext; при создании()/*(!) no_type */ Объект?; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGLRenderingContextBase = интерфейс
{
  drawingBufferColorSpace: PredefinedColorSpace

  защищено 
  drawingBufferHeight: GLsizei

  защищено 
  drawingBufferWidth: GLsizei

  операция activeTexture(texture: GLenum)

  операция attachShader(program: WebGLProgram, shader: WebGLShader)

  операция bindAttribLocation(program: WebGLProgram, index: GLuint, name: Текст)

  операция bindBuffer(target: GLenum, buffer: WebGLBuffer?FUCKFUCK)

  операция bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer?FUCKFUCK)

  операция bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция bindTexture(target: GLenum, texture: WebGLTexture?FUCKFUCK)

  операция blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция blendEquation(mode: GLenum)

  операция blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum)

  операция blendFunc(sfactor: GLenum, dfactor: GLenum)

  операция blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция checkFramebufferStatus(target: GLenum): GLenum

  операция clear(mask: GLbitfield)

  операция clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция clearDepth(depth: GLclampf)

  операция clearStencil(s: GLint)

  операция colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean)

  операция compileShader(shader: WebGLShader)

  операция copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint)

  операция copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createBuffer(): WebGLBuffer?FUCKFUCK

  операция createFramebuffer(): WebGLFramebuffer?FUCKFUCK

  операция createProgram(): WebGLProgram?FUCKFUCK

  операция createRenderbuffer(): WebGLRenderbuffer?FUCKFUCK

  операция createShader(type: GLenum): WebGLShader?FUCKFUCK

  операция createTexture(): WebGLTexture?FUCKFUCK

  операция cullFace(mode: GLenum)

  операция deleteBuffer(buffer: WebGLBuffer?FUCKFUCK)

  операция deleteFramebuffer(framebuffer: WebGLFramebuffer?FUCKFUCK)

  операция deleteProgram(program: WebGLProgram?FUCKFUCK)

  операция deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция deleteShader(shader: WebGLShader?FUCKFUCK)

  операция deleteTexture(texture: WebGLTexture?FUCKFUCK)

  операция depthFunc(func: GLenum)

  операция depthMask(flag: GLboolean)

  операция depthRange(zNear: GLclampf, zFar: GLclampf)

  операция detachShader(program: WebGLProgram, shader: WebGLShader)

  операция disable(cap: GLenum)

  операция disableVertexAttribArray(index: GLuint)

  операция drawArrays(mode: GLenum, first: GLint, count: GLsizei)

  операция drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr)

  операция enable(cap: GLenum)

  операция enableVertexAttribArray(index: GLuint)

  операция finish()

  операция flush()

  операция framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint)

  операция frontFace(mode: GLenum)

  операция generateMipmap(target: GLenum)

  операция getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getAttachedShaders(program: WebGLProgram): Список<WebGLShader>?FUCKFUCK

  операция getAttribLocation(program: WebGLProgram, name: Текст): GLint

  операция getBufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getContextAttributes(): WebGLContextAttributes?FUCKFUCK

  операция getError(): GLenum

  операция getExtension(extensionName: "ANGLE_instanced_arrays"): ANGLE_instanced_arrays?FUCKFUCK

  операция getExtension(extensionName: "EXT_blend_minmax"): EXT_blend_minmax?FUCKFUCK

  операция getExtension(extensionName: "EXT_color_buffer_float"): EXT_color_buffer_float?FUCKFUCK

  операция getExtension(extensionName: "EXT_color_buffer_half_float"): EXT_color_buffer_half_float?FUCKFUCK

  операция getExtension(extensionName: "EXT_float_blend"): EXT_float_blend?FUCKFUCK

  операция getExtension(extensionName: "EXT_frag_depth"): EXT_frag_depth?FUCKFUCK

  операция getExtension(extensionName: "EXT_sRGB"): EXT_sRGB?FUCKFUCK

  операция getExtension(extensionName: "EXT_shader_texture_lod"): EXT_shader_texture_lod?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_compression_bptc"): EXT_texture_compression_bptc?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_compression_rgtc"): EXT_texture_compression_rgtc?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_filter_anisotropic"): EXT_texture_filter_anisotropic?FUCKFUCK

  операция getExtension(extensionName: "KHR_parallel_shader_compile"): KHR_parallel_shader_compile?FUCKFUCK

  операция getExtension(extensionName: "OES_element_index_uint"): OES_element_index_uint?FUCKFUCK

  операция getExtension(extensionName: "OES_fbo_render_mipmap"): OES_fbo_render_mipmap?FUCKFUCK

  операция getExtension(extensionName: "OES_standard_derivatives"): OES_standard_derivatives?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_float"): OES_texture_float?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_float_linear"): OES_texture_float_linear?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_half_float"): OES_texture_half_float?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_half_float_linear"): OES_texture_half_float_linear?FUCKFUCK

  операция getExtension(extensionName: "OES_vertex_array_object"): OES_vertex_array_object?FUCKFUCK

  операция getExtension(extensionName: "OVR_multiview2"): OVR_multiview2?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_color_buffer_float"): WEBGL_color_buffer_float?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_astc"): WEBGL_compressed_texture_astc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc"): WEBGL_compressed_texture_etc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc1"): WEBGL_compressed_texture_etc1?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_pvrtc"): WEBGL_compressed_texture_pvrtc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc"): WEBGL_compressed_texture_s3tc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc_srgb"): WEBGL_compressed_texture_s3tc_srgb?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_debug_renderer_info"): WEBGL_debug_renderer_info?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_debug_shaders"): WEBGL_debug_shaders?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_depth_texture"): WEBGL_depth_texture?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_draw_buffers"): WEBGL_draw_buffers?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_lose_context"): WEBGL_lose_context?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_multi_draw"): WEBGL_multi_draw?FUCKFUCK

  операция getExtension(name: Текст): /*(!) any */ Объект?

  операция getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getParameter(pname: GLenum): /*(!) any */ Объект?

  операция getProgramInfoLog(program: WebGLProgram): Текст?FUCKFUCK

  операция getProgramParameter(program: WebGLProgram, pname: GLenum): /*(!) any */ Объект?

  операция getRenderbufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getShaderInfoLog(shader: WebGLShader): Текст?FUCKFUCK

  операция getShaderParameter(shader: WebGLShader, pname: GLenum): /*(!) any */ Объект?

  операция getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat?FUCKFUCK

  операция getShaderSource(shader: WebGLShader): Текст?FUCKFUCK

  операция getSupportedExtensions(): Список<Текст>?FUCKFUCK

  операция getTexParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getUniform(program: WebGLProgram, location: WebGLUniformLocation): /*(!) any */ Объект?

  операция getUniformLocation(program: WebGLProgram, name: Текст): WebGLUniformLocation?FUCKFUCK

  операция getVertexAttrib(index: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr

  операция hint(target: GLenum, mode: GLenum)

  операция isBuffer(buffer: WebGLBuffer?FUCKFUCK): GLboolean

  операция isContextLost(): ДаНет

  операция isEnabled(cap: GLenum): GLboolean

  операция isFramebuffer(framebuffer: WebGLFramebuffer?FUCKFUCK): GLboolean

  операция isProgram(program: WebGLProgram?FUCKFUCK): GLboolean

  операция isRenderbuffer(renderbuffer: WebGLRenderbuffer?FUCKFUCK): GLboolean

  операция isShader(shader: WebGLShader?FUCKFUCK): GLboolean

  операция isTexture(texture: WebGLTexture?FUCKFUCK): GLboolean

  операция lineWidth(width: GLfloat)

  операция linkProgram(program: WebGLProgram)

  операция pixelStorei(pname: GLenum, param: GLint | GLboolean)

  операция polygonOffset(factor: GLfloat, units: GLfloat)

  операция renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция sampleCoverage(value: GLclampf, invert: GLboolean)

  операция scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция shaderSource(shader: WebGLShader, source: Текст)

  операция stencilFunc(func: GLenum, ref: GLint, mask: GLuint)

  операция stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint)

  операция stencilMask(mask: GLuint)

  операция stencilMaskSeparate(face: GLenum, mask: GLuint)

  операция stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция texParameterf(target: GLenum, pname: GLenum, param: GLfloat)

  операция texParameteri(target: GLenum, pname: GLenum, param: GLint)

  операция uniform1f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat)

  операция uniform1i(location: WebGLUniformLocation?FUCKFUCK, x: GLint)

  операция uniform2f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat)

  операция uniform2i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint)

  операция uniform3f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat, z: GLfloat)

  операция uniform3i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint, z: GLint)

  операция uniform4f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция uniform4i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint, z: GLint, w: GLint)

  операция useProgram(program: WebGLProgram?FUCKFUCK)

  операция validateProgram(program: WebGLProgram)

  операция vertexAttrib1f(index: GLuint, x: GLfloat)

  операция vertexAttrib1fv(index: GLuint, values: Float32List)

  операция vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat)

  операция vertexAttrib2fv(index: GLuint, values: Float32List)

  операция vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat)

  операция vertexAttrib3fv(index: GLuint, values: Float32List)

  операция vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция vertexAttrib4fv(index: GLuint, values: Float32List)

  операция vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr)

  операция viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  защищено 
  DEPTH_BUFFER_BIT: 0x00000100

  защищено 
  STENCIL_BUFFER_BIT: 0x00000400

  защищено 
  COLOR_BUFFER_BIT: 0x00004000

  защищено 
  POINTS: 0x0000

  защищено 
  LINES: 0x0001

  защищено 
  LINE_LOOP: 0x0002

  защищено 
  LINE_STRIP: 0x0003

  защищено 
  TRIANGLES: 0x0004

  защищено 
  TRIANGLE_STRIP: 0x0005

  защищено 
  TRIANGLE_FAN: 0x0006

  защищено 
  ZERO: 0

  защищено 
  ONE: 1

  защищено 
  SRC_COLOR: 0x0300

  защищено 
  ONE_MINUS_SRC_COLOR: 0x0301

  защищено 
  SRC_ALPHA: 0x0302

  защищено 
  ONE_MINUS_SRC_ALPHA: 0x0303

  защищено 
  DST_ALPHA: 0x0304

  защищено 
  ONE_MINUS_DST_ALPHA: 0x0305

  защищено 
  DST_COLOR: 0x0306

  защищено 
  ONE_MINUS_DST_COLOR: 0x0307

  защищено 
  SRC_ALPHA_SATURATE: 0x0308

  защищено 
  FUNC_ADD: 0x8006

  защищено 
  BLEND_EQUATION: 0x8009

  защищено 
  BLEND_EQUATION_RGB: 0x8009

  защищено 
  BLEND_EQUATION_ALPHA: 0x883D

  защищено 
  FUNC_SUBTRACT: 0x800A

  защищено 
  FUNC_REVERSE_SUBTRACT: 0x800B

  защищено 
  BLEND_DST_RGB: 0x80C8

  защищено 
  BLEND_SRC_RGB: 0x80C9

  защищено 
  BLEND_DST_ALPHA: 0x80CA

  защищено 
  BLEND_SRC_ALPHA: 0x80CB

  защищено 
  CONSTANT_COLOR: 0x8001

  защищено 
  ONE_MINUS_CONSTANT_COLOR: 0x8002

  защищено 
  CONSTANT_ALPHA: 0x8003

  защищено 
  ONE_MINUS_CONSTANT_ALPHA: 0x8004

  защищено 
  BLEND_COLOR: 0x8005

  защищено 
  ARRAY_BUFFER: 0x8892

  защищено 
  ELEMENT_ARRAY_BUFFER: 0x8893

  защищено 
  ARRAY_BUFFER_BINDING: 0x8894

  защищено 
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895

  защищено 
  STREAM_DRAW: 0x88E0

  защищено 
  STATIC_DRAW: 0x88E4

  защищено 
  DYNAMIC_DRAW: 0x88E8

  защищено 
  BUFFER_SIZE: 0x8764

  защищено 
  BUFFER_USAGE: 0x8765

  защищено 
  CURRENT_VERTEX_ATTRIB: 0x8626

  защищено 
  FRONT: 0x0404

  защищено 
  BACK: 0x0405

  защищено 
  FRONT_AND_BACK: 0x0408

  защищено 
  CULL_FACE: 0x0B44

  защищено 
  BLEND: 0x0BE2

  защищено 
  DITHER: 0x0BD0

  защищено 
  STENCIL_TEST: 0x0B90

  защищено 
  DEPTH_TEST: 0x0B71

  защищено 
  SCISSOR_TEST: 0x0C11

  защищено 
  POLYGON_OFFSET_FILL: 0x8037

  защищено 
  SAMPLE_ALPHA_TO_COVERAGE: 0x809E

  защищено 
  SAMPLE_COVERAGE: 0x80A0

  защищено 
  NO_ERROR: 0

  защищено 
  INVALID_ENUM: 0x0500

  защищено 
  INVALID_VALUE: 0x0501

  защищено 
  INVALID_OPERATION: 0x0502

  защищено 
  OUT_OF_MEMORY: 0x0505

  защищено 
  CW: 0x0900

  защищено 
  CCW: 0x0901

  защищено 
  LINE_WIDTH: 0x0B21

  защищено 
  ALIASED_POINT_SIZE_RANGE: 0x846D

  защищено 
  ALIASED_LINE_WIDTH_RANGE: 0x846E

  защищено 
  CULL_FACE_MODE: 0x0B45

  защищено 
  FRONT_FACE: 0x0B46

  защищено 
  DEPTH_RANGE: 0x0B70

  защищено 
  DEPTH_WRITEMASK: 0x0B72

  защищено 
  DEPTH_CLEAR_VALUE: 0x0B73

  защищено 
  DEPTH_FUNC: 0x0B74

  защищено 
  STENCIL_CLEAR_VALUE: 0x0B91

  защищено 
  STENCIL_FUNC: 0x0B92

  защищено 
  STENCIL_FAIL: 0x0B94

  защищено 
  STENCIL_PASS_DEPTH_FAIL: 0x0B95

  защищено 
  STENCIL_PASS_DEPTH_PASS: 0x0B96

  защищено 
  STENCIL_REF: 0x0B97

  защищено 
  STENCIL_VALUE_MASK: 0x0B93

  защищено 
  STENCIL_WRITEMASK: 0x0B98

  защищено 
  STENCIL_BACK_FUNC: 0x8800

  защищено 
  STENCIL_BACK_FAIL: 0x8801

  защищено 
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802

  защищено 
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803

  защищено 
  STENCIL_BACK_REF: 0x8CA3

  защищено 
  STENCIL_BACK_VALUE_MASK: 0x8CA4

  защищено 
  STENCIL_BACK_WRITEMASK: 0x8CA5

  защищено 
  VIEWPORT: 0x0BA2

  защищено 
  SCISSOR_BOX: 0x0C10

  защищено 
  COLOR_CLEAR_VALUE: 0x0C22

  защищено 
  COLOR_WRITEMASK: 0x0C23

  защищено 
  UNPACK_ALIGNMENT: 0x0CF5

  защищено 
  PACK_ALIGNMENT: 0x0D05

  защищено 
  MAX_TEXTURE_SIZE: 0x0D33

  защищено 
  MAX_VIEWPORT_DIMS: 0x0D3A

  защищено 
  SUBPIXEL_BITS: 0x0D50

  защищено 
  RED_BITS: 0x0D52

  защищено 
  GREEN_BITS: 0x0D53

  защищено 
  BLUE_BITS: 0x0D54

  защищено 
  ALPHA_BITS: 0x0D55

  защищено 
  DEPTH_BITS: 0x0D56

  защищено 
  STENCIL_BITS: 0x0D57

  защищено 
  POLYGON_OFFSET_UNITS: 0x2A00

  защищено 
  POLYGON_OFFSET_FACTOR: 0x8038

  защищено 
  TEXTURE_BINDING_2D: 0x8069

  защищено 
  SAMPLE_BUFFERS: 0x80A8

  защищено 
  SAMPLES: 0x80A9

  защищено 
  SAMPLE_COVERAGE_VALUE: 0x80AA

  защищено 
  SAMPLE_COVERAGE_INVERT: 0x80AB

  защищено 
  COMPRESSED_TEXTURE_FORMATS: 0x86A3

  защищено 
  DONT_CARE: 0x1100

  защищено 
  FASTEST: 0x1101

  защищено 
  NICEST: 0x1102

  защищено 
  GENERATE_MIPMAP_HINT: 0x8192

  защищено 
  BYTE: 0x1400

  защищено 
  UNSIGNED_BYTE: 0x1401

  защищено 
  SHORT: 0x1402

  защищено 
  UNSIGNED_SHORT: 0x1403

  защищено 
  INT: 0x1404

  защищено 
  UNSIGNED_INT: 0x1405

  защищено 
  FLOAT: 0x1406

  защищено 
  DEPTH_COMPONENT: 0x1902

  защищено 
  ALPHA: 0x1906

  защищено 
  RGB: 0x1907

  защищено 
  RGBA: 0x1908

  защищено 
  LUMINANCE: 0x1909

  защищено 
  LUMINANCE_ALPHA: 0x190A

  защищено 
  UNSIGNED_SHORT_4_4_4_4: 0x8033

  защищено 
  UNSIGNED_SHORT_5_5_5_1: 0x8034

  защищено 
  UNSIGNED_SHORT_5_6_5: 0x8363

  защищено 
  FRAGMENT_SHADER: 0x8B30

  защищено 
  VERTEX_SHADER: 0x8B31

  защищено 
  MAX_VERTEX_ATTRIBS: 0x8869

  защищено 
  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB

  защищено 
  MAX_VARYING_VECTORS: 0x8DFC

  защищено 
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D

  защищено 
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C

  защищено 
  MAX_TEXTURE_IMAGE_UNITS: 0x8872

  защищено 
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD

  защищено 
  SHADER_TYPE: 0x8B4F

  защищено 
  DELETE_STATUS: 0x8B80

  защищено 
  LINK_STATUS: 0x8B82

  защищено 
  VALIDATE_STATUS: 0x8B83

  защищено 
  ATTACHED_SHADERS: 0x8B85

  защищено 
  ACTIVE_UNIFORMS: 0x8B86

  защищено 
  ACTIVE_ATTRIBUTES: 0x8B89

  защищено 
  SHADING_LANGUAGE_VERSION: 0x8B8C

  защищено 
  CURRENT_PROGRAM: 0x8B8D

  защищено 
  NEVER: 0x0200

  защищено 
  LESS: 0x0201

  защищено 
  EQUAL: 0x0202

  защищено 
  LEQUAL: 0x0203

  защищено 
  GREATER: 0x0204

  защищено 
  NOTEQUAL: 0x0205

  защищено 
  GEQUAL: 0x0206

  защищено 
  ALWAYS: 0x0207

  защищено 
  KEEP: 0x1E00

  защищено 
  REPLACE: 0x1E01

  защищено 
  INCR: 0x1E02

  защищено 
  DECR: 0x1E03

  защищено 
  INVERT: 0x150A

  защищено 
  INCR_WRAP: 0x8507

  защищено 
  DECR_WRAP: 0x8508

  защищено 
  VENDOR: 0x1F00

  защищено 
  RENDERER: 0x1F01

  защищено 
  VERSION: 0x1F02

  защищено 
  NEAREST: 0x2600

  защищено 
  LINEAR: 0x2601

  защищено 
  NEAREST_MIPMAP_NEAREST: 0x2700

  защищено 
  LINEAR_MIPMAP_NEAREST: 0x2701

  защищено 
  NEAREST_MIPMAP_LINEAR: 0x2702

  защищено 
  LINEAR_MIPMAP_LINEAR: 0x2703

  защищено 
  TEXTURE_MAG_FILTER: 0x2800

  защищено 
  TEXTURE_MIN_FILTER: 0x2801

  защищено 
  TEXTURE_WRAP_S: 0x2802

  защищено 
  TEXTURE_WRAP_T: 0x2803

  защищено 
  TEXTURE_2D: 0x0DE1

  защищено 
  TEXTURE: 0x1702

  защищено 
  TEXTURE_CUBE_MAP: 0x8513

  защищено 
  TEXTURE_BINDING_CUBE_MAP: 0x8514

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A

  защищено 
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C

  защищено 
  TEXTURE0: 0x84C0

  защищено 
  TEXTURE1: 0x84C1

  защищено 
  TEXTURE2: 0x84C2

  защищено 
  TEXTURE3: 0x84C3

  защищено 
  TEXTURE4: 0x84C4

  защищено 
  TEXTURE5: 0x84C5

  защищено 
  TEXTURE6: 0x84C6

  защищено 
  TEXTURE7: 0x84C7

  защищено 
  TEXTURE8: 0x84C8

  защищено 
  TEXTURE9: 0x84C9

  защищено 
  TEXTURE10: 0x84CA

  защищено 
  TEXTURE11: 0x84CB

  защищено 
  TEXTURE12: 0x84CC

  защищено 
  TEXTURE13: 0x84CD

  защищено 
  TEXTURE14: 0x84CE

  защищено 
  TEXTURE15: 0x84CF

  защищено 
  TEXTURE16: 0x84D0

  защищено 
  TEXTURE17: 0x84D1

  защищено 
  TEXTURE18: 0x84D2

  защищено 
  TEXTURE19: 0x84D3

  защищено 
  TEXTURE20: 0x84D4

  защищено 
  TEXTURE21: 0x84D5

  защищено 
  TEXTURE22: 0x84D6

  защищено 
  TEXTURE23: 0x84D7

  защищено 
  TEXTURE24: 0x84D8

  защищено 
  TEXTURE25: 0x84D9

  защищено 
  TEXTURE26: 0x84DA

  защищено 
  TEXTURE27: 0x84DB

  защищено 
  TEXTURE28: 0x84DC

  защищено 
  TEXTURE29: 0x84DD

  защищено 
  TEXTURE30: 0x84DE

  защищено 
  TEXTURE31: 0x84DF

  защищено 
  ACTIVE_TEXTURE: 0x84E0

  защищено 
  REPEAT: 0x2901

  защищено 
  CLAMP_TO_EDGE: 0x812F

  защищено 
  MIRRORED_REPEAT: 0x8370

  защищено 
  FLOAT_VEC2: 0x8B50

  защищено 
  FLOAT_VEC3: 0x8B51

  защищено 
  FLOAT_VEC4: 0x8B52

  защищено 
  INT_VEC2: 0x8B53

  защищено 
  INT_VEC3: 0x8B54

  защищено 
  INT_VEC4: 0x8B55

  защищено 
  BOOL: 0x8B56

  защищено 
  BOOL_VEC2: 0x8B57

  защищено 
  BOOL_VEC3: 0x8B58

  защищено 
  BOOL_VEC4: 0x8B59

  защищено 
  FLOAT_MAT2: 0x8B5A

  защищено 
  FLOAT_MAT3: 0x8B5B

  защищено 
  FLOAT_MAT4: 0x8B5C

  защищено 
  SAMPLER_2D: 0x8B5E

  защищено 
  SAMPLER_CUBE: 0x8B60

  защищено 
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622

  защищено 
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623

  защищено 
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624

  защищено 
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625

  защищено 
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A

  защищено 
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645

  защищено 
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F

  защищено 
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A

  защищено 
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B

  защищено 
  COMPILE_STATUS: 0x8B81

  защищено 
  LOW_FLOAT: 0x8DF0

  защищено 
  MEDIUM_FLOAT: 0x8DF1

  защищено 
  HIGH_FLOAT: 0x8DF2

  защищено 
  LOW_INT: 0x8DF3

  защищено 
  MEDIUM_INT: 0x8DF4

  защищено 
  HIGH_INT: 0x8DF5

  защищено 
  FRAMEBUFFER: 0x8D40

  защищено 
  RENDERBUFFER: 0x8D41

  защищено 
  RGBA4: 0x8056

  защищено 
  RGB5_A1: 0x8057

  защищено 
  RGB565: 0x8D62

  защищено 
  DEPTH_COMPONENT16: 0x81A5

  защищено 
  STENCIL_INDEX8: 0x8D48

  защищено 
  DEPTH_STENCIL: 0x84F9

  защищено 
  RENDERBUFFER_WIDTH: 0x8D42

  защищено 
  RENDERBUFFER_HEIGHT: 0x8D43

  защищено 
  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44

  защищено 
  RENDERBUFFER_RED_SIZE: 0x8D50

  защищено 
  RENDERBUFFER_GREEN_SIZE: 0x8D51

  защищено 
  RENDERBUFFER_BLUE_SIZE: 0x8D52

  защищено 
  RENDERBUFFER_ALPHA_SIZE: 0x8D53

  защищено 
  RENDERBUFFER_DEPTH_SIZE: 0x8D54

  защищено 
  RENDERBUFFER_STENCIL_SIZE: 0x8D55

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3

  защищено 
  COLOR_ATTACHMENT0: 0x8CE0

  защищено 
  DEPTH_ATTACHMENT: 0x8D00

  защищено 
  STENCIL_ATTACHMENT: 0x8D20

  защищено 
  DEPTH_STENCIL_ATTACHMENT: 0x821A

  защищено 
  NONE: 0

  защищено 
  FRAMEBUFFER_COMPLETE: 0x8CD5

  защищено 
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6

  защищено 
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7

  защищено 
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9

  защищено 
  FRAMEBUFFER_UNSUPPORTED: 0x8CDD

  защищено 
  FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  RENDERBUFFER_BINDING: 0x8CA7

  защищено 
  MAX_RENDERBUFFER_SIZE: 0x84E8

  защищено 
  INVALID_FRAMEBUFFER_OPERATION: 0x0506

  защищено 
  UNPACK_FLIP_Y_WEBGL: 0x9240

  защищено 
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241

  защищено 
  CONTEXT_LOST_WEBGL: 0x9242

  защищено 
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243

  защищено 
  BROWSER_DEFAULT_WEBGL: 0x9244
}


тип WebGLRenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, data: BufferSource?FUCKFUCK, usage: GLenum)

  операция bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция uniform1fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform1iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform2fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform2iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform3fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform3iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform4fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform4iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniformMatrix2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)

  операция uniformMatrix3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)

  операция uniformMatrix4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSampler) */

тип WebGLSampler = интерфейс
{

}


внешнее
/*(!) var */ WebGLSampler: объект { prototype: WebGLSampler; при создании()/*(!) no_type */ Объект? }


/**
* The WebGLShader is part of the WebGL API and can either be a vertex or a fragment shader. A WebGLProgram requires both types of shaders.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShader)
*/

тип WebGLShader = интерфейс
{

}


внешнее
/*(!) var */ WebGLShader: объект { prototype: WebGLShader; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getShaderPrecisionFormat() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShaderPrecisionFormat)
*/

тип WebGLShaderPrecisionFormat = интерфейс
{
  защищено 
  precision: GLint

  защищено 
  rangeMax: GLint

  защищено 
  rangeMin: GLint
}


внешнее
/*(!) var */ WebGLShaderPrecisionFormat: объект { prototype: WebGLShaderPrecisionFormat; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSync) */

тип WebGLSync = интерфейс
{

}


внешнее
/*(!) var */ WebGLSync: объект { prototype: WebGLSync; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents an opaque texture object providing storage and state for texturing operations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTexture)
*/

тип WebGLTexture = интерфейс
{

}


внешнее
/*(!) var */ WebGLTexture: объект { prototype: WebGLTexture; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTransformFeedback) */

тип WebGLTransformFeedback = интерфейс
{

}


внешнее
/*(!) var */ WebGLTransformFeedback: объект { prototype: WebGLTransformFeedback; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents the location of a uniform variable in a shader program.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLUniformLocation)
*/

тип WebGLUniformLocation = интерфейс
{

}


внешнее
/*(!) var */ WebGLUniformLocation: объект { prototype: WebGLUniformLocation; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObject) */

тип WebGLVertexArrayObject = интерфейс
{

}


внешнее
/*(!) var */ WebGLVertexArrayObject: объект { prototype: WebGLVertexArrayObject; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObjectOES) */

тип WebGLVertexArrayObjectOES = интерфейс
{

}


тип WebSocketEventMap = интерфейс
{
  "close": CloseEvent

  "error": Event

  "message": MessageEvent

  "open": Event
}


/**
* Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)
*/

тип WebSocket = интерфейс
{
  binaryType: BinaryType

  защищено 
  bufferedAmount: Число

  защищено 
  extensions: Текст

  onclose: операция(this: WebSocket, ev: CloseEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: WebSocket, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: WebSocket, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onopen: операция(this: WebSocket, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  protocol: Текст

  защищено 
  readyState: Число

  защищено 
  url: Текст

  операция close(code: Число?FUCKFUCK = пусто, reason: Текст?FUCKFUCK = пусто)

  операция send(data: Текст | ArrayBufferLike | Blob | ArrayBufferView)

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSING: 2

  защищено 
  CLOSED: 3

  операция addEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ WebSocket: объект { prototype: WebSocket; при создании(url: Текст | URL, protocols: Текст | Список<Текст> | пусто = пусто)/*(!) no_type */ Объект?; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSING: 2; защищено  CLOSED: 3 }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransport)
*/

тип WebTransport = интерфейс
{
  защищено 
  closed: Promise<WebTransportCloseInfo>

  защищено 
  datagrams: WebTransportDatagramDuplexStream

  защищено 
  incomingBidirectionalStreams: ReadableStream

  защищено 
  incomingUnidirectionalStreams: ReadableStream

  защищено 
  ready: Promise<пусто>

  операция close(closeInfo: WebTransportCloseInfo?FUCKFUCK = пусто)

  операция createBidirectionalStream(options: WebTransportSendStreamOptions?FUCKFUCK = пусто): Promise<WebTransportBidirectionalStream>

  операция createUnidirectionalStream(options: WebTransportSendStreamOptions?FUCKFUCK = пусто): Promise<WritableStream>
}


внешнее
/*(!) var */ WebTransport: объект { prototype: WebTransport; при создании(url: Текст | URL, options: WebTransportOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportBidirectionalStream)
*/

тип WebTransportBidirectionalStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportBidirectionalStream: объект { prototype: WebTransportBidirectionalStream; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportDatagramDuplexStream)
*/

тип WebTransportDatagramDuplexStream = интерфейс
{
  incomingHighWaterMark: Число

  incomingMaxAge: Число

  защищено 
  maxDatagramSize: Число

  outgoingHighWaterMark: Число

  outgoingMaxAge: Число

  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportDatagramDuplexStream: объект { prototype: WebTransportDatagramDuplexStream; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportError)
*/

тип WebTransportError = интерфейс
{
  защищено 
  source: WebTransportErrorSource

  защищено 
  streamErrorCode: Число?FUCKFUCK
}


внешнее
/*(!) var */ WebTransportError: объект { prototype: WebTransportError; при создании(message: Текст?FUCKFUCK = пусто, options: WebTransportErrorOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This ServiceWorker API interface represents the scope of a service worker client that is a document in a browser context, controlled by an active worker. The service worker client independently selects and uses a service worker for its own loading and sub-resources.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WindowClient)
*/

тип WindowClient = интерфейс
{
  защищено 
  focused: ДаНет

  защищено 
  visibilityState: DocumentVisibilityState

  операция focus(): Promise<WindowClient>

  операция navigate(url: Текст | URL): Promise<WindowClient?FUCKFUCK>
}


внешнее
/*(!) var */ WindowClient: объект { prototype: WindowClient; при создании()/*(!) no_type */ Объект? }


тип WindowOrWorkerGlobalScope = интерфейс
{
  защищено 
  caches: CacheStorage

  защищено 
  crossOriginIsolated: ДаНет

  защищено 
  crypto: Crypto

  защищено 
  indexedDB: IDBFactory

  защищено 
  isSecureContext: ДаНет

  защищено 
  origin: Текст

  защищено 
  performance: Performance

  операция atob(data: Текст): Текст

  операция btoa(data: Текст): Текст

  операция clearInterval(id: Число?FUCKFUCK)

  операция clearTimeout(id: Число?FUCKFUCK)

  операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

  операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

  операция fetch(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто): Promise<Response>

  операция queueMicrotask(callback: VoidFunction)

  операция reportError(e: /*(!) any */ Объект?)

  #js.МассивПараметров
  операция setInterval(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

  #js.МассивПараметров
  операция setTimeout(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

  операция structuredClone<T>(value: T, options: StructuredSerializeOptions?FUCKFUCK = пусто): T
}


тип WorkerEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Web Workers API interface represents a background task that can be easily created and can send messages back to its creator. Creating a worker is as simple as calling the Worker() constructor and specifying a script to be run in the worker thread.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Worker)
*/

тип Worker = интерфейс
{
  onmessage: операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция terminate()

  операция addEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Worker: объект { prototype: Worker; при создании(scriptURL: Текст | URL, options: WorkerOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип WorkerGlobalScopeEventMap = интерфейс
{
  "error": ErrorEvent

  "languagechange": Event

  "offline": Event

  "online": Event

  "rejectionhandled": PromiseRejectionEvent

  "unhandledrejection": PromiseRejectionEvent
}


/**
* This Web Workers API interface is an interface representing the scope of any worker. Workers have no browsing context; this scope contains the information usually conveyed by Window objects — in this case event handlers, the console or the associated WorkerNavigator object. Each WorkerGlobalScope has its own event loop.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope)
*/

тип WorkerGlobalScope = интерфейс
{
  защищено 
  location: WorkerLocation

  защищено 
  navigator: WorkerNavigator

  onerror: операция(this: WorkerGlobalScope, ev: ErrorEvent): /*(!) any */ Объект??FUCKFUCK

  onlanguagechange: операция(this: WorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onoffline: операция(this: WorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ononline: операция(this: WorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onrejectionhandled: операция(this: WorkerGlobalScope, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK

  onunhandledrejection: операция(this: WorkerGlobalScope, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  self: /*(!) WorkerGlobalScope & typeof globalThis */ Объект?

  #js.МассивПараметров
  операция importScripts(urls: Список<Текст | URL>)

  операция addEventListener<K = /*(!) keyof WorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: WorkerGlobalScope, ev: /*(!) WorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: WorkerGlobalScope, ev: /*(!) WorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ WorkerGlobalScope: объект { prototype: WorkerGlobalScope; при создании()/*(!) no_type */ Объект? }


/**
* The absolute location of the script executed by the Worker. Such an object is initialized for each worker and is available via the WorkerGlobalScope.location property obtained by calling self.location.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerLocation)
*/

тип WorkerLocation = интерфейс
{
  защищено 
  hash: Текст

  защищено 
  host: Текст

  защищено 
  hostname: Текст

  защищено 
  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  защищено 
  pathname: Текст

  защищено 
  port: Текст

  защищено 
  protocol: Текст

  защищено 
  search: Текст
}


внешнее
/*(!) var */ WorkerLocation: объект { prototype: WorkerLocation; при создании()/*(!) no_type */ Объект? }


/**
* A subset of the Navigator interface allowed to be accessed from a Worker. Such an object is initialized for each worker and is available via the WorkerGlobalScope.navigator property obtained by calling window.self.navigator.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerNavigator)
*/

тип WorkerNavigator = интерфейс
{
  защищено 
  mediaCapabilities: MediaCapabilities

  защищено 
  permissions: Permissions
}


внешнее
/*(!) var */ WorkerNavigator: объект { prototype: WorkerNavigator; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)
*/

тип WritableStream<W> = интерфейс
{
  защищено 
  locked: ДаНет

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция getWriter(): WritableStreamDefaultWriter<W>
}


внешнее
/*(!) var */ WritableStream: объект { prototype: WritableStream; при создании(underlyingSink: UnderlyingSink<W>?FUCKFUCK = пусто, strategy: QueuingStrategy<W>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)
*/

тип WritableStreamDefaultController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ WritableStreamDefaultController: объект { prototype: WritableStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the < writer to the WritableStream ensuring that no other streams can write to the underlying sink.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)
*/

тип WritableStreamDefaultWriter<W> = интерфейс
{
  защищено 
  closed: Promise<пусто>

  защищено 
  desiredSize: Число?FUCKFUCK

  защищено 
  ready: Promise<пусто>

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция releaseLock()

  операция write(chunk: W?FUCKFUCK = пусто): Promise<Ничего>
}


внешнее
/*(!) var */ WritableStreamDefaultWriter: объект { prototype: WritableStreamDefaultWriter; при создании(stream: WritableStream<W>)/*(!) no_type */ Объект? }


тип XMLHttpRequestEventMap = интерфейс
{
  "readystatechange": Event
}


/**
* Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest)
*/

тип XMLHttpRequest = интерфейс
{
  onreadystatechange: операция(this: XMLHttpRequest, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: Число

  защищено 
  response: /*(!) any */ Объект?

  защищено 
  responseText: Текст

  responseType: XMLHttpRequestResponseType

  защищено 
  responseURL: Текст

  защищено 
  status: Число

  защищено 
  statusText: Текст

  timeout: Число

  защищено 
  upload: XMLHttpRequestUpload

  withCredentials: ДаНет

  операция abort()

  операция getAllResponseHeaders(): Текст

  операция getResponseHeader(name: Текст): Текст?FUCKFUCK

  операция open(method: Текст, url: Текст | URL)

  операция open(method: Текст, url: Текст | URL, async: ДаНет, username: Текст?FUCKFUCK = пусто, password: Текст?FUCKFUCK = пусто)

  операция overrideMimeType(mime: Текст)

  операция send(body: XMLHttpRequestBodyInit?FUCKFUCK = пусто)

  операция setRequestHeader(name: Текст, value: Текст)

  защищено 
  UNSENT: 0

  защищено 
  OPENED: 1

  защищено 
  HEADERS_RECEIVED: 2

  защищено 
  LOADING: 3

  защищено 
  DONE: 4

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequest: объект { prototype: XMLHttpRequest; при создании()/*(!) no_type */ Объект?; защищено  UNSENT: 0; защищено  OPENED: 1; защищено  HEADERS_RECEIVED: 2; защищено  LOADING: 3; защищено  DONE: 4 }


тип XMLHttpRequestEventTargetEventMap = интерфейс
{
  "abort": ProgressEvent<XMLHttpRequestEventTarget>

  "error": ProgressEvent<XMLHttpRequestEventTarget>

  "load": ProgressEvent<XMLHttpRequestEventTarget>

  "loadend": ProgressEvent<XMLHttpRequestEventTarget>

  "loadstart": ProgressEvent<XMLHttpRequestEventTarget>

  "progress": ProgressEvent<XMLHttpRequestEventTarget>

  "timeout": ProgressEvent<XMLHttpRequestEventTarget>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestEventTarget) */

тип XMLHttpRequestEventTarget = интерфейс
{
  onabort: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onload: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onloadend: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onloadstart: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onprogress: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  ontimeout: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestEventTarget: объект { prototype: XMLHttpRequestEventTarget; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestUpload) */

тип XMLHttpRequestUpload = интерфейс
{
  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestUpload: объект { prototype: XMLHttpRequestUpload; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */

тип Console = интерфейс
{
  #js.МассивПараметров
  операция assert(condition: ДаНет?FUCKFUCK = пусто, data: Список</*(!) any */ Объект?>)

  операция clear()

  операция count(label: Текст?FUCKFUCK = пусто)

  операция countReset(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция debug(data: Список</*(!) any */ Объект?>)

  операция dir(item: /*(!) any */ Объект??FUCKFUCK = пусто, options: /*(!) any */ Объект??FUCKFUCK = пусто)

  #js.МассивПараметров
  операция dirxml(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция error(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция group(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция groupCollapsed(data: Список</*(!) any */ Объект?>)

  операция groupEnd()

  #js.МассивПараметров
  операция info(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция log(data: Список</*(!) any */ Объект?>)

  операция table(tabularData: /*(!) any */ Объект??FUCKFUCK = пусто, properties: Список<Текст>?FUCKFUCK = пусто)

  операция time(label: Текст?FUCKFUCK = пусто)

  операция timeEnd(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция timeLog(label: Текст?FUCKFUCK = пусто, data: Список</*(!) any */ Объект?>)

  операция timeStamp(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция trace(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция warn(data: Список</*(!) any */ Объект?>)
}


внешнее
/*(!) var */ console: Console


внешнее
/*(!) WebAssembly */
{
тип CompileError = интерфейс
{

}


/*(!) var */ CompileError: объект { prototype: CompileError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): CompileError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Global) */

тип Global<T = ValueType> = интерфейс
{
  value: /*(!) ValueTypeMap[T] */ Объект?

  операция valueOf(): /*(!) ValueTypeMap[T] */ Объект?
}


/*(!) var */ Global: объект { prototype: Global; при создании(descriptor: GlobalDescriptor<T>, v: /*(!) ValueTypeMap[T] */ Объект??FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance) */

тип Instance = интерфейс
{
  защищено 
  exports: Exports
}


/*(!) var */ Instance: объект { prototype: Instance; при создании(module: Module, importObject: Imports?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип LinkError = интерфейс
{

}


/*(!) var */ LinkError: объект { prototype: LinkError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): LinkError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory) */

тип Memory = интерфейс
{
  защищено 
  buffer: ArrayBuffer

  операция grow(delta: Число): Число
}


/*(!) var */ Memory: объект { prototype: Memory; при создании(descriptor: MemoryDescriptor)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) */

тип Module = интерфейс
{

}


/*(!) var */ Module: объект { prototype: Module; при создании(bytes: BufferSource)/*(!) no_type */ Объект?; операция customSections(moduleObject: Module, sectionName: Текст): Список<ArrayBuffer>; операция exports(moduleObject: Module): Список<ModuleExportDescriptor>; операция imports(moduleObject: Module): Список<ModuleImportDescriptor> }


тип RuntimeError = интерфейс
{

}


/*(!) var */ RuntimeError: объект { prototype: RuntimeError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): RuntimeError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Table) */

тип Table = интерфейс
{
  защищено 
  length: Число

  операция get(index: Число): /*(!) any */ Объект?

  операция grow(delta: Число, value: /*(!) any */ Объект??FUCKFUCK = пусто): Число

  операция set(index: Число, value: /*(!) any */ Объект??FUCKFUCK = пусто)
}


/*(!) var */ Table: объект { prototype: Table; при создании(descriptor: TableDescriptor, value: /*(!) any */ Объект??FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип GlobalDescriptor<T = ValueType> = интерфейс
{
  mutable: ДаНет

  value: T
}


тип MemoryDescriptor = интерфейс
{
  initial: Число

  maximum: Число

  shared: ДаНет
}


тип ModuleExportDescriptor = интерфейс
{
  kind: ImportExportKind

  name: Текст
}


тип ModuleImportDescriptor = интерфейс
{
  kind: ImportExportKind

  module: Текст

  name: Текст
}


тип TableDescriptor = интерфейс
{
  element: TableKind

  initial: Число

  maximum: Число
}


тип ValueTypeMap = интерфейс
{
  anyfunc: Function

  externref: /*(!) any */ Объект?

  f32: Число

  f64: Число

  i32: Число

  i64: bigint

  v128: Никогда
}


тип WebAssemblyInstantiatedSource = интерфейс
{
  instance: Instance

  module: Module
}


тип ImportExportKind = "function" | "global" | "memory" | "table"

тип TableKind = "anyfunc" | "externref"

тип ExportValue = Function | Global | Memory | Table

тип Exports = Record<Текст, ExportValue>

тип ImportValue = ExportValue | Число

тип Imports = Record<Текст, ModuleImports>

тип ModuleImports = Record<Текст, ImportValue>

тип ValueType = /*(!) keyof ValueTypeMap */ Объект?

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile) */

операция compile(bytes: BufferSource): Promise<Module>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compileStreaming) */

операция compileStreaming(source: Response | PromiseLike<Response>): Promise<Module>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate) */

операция instantiate(bytes: BufferSource, importObject: Imports?FUCKFUCK = пусто): Promise<WebAssemblyInstantiatedSource>

операция instantiate(moduleObject: Module, importObject: Imports?FUCKFUCK = пусто): Promise<Instance>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming) */

операция instantiateStreaming(source: Response | PromiseLike<Response>, importObject: Imports?FUCKFUCK = пусто): Promise<WebAssemblyInstantiatedSource>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/validate) */

операция validate(bytes: BufferSource): ДаНет
}

тип EncodedVideoChunkOutputCallback = интерфейс
{
  /*(!) (chunk: EncodedVideoChunk, metadata?: EncodedVideoChunkMetadata): void*/
}


тип FrameRequestCallback = интерфейс
{
  /*(!) (time: DOMHighResTimeStamp): void*/
}


тип LockGrantedCallback = интерфейс
{
  /*(!) (lock: Lock | null): any*/
}


тип OnErrorEventHandlerNonNull = интерфейс
{
  /*(!) (event: Event | string, source?: string, lineno?: number, colno?: number, error?: Error): any*/
}


тип PerformanceObserverCallback = интерфейс
{
  /*(!) (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void*/
}


тип QueuingStrategySize<T> = интерфейс
{
  /*(!) (chunk: T): number*/
}


тип ReportingObserverCallback = интерфейс
{
  /*(!) (reports: Report[], observer: ReportingObserver): void*/
}


тип TransformerFlushCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип TransformerStartCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): any*/
}


тип TransformerTransformCallback<I, O> = интерфейс
{
  /*(!) (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип UnderlyingSinkAbortCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSinkCloseCallback = интерфейс
{
  /*(!) (): void | PromiseLike<void>*/
}


тип UnderlyingSinkStartCallback = интерфейс
{
  /*(!) (controller: WritableStreamDefaultController): any*/
}


тип UnderlyingSinkWriteCallback<W> = интерфейс
{
  /*(!) (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>*/
}


тип UnderlyingSourceCancelCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSourcePullCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): void | PromiseLike<void>*/
}


тип UnderlyingSourceStartCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): any*/
}


тип VideoFrameOutputCallback = интерфейс
{
  /*(!) (output: VideoFrame): void*/
}


тип VoidFunction = интерфейс
{
  /*(!) (): void*/
}


тип WebCodecsErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


/**
* Returns dedicatedWorkerGlobal's name, i.e. the value given to the Worker constructor. Primarily useful for debugging.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope/name)
*/

внешнее
/*(!) var */ name: Текст


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope/message_event) */

внешнее
/*(!) var */ onmessage: операция(this: DedicatedWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope/messageerror_event) */

внешнее
/*(!) var */ onmessageerror: операция(this: DedicatedWorkerGlobalScope, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Aborts dedicatedWorkerGlobal.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope/close)
*/

внешнее
операция close()

/**
* Clones message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DedicatedWorkerGlobalScope/postMessage)
*/

внешнее
операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

внешнее
операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

/**
* Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
*/

внешнее
операция dispatchEvent(event: Event): ДаНет

/**
* Returns workerGlobal's WorkerLocation object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/location)
*/

внешнее
/*(!) var */ location: WorkerLocation


/**
* Returns workerGlobal's WorkerNavigator object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/navigator)
*/

внешнее
/*(!) var */ navigator: WorkerNavigator


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/error_event) */

внешнее
/*(!) var */ onerror: операция(this: DedicatedWorkerGlobalScope, ev: ErrorEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/languagechange_event) */

внешнее
/*(!) var */ onlanguagechange: операция(this: DedicatedWorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/offline_event) */

внешнее
/*(!) var */ onoffline: операция(this: DedicatedWorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/online_event) */

внешнее
/*(!) var */ ononline: операция(this: DedicatedWorkerGlobalScope, ev: Event): /*(!) any */ Объект??FUCKFUCK


внешнее
/*(!) var */ onrejectionhandled: операция(this: DedicatedWorkerGlobalScope, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK


внешнее
/*(!) var */ onunhandledrejection: операция(this: DedicatedWorkerGlobalScope, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Returns workerGlobal.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/self)
*/

внешнее
/*(!) var */ self: /*(!) WorkerGlobalScope & typeof globalThis */ Объект?


/**
* Fetches each URL in urls, executes them one-by-one in the order they are passed, and then returns (or throws if something went amiss).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts)
*/

внешнее
#js.МассивПараметров
операция importScripts(urls: Список<Текст | URL>)

/**
* Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
*/

внешнее
операция dispatchEvent(event: Event): ДаНет

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/fonts) */

внешнее
/*(!) var */ fonts: FontFaceSet


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/caches)
*/

внешнее
/*(!) var */ caches: CacheStorage


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crossOriginIsolated) */

внешнее
/*(!) var */ crossOriginIsolated: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crypto_property) */

внешнее
/*(!) var */ crypto: Crypto


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/indexedDB) */

внешнее
/*(!) var */ indexedDB: IDBFactory


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/isSecureContext) */

внешнее
/*(!) var */ isSecureContext: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/origin) */

внешнее
/*(!) var */ origin: Текст


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/performance_property) */

внешнее
/*(!) var */ performance: Performance


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/atob) */

внешнее
операция atob(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/btoa) */

внешнее
операция btoa(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearInterval) */

внешнее
операция clearInterval(id: Число?FUCKFUCK)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearTimeout) */

внешнее
операция clearTimeout(id: Число?FUCKFUCK)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/createImageBitmap) */

внешнее
операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

внешнее
операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/fetch) */

внешнее
операция fetch(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто): Promise<Response>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/queueMicrotask) */

внешнее
операция queueMicrotask(callback: VoidFunction)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/reportError) */

внешнее
операция reportError(e: /*(!) any */ Объект?)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setInterval) */

внешнее
#js.МассивПараметров
операция setInterval(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setTimeout) */

внешнее
#js.МассивПараметров
операция setTimeout(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/structuredClone) */

внешнее
операция structuredClone<T>(value: T, options: StructuredSerializeOptions?FUCKFUCK = пусто): T

внешнее
операция cancelAnimationFrame(handle: Число)

внешнее
операция requestAnimationFrame(callback: FrameRequestCallback): Число

внешнее
операция addEventListener<K = /*(!) keyof DedicatedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: DedicatedWorkerGlobalScope, ev: /*(!) DedicatedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

внешнее
операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

внешнее
операция removeEventListener<K = /*(!) keyof DedicatedWorkerGlobalScopeEventMap */ Объект?>(type: K, listener: операция(this: DedicatedWorkerGlobalScope, ev: /*(!) DedicatedWorkerGlobalScopeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

внешнее
операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

тип AlgorithmIdentifier = Algorithm | Текст

тип AllowSharedBufferSource = ArrayBuffer | ArrayBufferView

тип BigInteger = Uint8Array

тип BinaryData = ArrayBuffer | ArrayBufferView

тип BlobPart = BufferSource | Blob | Текст

тип BodyInit = ReadableStream | XMLHttpRequestBodyInit

тип BufferSource = ArrayBufferView | ArrayBuffer

тип CSSKeywordish = Текст | CSSKeywordValue

тип CSSNumberish = Число | CSSNumericValue

тип CSSPerspectiveValue = CSSNumericValue | CSSKeywordish

тип CSSUnparsedSegment = Текст | CSSVariableReferenceValue

тип CanvasImageSource = ImageBitmap | OffscreenCanvas | VideoFrame

тип DOMHighResTimeStamp = Число

тип EpochTimeStamp = Число

тип EventListenerOrEventListenerObject = EventListener | EventListenerObject

тип FileSystemWriteChunkType = BufferSource | Blob | Текст | WriteParams

тип Float32List = Float32Array | Список<GLfloat>

тип FormDataEntryValue = File | Текст

тип GLbitfield = Число

тип GLboolean = ДаНет

тип GLclampf = Число

тип GLenum = Число

тип GLfloat = Число

тип GLint = Число

тип GLint64 = Число

тип GLintptr = Число

тип GLsizei = Число

тип GLsizeiptr = Число

тип GLuint = Число

тип GLuint64 = Число

тип HashAlgorithmIdentifier = AlgorithmIdentifier

тип HeadersInit = Список<объект { _0: Текст, _1: Текст }> | Record<Текст, Текст> | Headers

тип IDBValidKey = Число | Текст | Date | BufferSource | Список<IDBValidKey>

тип ImageBitmapSource = CanvasImageSource | Blob | ImageData

тип Int32List = Int32Array | Список<GLint>

тип MessageEventSource = MessagePort | ServiceWorker

тип NamedCurve = Текст

тип OffscreenRenderingContext = OffscreenCanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext

тип OnErrorEventHandler = OnErrorEventHandlerNonNull?FUCKFUCK

тип PerformanceEntryList = Список<PerformanceEntry>

тип PushMessageDataInit = BufferSource | Текст

тип ReadableStreamController<T> = ReadableStreamDefaultController<T> | ReadableByteStreamController

тип ReadableStreamReadResult<T> = ReadableStreamReadValueResult<T> | ReadableStreamReadDoneResult<T>

тип ReadableStreamReader<T> = ReadableStreamDefaultReader<T> | ReadableStreamBYOBReader

тип ReportList = Список<Report>

тип RequestInfo = Request | Текст

тип TexImageSource = ImageBitmap | ImageData | OffscreenCanvas | VideoFrame

тип TimerHandler = Текст | Function

тип Transferable = OffscreenCanvas | ImageBitmap | MessagePort | ReadableStream | WritableStream | TransformStream | VideoFrame | ArrayBuffer

тип Uint32List = Uint32Array | Список<GLuint>

тип VibratePattern = Число | Список<Число>

тип XMLHttpRequestBodyInit = Blob | BufferSource | FormData | URLSearchParams | Текст

тип AlphaOption = "discard" | "keep"

тип AvcBitstreamFormat = "annexb" | "avc"

тип BinaryType = "arraybuffer" | "blob"

тип CSSMathOperator = "clamp" | "invert" | "max" | "min" | "negate" | "product" | "sum"

тип CSSNumericBaseType = "angle" | "flex" | "frequency" | "length" | "percent" | "resolution" | "time"

тип CanvasDirection = "inherit" | "ltr" | "rtl"

тип CanvasFillRule = "evenodd" | "nonzero"

тип CanvasFontKerning = "auto" | "none" | "normal"

тип CanvasFontStretch = "condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded"

тип CanvasFontVariantCaps = "all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase"

тип CanvasLineCap = "butt" | "round" | "square"

тип CanvasLineJoin = "bevel" | "miter" | "round"

тип CanvasTextAlign = "center" | "end" | "left" | "right" | "start"

тип CanvasTextBaseline = "alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top"

тип CanvasTextRendering = "auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed"

тип ClientTypes = "all" | "sharedworker" | "window" | "worker"

тип CodecState = "closed" | "configured" | "unconfigured"

тип ColorGamut = "p3" | "rec2020" | "srgb"

тип ColorSpaceConversion = "default" | "none"

тип CompressionFormat = "deflate" | "deflate-raw" | "gzip"

тип DocumentVisibilityState = "hidden" | "visible"

тип EncodedVideoChunkType = "delta" | "key"

тип EndingType = "native" | "transparent"

тип FileSystemHandleKind = "directory" | "file"

тип FontDisplay = "auto" | "block" | "fallback" | "optional" | "swap"

тип FontFaceLoadStatus = "error" | "loaded" | "loading" | "unloaded"

тип FontFaceSetLoadStatus = "loaded" | "loading"

тип FrameType = "auxiliary" | "nested" | "none" | "top-level"

тип GlobalCompositeOperation = "color" | "color-burn" | "color-dodge" | "copy" | "darken" | "destination-atop" | "destination-in" | "destination-out" | "destination-over" | "difference" | "exclusion" | "hard-light" | "hue" | "lighten" | "lighter" | "luminosity" | "multiply" | "overlay" | "saturation" | "screen" | "soft-light" | "source-atop" | "source-in" | "source-out" | "source-over" | "xor"

тип HardwareAcceleration = "no-preference" | "prefer-hardware" | "prefer-software"

тип HdrMetadataType = "smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40"

тип IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique"

тип IDBRequestReadyState = "done" | "pending"

тип IDBTransactionDurability = "default" | "relaxed" | "strict"

тип IDBTransactionMode = "readonly" | "readwrite" | "versionchange"

тип ImageOrientation = "flipY" | "from-image" | "none"

тип ImageSmoothingQuality = "high" | "low" | "medium"

тип KeyFormat = "jwk" | "pkcs8" | "raw" | "spki"

тип KeyType = "private" | "public" | "secret"

тип KeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey"

тип LatencyMode = "quality" | "realtime"

тип LockMode = "exclusive" | "shared"

тип MediaDecodingType = "file" | "media-source" | "webrtc"

тип MediaEncodingType = "record" | "webrtc"

тип NotificationDirection = "auto" | "ltr" | "rtl"

тип NotificationPermission = "default" | "denied" | "granted"

тип OffscreenRenderingContextId = "2d" | "bitmaprenderer" | "webgl" | "webgl2" | "webgpu"

тип PermissionName = "geolocation" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock" | "xr-spatial-tracking"

тип PermissionState = "denied" | "granted" | "prompt"

тип PredefinedColorSpace = "display-p3" | "srgb"

тип PremultiplyAlpha = "default" | "none" | "premultiply"

тип PushEncryptionKeyName = "auth" | "p256dh"

тип RTCEncodedVideoFrameType = "delta" | "empty" | "key"

тип ReadableStreamReaderMode = "byob"

тип ReadableStreamType = "bytes"

тип ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url"

тип RequestCache = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload"

тип RequestCredentials = "include" | "omit" | "same-origin"

тип RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt"

тип RequestMode = "cors" | "navigate" | "no-cors" | "same-origin"

тип RequestRedirect = "error" | "follow" | "manual"

тип ResizeQuality = "high" | "low" | "medium" | "pixelated"

тип ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect"

тип SecurityPolicyViolationEventDisposition = "enforce" | "report"

тип ServiceWorkerState = "activated" | "activating" | "installed" | "installing" | "parsed" | "redundant"

тип ServiceWorkerUpdateViaCache = "all" | "imports" | "none"

тип TransferFunction = "hlg" | "pq" | "srgb"

тип VideoColorPrimaries = "bt470bg" | "bt709" | "smpte170m"

тип VideoEncoderBitrateMode = "constant" | "quantizer" | "variable"

тип VideoMatrixCoefficients = "bt470bg" | "bt709" | "rgb" | "smpte170m"

тип VideoPixelFormat = "BGRA" | "BGRX" | "I420" | "I420A" | "I422" | "I444" | "NV12" | "RGBA" | "RGBX"

тип VideoTransferCharacteristics = "bt709" | "iec61966-2-1" | "smpte170m"

тип WebGLPowerPreference = "default" | "high-performance" | "low-power"

тип WebTransportCongestionControl = "default" | "low-latency" | "throughput"

тип WebTransportErrorSource = "session" | "stream"

тип WorkerType = "classic" | "module"

тип WriteCommandType = "seek" | "truncate" | "write"

тип XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text"
