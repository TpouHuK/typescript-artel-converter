/////////////////////////////

/// Window APIs

/////////////////////////////

тип AddEventListenerOptions = интерфейс
{
  once: ДаНет

  passive: ДаНет

  signal: AbortSignal
}


тип AesCbcParams = интерфейс
{
  iv: BufferSource
}


тип AesCtrParams = интерфейс
{
  counter: BufferSource

  length: Число
}


тип AesDerivedKeyParams = интерфейс
{
  length: Число
}


тип AesGcmParams = интерфейс
{
  additionalData: BufferSource

  iv: BufferSource

  tagLength: Число
}


тип AesKeyAlgorithm = интерфейс
{
  length: Число
}


тип AesKeyGenParams = интерфейс
{
  length: Число
}


тип Algorithm = интерфейс
{
  name: Текст
}


тип AnalyserOptions = интерфейс
{
  fftSize: Число

  maxDecibels: Число

  minDecibels: Число

  smoothingTimeConstant: Число
}


тип AnimationEventInit = интерфейс
{
  animationName: Текст

  elapsedTime: Число

  pseudoElement: Текст
}


тип AnimationPlaybackEventInit = интерфейс
{
  currentTime: CSSNumberish?FUCKFUCK

  timelineTime: CSSNumberish?FUCKFUCK
}


тип AssignedNodesOptions = интерфейс
{
  flatten: ДаНет
}


тип AudioBufferOptions = интерфейс
{
  length: Число

  numberOfChannels: Число

  sampleRate: Число
}


тип AudioBufferSourceOptions = интерфейс
{
  buffer: AudioBuffer?FUCKFUCK

  detune: Число

  loop: ДаНет

  loopEnd: Число

  loopStart: Число

  playbackRate: Число
}


тип AudioConfiguration = интерфейс
{
  bitrate: Число

  channels: Текст

  contentType: Текст

  samplerate: Число

  spatialRendering: ДаНет
}


тип AudioContextOptions = интерфейс
{
  latencyHint: AudioContextLatencyCategory | Число

  sampleRate: Число
}


тип AudioNodeOptions = интерфейс
{
  channelCount: Число

  channelCountMode: ChannelCountMode

  channelInterpretation: ChannelInterpretation
}


тип AudioProcessingEventInit = интерфейс
{
  inputBuffer: AudioBuffer

  outputBuffer: AudioBuffer

  playbackTime: Число
}


тип AudioTimestamp = интерфейс
{
  contextTime: Число

  performanceTime: DOMHighResTimeStamp
}


тип AudioWorkletNodeOptions = интерфейс
{
  numberOfInputs: Число

  numberOfOutputs: Число

  outputChannelCount: Список<Число>

  parameterData: Record<Текст, Число>

  processorOptions: /*(!) any */ Объект?
}


тип AuthenticationExtensionsClientInputs = интерфейс
{
  appid: Текст

  credProps: ДаНет

  hmacCreateSecret: ДаНет
}


тип AuthenticationExtensionsClientOutputs = интерфейс
{
  appid: ДаНет

  credProps: CredentialPropertiesOutput

  hmacCreateSecret: ДаНет
}


тип AuthenticatorSelectionCriteria = интерфейс
{
  authenticatorAttachment: AuthenticatorAttachment

  requireResidentKey: ДаНет

  residentKey: ResidentKeyRequirement

  userVerification: UserVerificationRequirement
}


тип AvcEncoderConfig = интерфейс
{
  format: AvcBitstreamFormat
}


тип BiquadFilterOptions = интерфейс
{
  Q: Число

  detune: Число

  frequency: Число

  gain: Число

  type: BiquadFilterType
}


тип BlobEventInit = интерфейс
{
  data: Blob

  timecode: DOMHighResTimeStamp
}


тип BlobPropertyBag = интерфейс
{
  endings: EndingType

  type: Текст
}


тип CSSMatrixComponentOptions = интерфейс
{
  is2D: ДаНет
}


тип CSSNumericType = интерфейс
{
  angle: Число

  flex: Число

  frequency: Число

  length: Число

  percent: Число

  percentHint: CSSNumericBaseType

  resolution: Число

  time: Число
}


тип CSSStyleSheetInit = интерфейс
{
  baseURL: Текст

  disabled: ДаНет

  media: MediaList | Текст
}


тип CacheQueryOptions = интерфейс
{
  ignoreMethod: ДаНет

  ignoreSearch: ДаНет

  ignoreVary: ДаНет
}


тип CanvasRenderingContext2DSettings = интерфейс
{
  alpha: ДаНет

  colorSpace: PredefinedColorSpace

  desynchronized: ДаНет

  willReadFrequently: ДаНет
}


тип ChannelMergerOptions = интерфейс
{
  numberOfInputs: Число
}


тип ChannelSplitterOptions = интерфейс
{
  numberOfOutputs: Число
}


тип CheckVisibilityOptions = интерфейс
{
  checkOpacity: ДаНет

  checkVisibilityCSS: ДаНет
}


тип ClientQueryOptions = интерфейс
{
  includeUncontrolled: ДаНет

  type: ClientTypes
}


тип ClipboardEventInit = интерфейс
{
  clipboardData: DataTransfer?FUCKFUCK
}


тип ClipboardItemOptions = интерфейс
{
  presentationStyle: PresentationStyle
}


тип CloseEventInit = интерфейс
{
  code: Число

  reason: Текст

  wasClean: ДаНет
}


тип CompositionEventInit = интерфейс
{
  data: Текст
}


тип ComputedEffectTiming = интерфейс
{
  activeDuration: CSSNumberish

  currentIteration: Число?FUCKFUCK

  endTime: CSSNumberish

  localTime: CSSNumberish?FUCKFUCK

  progress: Число?FUCKFUCK

  startTime: CSSNumberish
}


тип ComputedKeyframe = интерфейс
{
  composite: CompositeOperationOrAuto

  computedOffset: Число

  easing: Текст

  offset: Число?FUCKFUCK

  /*(!) [property: string]: string | number | null | undefined*/
}


тип ConstantSourceOptions = интерфейс
{
  offset: Число
}


тип ConstrainBooleanParameters = интерфейс
{
  exact: ДаНет

  ideal: ДаНет
}


тип ConstrainDOMStringParameters = интерфейс
{
  exact: Текст | Список<Текст>

  ideal: Текст | Список<Текст>
}


тип ConstrainDoubleRange = интерфейс
{
  exact: Число

  ideal: Число
}


тип ConstrainULongRange = интерфейс
{
  exact: Число

  ideal: Число
}


тип ConvolverOptions = интерфейс
{
  buffer: AudioBuffer?FUCKFUCK

  disableNormalization: ДаНет
}


тип CredentialCreationOptions = интерфейс
{
  publicKey: PublicKeyCredentialCreationOptions

  signal: AbortSignal
}


тип CredentialPropertiesOutput = интерфейс
{
  rk: ДаНет
}


тип CredentialRequestOptions = интерфейс
{
  mediation: CredentialMediationRequirement

  publicKey: PublicKeyCredentialRequestOptions

  signal: AbortSignal
}


тип CryptoKeyPair = интерфейс
{
  privateKey: CryptoKey

  publicKey: CryptoKey
}


тип CustomEventInit<T> = интерфейс
{
  detail: T
}


тип DOMMatrix2DInit = интерфейс
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m21: Число

  m22: Число

  m41: Число

  m42: Число
}


тип DOMMatrixInit = интерфейс
{
  is2D: ДаНет

  m13: Число

  m14: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m43: Число

  m44: Число
}


тип DOMPointInit = интерфейс
{
  w: Число

  x: Число

  y: Число

  z: Число
}


тип DOMQuadInit = интерфейс
{
  p1: DOMPointInit

  p2: DOMPointInit

  p3: DOMPointInit

  p4: DOMPointInit
}


тип DOMRectInit = интерфейс
{
  height: Число

  width: Число

  x: Число

  y: Число
}


тип DelayOptions = интерфейс
{
  delayTime: Число

  maxDelayTime: Число
}


тип DeviceMotionEventAccelerationInit = интерфейс
{
  x: Число?FUCKFUCK

  y: Число?FUCKFUCK

  z: Число?FUCKFUCK
}


тип DeviceMotionEventInit = интерфейс
{
  acceleration: DeviceMotionEventAccelerationInit

  accelerationIncludingGravity: DeviceMotionEventAccelerationInit

  interval: Число

  rotationRate: DeviceMotionEventRotationRateInit
}


тип DeviceMotionEventRotationRateInit = интерфейс
{
  alpha: Число?FUCKFUCK

  beta: Число?FUCKFUCK

  gamma: Число?FUCKFUCK
}


тип DeviceOrientationEventInit = интерфейс
{
  absolute: ДаНет

  alpha: Число?FUCKFUCK

  beta: Число?FUCKFUCK

  gamma: Число?FUCKFUCK
}


тип DisplayMediaStreamOptions = интерфейс
{
  audio: ДаНет | MediaTrackConstraints

  video: ДаНет | MediaTrackConstraints
}


тип DocumentTimelineOptions = интерфейс
{
  originTime: DOMHighResTimeStamp
}


тип DoubleRange = интерфейс
{
  max: Число

  min: Число
}


тип DragEventInit = интерфейс
{
  dataTransfer: DataTransfer?FUCKFUCK
}


тип DynamicsCompressorOptions = интерфейс
{
  attack: Число

  knee: Число

  ratio: Число

  release: Число

  threshold: Число
}


тип EcKeyAlgorithm = интерфейс
{
  namedCurve: NamedCurve
}


тип EcKeyGenParams = интерфейс
{
  namedCurve: NamedCurve
}


тип EcKeyImportParams = интерфейс
{
  namedCurve: NamedCurve
}


тип EcdhKeyDeriveParams = интерфейс
{
  public: CryptoKey
}


тип EcdsaParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип EffectTiming = интерфейс
{
  delay: Число

  direction: PlaybackDirection

  duration: Число | CSSNumericValue | Текст

  easing: Текст

  endDelay: Число

  fill: FillMode

  iterationStart: Число

  iterations: Число

  playbackRate: Число
}


тип ElementCreationOptions = интерфейс
{
  is: Текст
}


тип ElementDefinitionOptions = интерфейс
{
  extends: Текст
}


тип EncodedVideoChunkInit = интерфейс
{
  data: BufferSource

  duration: Число

  timestamp: Число

  type: EncodedVideoChunkType
}


тип EncodedVideoChunkMetadata = интерфейс
{
  decoderConfig: VideoDecoderConfig
}


тип ErrorEventInit = интерфейс
{
  colno: Число

  error: /*(!) any */ Объект?

  filename: Текст

  lineno: Число

  message: Текст
}


тип EventInit = интерфейс
{
  bubbles: ДаНет

  cancelable: ДаНет

  composed: ДаНет
}


тип EventListenerOptions = интерфейс
{
  capture: ДаНет
}


тип EventModifierInit = интерфейс
{
  altKey: ДаНет

  ctrlKey: ДаНет

  metaKey: ДаНет

  modifierAltGraph: ДаНет

  modifierCapsLock: ДаНет

  modifierFn: ДаНет

  modifierFnLock: ДаНет

  modifierHyper: ДаНет

  modifierNumLock: ДаНет

  modifierScrollLock: ДаНет

  modifierSuper: ДаНет

  modifierSymbol: ДаНет

  modifierSymbolLock: ДаНет

  shiftKey: ДаНет
}


тип EventSourceInit = интерфейс
{
  withCredentials: ДаНет
}


тип FilePropertyBag = интерфейс
{
  lastModified: Число
}


тип FileSystemCreateWritableOptions = интерфейс
{
  keepExistingData: ДаНет
}


тип FileSystemFlags = интерфейс
{
  create: ДаНет

  exclusive: ДаНет
}


тип FileSystemGetDirectoryOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemGetFileOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemRemoveOptions = интерфейс
{
  recursive: ДаНет
}


тип FocusEventInit = интерфейс
{
  relatedTarget: EventTarget?FUCKFUCK
}


тип FocusOptions = интерфейс
{
  preventScroll: ДаНет
}


тип FontFaceDescriptors = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  featureSettings: Текст

  lineGapOverride: Текст

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant: Текст

  weight: Текст
}


тип FontFaceSetLoadEventInit = интерфейс
{
  fontfaces: Список<FontFace>
}


тип FormDataEventInit = интерфейс
{
  formData: FormData
}


тип FullscreenOptions = интерфейс
{
  navigationUI: FullscreenNavigationUI
}


тип GainOptions = интерфейс
{
  gain: Число
}


тип GamepadEffectParameters = интерфейс
{
  duration: Число

  startDelay: Число

  strongMagnitude: Число

  weakMagnitude: Число
}


тип GamepadEventInit = интерфейс
{
  gamepad: Gamepad
}


тип GetAnimationsOptions = интерфейс
{
  subtree: ДаНет
}


тип GetNotificationOptions = интерфейс
{
  tag: Текст
}


тип GetRootNodeOptions = интерфейс
{
  composed: ДаНет
}


тип HashChangeEventInit = интерфейс
{
  newURL: Текст

  oldURL: Текст
}


тип HkdfParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  info: BufferSource

  salt: BufferSource
}


тип HmacImportParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип HmacKeyAlgorithm = интерфейс
{
  hash: KeyAlgorithm

  length: Число
}


тип HmacKeyGenParams = интерфейс
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип IDBDatabaseInfo = интерфейс
{
  name: Текст

  version: Число
}


тип IDBIndexParameters = интерфейс
{
  multiEntry: ДаНет

  unique: ДаНет
}


тип IDBObjectStoreParameters = интерфейс
{
  autoIncrement: ДаНет

  keyPath: Текст | Список<Текст> | пусто
}


тип IDBTransactionOptions = интерфейс
{
  durability: IDBTransactionDurability
}


тип IDBVersionChangeEventInit = интерфейс
{
  newVersion: Число?FUCKFUCK

  oldVersion: Число
}


тип IIRFilterOptions = интерфейс
{
  feedback: Список<Число>

  feedforward: Список<Число>
}


тип IdleRequestOptions = интерфейс
{
  timeout: Число
}


тип ImageBitmapOptions = интерфейс
{
  colorSpaceConversion: ColorSpaceConversion

  imageOrientation: ImageOrientation

  premultiplyAlpha: PremultiplyAlpha

  resizeHeight: Число

  resizeQuality: ResizeQuality

  resizeWidth: Число
}


тип ImageBitmapRenderingContextSettings = интерфейс
{
  alpha: ДаНет
}


тип ImageDataSettings = интерфейс
{
  colorSpace: PredefinedColorSpace
}


тип ImageEncodeOptions = интерфейс
{
  quality: Число

  type: Текст
}


тип ImportMeta = интерфейс
{
  url: Текст
}


тип InputEventInit = интерфейс
{
  data: Текст?FUCKFUCK

  dataTransfer: DataTransfer?FUCKFUCK

  inputType: Текст

  isComposing: ДаНет

  targetRanges: Список<StaticRange>
}


тип IntersectionObserverEntryInit = интерфейс
{
  boundingClientRect: DOMRectInit

  intersectionRatio: Число

  intersectionRect: DOMRectInit

  isIntersecting: ДаНет

  rootBounds: DOMRectInit?FUCKFUCK

  target: Element

  time: DOMHighResTimeStamp
}


тип IntersectionObserverInit = интерфейс
{
  root: Element | Document | пусто

  rootMargin: Текст

  threshold: Число | Список<Число>
}


тип JsonWebKey = интерфейс
{
  alg: Текст

  crv: Текст

  d: Текст

  dp: Текст

  dq: Текст

  e: Текст

  ext: ДаНет

  k: Текст

  key_ops: Список<Текст>

  kty: Текст

  n: Текст

  oth: Список<RsaOtherPrimesInfo>

  p: Текст

  q: Текст

  qi: Текст

  use: Текст

  x: Текст

  y: Текст
}


тип KeyAlgorithm = интерфейс
{
  name: Текст
}


тип KeyboardEventInit = интерфейс
{
  charCode: Число

  code: Текст

  isComposing: ДаНет

  key: Текст

  keyCode: Число

  location: Число

  repeat: ДаНет
}


тип Keyframe = интерфейс
{
  composite: CompositeOperationOrAuto

  easing: Текст

  offset: Число?FUCKFUCK

  /*(!) [property: string]: string | number | null | undefined*/
}


тип KeyframeAnimationOptions = интерфейс
{
  id: Текст

  timeline: AnimationTimeline?FUCKFUCK
}


тип KeyframeEffectOptions = интерфейс
{
  composite: CompositeOperation

  iterationComposite: IterationCompositeOperation

  pseudoElement: Текст?FUCKFUCK
}


тип LockInfo = интерфейс
{
  clientId: Текст

  mode: LockMode

  name: Текст
}


тип LockManagerSnapshot = интерфейс
{
  held: Список<LockInfo>

  pending: Список<LockInfo>
}


тип LockOptions = интерфейс
{
  ifAvailable: ДаНет

  mode: LockMode

  signal: AbortSignal

  steal: ДаНет
}


тип MIDIConnectionEventInit = интерфейс
{
  port: MIDIPort
}


тип MIDIMessageEventInit = интерфейс
{
  data: Uint8Array
}


тип MIDIOptions = интерфейс
{
  software: ДаНет

  sysex: ДаНет
}


тип MediaCapabilitiesDecodingInfo = интерфейс
{
  configuration: MediaDecodingConfiguration
}


тип MediaCapabilitiesEncodingInfo = интерфейс
{
  configuration: MediaEncodingConfiguration
}


тип MediaCapabilitiesInfo = интерфейс
{
  powerEfficient: ДаНет

  smooth: ДаНет

  supported: ДаНет
}


тип MediaConfiguration = интерфейс
{
  audio: AudioConfiguration

  video: VideoConfiguration
}


тип MediaDecodingConfiguration = интерфейс
{
  type: MediaDecodingType
}


тип MediaElementAudioSourceOptions = интерфейс
{
  mediaElement: HTMLMediaElement
}


тип MediaEncodingConfiguration = интерфейс
{
  type: MediaEncodingType
}


тип MediaEncryptedEventInit = интерфейс
{
  initData: ArrayBuffer?FUCKFUCK

  initDataType: Текст
}


тип MediaImage = интерфейс
{
  sizes: Текст

  src: Текст

  type: Текст
}


тип MediaKeyMessageEventInit = интерфейс
{
  message: ArrayBuffer

  messageType: MediaKeyMessageType
}


тип MediaKeySystemConfiguration = интерфейс
{
  audioCapabilities: Список<MediaKeySystemMediaCapability>

  distinctiveIdentifier: MediaKeysRequirement

  initDataTypes: Список<Текст>

  label: Текст

  persistentState: MediaKeysRequirement

  sessionTypes: Список<Текст>

  videoCapabilities: Список<MediaKeySystemMediaCapability>
}


тип MediaKeySystemMediaCapability = интерфейс
{
  contentType: Текст

  encryptionScheme: Текст?FUCKFUCK

  robustness: Текст
}


тип MediaMetadataInit = интерфейс
{
  album: Текст

  artist: Текст

  artwork: Список<MediaImage>

  title: Текст
}


тип MediaPositionState = интерфейс
{
  duration: Число

  playbackRate: Число

  position: Число
}


тип MediaQueryListEventInit = интерфейс
{
  matches: ДаНет

  media: Текст
}


тип MediaRecorderOptions = интерфейс
{
  audioBitsPerSecond: Число

  bitsPerSecond: Число

  mimeType: Текст

  videoBitsPerSecond: Число
}


тип MediaSessionActionDetails = интерфейс
{
  action: MediaSessionAction

  fastSeek: ДаНет

  seekOffset: Число

  seekTime: Число
}


тип MediaStreamAudioSourceOptions = интерфейс
{
  mediaStream: MediaStream
}


тип MediaStreamConstraints = интерфейс
{
  audio: ДаНет | MediaTrackConstraints

  peerIdentity: Текст

  preferCurrentTab: ДаНет

  video: ДаНет | MediaTrackConstraints
}


тип MediaStreamTrackEventInit = интерфейс
{
  track: MediaStreamTrack
}


тип MediaTrackCapabilities = интерфейс
{
  aspectRatio: DoubleRange

  autoGainControl: Список<ДаНет>

  channelCount: ULongRange

  deviceId: Текст

  displaySurface: Текст

  echoCancellation: Список<ДаНет>

  facingMode: Список<Текст>

  frameRate: DoubleRange

  groupId: Текст

  height: ULongRange

  noiseSuppression: Список<ДаНет>

  sampleRate: ULongRange

  sampleSize: ULongRange

  width: ULongRange
}


тип MediaTrackConstraintSet = интерфейс
{
  aspectRatio: ConstrainDouble

  autoGainControl: ConstrainBoolean

  channelCount: ConstrainULong

  deviceId: ConstrainDOMString

  displaySurface: ConstrainDOMString

  echoCancellation: ConstrainBoolean

  facingMode: ConstrainDOMString

  frameRate: ConstrainDouble

  groupId: ConstrainDOMString

  height: ConstrainULong

  noiseSuppression: ConstrainBoolean

  sampleRate: ConstrainULong

  sampleSize: ConstrainULong

  width: ConstrainULong
}


тип MediaTrackConstraints = интерфейс
{
  advanced: Список<MediaTrackConstraintSet>
}


тип MediaTrackSettings = интерфейс
{
  aspectRatio: Число

  autoGainControl: ДаНет

  channelCount: Число

  deviceId: Текст

  displaySurface: Текст

  echoCancellation: ДаНет

  facingMode: Текст

  frameRate: Число

  groupId: Текст

  height: Число

  noiseSuppression: ДаНет

  sampleRate: Число

  sampleSize: Число

  width: Число
}


тип MediaTrackSupportedConstraints = интерфейс
{
  aspectRatio: ДаНет

  autoGainControl: ДаНет

  channelCount: ДаНет

  deviceId: ДаНет

  displaySurface: ДаНет

  echoCancellation: ДаНет

  facingMode: ДаНет

  frameRate: ДаНет

  groupId: ДаНет

  height: ДаНет

  noiseSuppression: ДаНет

  sampleRate: ДаНет

  sampleSize: ДаНет

  width: ДаНет
}


тип MessageEventInit<T> = интерфейс
{
  data: T

  lastEventId: Текст

  origin: Текст

  ports: Список<MessagePort>

  source: MessageEventSource?FUCKFUCK
}


тип MouseEventInit = интерфейс
{
  button: Число

  buttons: Число

  clientX: Число

  clientY: Число

  movementX: Число

  movementY: Число

  relatedTarget: EventTarget?FUCKFUCK

  screenX: Число

  screenY: Число
}


тип MultiCacheQueryOptions = интерфейс
{
  cacheName: Текст
}


тип MutationObserverInit = интерфейс
{
  attributeFilter: Список<Текст>

  attributeOldValue: ДаНет

  attributes: ДаНет

  characterData: ДаНет

  characterDataOldValue: ДаНет

  childList: ДаНет

  subtree: ДаНет
}


тип NavigationPreloadState = интерфейс
{
  enabled: ДаНет

  headerValue: Текст
}


тип NotificationAction = интерфейс
{
  action: Текст

  icon: Текст

  title: Текст
}


тип NotificationOptions = интерфейс
{
  actions: Список<NotificationAction>

  badge: Текст

  body: Текст

  data: /*(!) any */ Объект?

  dir: NotificationDirection

  icon: Текст

  image: Текст

  lang: Текст

  renotify: ДаНет

  requireInteraction: ДаНет

  silent: ДаНет?FUCKFUCK

  tag: Текст

  timestamp: EpochTimeStamp

  vibrate: VibratePattern
}


тип OfflineAudioCompletionEventInit = интерфейс
{
  renderedBuffer: AudioBuffer
}


тип OfflineAudioContextOptions = интерфейс
{
  length: Число

  numberOfChannels: Число

  sampleRate: Число
}


тип OptionalEffectTiming = интерфейс
{
  delay: Число

  direction: PlaybackDirection

  duration: Число | Текст

  easing: Текст

  endDelay: Число

  fill: FillMode

  iterationStart: Число

  iterations: Число

  playbackRate: Число
}


тип OscillatorOptions = интерфейс
{
  detune: Число

  frequency: Число

  periodicWave: PeriodicWave

  type: OscillatorType
}


тип PageTransitionEventInit = интерфейс
{
  persisted: ДаНет
}


тип PannerOptions = интерфейс
{
  coneInnerAngle: Число

  coneOuterAngle: Число

  coneOuterGain: Число

  distanceModel: DistanceModelType

  maxDistance: Число

  orientationX: Число

  orientationY: Число

  orientationZ: Число

  panningModel: PanningModelType

  positionX: Число

  positionY: Число

  positionZ: Число

  refDistance: Число

  rolloffFactor: Число
}


тип PaymentCurrencyAmount = интерфейс
{
  currency: Текст

  value: Текст
}


тип PaymentDetailsBase = интерфейс
{
  displayItems: Список<PaymentItem>

  modifiers: Список<PaymentDetailsModifier>
}


тип PaymentDetailsInit = интерфейс
{
  id: Текст

  total: PaymentItem
}


тип PaymentDetailsModifier = интерфейс
{
  additionalDisplayItems: Список<PaymentItem>

  data: /*(!) any */ Объект?

  supportedMethods: Текст

  total: PaymentItem
}


тип PaymentDetailsUpdate = интерфейс
{
  paymentMethodErrors: /*(!) any */ Объект?

  total: PaymentItem
}


тип PaymentItem = интерфейс
{
  amount: PaymentCurrencyAmount

  label: Текст

  pending: ДаНет
}


тип PaymentMethodChangeEventInit = интерфейс
{
  methodDetails: /*(!) any */ Объект?

  methodName: Текст
}


тип PaymentMethodData = интерфейс
{
  data: /*(!) any */ Объект?

  supportedMethods: Текст
}


тип PaymentRequestUpdateEventInit = интерфейс
{

}


тип PaymentValidationErrors = интерфейс
{
  error: Текст

  paymentMethod: /*(!) any */ Объект?
}


тип Pbkdf2Params = интерфейс
{
  hash: HashAlgorithmIdentifier

  iterations: Число

  salt: BufferSource
}


тип PerformanceMarkOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  startTime: DOMHighResTimeStamp
}


тип PerformanceMeasureOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  duration: DOMHighResTimeStamp

  end: Текст | DOMHighResTimeStamp

  start: Текст | DOMHighResTimeStamp
}


тип PerformanceObserverInit = интерфейс
{
  buffered: ДаНет

  entryTypes: Список<Текст>

  type: Текст
}


тип PeriodicWaveConstraints = интерфейс
{
  disableNormalization: ДаНет
}


тип PeriodicWaveOptions = интерфейс
{
  imag: Список<Число> | Float32Array

  real: Список<Число> | Float32Array
}


тип PermissionDescriptor = интерфейс
{
  name: PermissionName
}


тип PictureInPictureEventInit = интерфейс
{
  pictureInPictureWindow: PictureInPictureWindow
}


тип PlaneLayout = интерфейс
{
  offset: Число

  stride: Число
}


тип PointerEventInit = интерфейс
{
  coalescedEvents: Список<PointerEvent>

  height: Число

  isPrimary: ДаНет

  pointerId: Число

  pointerType: Текст

  predictedEvents: Список<PointerEvent>

  pressure: Число

  tangentialPressure: Число

  tiltX: Число

  tiltY: Число

  twist: Число

  width: Число
}


тип PopStateEventInit = интерфейс
{
  state: /*(!) any */ Объект?
}


тип PositionOptions = интерфейс
{
  enableHighAccuracy: ДаНет

  maximumAge: Число

  timeout: Число
}


тип ProgressEventInit = интерфейс
{
  lengthComputable: ДаНет

  loaded: Число

  total: Число
}


тип PromiseRejectionEventInit = интерфейс
{
  promise: Promise</*(!) any */ Объект?>

  reason: /*(!) any */ Объект?
}


тип PropertyDefinition = интерфейс
{
  inherits: ДаНет

  initialValue: Текст

  name: Текст

  syntax: Текст
}


тип PropertyIndexedKeyframes = интерфейс
{
  composite: CompositeOperationOrAuto | Список<CompositeOperationOrAuto>

  easing: Текст | Список<Текст>

  offset: Число | Список<Число?FUCKFUCK>

  /*(!) [property: string]: string | string[] | number | null | (number | null)[] | undefined*/
}


тип PublicKeyCredentialCreationOptions = интерфейс
{
  attestation: AttestationConveyancePreference

  authenticatorSelection: AuthenticatorSelectionCriteria

  challenge: BufferSource

  excludeCredentials: Список<PublicKeyCredentialDescriptor>

  extensions: AuthenticationExtensionsClientInputs

  pubKeyCredParams: Список<PublicKeyCredentialParameters>

  rp: PublicKeyCredentialRpEntity

  timeout: Число

  user: PublicKeyCredentialUserEntity
}


тип PublicKeyCredentialDescriptor = интерфейс
{
  id: BufferSource

  transports: Список<AuthenticatorTransport>

  type: PublicKeyCredentialType
}


тип PublicKeyCredentialEntity = интерфейс
{
  name: Текст
}


тип PublicKeyCredentialParameters = интерфейс
{
  alg: COSEAlgorithmIdentifier

  type: PublicKeyCredentialType
}


тип PublicKeyCredentialRequestOptions = интерфейс
{
  allowCredentials: Список<PublicKeyCredentialDescriptor>

  challenge: BufferSource

  extensions: AuthenticationExtensionsClientInputs

  rpId: Текст

  timeout: Число

  userVerification: UserVerificationRequirement
}


тип PublicKeyCredentialRpEntity = интерфейс
{
  id: Текст
}


тип PublicKeyCredentialUserEntity = интерфейс
{
  displayName: Текст

  id: BufferSource
}


тип PushSubscriptionJSON = интерфейс
{
  endpoint: Текст

  expirationTime: EpochTimeStamp?FUCKFUCK

  keys: Record<Текст, Текст>
}


тип PushSubscriptionOptionsInit = интерфейс
{
  applicationServerKey: BufferSource | Текст | пусто

  userVisibleOnly: ДаНет
}


тип QueuingStrategy<T> = интерфейс
{
  highWaterMark: Число

  size: QueuingStrategySize<T>
}


тип QueuingStrategyInit = интерфейс
{
  highWaterMark: Число
}


тип RTCAnswerOptions = интерфейс
{

}


тип RTCCertificateExpiration = интерфейс
{
  expires: Число
}


тип RTCConfiguration = интерфейс
{
  bundlePolicy: RTCBundlePolicy

  certificates: Список<RTCCertificate>

  iceCandidatePoolSize: Число

  iceServers: Список<RTCIceServer>

  iceTransportPolicy: RTCIceTransportPolicy

  rtcpMuxPolicy: RTCRtcpMuxPolicy
}


тип RTCDTMFToneChangeEventInit = интерфейс
{
  tone: Текст
}


тип RTCDataChannelEventInit = интерфейс
{
  channel: RTCDataChannel
}


тип RTCDataChannelInit = интерфейс
{
  id: Число

  maxPacketLifeTime: Число

  maxRetransmits: Число

  negotiated: ДаНет

  ordered: ДаНет

  protocol: Текст
}


тип RTCDtlsFingerprint = интерфейс
{
  algorithm: Текст

  value: Текст
}


тип RTCEncodedAudioFrameMetadata = интерфейс
{
  contributingSources: Список<Число>

  synchronizationSource: Число
}


тип RTCEncodedVideoFrameMetadata = интерфейс
{
  dependencies: Список<Число>

  frameId: Число

  height: Число

  spatialIndex: Число

  synchronizationSource: Число

  temporalIndex: Число

  width: Число
}


тип RTCErrorEventInit = интерфейс
{
  error: RTCError
}


тип RTCErrorInit = интерфейс
{
  errorDetail: RTCErrorDetailType

  httpRequestStatusCode: Число

  receivedAlert: Число

  sctpCauseCode: Число

  sdpLineNumber: Число

  sentAlert: Число
}


тип RTCIceCandidateInit = интерфейс
{
  candidate: Текст

  sdpMLineIndex: Число?FUCKFUCK

  sdpMid: Текст?FUCKFUCK

  usernameFragment: Текст?FUCKFUCK
}


тип RTCIceCandidatePair = интерфейс
{
  local: RTCIceCandidate

  remote: RTCIceCandidate
}


тип RTCIceCandidatePairStats = интерфейс
{
  availableIncomingBitrate: Число

  availableOutgoingBitrate: Число

  bytesReceived: Число

  bytesSent: Число

  currentRoundTripTime: Число

  lastPacketReceivedTimestamp: DOMHighResTimeStamp

  lastPacketSentTimestamp: DOMHighResTimeStamp

  localCandidateId: Текст

  nominated: ДаНет

  remoteCandidateId: Текст

  requestsReceived: Число

  requestsSent: Число

  responsesReceived: Число

  responsesSent: Число

  state: RTCStatsIceCandidatePairState

  totalRoundTripTime: Число

  transportId: Текст
}


тип RTCIceServer = интерфейс
{
  credential: Текст

  urls: Текст | Список<Текст>

  username: Текст
}


тип RTCInboundRtpStreamStats = интерфейс
{
  audioLevel: Число

  bytesReceived: Число

  concealedSamples: Число

  concealmentEvents: Число

  decoderImplementation: Текст

  estimatedPlayoutTimestamp: DOMHighResTimeStamp

  fecPacketsDiscarded: Число

  fecPacketsReceived: Число

  firCount: Число

  frameHeight: Число

  frameWidth: Число

  framesDecoded: Число

  framesDropped: Число

  framesPerSecond: Число

  framesReceived: Число

  headerBytesReceived: Число

  insertedSamplesForDeceleration: Число

  jitterBufferDelay: Число

  jitterBufferEmittedCount: Число

  keyFramesDecoded: Число

  kind: Текст

  lastPacketReceivedTimestamp: DOMHighResTimeStamp

  mid: Текст

  nackCount: Число

  packetsDiscarded: Число

  pliCount: Число

  qpSum: Число

  remoteId: Текст

  removedSamplesForAcceleration: Число

  silentConcealedSamples: Число

  totalAudioEnergy: Число

  totalDecodeTime: Число

  totalInterFrameDelay: Число

  totalProcessingDelay: Число

  totalSamplesDuration: Число

  totalSamplesReceived: Число

  totalSquaredInterFrameDelay: Число

  trackIdentifier: Текст
}


тип RTCLocalSessionDescriptionInit = интерфейс
{
  sdp: Текст

  type: RTCSdpType
}


тип RTCOfferAnswerOptions = интерфейс
{

}


тип RTCOfferOptions = интерфейс
{
  iceRestart: ДаНет

  offerToReceiveAudio: ДаНет

  offerToReceiveVideo: ДаНет
}


тип RTCOutboundRtpStreamStats = интерфейс
{
  firCount: Число

  frameHeight: Число

  frameWidth: Число

  framesEncoded: Число

  framesPerSecond: Число

  framesSent: Число

  headerBytesSent: Число

  hugeFramesSent: Число

  keyFramesEncoded: Число

  mediaSourceId: Текст

  nackCount: Число

  pliCount: Число

  qpSum: Число

  qualityLimitationResolutionChanges: Число

  remoteId: Текст

  retransmittedBytesSent: Число

  retransmittedPacketsSent: Число

  rid: Текст

  targetBitrate: Число

  totalEncodeTime: Число

  totalEncodedBytesTarget: Число

  totalPacketSendDelay: Число
}


тип RTCPeerConnectionIceErrorEventInit = интерфейс
{
  address: Текст?FUCKFUCK

  errorCode: Число

  errorText: Текст

  port: Число?FUCKFUCK

  url: Текст
}


тип RTCPeerConnectionIceEventInit = интерфейс
{
  candidate: RTCIceCandidate?FUCKFUCK

  url: Текст?FUCKFUCK
}


тип RTCReceivedRtpStreamStats = интерфейс
{
  jitter: Число

  packetsLost: Число

  packetsReceived: Число
}


тип RTCRtcpParameters = интерфейс
{
  cname: Текст

  reducedSize: ДаНет
}


тип RTCRtpCapabilities = интерфейс
{
  codecs: Список<RTCRtpCodecCapability>

  headerExtensions: Список<RTCRtpHeaderExtensionCapability>
}


тип RTCRtpCodec = интерфейс
{
  channels: Число

  clockRate: Число

  mimeType: Текст

  sdpFmtpLine: Текст
}


тип RTCRtpCodecCapability = интерфейс
{

}


тип RTCRtpCodecParameters = интерфейс
{
  payloadType: Число
}


тип RTCRtpCodingParameters = интерфейс
{
  rid: Текст
}


тип RTCRtpContributingSource = интерфейс
{
  audioLevel: Число

  rtpTimestamp: Число

  source: Число

  timestamp: DOMHighResTimeStamp
}


тип RTCRtpEncodingParameters = интерфейс
{
  active: ДаНет

  maxBitrate: Число

  maxFramerate: Число

  networkPriority: RTCPriorityType

  priority: RTCPriorityType

  scaleResolutionDownBy: Число
}


тип RTCRtpHeaderExtensionCapability = интерфейс
{
  uri: Текст
}


тип RTCRtpHeaderExtensionParameters = интерфейс
{
  encrypted: ДаНет

  id: Число

  uri: Текст
}


тип RTCRtpParameters = интерфейс
{
  codecs: Список<RTCRtpCodecParameters>

  headerExtensions: Список<RTCRtpHeaderExtensionParameters>

  rtcp: RTCRtcpParameters
}


тип RTCRtpReceiveParameters = интерфейс
{

}


тип RTCRtpSendParameters = интерфейс
{
  degradationPreference: RTCDegradationPreference

  encodings: Список<RTCRtpEncodingParameters>

  transactionId: Текст
}


тип RTCRtpStreamStats = интерфейс
{
  codecId: Текст

  kind: Текст

  ssrc: Число

  transportId: Текст
}


тип RTCRtpSynchronizationSource = интерфейс
{

}


тип RTCRtpTransceiverInit = интерфейс
{
  direction: RTCRtpTransceiverDirection

  sendEncodings: Список<RTCRtpEncodingParameters>

  streams: Список<MediaStream>
}


тип RTCSentRtpStreamStats = интерфейс
{
  bytesSent: Число

  packetsSent: Число
}


тип RTCSessionDescriptionInit = интерфейс
{
  sdp: Текст

  type: RTCSdpType
}


тип RTCStats = интерфейс
{
  id: Текст

  timestamp: DOMHighResTimeStamp

  type: RTCStatsType
}


тип RTCTrackEventInit = интерфейс
{
  receiver: RTCRtpReceiver

  streams: Список<MediaStream>

  track: MediaStreamTrack

  transceiver: RTCRtpTransceiver
}


тип RTCTransportStats = интерфейс
{
  bytesReceived: Число

  bytesSent: Число

  dtlsCipher: Текст

  dtlsState: RTCDtlsTransportState

  localCertificateId: Текст

  remoteCertificateId: Текст

  selectedCandidatePairId: Текст

  srtpCipher: Текст

  tlsVersion: Текст
}


тип ReadableStreamGetReaderOptions = интерфейс
{
  mode: ReadableStreamReaderMode
}


тип ReadableStreamReadDoneResult<T> = интерфейс
{
  done: да

  value: T
}


тип ReadableStreamReadValueResult<T> = интерфейс
{
  done: нет

  value: T
}


тип ReadableWritablePair<R, W> = интерфейс
{
  readable: ReadableStream<R>

  writable: WritableStream<W>
}


тип RegistrationOptions = интерфейс
{
  scope: Текст

  type: WorkerType

  updateViaCache: ServiceWorkerUpdateViaCache
}


тип ReportingObserverOptions = интерфейс
{
  buffered: ДаНет

  types: Список<Текст>
}


тип RequestInit = интерфейс
{
  body: BodyInit?FUCKFUCK

  cache: RequestCache

  credentials: RequestCredentials

  headers: HeadersInit

  integrity: Текст

  keepalive: ДаНет

  method: Текст

  mode: RequestMode

  redirect: RequestRedirect

  referrer: Текст

  referrerPolicy: ReferrerPolicy

  signal: AbortSignal?FUCKFUCK

  window: пусто
}


тип ResizeObserverOptions = интерфейс
{
  box: ResizeObserverBoxOptions
}


тип ResponseInit = интерфейс
{
  headers: HeadersInit

  status: Число

  statusText: Текст
}


тип RsaHashedImportParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип RsaHashedKeyAlgorithm = интерфейс
{
  hash: KeyAlgorithm
}


тип RsaHashedKeyGenParams = интерфейс
{
  hash: HashAlgorithmIdentifier
}


тип RsaKeyAlgorithm = интерфейс
{
  modulusLength: Число

  publicExponent: BigInteger
}


тип RsaKeyGenParams = интерфейс
{
  modulusLength: Число

  publicExponent: BigInteger
}


тип RsaOaepParams = интерфейс
{
  label: BufferSource
}


тип RsaOtherPrimesInfo = интерфейс
{
  d: Текст

  r: Текст

  t: Текст
}


тип RsaPssParams = интерфейс
{
  saltLength: Число
}


тип SVGBoundingBoxOptions = интерфейс
{
  clipped: ДаНет

  fill: ДаНет

  markers: ДаНет

  stroke: ДаНет
}


тип ScrollIntoViewOptions = интерфейс
{
  block: ScrollLogicalPosition

  inline: ScrollLogicalPosition
}


тип ScrollOptions = интерфейс
{
  behavior: ScrollBehavior
}


тип ScrollToOptions = интерфейс
{
  left: Число

  top: Число
}


тип SecurityPolicyViolationEventInit = интерфейс
{
  blockedURI: Текст

  columnNumber: Число

  disposition: SecurityPolicyViolationEventDisposition

  documentURI: Текст

  effectiveDirective: Текст

  lineNumber: Число

  originalPolicy: Текст

  referrer: Текст

  sample: Текст

  sourceFile: Текст

  statusCode: Число

  violatedDirective: Текст
}


тип ShadowRootInit = интерфейс
{
  delegatesFocus: ДаНет

  mode: ShadowRootMode

  slotAssignment: SlotAssignmentMode
}


тип ShareData = интерфейс
{
  files: Список<File>

  text: Текст

  title: Текст

  url: Текст
}


тип SpeechSynthesisErrorEventInit = интерфейс
{
  error: SpeechSynthesisErrorCode
}


тип SpeechSynthesisEventInit = интерфейс
{
  charIndex: Число

  charLength: Число

  elapsedTime: Число

  name: Текст

  utterance: SpeechSynthesisUtterance
}


тип StaticRangeInit = интерфейс
{
  endContainer: Node

  endOffset: Число

  startContainer: Node

  startOffset: Число
}


тип StereoPannerOptions = интерфейс
{
  pan: Число
}


тип StorageEstimate = интерфейс
{
  quota: Число

  usage: Число
}


тип StorageEventInit = интерфейс
{
  key: Текст?FUCKFUCK

  newValue: Текст?FUCKFUCK

  oldValue: Текст?FUCKFUCK

  storageArea: Storage?FUCKFUCK

  url: Текст
}


тип StreamPipeOptions = интерфейс
{
  preventAbort: ДаНет

  preventCancel: ДаНет

  preventClose: ДаНет

  signal: AbortSignal
}


тип StructuredSerializeOptions = интерфейс
{
  transfer: Список<Transferable>
}


тип SubmitEventInit = интерфейс
{
  submitter: HTMLElement?FUCKFUCK
}


тип TextDecodeOptions = интерфейс
{
  stream: ДаНет
}


тип TextDecoderOptions = интерфейс
{
  fatal: ДаНет

  ignoreBOM: ДаНет
}


тип TextEncoderEncodeIntoResult = интерфейс
{
  read: Число

  written: Число
}


тип ToggleEventInit = интерфейс
{
  newState: Текст

  oldState: Текст
}


тип TouchEventInit = интерфейс
{
  changedTouches: Список<Touch>

  targetTouches: Список<Touch>

  touches: Список<Touch>
}


тип TouchInit = интерфейс
{
  altitudeAngle: Число

  azimuthAngle: Число

  clientX: Число

  clientY: Число

  force: Число

  identifier: Число

  pageX: Число

  pageY: Число

  radiusX: Число

  radiusY: Число

  rotationAngle: Число

  screenX: Число

  screenY: Число

  target: EventTarget

  touchType: TouchType
}


тип TrackEventInit = интерфейс
{
  track: TextTrack?FUCKFUCK
}


тип Transformer<I, O> = интерфейс
{
  flush: TransformerFlushCallback<O>

  readableType: пусто

  start: TransformerStartCallback<O>

  transform: TransformerTransformCallback<I, O>

  writableType: пусто
}


тип TransitionEventInit = интерфейс
{
  elapsedTime: Число

  propertyName: Текст

  pseudoElement: Текст
}


тип UIEventInit = интерфейс
{
  detail: Число

  view: Window?FUCKFUCK

  which: Число
}


тип ULongRange = интерфейс
{
  max: Число

  min: Число
}


тип UnderlyingByteSource = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableByteStreamController): Ничего | PromiseLike<Ничего>

  start: операция(controller: ReadableByteStreamController): /*(!) any */ Объект?

  type: "bytes"
}


тип UnderlyingDefaultSource<R> = интерфейс
{
  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableStreamDefaultController<R>): Ничего | PromiseLike<Ничего>

  start: операция(controller: ReadableStreamDefaultController<R>): /*(!) any */ Объект?

  type: пусто
}


тип UnderlyingSink<W> = интерфейс
{
  abort: UnderlyingSinkAbortCallback

  close: UnderlyingSinkCloseCallback

  start: UnderlyingSinkStartCallback

  type: пусто

  write: UnderlyingSinkWriteCallback<W>
}


тип UnderlyingSource<R> = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: UnderlyingSourcePullCallback<R>

  start: UnderlyingSourceStartCallback<R>

  type: ReadableStreamType
}


тип ValidityStateFlags = интерфейс
{
  badInput: ДаНет

  customError: ДаНет

  patternMismatch: ДаНет

  rangeOverflow: ДаНет

  rangeUnderflow: ДаНет

  stepMismatch: ДаНет

  tooLong: ДаНет

  tooShort: ДаНет

  typeMismatch: ДаНет

  valueMissing: ДаНет
}


тип VideoColorSpaceInit = интерфейс
{
  fullRange: ДаНет?FUCKFUCK

  matrix: VideoMatrixCoefficients?FUCKFUCK

  primaries: VideoColorPrimaries?FUCKFUCK

  transfer: VideoTransferCharacteristics?FUCKFUCK
}


тип VideoConfiguration = интерфейс
{
  bitrate: Число

  colorGamut: ColorGamut

  contentType: Текст

  framerate: Число

  hdrMetadataType: HdrMetadataType

  height: Число

  scalabilityMode: Текст

  transferFunction: TransferFunction

  width: Число
}


тип VideoDecoderConfig = интерфейс
{
  codec: Текст

  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  description: BufferSource

  displayAspectHeight: Число

  displayAspectWidth: Число

  hardwareAcceleration: HardwareAcceleration

  optimizeForLatency: ДаНет
}


тип VideoDecoderInit = интерфейс
{
  error: WebCodecsErrorCallback

  output: VideoFrameOutputCallback
}


тип VideoDecoderSupport = интерфейс
{
  config: VideoDecoderConfig

  supported: ДаНет
}


тип VideoEncoderConfig = интерфейс
{
  alpha: AlphaOption

  avc: AvcEncoderConfig

  bitrate: Число

  bitrateMode: VideoEncoderBitrateMode

  codec: Текст

  displayHeight: Число

  displayWidth: Число

  framerate: Число

  hardwareAcceleration: HardwareAcceleration

  height: Число

  latencyMode: LatencyMode

  scalabilityMode: Текст

  width: Число
}


тип VideoEncoderEncodeOptions = интерфейс
{
  keyFrame: ДаНет
}


тип VideoEncoderInit = интерфейс
{
  error: WebCodecsErrorCallback

  output: EncodedVideoChunkOutputCallback
}


тип VideoEncoderSupport = интерфейс
{
  config: VideoEncoderConfig

  supported: ДаНет
}


тип VideoFrameBufferInit = интерфейс
{
  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  displayHeight: Число

  displayWidth: Число

  duration: Число

  format: VideoPixelFormat

  layout: Список<PlaneLayout>

  timestamp: Число

  visibleRect: DOMRectInit
}


тип VideoFrameCallbackMetadata = интерфейс
{
  captureTime: DOMHighResTimeStamp

  expectedDisplayTime: DOMHighResTimeStamp

  height: Число

  mediaTime: Число

  presentationTime: DOMHighResTimeStamp

  presentedFrames: Число

  processingDuration: Число

  receiveTime: DOMHighResTimeStamp

  rtpTimestamp: Число

  width: Число
}


тип VideoFrameCopyToOptions = интерфейс
{
  layout: Список<PlaneLayout>

  rect: DOMRectInit
}


тип VideoFrameInit = интерфейс
{
  alpha: AlphaOption

  displayHeight: Число

  displayWidth: Число

  duration: Число

  timestamp: Число

  visibleRect: DOMRectInit
}


тип WaveShaperOptions = интерфейс
{
  curve: Список<Число> | Float32Array

  oversample: OverSampleType
}


тип WebGLContextAttributes = интерфейс
{
  alpha: ДаНет

  antialias: ДаНет

  depth: ДаНет

  desynchronized: ДаНет

  failIfMajorPerformanceCaveat: ДаНет

  powerPreference: WebGLPowerPreference

  premultipliedAlpha: ДаНет

  preserveDrawingBuffer: ДаНет

  stencil: ДаНет
}


тип WebGLContextEventInit = интерфейс
{
  statusMessage: Текст
}


тип WebTransportCloseInfo = интерфейс
{
  closeCode: Число

  reason: Текст
}


тип WebTransportErrorOptions = интерфейс
{
  source: WebTransportErrorSource

  streamErrorCode: Число?FUCKFUCK
}


тип WebTransportHash = интерфейс
{
  algorithm: Текст

  value: BufferSource
}


тип WebTransportOptions = интерфейс
{
  allowPooling: ДаНет

  congestionControl: WebTransportCongestionControl

  requireUnreliable: ДаНет

  serverCertificateHashes: Список<WebTransportHash>
}


тип WebTransportSendStreamOptions = интерфейс
{
  sendOrder: Число?FUCKFUCK
}


тип WheelEventInit = интерфейс
{
  deltaMode: Число

  deltaX: Число

  deltaY: Число

  deltaZ: Число
}


тип WindowPostMessageOptions = интерфейс
{
  targetOrigin: Текст
}


тип WorkerOptions = интерфейс
{
  credentials: RequestCredentials

  name: Текст

  type: WorkerType
}


тип WorkletOptions = интерфейс
{
  credentials: RequestCredentials
}


тип WriteParams = интерфейс
{
  data: BufferSource | Blob | Текст | пусто

  position: Число?FUCKFUCK

  size: Число?FUCKFUCK

  type: WriteCommandType
}


тип NodeFilter = операция(node: Node): Число | объект { операция acceptNode(node: Node): Число }

внешнее
/*(!) var */ NodeFilter: объект { защищено  FILTER_ACCEPT: 1; защищено  FILTER_REJECT: 2; защищено  FILTER_SKIP: 3; защищено  SHOW_ALL: 0xFFFFFFFF; защищено  SHOW_ELEMENT: 0x1; защищено  SHOW_ATTRIBUTE: 0x2; защищено  SHOW_TEXT: 0x4; защищено  SHOW_CDATA_SECTION: 0x8; защищено  SHOW_ENTITY_REFERENCE: 0x10; защищено  SHOW_ENTITY: 0x20; защищено  SHOW_PROCESSING_INSTRUCTION: 0x40; защищено  SHOW_COMMENT: 0x80; защищено  SHOW_DOCUMENT: 0x100; защищено  SHOW_DOCUMENT_TYPE: 0x200; защищено  SHOW_DOCUMENT_FRAGMENT: 0x400; защищено  SHOW_NOTATION: 0x800 }


тип XPathNSResolver = операция(prefix: Текст?FUCKFUCK): Текст?FUCKFUCK | объект { операция lookupNamespaceURI(prefix: Текст?FUCKFUCK): Текст?FUCKFUCK }

/**
* The ANGLE_instanced_arrays extension is part of the WebGL API and allows to draw the same object, or groups of similar objects multiple times, if they share the same vertex data, primitive count and type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ANGLE_instanced_arrays)
*/

тип ANGLE_instanced_arrays = интерфейс
{
  операция drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei)

  операция drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, primcount: GLsizei)

  операция vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint)

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE
}


тип ARIAMixin = интерфейс
{
  ariaAtomic: Текст?FUCKFUCK

  ariaAutoComplete: Текст?FUCKFUCK

  ariaBusy: Текст?FUCKFUCK

  ariaChecked: Текст?FUCKFUCK

  ariaColCount: Текст?FUCKFUCK

  ariaColIndex: Текст?FUCKFUCK

  ariaColSpan: Текст?FUCKFUCK

  ariaCurrent: Текст?FUCKFUCK

  ariaDisabled: Текст?FUCKFUCK

  ariaExpanded: Текст?FUCKFUCK

  ariaHasPopup: Текст?FUCKFUCK

  ariaHidden: Текст?FUCKFUCK

  ariaInvalid: Текст?FUCKFUCK

  ariaKeyShortcuts: Текст?FUCKFUCK

  ariaLabel: Текст?FUCKFUCK

  ariaLevel: Текст?FUCKFUCK

  ariaLive: Текст?FUCKFUCK

  ariaModal: Текст?FUCKFUCK

  ariaMultiLine: Текст?FUCKFUCK

  ariaMultiSelectable: Текст?FUCKFUCK

  ariaOrientation: Текст?FUCKFUCK

  ariaPlaceholder: Текст?FUCKFUCK

  ariaPosInSet: Текст?FUCKFUCK

  ariaPressed: Текст?FUCKFUCK

  ariaReadOnly: Текст?FUCKFUCK

  ariaRequired: Текст?FUCKFUCK

  ariaRoleDescription: Текст?FUCKFUCK

  ariaRowCount: Текст?FUCKFUCK

  ariaRowIndex: Текст?FUCKFUCK

  ariaRowSpan: Текст?FUCKFUCK

  ariaSelected: Текст?FUCKFUCK

  ariaSetSize: Текст?FUCKFUCK

  ariaSort: Текст?FUCKFUCK

  ariaValueMax: Текст?FUCKFUCK

  ariaValueMin: Текст?FUCKFUCK

  ariaValueNow: Текст?FUCKFUCK

  ariaValueText: Текст?FUCKFUCK

  role: Текст?FUCKFUCK
}


/**
* A controller object that allows you to abort one or more DOM requests as and when desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)
*/

тип AbortController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ AbortController: объект { prototype: AbortController; при создании()/*(!) no_type */ Объект? }


тип AbortSignalEventMap = интерфейс
{
  "abort": Event
}


/**
* A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)
*/

тип AbortSignal = интерфейс
{
  защищено 
  aborted: ДаНет

  onabort: операция(this: AbortSignal, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  reason: /*(!) any */ Объект?

  операция throwIfAborted()

  операция addEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AbortSignal: объект { prototype: AbortSignal; при создании()/*(!) no_type */ Объект?; операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): AbortSignal; операция timeout(milliseconds: Число): AbortSignal }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbstractRange) */

тип AbstractRange = интерфейс
{
  защищено 
  collapsed: ДаНет

  защищено 
  endContainer: Node

  защищено 
  endOffset: Число

  защищено 
  startContainer: Node

  защищено 
  startOffset: Число
}


внешнее
/*(!) var */ AbstractRange: объект { prototype: AbstractRange; при создании()/*(!) no_type */ Объект? }


тип AbstractWorkerEventMap = интерфейс
{
  "error": ErrorEvent
}


тип AbstractWorker = интерфейс
{
  onerror: операция(this: AbstractWorker, ev: ErrorEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/**
* A node able to provide real-time frequency and time-domain analysis information. It is an AudioNode that passes the audio stream unchanged from the input to the output, but allows you to take the generated data, process it, and create audio visualizations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnalyserNode)
*/

тип AnalyserNode = интерфейс
{
  fftSize: Число

  защищено 
  frequencyBinCount: Число

  maxDecibels: Число

  minDecibels: Число

  smoothingTimeConstant: Число

  операция getByteFrequencyData(array: Uint8Array)

  операция getByteTimeDomainData(array: Uint8Array)

  операция getFloatFrequencyData(array: Float32Array)

  операция getFloatTimeDomainData(array: Float32Array)
}


внешнее
/*(!) var */ AnalyserNode: объект { prototype: AnalyserNode; при создании(context: BaseAudioContext, options: AnalyserOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип Animatable = интерфейс
{
  операция animate(keyframes: Список<Keyframe> | PropertyIndexedKeyframes | пусто, options: Число | KeyframeAnimationOptions | пусто = пусто): Animation

  операция getAnimations(options: GetAnimationsOptions?FUCKFUCK = пусто): Список<Animation>
}


тип AnimationEventMap = интерфейс
{
  "cancel": AnimationPlaybackEvent

  "finish": AnimationPlaybackEvent

  "remove": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Animation) */

тип Animation = интерфейс
{
  currentTime: CSSNumberish?FUCKFUCK

  effect: AnimationEffect?FUCKFUCK

  защищено 
  finished: Promise<Animation>

  id: Текст

  oncancel: операция(this: Animation, ev: AnimationPlaybackEvent): /*(!) any */ Объект??FUCKFUCK

  onfinish: операция(this: Animation, ev: AnimationPlaybackEvent): /*(!) any */ Объект??FUCKFUCK

  onremove: операция(this: Animation, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  pending: ДаНет

  защищено 
  playState: AnimationPlayState

  playbackRate: Число

  защищено 
  ready: Promise<Animation>

  защищено 
  replaceState: AnimationReplaceState

  startTime: CSSNumberish?FUCKFUCK

  timeline: AnimationTimeline?FUCKFUCK

  операция cancel()

  операция commitStyles()

  операция finish()

  операция pause()

  операция persist()

  операция play()

  операция reverse()

  операция updatePlaybackRate(playbackRate: Число)

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: Animation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: Animation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Animation: объект { prototype: Animation; при создании(effect: AnimationEffect?FUCKFUCK = пусто, timeline: AnimationTimeline?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationEffect) */

тип AnimationEffect = интерфейс
{
  операция getComputedTiming(): ComputedEffectTiming

  операция getTiming(): EffectTiming

  операция updateTiming(timing: OptionalEffectTiming?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ AnimationEffect: объект { prototype: AnimationEffect; при создании()/*(!) no_type */ Объект? }


/**
* Events providing information related to animations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationEvent)
*/

тип AnimationEvent = интерфейс
{
  защищено 
  animationName: Текст

  защищено 
  elapsedTime: Число

  защищено 
  pseudoElement: Текст
}


внешнее
/*(!) var */ AnimationEvent: объект { prototype: AnimationEvent; при создании(type: Текст, animationEventInitDict: AnimationEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип AnimationFrameProvider = интерфейс
{
  операция cancelAnimationFrame(handle: Число)

  операция requestAnimationFrame(callback: FrameRequestCallback): Число
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationPlaybackEvent) */

тип AnimationPlaybackEvent = интерфейс
{
  защищено 
  currentTime: CSSNumberish?FUCKFUCK

  защищено 
  timelineTime: CSSNumberish?FUCKFUCK
}


внешнее
/*(!) var */ AnimationPlaybackEvent: объект { prototype: AnimationPlaybackEvent; при создании(type: Текст, eventInitDict: AnimationPlaybackEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationTimeline) */

тип AnimationTimeline = интерфейс
{
  защищено 
  currentTime: CSSNumberish?FUCKFUCK
}


внешнее
/*(!) var */ AnimationTimeline: объект { prototype: AnimationTimeline; при создании()/*(!) no_type */ Объект? }


/**
* A DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Attr)
*/

тип Attr = интерфейс
{
  защищено 
  localName: Текст

  защищено 
  name: Текст

  защищено 
  namespaceURI: Текст?FUCKFUCK

  защищено 
  ownerDocument: Document

  защищено 
  ownerElement: Element?FUCKFUCK

  защищено 
  prefix: Текст?FUCKFUCK

  защищено 
  specified: ДаНет

  value: Текст
}


внешнее
/*(!) var */ Attr: объект { prototype: Attr; при создании()/*(!) no_type */ Объект? }


/**
* A short audio asset residing in memory, created from an audio file using the AudioContext.decodeAudioData() method, or from raw data using AudioContext.createBuffer(). Once put into an AudioBuffer, the audio can then be played by being passed into an AudioBufferSourceNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioBuffer)
*/

тип AudioBuffer = интерфейс
{
  защищено 
  duration: Число

  защищено 
  length: Число

  защищено 
  numberOfChannels: Число

  защищено 
  sampleRate: Число

  операция copyFromChannel(destination: Float32Array, channelNumber: Число, bufferOffset: Число?FUCKFUCK = пусто)

  операция copyToChannel(source: Float32Array, channelNumber: Число, bufferOffset: Число?FUCKFUCK = пусто)

  операция getChannelData(channel: Число): Float32Array
}


внешнее
/*(!) var */ AudioBuffer: объект { prototype: AudioBuffer; при создании(options: AudioBufferOptions)/*(!) no_type */ Объект? }


/**
* An AudioScheduledSourceNode which represents an audio source consisting of in-memory audio data, stored in an AudioBuffer. It's especially useful for playing back audio which has particularly stringent timing accuracy requirements, such as for sounds that must match a specific rhythm and can be kept in memory rather than being played from disk or the network.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioBufferSourceNode)
*/

тип AudioBufferSourceNode = интерфейс
{
  buffer: AudioBuffer?FUCKFUCK

  защищено 
  detune: AudioParam

  loop: ДаНет

  loopEnd: Число

  loopStart: Число

  защищено 
  playbackRate: AudioParam

  операция start(when: Число?FUCKFUCK = пусто, offset: Число?FUCKFUCK = пусто, duration: Число?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioBufferSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioBufferSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AudioBufferSourceNode: объект { prototype: AudioBufferSourceNode; при создании(context: BaseAudioContext, options: AudioBufferSourceOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An audio-processing graph built from audio modules linked together, each represented by an AudioNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioContext)
*/

тип AudioContext = интерфейс
{
  защищено 
  baseLatency: Число

  защищено 
  outputLatency: Число

  операция close(): Promise<Ничего>

  операция createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode

  операция createMediaStreamDestination(): MediaStreamAudioDestinationNode

  операция createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode

  операция getOutputTimestamp(): AudioTimestamp

  операция resume(): Promise<Ничего>

  операция suspend(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type: K, listener: операция(this: AudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type: K, listener: операция(this: AudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AudioContext: объект { prototype: AudioContext; при создании(contextOptions: AudioContextOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* AudioDestinationNode has no output (as it is the output, no more AudioNode can be linked after it in the audio graph) and one input. The number of channels in the input must be between 0 and the maxChannelCount value or an exception is raised.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioDestinationNode)
*/

тип AudioDestinationNode = интерфейс
{
  защищено 
  maxChannelCount: Число
}


внешнее
/*(!) var */ AudioDestinationNode: объект { prototype: AudioDestinationNode; при создании()/*(!) no_type */ Объект? }


/**
* The position and orientation of the unique person listening to the audio scene, and is used in audio spatialization. All PannerNodes spatialize in relation to the AudioListener stored in the BaseAudioContext.listener attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioListener)
*/

тип AudioListener = интерфейс
{
  защищено 
  forwardX: AudioParam

  защищено 
  forwardY: AudioParam

  защищено 
  forwardZ: AudioParam

  защищено 
  positionX: AudioParam

  защищено 
  positionY: AudioParam

  защищено 
  positionZ: AudioParam

  защищено 
  upX: AudioParam

  защищено 
  upY: AudioParam

  защищено 
  upZ: AudioParam

  операция setOrientation(x: Число, y: Число, z: Число, xUp: Число, yUp: Число, zUp: Число)

  операция setPosition(x: Число, y: Число, z: Число)
}


внешнее
/*(!) var */ AudioListener: объект { prototype: AudioListener; при создании()/*(!) no_type */ Объект? }


/**
* A generic interface for representing an audio processing module. Examples include:
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioNode)
*/

тип AudioNode = интерфейс
{
  channelCount: Число

  channelCountMode: ChannelCountMode

  channelInterpretation: ChannelInterpretation

  защищено 
  context: BaseAudioContext

  защищено 
  numberOfInputs: Число

  защищено 
  numberOfOutputs: Число

  операция connect(destinationNode: AudioNode, output: Число?FUCKFUCK = пусто, input: Число?FUCKFUCK = пусто): AudioNode

  операция connect(destinationParam: AudioParam, output: Число?FUCKFUCK = пусто)

  операция disconnect()

  операция disconnect(output: Число)

  операция disconnect(destinationNode: AudioNode)

  операция disconnect(destinationNode: AudioNode, output: Число)

  операция disconnect(destinationNode: AudioNode, output: Число, input: Число)

  операция disconnect(destinationParam: AudioParam)

  операция disconnect(destinationParam: AudioParam, output: Число)
}


внешнее
/*(!) var */ AudioNode: объект { prototype: AudioNode; при создании()/*(!) no_type */ Объект? }


/**
* The Web Audio API's AudioParam interface represents an audio-related parameter, usually a parameter of an AudioNode (such as GainNode.gain).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioParam)
*/

тип AudioParam = интерфейс
{
  automationRate: AutomationRate

  защищено 
  defaultValue: Число

  защищено 
  maxValue: Число

  защищено 
  minValue: Число

  value: Число

  операция cancelAndHoldAtTime(cancelTime: Число): AudioParam

  операция cancelScheduledValues(cancelTime: Число): AudioParam

  операция exponentialRampToValueAtTime(value: Число, endTime: Число): AudioParam

  операция linearRampToValueAtTime(value: Число, endTime: Число): AudioParam

  операция setTargetAtTime(target: Число, startTime: Число, timeConstant: Число): AudioParam

  операция setValueAtTime(value: Число, startTime: Число): AudioParam

  операция setValueCurveAtTime(values: Список<Число> | Float32Array, startTime: Число, duration: Число): AudioParam
}


внешнее
/*(!) var */ AudioParam: объект { prototype: AudioParam; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioParamMap) */

тип AudioParamMap = интерфейс
{
  операция forEach(callbackfn: операция(value: AudioParam, key: Текст, parent: AudioParamMap), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ AudioParamMap: объект { prototype: AudioParamMap; при создании()/*(!) no_type */ Объект? }


/**
* The Web Audio API events that occur when a ScriptProcessorNode input buffer is ready to be processed.
* @deprecated As of the August 29 2014 Web Audio API spec publication, this feature has been marked as deprecated, and is soon to be replaced by AudioWorklet.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioProcessingEvent)
*/

тип AudioProcessingEvent = интерфейс
{
  защищено 
  inputBuffer: AudioBuffer

  защищено 
  outputBuffer: AudioBuffer

  защищено 
  playbackTime: Число
}


/** @deprecated */

внешнее
/*(!) var */ AudioProcessingEvent: объект { prototype: AudioProcessingEvent; при создании(type: Текст, eventInitDict: AudioProcessingEventInit)/*(!) no_type */ Объект? }


тип AudioScheduledSourceNodeEventMap = интерфейс
{
  "ended": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioScheduledSourceNode) */

тип AudioScheduledSourceNode = интерфейс
{
  onended: операция(this: AudioScheduledSourceNode, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция start(when: Число?FUCKFUCK = пусто)

  операция stop(when: Число?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioScheduledSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioScheduledSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AudioScheduledSourceNode: объект { prototype: AudioScheduledSourceNode; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioWorklet)
*/

тип AudioWorklet = интерфейс
{

}


внешнее
/*(!) var */ AudioWorklet: объект { prototype: AudioWorklet; при создании()/*(!) no_type */ Объект? }


тип AudioWorkletNodeEventMap = интерфейс
{
  "processorerror": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioWorkletNode)
*/

тип AudioWorkletNode = интерфейс
{
  onprocessorerror: операция(this: AudioWorkletNode, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  parameters: AudioParamMap

  защищено 
  port: MessagePort

  операция addEventListener<K = /*(!) keyof AudioWorkletNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioWorkletNode, ev: /*(!) AudioWorkletNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AudioWorkletNodeEventMap */ Объект?>(type: K, listener: операция(this: AudioWorkletNode, ev: /*(!) AudioWorkletNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ AudioWorkletNode: объект { prototype: AudioWorkletNode; при создании(context: BaseAudioContext, name: Текст, options: AudioWorkletNodeOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorAssertionResponse)
*/

тип AuthenticatorAssertionResponse = интерфейс
{
  защищено 
  authenticatorData: ArrayBuffer

  защищено 
  signature: ArrayBuffer

  защищено 
  userHandle: ArrayBuffer?FUCKFUCK
}


внешнее
/*(!) var */ AuthenticatorAssertionResponse: объект { prototype: AuthenticatorAssertionResponse; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorAttestationResponse)
*/

тип AuthenticatorAttestationResponse = интерфейс
{
  защищено 
  attestationObject: ArrayBuffer

  операция getAuthenticatorData(): ArrayBuffer

  операция getPublicKey(): ArrayBuffer?FUCKFUCK

  операция getPublicKeyAlgorithm(): COSEAlgorithmIdentifier

  операция getTransports(): Список<Текст>
}


внешнее
/*(!) var */ AuthenticatorAttestationResponse: объект { prototype: AuthenticatorAttestationResponse; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorResponse)
*/

тип AuthenticatorResponse = интерфейс
{
  защищено 
  clientDataJSON: ArrayBuffer
}


внешнее
/*(!) var */ AuthenticatorResponse: объект { prototype: AuthenticatorResponse; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BarProp) */

тип BarProp = интерфейс
{
  защищено 
  visible: ДаНет
}


внешнее
/*(!) var */ BarProp: объект { prototype: BarProp; при создании()/*(!) no_type */ Объект? }


тип BaseAudioContextEventMap = интерфейс
{
  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BaseAudioContext) */

тип BaseAudioContext = интерфейс
{
  защищено 
  audioWorklet: AudioWorklet

  защищено 
  currentTime: Число

  защищено 
  destination: AudioDestinationNode

  защищено 
  listener: AudioListener

  onstatechange: операция(this: BaseAudioContext, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  sampleRate: Число

  защищено 
  state: AudioContextState

  операция createAnalyser(): AnalyserNode

  операция createBiquadFilter(): BiquadFilterNode

  операция createBuffer(numberOfChannels: Число, length: Число, sampleRate: Число): AudioBuffer

  операция createBufferSource(): AudioBufferSourceNode

  операция createChannelMerger(numberOfInputs: Число?FUCKFUCK = пусто): ChannelMergerNode

  операция createChannelSplitter(numberOfOutputs: Число?FUCKFUCK = пусто): ChannelSplitterNode

  операция createConstantSource(): ConstantSourceNode

  операция createConvolver(): ConvolverNode

  операция createDelay(maxDelayTime: Число?FUCKFUCK = пусто): DelayNode

  операция createDynamicsCompressor(): DynamicsCompressorNode

  операция createGain(): GainNode

  операция createIIRFilter(feedforward: Список<Число>, feedback: Список<Число>): IIRFilterNode

  операция createOscillator(): OscillatorNode

  операция createPanner(): PannerNode

  операция createPeriodicWave(real: Список<Число> | Float32Array, imag: Список<Число> | Float32Array, constraints: PeriodicWaveConstraints?FUCKFUCK = пусто): PeriodicWave

  операция createScriptProcessor(bufferSize: Число?FUCKFUCK = пусто, numberOfInputChannels: Число?FUCKFUCK = пусто, numberOfOutputChannels: Число?FUCKFUCK = пусто): ScriptProcessorNode

  операция createStereoPanner(): StereoPannerNode

  операция createWaveShaper(): WaveShaperNode

  операция decodeAudioData(audioData: ArrayBuffer, successCallback: DecodeSuccessCallback?FUCKFUCK = пусто, errorCallback: DecodeErrorCallback?FUCKFUCK = пусто): Promise<AudioBuffer>

  операция addEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type: K, listener: операция(this: BaseAudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type: K, listener: операция(this: BaseAudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ BaseAudioContext: объект { prototype: BaseAudioContext; при создании()/*(!) no_type */ Объект? }


/**
* The beforeunload event is fired when the window, the document and its resources are about to be unloaded.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/BeforeUnloadEvent)
*/

тип BeforeUnloadEvent = интерфейс
{
  returnValue: /*(!) any */ Объект?
}


внешнее
/*(!) var */ BeforeUnloadEvent: объект { prototype: BeforeUnloadEvent; при создании()/*(!) no_type */ Объект? }


/**
* A simple low-order filter, and is created using the AudioContext.createBiquadFilter() method. It is an AudioNode that can represent different kinds of filters, tone control devices, and graphic equalizers.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/BiquadFilterNode)
*/

тип BiquadFilterNode = интерфейс
{
  защищено 
  Q: AudioParam

  защищено 
  detune: AudioParam

  защищено 
  frequency: AudioParam

  защищено 
  gain: AudioParam

  type: BiquadFilterType

  операция getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array)
}


внешнее
/*(!) var */ BiquadFilterNode: объект { prototype: BiquadFilterNode; при создании(context: BaseAudioContext, options: BiquadFilterOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)
*/

тип Blob = интерфейс
{
  защищено 
  size: Число

  защищено 
  type: Текст

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция slice(start: Число?FUCKFUCK = пусто, end: Число?FUCKFUCK = пусто, contentType: Текст?FUCKFUCK = пусто): Blob

  операция stream(): ReadableStream<Uint8Array>

  операция text(): Promise<Текст>
}


внешнее
/*(!) var */ Blob: объект { prototype: Blob; при создании(blobParts: Список<BlobPart>?FUCKFUCK = пусто, options: BlobPropertyBag?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BlobEvent) */

тип BlobEvent = интерфейс
{
  защищено 
  data: Blob

  защищено 
  timecode: DOMHighResTimeStamp
}


внешнее
/*(!) var */ BlobEvent: объект { prototype: BlobEvent; при создании(type: Текст, eventInitDict: BlobEventInit)/*(!) no_type */ Объект? }


тип Body = интерфейс
{
  защищено 
  body: ReadableStream<Uint8Array>?FUCKFUCK

  защищено 
  bodyUsed: ДаНет

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция blob(): Promise<Blob>

  операция formData(): Promise<FormData>

  операция json(): Promise</*(!) any */ Объект?>

  операция text(): Promise<Текст>
}


тип BroadcastChannelEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BroadcastChannel) */

тип BroadcastChannel = интерфейс
{
  защищено 
  name: Текст

  onmessage: операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция postMessage(message: /*(!) any */ Объект?)

  операция addEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ BroadcastChannel: объект { prototype: BroadcastChannel; при создании(name: Текст)/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)
*/

тип ByteLengthQueuingStrategy = интерфейс
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize<ArrayBufferView>
}


внешнее
/*(!) var */ ByteLengthQueuingStrategy: объект { prototype: ByteLengthQueuingStrategy; при создании(init: QueuingStrategyInit)/*(!) no_type */ Объект? }


/**
* A CDATA section that can be used within XML to include extended portions of unescaped text. The symbols < and & don’t need escaping as they normally do when inside a CDATA section.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CDATASection)
*/

тип CDATASection = интерфейс
{

}


внешнее
/*(!) var */ CDATASection: объект { prototype: CDATASection; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSAnimation) */

тип CSSAnimation = интерфейс
{
  защищено 
  animationName: Текст

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: CSSAnimation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: CSSAnimation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ CSSAnimation: объект { prototype: CSSAnimation; при создании()/*(!) no_type */ Объект? }


/**
* A single condition CSS at-rule, which consists of a condition and a statement block. It is a child of CSSGroupingRule.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSConditionRule)
*/

тип CSSConditionRule = интерфейс
{
  защищено 
  conditionText: Текст
}


внешнее
/*(!) var */ CSSConditionRule: объект { prototype: CSSConditionRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSContainerRule) */

тип CSSContainerRule = интерфейс
{
  защищено 
  containerName: Текст

  защищено 
  containerQuery: Текст
}


внешнее
/*(!) var */ CSSContainerRule: объект { prototype: CSSContainerRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSCounterStyleRule) */

тип CSSCounterStyleRule = интерфейс
{
  additiveSymbols: Текст

  fallback: Текст

  name: Текст

  negative: Текст

  pad: Текст

  prefix: Текст

  range: Текст

  speakAs: Текст

  suffix: Текст

  symbols: Текст

  system: Текст
}


внешнее
/*(!) var */ CSSCounterStyleRule: объект { prototype: CSSCounterStyleRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontFaceRule) */

тип CSSFontFaceRule = интерфейс
{
  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSFontFaceRule: объект { prototype: CSSFontFaceRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontFeatureValuesRule) */

тип CSSFontFeatureValuesRule = интерфейс
{
  fontFamily: Текст
}


внешнее
/*(!) var */ CSSFontFeatureValuesRule: объект { prototype: CSSFontFeatureValuesRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontPaletteValuesRule) */

тип CSSFontPaletteValuesRule = интерфейс
{
  защищено 
  basePalette: Текст

  защищено 
  fontFamily: Текст

  защищено 
  name: Текст

  защищено 
  overrideColors: Текст
}


внешнее
/*(!) var */ CSSFontPaletteValuesRule: объект { prototype: CSSFontPaletteValuesRule; при создании()/*(!) no_type */ Объект? }


/**
* Any CSS at-rule that contains other rules nested within it.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSGroupingRule)
*/

тип CSSGroupingRule = интерфейс
{
  защищено 
  cssRules: CSSRuleList

  операция deleteRule(index: Число)

  операция insertRule(rule: Текст, index: Число?FUCKFUCK = пусто): Число
}


внешнее
/*(!) var */ CSSGroupingRule: объект { prototype: CSSGroupingRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSImageValue) */

тип CSSImageValue = интерфейс
{

}


внешнее
/*(!) var */ CSSImageValue: объект { prototype: CSSImageValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSImportRule) */

тип CSSImportRule = интерфейс
{
  защищено 
  href: Текст

  защищено 
  layerName: Текст?FUCKFUCK

  защищено 
  media: MediaList

  защищено 
  styleSheet: CSSStyleSheet?FUCKFUCK
}


внешнее
/*(!) var */ CSSImportRule: объект { prototype: CSSImportRule; при создании()/*(!) no_type */ Объект? }


/**
* An object representing a set of style for a given keyframe. It corresponds to the contains of a single keyframe of a @keyframes at-rule. It implements the CSSRule interface with a type value of 8 (CSSRule.KEYFRAME_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeyframeRule)
*/

тип CSSKeyframeRule = интерфейс
{
  keyText: Текст

  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSKeyframeRule: объект { prototype: CSSKeyframeRule; при создании()/*(!) no_type */ Объект? }


/**
* An object representing a complete set of keyframes for a CSS animation. It corresponds to the contains of a whole @keyframes at-rule. It implements the CSSRule interface with a type value of 7 (CSSRule.KEYFRAMES_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeyframesRule)
*/

тип CSSKeyframesRule = интерфейс
{
  защищено 
  cssRules: CSSRuleList

  защищено 
  length: Число

  name: Текст

  операция appendRule(rule: Текст)

  операция deleteRule(select: Текст)

  операция findRule(select: Текст): CSSKeyframeRule?FUCKFUCK

  /*(!) [index: number]: CSSKeyframeRule*/
}


внешнее
/*(!) var */ CSSKeyframesRule: объект { prototype: CSSKeyframesRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeywordValue) */

тип CSSKeywordValue = интерфейс
{
  value: Текст
}


внешнее
/*(!) var */ CSSKeywordValue: объект { prototype: CSSKeywordValue; при создании(value: Текст)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSLayerBlockRule) */

тип CSSLayerBlockRule = интерфейс
{
  защищено 
  name: Текст
}


внешнее
/*(!) var */ CSSLayerBlockRule: объект { prototype: CSSLayerBlockRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSLayerStatementRule) */

тип CSSLayerStatementRule = интерфейс
{
  защищено 
  nameList: ReadonlyArray<Текст>
}


внешнее
/*(!) var */ CSSLayerStatementRule: объект { prototype: CSSLayerStatementRule; при создании()/*(!) no_type */ Объект? }


тип CSSMathClamp = интерфейс
{
  защищено 
  lower: CSSNumericValue

  защищено 
  upper: CSSNumericValue

  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathClamp: объект { prototype: CSSMathClamp; при создании(lower: CSSNumberish, value: CSSNumberish, upper: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathInvert) */

тип CSSMathInvert = интерфейс
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathInvert: объект { prototype: CSSMathInvert; при создании(arg: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMax) */

тип CSSMathMax = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMax: объект { prototype: CSSMathMax; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMin) */

тип CSSMathMin = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMin: объект { prototype: CSSMathMin; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathNegate) */

тип CSSMathNegate = интерфейс
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathNegate: объект { prototype: CSSMathNegate; при создании(arg: CSSNumberish)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathProduct) */

тип CSSMathProduct = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathProduct: объект { prototype: CSSMathProduct; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathSum) */

тип CSSMathSum = интерфейс
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathSum: объект { prototype: CSSMathSum; #js.МассивПараметров при создании(args: Список<CSSNumberish>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathValue) */

тип CSSMathValue = интерфейс
{
  защищено 
  operator: CSSMathOperator
}


внешнее
/*(!) var */ CSSMathValue: объект { prototype: CSSMathValue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMatrixComponent) */

тип CSSMatrixComponent = интерфейс
{
  matrix: DOMMatrix
}


внешнее
/*(!) var */ CSSMatrixComponent: объект { prototype: CSSMatrixComponent; при создании(matrix: DOMMatrixReadOnly, options: CSSMatrixComponentOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A single CSS @media rule. It implements the CSSConditionRule interface, and therefore the CSSGroupingRule and the CSSRule interface with a type value of 4 (CSSRule.MEDIA_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMediaRule)
*/

тип CSSMediaRule = интерфейс
{
  защищено 
  media: MediaList
}


внешнее
/*(!) var */ CSSMediaRule: объект { prototype: CSSMediaRule; при создании()/*(!) no_type */ Объект? }


/**
* An object representing a single CSS @namespace at-rule. It implements the CSSRule interface, with a type value of 10 (CSSRule.NAMESPACE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNamespaceRule)
*/

тип CSSNamespaceRule = интерфейс
{
  защищено 
  namespaceURI: Текст

  защищено 
  prefix: Текст
}


внешнее
/*(!) var */ CSSNamespaceRule: объект { prototype: CSSNamespaceRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericArray) */

тип CSSNumericArray = интерфейс
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSNumericValue, key: Число, parent: CSSNumericArray), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSNumericValue*/
}


внешнее
/*(!) var */ CSSNumericArray: объект { prototype: CSSNumericArray; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericValue) */

тип CSSNumericValue = интерфейс
{
  #js.МассивПараметров
  операция add(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция div(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция equals(value: Список<CSSNumberish>): ДаНет

  #js.МассивПараметров
  операция max(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция min(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция mul(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция sub(values: Список<CSSNumberish>): CSSNumericValue

  операция to(unit: Текст): CSSUnitValue

  #js.МассивПараметров
  операция toSum(units: Список<Текст>): CSSMathSum

  операция type(): CSSNumericType
}


внешнее
/*(!) var */ CSSNumericValue: объект { prototype: CSSNumericValue; при создании()/*(!) no_type */ Объект?; операция parse(cssText: Текст): CSSNumericValue }


/**
* CSSPageRule is an interface representing a single CSS @page rule. It implements the CSSRule interface with a type value of 6 (CSSRule.PAGE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPageRule)
*/

тип CSSPageRule = интерфейс
{
  selectorText: Текст

  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSPageRule: объект { prototype: CSSPageRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPerspective) */

тип CSSPerspective = интерфейс
{
  length: CSSPerspectiveValue
}


внешнее
/*(!) var */ CSSPerspective: объект { prototype: CSSPerspective; при создании(length: CSSPerspectiveValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPropertyRule) */

тип CSSPropertyRule = интерфейс
{
  защищено 
  inherits: ДаНет

  защищено 
  initialValue: Текст?FUCKFUCK

  защищено 
  name: Текст

  защищено 
  syntax: Текст
}


внешнее
/*(!) var */ CSSPropertyRule: объект { prototype: CSSPropertyRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRotate) */

тип CSSRotate = интерфейс
{
  angle: CSSNumericValue

  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSRotate: объект { prototype: CSSRotate; при создании(angle: CSSNumericValue)/*(!) no_type */ Объект?; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish, angle: CSSNumericValue)/*(!) no_type */ Объект? }


/**
* A single CSS rule. There are several types of rules, listed in the Type constants section below.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRule)
*/

тип CSSRule = интерфейс
{
  cssText: Текст

  защищено 
  parentRule: CSSRule?FUCKFUCK

  защищено 
  parentStyleSheet: CSSStyleSheet?FUCKFUCK

  защищено 
  type: Число

  защищено 
  STYLE_RULE: 1

  защищено 
  CHARSET_RULE: 2

  защищено 
  IMPORT_RULE: 3

  защищено 
  MEDIA_RULE: 4

  защищено 
  FONT_FACE_RULE: 5

  защищено 
  PAGE_RULE: 6

  защищено 
  NAMESPACE_RULE: 10

  защищено 
  KEYFRAMES_RULE: 7

  защищено 
  KEYFRAME_RULE: 8

  защищено 
  SUPPORTS_RULE: 12
}


внешнее
/*(!) var */ CSSRule: объект { prototype: CSSRule; при создании()/*(!) no_type */ Объект?; защищено  STYLE_RULE: 1; защищено  CHARSET_RULE: 2; защищено  IMPORT_RULE: 3; защищено  MEDIA_RULE: 4; защищено  FONT_FACE_RULE: 5; защищено  PAGE_RULE: 6; защищено  NAMESPACE_RULE: 10; защищено  KEYFRAMES_RULE: 7; защищено  KEYFRAME_RULE: 8; защищено  SUPPORTS_RULE: 12 }


/**
* A CSSRuleList is an (indirect-modify only) array-like object containing an ordered collection of CSSRule objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRuleList)
*/

тип CSSRuleList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): CSSRule?FUCKFUCK

  /*(!) [index: number]: CSSRule*/
}


внешнее
/*(!) var */ CSSRuleList: объект { prototype: CSSRuleList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSScale) */

тип CSSScale = интерфейс
{
  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSScale: объект { prototype: CSSScale; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkew) */

тип CSSSkew = интерфейс
{
  ax: CSSNumericValue

  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkew: объект { prototype: CSSSkew; при создании(ax: CSSNumericValue, ay: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewX) */

тип CSSSkewX = интерфейс
{
  ax: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewX: объект { prototype: CSSSkewX; при создании(ax: CSSNumericValue)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewY) */

тип CSSSkewY = интерфейс
{
  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewY: объект { prototype: CSSSkewY; при создании(ay: CSSNumericValue)/*(!) no_type */ Объект? }


/**
* An object that is a CSS declaration block, and exposes style information and various style-related methods and properties.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration)
*/

тип CSSStyleDeclaration = интерфейс
{
  accentColor: Текст

  alignContent: Текст

  alignItems: Текст

  alignSelf: Текст

  alignmentBaseline: Текст

  all: Текст

  animation: Текст

  animationComposition: Текст

  animationDelay: Текст

  animationDirection: Текст

  animationDuration: Текст

  animationFillMode: Текст

  animationIterationCount: Текст

  animationName: Текст

  animationPlayState: Текст

  animationTimingFunction: Текст

  appearance: Текст

  aspectRatio: Текст

  backdropFilter: Текст

  backfaceVisibility: Текст

  background: Текст

  backgroundAttachment: Текст

  backgroundBlendMode: Текст

  backgroundClip: Текст

  backgroundColor: Текст

  backgroundImage: Текст

  backgroundOrigin: Текст

  backgroundPosition: Текст

  backgroundPositionX: Текст

  backgroundPositionY: Текст

  backgroundRepeat: Текст

  backgroundSize: Текст

  baselineShift: Текст

  blockSize: Текст

  border: Текст

  borderBlock: Текст

  borderBlockColor: Текст

  borderBlockEnd: Текст

  borderBlockEndColor: Текст

  borderBlockEndStyle: Текст

  borderBlockEndWidth: Текст

  borderBlockStart: Текст

  borderBlockStartColor: Текст

  borderBlockStartStyle: Текст

  borderBlockStartWidth: Текст

  borderBlockStyle: Текст

  borderBlockWidth: Текст

  borderBottom: Текст

  borderBottomColor: Текст

  borderBottomLeftRadius: Текст

  borderBottomRightRadius: Текст

  borderBottomStyle: Текст

  borderBottomWidth: Текст

  borderCollapse: Текст

  borderColor: Текст

  borderEndEndRadius: Текст

  borderEndStartRadius: Текст

  borderImage: Текст

  borderImageOutset: Текст

  borderImageRepeat: Текст

  borderImageSlice: Текст

  borderImageSource: Текст

  borderImageWidth: Текст

  borderInline: Текст

  borderInlineColor: Текст

  borderInlineEnd: Текст

  borderInlineEndColor: Текст

  borderInlineEndStyle: Текст

  borderInlineEndWidth: Текст

  borderInlineStart: Текст

  borderInlineStartColor: Текст

  borderInlineStartStyle: Текст

  borderInlineStartWidth: Текст

  borderInlineStyle: Текст

  borderInlineWidth: Текст

  borderLeft: Текст

  borderLeftColor: Текст

  borderLeftStyle: Текст

  borderLeftWidth: Текст

  borderRadius: Текст

  borderRight: Текст

  borderRightColor: Текст

  borderRightStyle: Текст

  borderRightWidth: Текст

  borderSpacing: Текст

  borderStartEndRadius: Текст

  borderStartStartRadius: Текст

  borderStyle: Текст

  borderTop: Текст

  borderTopColor: Текст

  borderTopLeftRadius: Текст

  borderTopRightRadius: Текст

  borderTopStyle: Текст

  borderTopWidth: Текст

  borderWidth: Текст

  bottom: Текст

  boxShadow: Текст

  boxSizing: Текст

  breakAfter: Текст

  breakBefore: Текст

  breakInside: Текст

  captionSide: Текст

  caretColor: Текст

  clear: Текст

  clip: Текст

  clipPath: Текст

  clipRule: Текст

  color: Текст

  colorInterpolation: Текст

  colorInterpolationFilters: Текст

  colorScheme: Текст

  columnCount: Текст

  columnFill: Текст

  columnGap: Текст

  columnRule: Текст

  columnRuleColor: Текст

  columnRuleStyle: Текст

  columnRuleWidth: Текст

  columnSpan: Текст

  columnWidth: Текст

  columns: Текст

  contain: Текст

  containIntrinsicBlockSize: Текст

  containIntrinsicHeight: Текст

  containIntrinsicInlineSize: Текст

  containIntrinsicSize: Текст

  containIntrinsicWidth: Текст

  container: Текст

  containerName: Текст

  containerType: Текст

  content: Текст

  counterIncrement: Текст

  counterReset: Текст

  counterSet: Текст

  cssFloat: Текст

  cssText: Текст

  cursor: Текст

  direction: Текст

  display: Текст

  dominantBaseline: Текст

  emptyCells: Текст

  fill: Текст

  fillOpacity: Текст

  fillRule: Текст

  filter: Текст

  flex: Текст

  flexBasis: Текст

  flexDirection: Текст

  flexFlow: Текст

  flexGrow: Текст

  flexShrink: Текст

  flexWrap: Текст

  float: Текст

  floodColor: Текст

  floodOpacity: Текст

  font: Текст

  fontFamily: Текст

  fontFeatureSettings: Текст

  fontKerning: Текст

  fontOpticalSizing: Текст

  fontPalette: Текст

  fontSize: Текст

  fontSizeAdjust: Текст

  fontStretch: Текст

  fontStyle: Текст

  fontSynthesis: Текст

  fontSynthesisSmallCaps: Текст

  fontSynthesisStyle: Текст

  fontSynthesisWeight: Текст

  fontVariant: Текст

  fontVariantAlternates: Текст

  fontVariantCaps: Текст

  fontVariantEastAsian: Текст

  fontVariantLigatures: Текст

  fontVariantNumeric: Текст

  fontVariantPosition: Текст

  fontVariationSettings: Текст

  fontWeight: Текст

  forcedColorAdjust: Текст

  gap: Текст

  grid: Текст

  gridArea: Текст

  gridAutoColumns: Текст

  gridAutoFlow: Текст

  gridAutoRows: Текст

  gridColumn: Текст

  gridColumnEnd: Текст

  gridColumnGap: Текст

  gridColumnStart: Текст

  gridGap: Текст

  gridRow: Текст

  gridRowEnd: Текст

  gridRowGap: Текст

  gridRowStart: Текст

  gridTemplate: Текст

  gridTemplateAreas: Текст

  gridTemplateColumns: Текст

  gridTemplateRows: Текст

  height: Текст

  hyphenateCharacter: Текст

  hyphens: Текст

  imageOrientation: Текст

  imageRendering: Текст

  inlineSize: Текст

  inset: Текст

  insetBlock: Текст

  insetBlockEnd: Текст

  insetBlockStart: Текст

  insetInline: Текст

  insetInlineEnd: Текст

  insetInlineStart: Текст

  isolation: Текст

  justifyContent: Текст

  justifyItems: Текст

  justifySelf: Текст

  left: Текст

  защищено 
  length: Число

  letterSpacing: Текст

  lightingColor: Текст

  lineBreak: Текст

  lineHeight: Текст

  listStyle: Текст

  listStyleImage: Текст

  listStylePosition: Текст

  listStyleType: Текст

  margin: Текст

  marginBlock: Текст

  marginBlockEnd: Текст

  marginBlockStart: Текст

  marginBottom: Текст

  marginInline: Текст

  marginInlineEnd: Текст

  marginInlineStart: Текст

  marginLeft: Текст

  marginRight: Текст

  marginTop: Текст

  marker: Текст

  markerEnd: Текст

  markerMid: Текст

  markerStart: Текст

  mask: Текст

  maskClip: Текст

  maskComposite: Текст

  maskImage: Текст

  maskMode: Текст

  maskOrigin: Текст

  maskPosition: Текст

  maskRepeat: Текст

  maskSize: Текст

  maskType: Текст

  mathStyle: Текст

  maxBlockSize: Текст

  maxHeight: Текст

  maxInlineSize: Текст

  maxWidth: Текст

  minBlockSize: Текст

  minHeight: Текст

  minInlineSize: Текст

  minWidth: Текст

  mixBlendMode: Текст

  objectFit: Текст

  objectPosition: Текст

  offset: Текст

  offsetDistance: Текст

  offsetPath: Текст

  offsetRotate: Текст

  opacity: Текст

  order: Текст

  orphans: Текст

  outline: Текст

  outlineColor: Текст

  outlineOffset: Текст

  outlineStyle: Текст

  outlineWidth: Текст

  overflow: Текст

  overflowAnchor: Текст

  overflowClipMargin: Текст

  overflowWrap: Текст

  overflowX: Текст

  overflowY: Текст

  overscrollBehavior: Текст

  overscrollBehaviorBlock: Текст

  overscrollBehaviorInline: Текст

  overscrollBehaviorX: Текст

  overscrollBehaviorY: Текст

  padding: Текст

  paddingBlock: Текст

  paddingBlockEnd: Текст

  paddingBlockStart: Текст

  paddingBottom: Текст

  paddingInline: Текст

  paddingInlineEnd: Текст

  paddingInlineStart: Текст

  paddingLeft: Текст

  paddingRight: Текст

  paddingTop: Текст

  page: Текст

  pageBreakAfter: Текст

  pageBreakBefore: Текст

  pageBreakInside: Текст

  paintOrder: Текст

  защищено 
  parentRule: CSSRule?FUCKFUCK

  perspective: Текст

  perspectiveOrigin: Текст

  placeContent: Текст

  placeItems: Текст

  placeSelf: Текст

  pointerEvents: Текст

  position: Текст

  printColorAdjust: Текст

  quotes: Текст

  resize: Текст

  right: Текст

  rotate: Текст

  rowGap: Текст

  rubyPosition: Текст

  scale: Текст

  scrollBehavior: Текст

  scrollMargin: Текст

  scrollMarginBlock: Текст

  scrollMarginBlockEnd: Текст

  scrollMarginBlockStart: Текст

  scrollMarginBottom: Текст

  scrollMarginInline: Текст

  scrollMarginInlineEnd: Текст

  scrollMarginInlineStart: Текст

  scrollMarginLeft: Текст

  scrollMarginRight: Текст

  scrollMarginTop: Текст

  scrollPadding: Текст

  scrollPaddingBlock: Текст

  scrollPaddingBlockEnd: Текст

  scrollPaddingBlockStart: Текст

  scrollPaddingBottom: Текст

  scrollPaddingInline: Текст

  scrollPaddingInlineEnd: Текст

  scrollPaddingInlineStart: Текст

  scrollPaddingLeft: Текст

  scrollPaddingRight: Текст

  scrollPaddingTop: Текст

  scrollSnapAlign: Текст

  scrollSnapStop: Текст

  scrollSnapType: Текст

  scrollbarGutter: Текст

  shapeImageThreshold: Текст

  shapeMargin: Текст

  shapeOutside: Текст

  shapeRendering: Текст

  stopColor: Текст

  stopOpacity: Текст

  stroke: Текст

  strokeDasharray: Текст

  strokeDashoffset: Текст

  strokeLinecap: Текст

  strokeLinejoin: Текст

  strokeMiterlimit: Текст

  strokeOpacity: Текст

  strokeWidth: Текст

  tabSize: Текст

  tableLayout: Текст

  textAlign: Текст

  textAlignLast: Текст

  textAnchor: Текст

  textCombineUpright: Текст

  textDecoration: Текст

  textDecorationColor: Текст

  textDecorationLine: Текст

  textDecorationSkipInk: Текст

  textDecorationStyle: Текст

  textDecorationThickness: Текст

  textEmphasis: Текст

  textEmphasisColor: Текст

  textEmphasisPosition: Текст

  textEmphasisStyle: Текст

  textIndent: Текст

  textOrientation: Текст

  textOverflow: Текст

  textRendering: Текст

  textShadow: Текст

  textTransform: Текст

  textUnderlineOffset: Текст

  textUnderlinePosition: Текст

  top: Текст

  touchAction: Текст

  transform: Текст

  transformBox: Текст

  transformOrigin: Текст

  transformStyle: Текст

  transition: Текст

  transitionDelay: Текст

  transitionDuration: Текст

  transitionProperty: Текст

  transitionTimingFunction: Текст

  translate: Текст

  unicodeBidi: Текст

  userSelect: Текст

  verticalAlign: Текст

  visibility: Текст

  webkitAlignContent: Текст

  webkitAlignItems: Текст

  webkitAlignSelf: Текст

  webkitAnimation: Текст

  webkitAnimationDelay: Текст

  webkitAnimationDirection: Текст

  webkitAnimationDuration: Текст

  webkitAnimationFillMode: Текст

  webkitAnimationIterationCount: Текст

  webkitAnimationName: Текст

  webkitAnimationPlayState: Текст

  webkitAnimationTimingFunction: Текст

  webkitAppearance: Текст

  webkitBackfaceVisibility: Текст

  webkitBackgroundClip: Текст

  webkitBackgroundOrigin: Текст

  webkitBackgroundSize: Текст

  webkitBorderBottomLeftRadius: Текст

  webkitBorderBottomRightRadius: Текст

  webkitBorderRadius: Текст

  webkitBorderTopLeftRadius: Текст

  webkitBorderTopRightRadius: Текст

  webkitBoxAlign: Текст

  webkitBoxFlex: Текст

  webkitBoxOrdinalGroup: Текст

  webkitBoxOrient: Текст

  webkitBoxPack: Текст

  webkitBoxShadow: Текст

  webkitBoxSizing: Текст

  webkitFilter: Текст

  webkitFlex: Текст

  webkitFlexBasis: Текст

  webkitFlexDirection: Текст

  webkitFlexFlow: Текст

  webkitFlexGrow: Текст

  webkitFlexShrink: Текст

  webkitFlexWrap: Текст

  webkitJustifyContent: Текст

  webkitLineClamp: Текст

  webkitMask: Текст

  webkitMaskBoxImage: Текст

  webkitMaskBoxImageOutset: Текст

  webkitMaskBoxImageRepeat: Текст

  webkitMaskBoxImageSlice: Текст

  webkitMaskBoxImageSource: Текст

  webkitMaskBoxImageWidth: Текст

  webkitMaskClip: Текст

  webkitMaskComposite: Текст

  webkitMaskImage: Текст

  webkitMaskOrigin: Текст

  webkitMaskPosition: Текст

  webkitMaskRepeat: Текст

  webkitMaskSize: Текст

  webkitOrder: Текст

  webkitPerspective: Текст

  webkitPerspectiveOrigin: Текст

  webkitTextFillColor: Текст

  webkitTextSizeAdjust: Текст

  webkitTextStroke: Текст

  webkitTextStrokeColor: Текст

  webkitTextStrokeWidth: Текст

  webkitTransform: Текст

  webkitTransformOrigin: Текст

  webkitTransformStyle: Текст

  webkitTransition: Текст

  webkitTransitionDelay: Текст

  webkitTransitionDuration: Текст

  webkitTransitionProperty: Текст

  webkitTransitionTimingFunction: Текст

  webkitUserSelect: Текст

  whiteSpace: Текст

  widows: Текст

  width: Текст

  willChange: Текст

  wordBreak: Текст

  wordSpacing: Текст

  wordWrap: Текст

  writingMode: Текст

  zIndex: Текст

  операция getPropertyPriority(property: Текст): Текст

  операция getPropertyValue(property: Текст): Текст

  операция item(index: Число): Текст

  операция removeProperty(property: Текст): Текст

  операция setProperty(property: Текст, value: Текст?FUCKFUCK, priority: Текст?FUCKFUCK = пусто)

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ CSSStyleDeclaration: объект { prototype: CSSStyleDeclaration; при создании()/*(!) no_type */ Объект? }


/**
* CSSStyleRule represents a single CSS style rule. It implements the CSSRule interface with a type value of 1 (CSSRule.STYLE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleRule)
*/

тип CSSStyleRule = интерфейс
{
  защищено 
  cssRules: CSSRuleList

  selectorText: Текст

  защищено 
  style: CSSStyleDeclaration

  защищено 
  styleMap: StylePropertyMap

  операция deleteRule(index: Число)

  операция insertRule(rule: Текст, index: Число?FUCKFUCK = пусто): Число
}


внешнее
/*(!) var */ CSSStyleRule: объект { prototype: CSSStyleRule; при создании()/*(!) no_type */ Объект? }


/**
* A single CSS style sheet. It inherits properties and methods from its parent, StyleSheet.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleSheet)
*/

тип CSSStyleSheet = интерфейс
{
  защищено 
  cssRules: CSSRuleList

  защищено 
  ownerRule: CSSRule?FUCKFUCK

  защищено 
  rules: CSSRuleList

  операция addRule(selector: Текст?FUCKFUCK = пусто, style: Текст?FUCKFUCK = пусто, index: Число?FUCKFUCK = пусто): Число

  операция deleteRule(index: Число)

  операция insertRule(rule: Текст, index: Число?FUCKFUCK = пусто): Число

  операция removeRule(index: Число?FUCKFUCK = пусто)

  операция replace(text: Текст): Promise<CSSStyleSheet>

  операция replaceSync(text: Текст)
}


внешнее
/*(!) var */ CSSStyleSheet: объект { prototype: CSSStyleSheet; при создании(options: CSSStyleSheetInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleValue) */

тип CSSStyleValue = интерфейс
{
  операция toString(): Текст
}


внешнее
/*(!) var */ CSSStyleValue: объект { prototype: CSSStyleValue; при создании()/*(!) no_type */ Объект?; операция parse(property: Текст, cssText: Текст): CSSStyleValue; операция parseAll(property: Текст, cssText: Текст): Список<CSSStyleValue> }


/**
* An object representing a single CSS @supports at-rule. It implements the CSSConditionRule interface, and therefore the CSSRule and CSSGroupingRule interfaces with a type value of 12 (CSSRule.SUPPORTS_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSupportsRule)
*/

тип CSSSupportsRule = интерфейс
{

}


внешнее
/*(!) var */ CSSSupportsRule: объект { prototype: CSSSupportsRule; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformComponent) */

тип CSSTransformComponent = интерфейс
{
  is2D: ДаНет

  операция toMatrix(): DOMMatrix

  операция toString(): Текст
}


внешнее
/*(!) var */ CSSTransformComponent: объект { prototype: CSSTransformComponent; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformValue) */

тип CSSTransformValue = интерфейс
{
  защищено 
  is2D: ДаНет

  защищено 
  length: Число

  операция toMatrix(): DOMMatrix

  операция forEach(callbackfn: операция(value: CSSTransformComponent, key: Число, parent: CSSTransformValue), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSTransformComponent*/
}


внешнее
/*(!) var */ CSSTransformValue: объект { prototype: CSSTransformValue; при создании(transforms: Список<CSSTransformComponent>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransition) */

тип CSSTransition = интерфейс
{
  защищено 
  transitionProperty: Текст

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: CSSTransition, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type: K, listener: операция(this: CSSTransition, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ CSSTransition: объект { prototype: CSSTransition; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTranslate) */

тип CSSTranslate = интерфейс
{
  x: CSSNumericValue

  y: CSSNumericValue

  z: CSSNumericValue
}


внешнее
/*(!) var */ CSSTranslate: объект { prototype: CSSTranslate; при создании(x: CSSNumericValue, y: CSSNumericValue, z: CSSNumericValue?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnitValue) */

тип CSSUnitValue = интерфейс
{
  защищено 
  unit: Текст

  value: Число
}


внешнее
/*(!) var */ CSSUnitValue: объект { prototype: CSSUnitValue; при создании(value: Число, unit: Текст)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnparsedValue) */

тип CSSUnparsedValue = интерфейс
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSUnparsedSegment, key: Число, parent: CSSUnparsedValue), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: CSSUnparsedSegment*/
}


внешнее
/*(!) var */ CSSUnparsedValue: объект { prototype: CSSUnparsedValue; при создании(members: Список<CSSUnparsedSegment>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSVariableReferenceValue) */

тип CSSVariableReferenceValue = интерфейс
{
  защищено 
  fallback: CSSUnparsedValue?FUCKFUCK

  variable: Текст
}


внешнее
/*(!) var */ CSSVariableReferenceValue: объект { prototype: CSSVariableReferenceValue; при создании(variable: Текст, fallback: CSSUnparsedValue?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Provides a storage mechanism for Request / Response object pairs that are cached, for example as part of the ServiceWorker life cycle. Note that the Cache interface is exposed to windowed scopes as well as workers. You don't have to use it in conjunction with service workers, even though it is defined in the service worker spec.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache)
*/

тип Cache = интерфейс
{
  операция add(request: RequestInfo | URL): Promise<Ничего>

  операция addAll(requests: Список<RequestInfo>): Promise<Ничего>

  операция delete(request: RequestInfo | URL, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ДаНет>

  операция keys(request: RequestInfo | URL | пусто = пусто, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ReadonlyArray<Request>>

  операция match(request: RequestInfo | URL, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<Response?FUCKFUCK>

  операция matchAll(request: RequestInfo | URL | пусто = пусто, options: CacheQueryOptions?FUCKFUCK = пусто): Promise<ReadonlyArray<Response>>

  операция put(request: RequestInfo | URL, response: Response): Promise<Ничего>
}


внешнее
/*(!) var */ Cache: объект { prototype: Cache; при создании()/*(!) no_type */ Объект? }


/**
* The storage for Cache objects.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage)
*/

тип CacheStorage = интерфейс
{
  операция delete(cacheName: Текст): Promise<ДаНет>

  операция has(cacheName: Текст): Promise<ДаНет>

  операция keys(): Promise<Список<Текст>>

  операция match(request: RequestInfo | URL, options: MultiCacheQueryOptions?FUCKFUCK = пусто): Promise<Response?FUCKFUCK>

  операция open(cacheName: Текст): Promise<Cache>
}


внешнее
/*(!) var */ CacheStorage: объект { prototype: CacheStorage; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasCaptureMediaStreamTrack) */

тип CanvasCaptureMediaStreamTrack = интерфейс
{
  защищено 
  canvas: HTMLCanvasElement

  операция requestFrame()

  операция addEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type: K, listener: операция(this: CanvasCaptureMediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type: K, listener: операция(this: CanvasCaptureMediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ CanvasCaptureMediaStreamTrack: объект { prototype: CanvasCaptureMediaStreamTrack; при создании()/*(!) no_type */ Объект? }


тип CanvasCompositing = интерфейс
{
  globalAlpha: Число

  globalCompositeOperation: GlobalCompositeOperation
}


тип CanvasDrawImage = интерфейс
{
  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число)

  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число, dw: Число, dh: Число)

  операция drawImage(image: CanvasImageSource, sx: Число, sy: Число, sw: Число, sh: Число, dx: Число, dy: Число, dw: Число, dh: Число)
}


тип CanvasDrawPath = интерфейс
{
  операция beginPath()

  операция clip(fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция clip(path: Path2D, fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция fill(fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция fill(path: Path2D, fillRule: CanvasFillRule?FUCKFUCK = пусто)

  операция isPointInPath(x: Число, y: Число, fillRule: CanvasFillRule?FUCKFUCK = пусто): ДаНет

  операция isPointInPath(path: Path2D, x: Число, y: Число, fillRule: CanvasFillRule?FUCKFUCK = пусто): ДаНет

  операция isPointInStroke(x: Число, y: Число): ДаНет

  операция isPointInStroke(path: Path2D, x: Число, y: Число): ДаНет

  операция stroke()

  операция stroke(path: Path2D)
}


тип CanvasFillStrokeStyles = интерфейс
{
  fillStyle: Текст | CanvasGradient | CanvasPattern

  strokeStyle: Текст | CanvasGradient | CanvasPattern

  операция createConicGradient(startAngle: Число, x: Число, y: Число): CanvasGradient

  операция createLinearGradient(x0: Число, y0: Число, x1: Число, y1: Число): CanvasGradient

  операция createPattern(image: CanvasImageSource, repetition: Текст?FUCKFUCK): CanvasPattern?FUCKFUCK

  операция createRadialGradient(x0: Число, y0: Число, r0: Число, x1: Число, y1: Число, r1: Число): CanvasGradient
}


тип CanvasFilters = интерфейс
{
  filter: Текст
}


/**
* An opaque object describing a gradient. It is returned by the methods CanvasRenderingContext2D.createLinearGradient() or CanvasRenderingContext2D.createRadialGradient().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasGradient)
*/

тип CanvasGradient = интерфейс
{
  операция addColorStop(offset: Число, color: Текст)
}


внешнее
/*(!) var */ CanvasGradient: объект { prototype: CanvasGradient; при создании()/*(!) no_type */ Объект? }


тип CanvasImageData = интерфейс
{
  операция createImageData(sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто): ImageData

  операция createImageData(imagedata: ImageData): ImageData

  операция getImageData(sx: Число, sy: Число, sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто): ImageData

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число)

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число, dirtyX: Число, dirtyY: Число, dirtyWidth: Число, dirtyHeight: Число)
}


тип CanvasImageSmoothing = интерфейс
{
  imageSmoothingEnabled: ДаНет

  imageSmoothingQuality: ImageSmoothingQuality
}


тип CanvasPath = интерфейс
{
  операция arc(x: Число, y: Число, radius: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет?FUCKFUCK = пусто)

  операция arcTo(x1: Число, y1: Число, x2: Число, y2: Число, radius: Число)

  операция bezierCurveTo(cp1x: Число, cp1y: Число, cp2x: Число, cp2y: Число, x: Число, y: Число)

  операция closePath()

  операция ellipse(x: Число, y: Число, radiusX: Число, radiusY: Число, rotation: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет?FUCKFUCK = пусто)

  операция lineTo(x: Число, y: Число)

  операция moveTo(x: Число, y: Число)

  операция quadraticCurveTo(cpx: Число, cpy: Число, x: Число, y: Число)

  операция rect(x: Число, y: Число, w: Число, h: Число)

  операция roundRect(x: Число, y: Число, w: Число, h: Число, radii: Число | DOMPointInit | Список<Число | DOMPointInit> | пусто = пусто)
}


тип CanvasPathDrawingStyles = интерфейс
{
  lineCap: CanvasLineCap

  lineDashOffset: Число

  lineJoin: CanvasLineJoin

  lineWidth: Число

  miterLimit: Число

  операция getLineDash(): Список<Число>

  операция setLineDash(segments: Список<Число>)
}


/**
* An opaque object describing a pattern, based on an image, a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasPattern)
*/

тип CanvasPattern = интерфейс
{
  операция setTransform(transform: DOMMatrix2DInit?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ CanvasPattern: объект { prototype: CanvasPattern; при создании()/*(!) no_type */ Объект? }


тип CanvasRect = интерфейс
{
  операция clearRect(x: Число, y: Число, w: Число, h: Число)

  операция fillRect(x: Число, y: Число, w: Число, h: Число)

  операция strokeRect(x: Число, y: Число, w: Число, h: Число)
}


/**
* The CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and other objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D)
*/

тип CanvasRenderingContext2D = интерфейс
{
  защищено 
  canvas: HTMLCanvasElement

  операция getContextAttributes(): CanvasRenderingContext2DSettings
}


внешнее
/*(!) var */ CanvasRenderingContext2D: объект { prototype: CanvasRenderingContext2D; при создании()/*(!) no_type */ Объект? }


тип CanvasShadowStyles = интерфейс
{
  shadowBlur: Число

  shadowColor: Текст

  shadowOffsetX: Число

  shadowOffsetY: Число
}


тип CanvasState = интерфейс
{
  операция reset()

  операция restore()

  операция save()
}


тип CanvasText = интерфейс
{
  операция fillText(text: Текст, x: Число, y: Число, maxWidth: Число?FUCKFUCK = пусто)

  операция measureText(text: Текст): TextMetrics

  операция strokeText(text: Текст, x: Число, y: Число, maxWidth: Число?FUCKFUCK = пусто)
}


тип CanvasTextDrawingStyles = интерфейс
{
  direction: CanvasDirection

  font: Текст

  fontKerning: CanvasFontKerning

  textAlign: CanvasTextAlign

  textBaseline: CanvasTextBaseline
}


тип CanvasTransform = интерфейс
{
  операция getTransform(): DOMMatrix

  операция resetTransform()

  операция rotate(angle: Число)

  операция scale(x: Число, y: Число)

  операция setTransform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция setTransform(transform: DOMMatrix2DInit?FUCKFUCK = пусто)

  операция transform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция translate(x: Число, y: Число)
}


тип CanvasUserInterface = интерфейс
{
  операция drawFocusIfNeeded(element: Element)

  операция drawFocusIfNeeded(path: Path2D, element: Element)
}


/**
* The ChannelMergerNode interface, often used in conjunction with its opposite, ChannelSplitterNode, reunites different mono inputs into a single output. Each input is used to fill a channel of the output. This is useful for accessing each channels separately, e.g. for performing channel mixing where gain must be separately controlled on each channel.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ChannelMergerNode)
*/

тип ChannelMergerNode = интерфейс
{

}


внешнее
/*(!) var */ ChannelMergerNode: объект { prototype: ChannelMergerNode; при создании(context: BaseAudioContext, options: ChannelMergerOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The ChannelSplitterNode interface, often used in conjunction with its opposite, ChannelMergerNode, separates the different channels of an audio source into a set of mono outputs. This is useful for accessing each channel separately, e.g. for performing channel mixing where gain must be separately controlled on each channel.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ChannelSplitterNode)
*/

тип ChannelSplitterNode = интерфейс
{

}


внешнее
/*(!) var */ ChannelSplitterNode: объект { prototype: ChannelSplitterNode; при создании(context: BaseAudioContext, options: ChannelSplitterOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The CharacterData abstract interface represents a Node object that contains characters. This is an abstract interface, meaning there aren't any object of type CharacterData: it is implemented by other interfaces, like Text, Comment, or ProcessingInstruction which aren't abstract.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CharacterData)
*/

тип CharacterData = интерфейс
{
  data: Текст

  защищено 
  length: Число

  защищено 
  ownerDocument: Document

  операция appendData(data: Текст)

  операция deleteData(offset: Число, count: Число)

  операция insertData(offset: Число, data: Текст)

  операция replaceData(offset: Число, count: Число, data: Текст)

  операция substringData(offset: Число, count: Число): Текст
}


внешнее
/*(!) var */ CharacterData: объект { prototype: CharacterData; при создании()/*(!) no_type */ Объект? }


тип ChildNode = интерфейс
{
  #js.МассивПараметров
  операция after(nodes: Список<Node | Текст>)

  #js.МассивПараметров
  операция before(nodes: Список<Node | Текст>)

  операция remove()

  #js.МассивПараметров
  операция replaceWith(nodes: Список<Node | Текст>)
}


/** @deprecated */

тип ClientRect = интерфейс
{

}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Clipboard)
*/

тип Clipboard = интерфейс
{
  операция read(): Promise<ClipboardItems>

  операция readText(): Promise<Текст>

  операция write(data: ClipboardItems): Promise<Ничего>

  операция writeText(data: Текст): Promise<Ничего>
}


внешнее
/*(!) var */ Clipboard: объект { prototype: Clipboard; при создании()/*(!) no_type */ Объект? }


/**
* Events providing information related to modification of the clipboard, that is cut, copy, and paste events.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ClipboardEvent)
*/

тип ClipboardEvent = интерфейс
{
  защищено 
  clipboardData: DataTransfer?FUCKFUCK
}


внешнее
/*(!) var */ ClipboardEvent: объект { prototype: ClipboardEvent; при создании(type: Текст, eventInitDict: ClipboardEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ClipboardItem)
*/

тип ClipboardItem = интерфейс
{
  защищено 
  types: ReadonlyArray<Текст>

  операция getType(type: Текст): Promise<Blob>
}


внешнее
/*(!) var */ ClipboardItem: объект { prototype: ClipboardItem; при создании(items: Record<Текст, Текст | Blob | PromiseLike<Текст | Blob>>, options: ClipboardItemOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)
*/

тип CloseEvent = интерфейс
{
  защищено 
  code: Число

  защищено 
  reason: Текст

  защищено 
  wasClean: ДаНет
}


внешнее
/*(!) var */ CloseEvent: объект { prototype: CloseEvent; при создании(type: Текст, eventInitDict: CloseEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Textual notations within markup; although it is generally not visually shown, such comments are available to be read in the source view.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Comment)
*/

тип Comment = интерфейс
{

}


внешнее
/*(!) var */ Comment: объект { prototype: Comment; при создании(data: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The DOM CompositionEvent represents events that occur due to the user indirectly entering text.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompositionEvent)
*/

тип CompositionEvent = интерфейс
{
  защищено 
  data: Текст

  операция initCompositionEvent(typeArg: Текст, bubblesArg: ДаНет?FUCKFUCK = пусто, cancelableArg: ДаНет?FUCKFUCK = пусто, viewArg: WindowProxy?FUCKFUCK = пусто, dataArg: Текст?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ CompositionEvent: объект { prototype: CompositionEvent; при создании(type: Текст, eventInitDict: CompositionEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */

тип CompressionStream = интерфейс
{

}


внешнее
/*(!) var */ CompressionStream: объект { prototype: CompressionStream; при создании(format: CompressionFormat)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ConstantSourceNode) */

тип ConstantSourceNode = интерфейс
{
  защищено 
  offset: AudioParam

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: ConstantSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: ConstantSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ConstantSourceNode: объект { prototype: ConstantSourceNode; при создании(context: BaseAudioContext, options: ConstantSourceOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An AudioNode that performs a Linear Convolution on a given AudioBuffer, often used to achieve a reverb effect. A ConvolverNode always has exactly one input and one output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ConvolverNode)
*/

тип ConvolverNode = интерфейс
{
  buffer: AudioBuffer?FUCKFUCK

  normalize: ДаНет
}


внешнее
/*(!) var */ ConvolverNode: объект { prototype: ConvolverNode; при создании(context: BaseAudioContext, options: ConvolverOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)
*/

тип CountQueuingStrategy = интерфейс
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize
}


внешнее
/*(!) var */ CountQueuingStrategy: объект { prototype: CountQueuingStrategy; при создании(init: QueuingStrategyInit)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Credential)
*/

тип Credential = интерфейс
{
  защищено 
  id: Текст

  защищено 
  type: Текст
}


внешнее
/*(!) var */ Credential: объект { prototype: Credential; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CredentialsContainer)
*/

тип CredentialsContainer = интерфейс
{
  операция create(options: CredentialCreationOptions?FUCKFUCK = пусто): Promise<Credential?FUCKFUCK>

  операция get(options: CredentialRequestOptions?FUCKFUCK = пусто): Promise<Credential?FUCKFUCK>

  операция preventSilentAccess(): Promise<Ничего>

  операция store(credential: Credential): Promise<Credential>
}


внешнее
/*(!) var */ CredentialsContainer: объект { prototype: CredentialsContainer; при создании()/*(!) no_type */ Объект? }


/**
* Basic cryptography features available in the current context. It allows access to a cryptographically strong random number generator and to cryptographic primitives.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto)
*/

тип Crypto = интерфейс
{
  защищено 
  subtle: SubtleCrypto

  операция getRandomValues<T = ArrayBufferView?FUCKFUCK>(array: T): T

  операция randomUUID(): /*(!) `${string}-${string}-${string}-${string}-${string}` */ Объект?
}


внешнее
/*(!) var */ Crypto: объект { prototype: Crypto; при создании()/*(!) no_type */ Объект? }


/**
* The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)
*/

тип CryptoKey = интерфейс
{
  защищено 
  algorithm: KeyAlgorithm

  защищено 
  extractable: ДаНет

  защищено 
  type: KeyType

  защищено 
  usages: Список<KeyUsage>
}


внешнее
/*(!) var */ CryptoKey: объект { prototype: CryptoKey; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry) */

тип CustomElementRegistry = интерфейс
{
  операция define(name: Текст, constructor: CustomElementConstructor, options: ElementDefinitionOptions?FUCKFUCK = пусто)

  операция get(name: Текст): CustomElementConstructor?FUCKFUCK

  операция upgrade(root: Node)

  операция whenDefined(name: Текст): Promise<CustomElementConstructor>
}


внешнее
/*(!) var */ CustomElementRegistry: объект { prototype: CustomElementRegistry; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */

тип CustomEvent<T> = интерфейс
{
  защищено 
  detail: T

  операция initCustomEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто, detail: T?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ CustomEvent: объект { prototype: CustomEvent; при создании(type: Текст, eventInitDict: CustomEventInit<T>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)
*/

тип DOMException = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  name: Текст

  защищено 
  INDEX_SIZE_ERR: 1

  защищено 
  DOMSTRING_SIZE_ERR: 2

  защищено 
  HIERARCHY_REQUEST_ERR: 3

  защищено 
  WRONG_DOCUMENT_ERR: 4

  защищено 
  INVALID_CHARACTER_ERR: 5

  защищено 
  NO_DATA_ALLOWED_ERR: 6

  защищено 
  NO_MODIFICATION_ALLOWED_ERR: 7

  защищено 
  NOT_FOUND_ERR: 8

  защищено 
  NOT_SUPPORTED_ERR: 9

  защищено 
  INUSE_ATTRIBUTE_ERR: 10

  защищено 
  INVALID_STATE_ERR: 11

  защищено 
  SYNTAX_ERR: 12

  защищено 
  INVALID_MODIFICATION_ERR: 13

  защищено 
  NAMESPACE_ERR: 14

  защищено 
  INVALID_ACCESS_ERR: 15

  защищено 
  VALIDATION_ERR: 16

  защищено 
  TYPE_MISMATCH_ERR: 17

  защищено 
  SECURITY_ERR: 18

  защищено 
  NETWORK_ERR: 19

  защищено 
  ABORT_ERR: 20

  защищено 
  URL_MISMATCH_ERR: 21

  защищено 
  QUOTA_EXCEEDED_ERR: 22

  защищено 
  TIMEOUT_ERR: 23

  защищено 
  INVALID_NODE_TYPE_ERR: 24

  защищено 
  DATA_CLONE_ERR: 25
}


внешнее
/*(!) var */ DOMException: объект { prototype: DOMException; при создании(message: Текст?FUCKFUCK = пусто, name: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  INDEX_SIZE_ERR: 1; защищено  DOMSTRING_SIZE_ERR: 2; защищено  HIERARCHY_REQUEST_ERR: 3; защищено  WRONG_DOCUMENT_ERR: 4; защищено  INVALID_CHARACTER_ERR: 5; защищено  NO_DATA_ALLOWED_ERR: 6; защищено  NO_MODIFICATION_ALLOWED_ERR: 7; защищено  NOT_FOUND_ERR: 8; защищено  NOT_SUPPORTED_ERR: 9; защищено  INUSE_ATTRIBUTE_ERR: 10; защищено  INVALID_STATE_ERR: 11; защищено  SYNTAX_ERR: 12; защищено  INVALID_MODIFICATION_ERR: 13; защищено  NAMESPACE_ERR: 14; защищено  INVALID_ACCESS_ERR: 15; защищено  VALIDATION_ERR: 16; защищено  TYPE_MISMATCH_ERR: 17; защищено  SECURITY_ERR: 18; защищено  NETWORK_ERR: 19; защищено  ABORT_ERR: 20; защищено  URL_MISMATCH_ERR: 21; защищено  QUOTA_EXCEEDED_ERR: 22; защищено  TIMEOUT_ERR: 23; защищено  INVALID_NODE_TYPE_ERR: 24; защищено  DATA_CLONE_ERR: 25 }


/**
* An object providing methods which are not dependent on any particular document. Such an object is returned by the Document.implementation property.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMImplementation)
*/

тип DOMImplementation = интерфейс
{
  операция createDocument(namespace: Текст?FUCKFUCK, qualifiedName: Текст?FUCKFUCK, doctype: DocumentType?FUCKFUCK = пусто): XMLDocument

  операция createDocumentType(qualifiedName: Текст, publicId: Текст, systemId: Текст): DocumentType

  операция createHTMLDocument(title: Текст?FUCKFUCK = пусто): Document

  #js.МассивПараметров
  операция hasFeature(args: Список</*(!) any */ Объект?>): да
}


внешнее
/*(!) var */ DOMImplementation: объект { prototype: DOMImplementation; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrix) */

тип DOMMatrix = интерфейс
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m13: Число

  m14: Число

  m21: Число

  m22: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m41: Число

  m42: Число

  m43: Число

  m44: Число

  операция invertSelf(): DOMMatrix

  операция multiplySelf(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция preMultiplySelf(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция rotateAxisAngleSelf(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, angle: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateFromVectorSelf(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateSelf(rotX: Число?FUCKFUCK = пусто, rotY: Число?FUCKFUCK = пусто, rotZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale3dSelf(scale: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scaleSelf(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто, scaleZ: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция setMatrixValue(transformList: Текст): DOMMatrix

  операция skewXSelf(sx: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewYSelf(sy: Число?FUCKFUCK = пусто): DOMMatrix

  операция translateSelf(tx: Число?FUCKFUCK = пусто, ty: Число?FUCKFUCK = пусто, tz: Число?FUCKFUCK = пусто): DOMMatrix
}


внешнее
/*(!) var */ DOMMatrix: объект { prototype: DOMMatrix; при создании(init: Текст | Список<Число> | пусто = пусто)/*(!) no_type */ Объект?; операция fromFloat32Array(array32: Float32Array): DOMMatrix; операция fromFloat64Array(array64: Float64Array): DOMMatrix; операция fromMatrix(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix }


тип SVGMatrix = DOMMatrix

внешнее
/*(!) var */ SVGMatrix: /*(!) typeof DOMMatrix */ Объект?


тип WebKitCSSMatrix = DOMMatrix

внешнее
/*(!) var */ WebKitCSSMatrix: /*(!) typeof DOMMatrix */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrixReadOnly) */

тип DOMMatrixReadOnly = интерфейс
{
  защищено 
  a: Число

  защищено 
  b: Число

  защищено 
  c: Число

  защищено 
  d: Число

  защищено 
  e: Число

  защищено 
  f: Число

  защищено 
  is2D: ДаНет

  защищено 
  isIdentity: ДаНет

  защищено 
  m11: Число

  защищено 
  m12: Число

  защищено 
  m13: Число

  защищено 
  m14: Число

  защищено 
  m21: Число

  защищено 
  m22: Число

  защищено 
  m23: Число

  защищено 
  m24: Число

  защищено 
  m31: Число

  защищено 
  m32: Число

  защищено 
  m33: Число

  защищено 
  m34: Число

  защищено 
  m41: Число

  защищено 
  m42: Число

  защищено 
  m43: Число

  защищено 
  m44: Число

  операция flipX(): DOMMatrix

  операция flipY(): DOMMatrix

  операция inverse(): DOMMatrix

  операция multiply(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrix

  операция rotate(rotX: Число?FUCKFUCK = пусто, rotY: Число?FUCKFUCK = пусто, rotZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateAxisAngle(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, angle: Число?FUCKFUCK = пусто): DOMMatrix

  операция rotateFromVector(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто, scaleZ: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scale3d(scale: Число?FUCKFUCK = пусто, originX: Число?FUCKFUCK = пусто, originY: Число?FUCKFUCK = пусто, originZ: Число?FUCKFUCK = пусто): DOMMatrix

  операция scaleNonUniform(scaleX: Число?FUCKFUCK = пусто, scaleY: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewX(sx: Число?FUCKFUCK = пусто): DOMMatrix

  операция skewY(sy: Число?FUCKFUCK = пусто): DOMMatrix

  операция toFloat32Array(): Float32Array

  операция toFloat64Array(): Float64Array

  операция toJSON(): /*(!) any */ Объект?

  операция transformPoint(point: DOMPointInit?FUCKFUCK = пусто): DOMPoint

  операция translate(tx: Число?FUCKFUCK = пусто, ty: Число?FUCKFUCK = пусто, tz: Число?FUCKFUCK = пусто): DOMMatrix

  операция toString(): Текст
}


внешнее
/*(!) var */ DOMMatrixReadOnly: объект { prototype: DOMMatrixReadOnly; при создании(init: Текст | Список<Число> | пусто = пусто)/*(!) no_type */ Объект?; операция fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly; операция fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly; операция fromMatrix(other: DOMMatrixInit?FUCKFUCK = пусто): DOMMatrixReadOnly }


/**
* Provides the ability to parse XML or HTML source code from a string into a DOM Document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMParser)
*/

тип DOMParser = интерфейс
{
  операция parseFromString(string: Текст, type: DOMParserSupportedType): Document
}


внешнее
/*(!) var */ DOMParser: объект { prototype: DOMParser; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPoint) */

тип DOMPoint = интерфейс
{
  w: Число

  x: Число

  y: Число

  z: Число
}


внешнее
/*(!) var */ DOMPoint: объект { prototype: DOMPoint; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, w: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromPoint(other: DOMPointInit?FUCKFUCK = пусто): DOMPoint }


тип SVGPoint = DOMPoint

внешнее
/*(!) var */ SVGPoint: /*(!) typeof DOMPoint */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPointReadOnly) */

тип DOMPointReadOnly = интерфейс
{
  защищено 
  w: Число

  защищено 
  x: Число

  защищено 
  y: Число

  защищено 
  z: Число

  операция matrixTransform(matrix: DOMMatrixInit?FUCKFUCK = пусто): DOMPoint

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMPointReadOnly: объект { prototype: DOMPointReadOnly; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, z: Число?FUCKFUCK = пусто, w: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromPoint(other: DOMPointInit?FUCKFUCK = пусто): DOMPointReadOnly }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMQuad) */

тип DOMQuad = интерфейс
{
  защищено 
  p1: DOMPoint

  защищено 
  p2: DOMPoint

  защищено 
  p3: DOMPoint

  защищено 
  p4: DOMPoint

  операция getBounds(): DOMRect

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMQuad: объект { prototype: DOMQuad; при создании(p1: DOMPointInit?FUCKFUCK = пусто, p2: DOMPointInit?FUCKFUCK = пусто, p3: DOMPointInit?FUCKFUCK = пусто, p4: DOMPointInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromQuad(other: DOMQuadInit?FUCKFUCK = пусто): DOMQuad; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMQuad }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */

тип DOMRect = интерфейс
{
  height: Число

  width: Число

  x: Число

  y: Число
}


внешнее
/*(!) var */ DOMRect: объект { prototype: DOMRect; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, width: Число?FUCKFUCK = пусто, height: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMRect }


тип SVGRect = DOMRect

внешнее
/*(!) var */ SVGRect: /*(!) typeof DOMRect */ Объект?


тип DOMRectList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): DOMRect?FUCKFUCK

  /*(!) [index: number]: DOMRect*/
}


внешнее
/*(!) var */ DOMRectList: объект { prototype: DOMRectList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */

тип DOMRectReadOnly = интерфейс
{
  защищено 
  bottom: Число

  защищено 
  height: Число

  защищено 
  left: Число

  защищено 
  right: Число

  защищено 
  top: Число

  защищено 
  width: Число

  защищено 
  x: Число

  защищено 
  y: Число

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMRectReadOnly: объект { prototype: DOMRectReadOnly; при создании(x: Число?FUCKFUCK = пусто, y: Число?FUCKFUCK = пусто, width: Число?FUCKFUCK = пусто, height: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция fromRect(other: DOMRectInit?FUCKFUCK = пусто): DOMRectReadOnly }


/**
* A type returned by some APIs which contains a list of DOMString (strings).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringList)
*/

тип DOMStringList = интерфейс
{
  защищено 
  length: Число

  операция contains(string: Текст): ДаНет

  операция item(index: Число): Текст?FUCKFUCK

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ DOMStringList: объект { prototype: DOMStringList; при создании()/*(!) no_type */ Объект? }


/**
* Used by the dataset HTML attribute to represent data for custom attributes added to elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringMap)
*/

тип DOMStringMap = интерфейс
{
  /*(!) [name: string]: string | undefined*/
}


внешнее
/*(!) var */ DOMStringMap: объект { prototype: DOMStringMap; при создании()/*(!) no_type */ Объект? }


/**
* A set of space-separated tokens. Such a set is returned by Element.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList, HTMLAreaElement.relList, HTMLIframeElement.sandbox, or HTMLOutputElement.htmlFor. It is indexed beginning with 0 as with JavaScript Array objects. DOMTokenList is always case-sensitive.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMTokenList)
*/

тип DOMTokenList = интерфейс
{
  защищено 
  length: Число

  value: Текст

  операция toString(): Текст

  #js.МассивПараметров
  операция add(tokens: Список<Текст>)

  операция contains(token: Текст): ДаНет

  операция item(index: Число): Текст?FUCKFUCK

  #js.МассивПараметров
  операция remove(tokens: Список<Текст>)

  операция replace(token: Текст, newToken: Текст): ДаНет

  операция supports(token: Текст): ДаНет

  операция toggle(token: Текст, force: ДаНет?FUCKFUCK = пусто): ДаНет

  операция forEach(callbackfn: операция(value: Текст, key: Число, parent: DOMTokenList), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ DOMTokenList: объект { prototype: DOMTokenList; при создании()/*(!) no_type */ Объект? }


/**
* Used to hold the data that is being dragged during a drag and drop operation. It may hold one or more data items, each of one or more data types. For more information about drag and drop, see HTML Drag and Drop API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransfer)
*/

тип DataTransfer = интерфейс
{
  dropEffect: "none" | "copy" | "link" | "move"

  effectAllowed: "none" | "copy" | "copyLink" | "copyMove" | "link" | "linkMove" | "move" | "all" | "uninitialized"

  защищено 
  files: FileList

  защищено 
  items: DataTransferItemList

  защищено 
  types: ReadonlyArray<Текст>

  операция clearData(format: Текст?FUCKFUCK = пусто)

  операция getData(format: Текст): Текст

  операция setData(format: Текст, data: Текст)

  операция setDragImage(image: Element, x: Число, y: Число)
}


внешнее
/*(!) var */ DataTransfer: объект { prototype: DataTransfer; при создании()/*(!) no_type */ Объект? }


/**
* One drag data item. During a drag operation, each drag event has a dataTransfer property which contains a list of drag data items. Each item in the list is a DataTransferItem object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransferItem)
*/

тип DataTransferItem = интерфейс
{
  защищено 
  kind: Текст

  защищено 
  type: Текст

  операция getAsFile(): File?FUCKFUCK

  операция getAsString(callback: FunctionStringCallback?FUCKFUCK)

  операция webkitGetAsEntry(): FileSystemEntry?FUCKFUCK
}


внешнее
/*(!) var */ DataTransferItem: объект { prototype: DataTransferItem; при создании()/*(!) no_type */ Объект? }


/**
* A list of DataTransferItem objects representing items being dragged. During a drag operation, each DragEvent has a dataTransfer property and that property is a DataTransferItemList.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransferItemList)
*/

тип DataTransferItemList = интерфейс
{
  защищено 
  length: Число

  операция add(data: Текст, type: Текст): DataTransferItem?FUCKFUCK

  операция add(data: File): DataTransferItem?FUCKFUCK

  операция clear()

  операция remove(index: Число)

  /*(!) [index: number]: DataTransferItem*/
}


внешнее
/*(!) var */ DataTransferItemList: объект { prototype: DataTransferItemList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */

тип DecompressionStream = интерфейс
{

}


внешнее
/*(!) var */ DecompressionStream: объект { prototype: DecompressionStream; при создании(format: CompressionFormat)/*(!) no_type */ Объект? }


/**
* A delay-line; an AudioNode audio-processing module that causes a delay between the arrival of an input data and its propagation to the output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DelayNode)
*/

тип DelayNode = интерфейс
{
  защищено 
  delayTime: AudioParam
}


внешнее
/*(!) var */ DelayNode: объект { prototype: DelayNode; при создании(context: BaseAudioContext, options: DelayOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The DeviceMotionEvent provides web developers with information about the speed of changes for the device's position and orientation.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent)
*/

тип DeviceMotionEvent = интерфейс
{
  защищено 
  acceleration: DeviceMotionEventAcceleration?FUCKFUCK

  защищено 
  accelerationIncludingGravity: DeviceMotionEventAcceleration?FUCKFUCK

  защищено 
  interval: Число

  защищено 
  rotationRate: DeviceMotionEventRotationRate?FUCKFUCK
}


внешнее
/*(!) var */ DeviceMotionEvent: объект { prototype: DeviceMotionEvent; при создании(type: Текст, eventInitDict: DeviceMotionEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEventAcceleration)
*/

тип DeviceMotionEventAcceleration = интерфейс
{
  защищено 
  x: Число?FUCKFUCK

  защищено 
  y: Число?FUCKFUCK

  защищено 
  z: Число?FUCKFUCK
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEventRotationRate)
*/

тип DeviceMotionEventRotationRate = интерфейс
{
  защищено 
  alpha: Число?FUCKFUCK

  защищено 
  beta: Число?FUCKFUCK

  защищено 
  gamma: Число?FUCKFUCK
}


/**
* The DeviceOrientationEvent provides web developers with information from the physical orientation of the device running the web page.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent)
*/

тип DeviceOrientationEvent = интерфейс
{
  защищено 
  absolute: ДаНет

  защищено 
  alpha: Число?FUCKFUCK

  защищено 
  beta: Число?FUCKFUCK

  защищено 
  gamma: Число?FUCKFUCK
}


внешнее
/*(!) var */ DeviceOrientationEvent: объект { prototype: DeviceOrientationEvent; при создании(type: Текст, eventInitDict: DeviceOrientationEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип DocumentEventMap = интерфейс
{
  "DOMContentLoaded": Event

  "fullscreenchange": Event

  "fullscreenerror": Event

  "pointerlockchange": Event

  "pointerlockerror": Event

  "readystatechange": Event

  "visibilitychange": Event
}


/**
* Any web page loaded in the browser and serves as an entry point into the web page's content, which is the DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document)
*/

тип Document = интерфейс
{
  защищено 
  URL: Текст

  alinkColor: Текст

  защищено 
  all: HTMLAllCollection

  защищено 
  anchors: HTMLCollectionOf<HTMLAnchorElement>

  защищено 
  applets: HTMLCollection

  bgColor: Текст

  body: HTMLElement

  защищено 
  characterSet: Текст

  защищено 
  charset: Текст

  защищено 
  compatMode: Текст

  защищено 
  contentType: Текст

  cookie: Текст

  защищено 
  currentScript: HTMLOrSVGScriptElement?FUCKFUCK

  защищено 
  defaultView: /*(!) WindowProxy & typeof globalThis */ Объект??FUCKFUCK

  designMode: Текст

  dir: Текст

  защищено 
  doctype: DocumentType?FUCKFUCK

  защищено 
  documentElement: HTMLElement

  защищено 
  documentURI: Текст

  domain: Текст

  защищено 
  embeds: HTMLCollectionOf<HTMLEmbedElement>

  fgColor: Текст

  защищено 
  forms: HTMLCollectionOf<HTMLFormElement>

  защищено 
  fullscreen: ДаНет

  защищено 
  fullscreenEnabled: ДаНет

  защищено 
  head: HTMLHeadElement

  защищено 
  hidden: ДаНет

  защищено 
  images: HTMLCollectionOf<HTMLImageElement>

  защищено 
  implementation: DOMImplementation

  защищено 
  inputEncoding: Текст

  защищено 
  lastModified: Текст

  linkColor: Текст

  защищено 
  links: HTMLCollectionOf<HTMLAnchorElement | HTMLAreaElement>

  операция location(): Location

  операция location(href: Текст | Location)/*(!) no_type */ Объект?

  onfullscreenchange: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onfullscreenerror: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onpointerlockchange: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onpointerlockerror: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onreadystatechange: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onvisibilitychange: операция(this: Document, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ownerDocument: пусто

  защищено 
  pictureInPictureEnabled: ДаНет

  защищено 
  plugins: HTMLCollectionOf<HTMLEmbedElement>

  защищено 
  readyState: DocumentReadyState

  защищено 
  referrer: Текст

  защищено 
  rootElement: SVGSVGElement?FUCKFUCK

  защищено 
  scripts: HTMLCollectionOf<HTMLScriptElement>

  защищено 
  scrollingElement: Element?FUCKFUCK

  защищено 
  timeline: DocumentTimeline

  title: Текст

  защищено 
  visibilityState: DocumentVisibilityState

  vlinkColor: Текст

  операция adoptNode<T = Node>(node: T): T

  операция captureEvents()

  операция caretRangeFromPoint(x: Число, y: Число): Range?FUCKFUCK

  операция clear()

  операция close()

  операция createAttribute(localName: Текст): Attr

  операция createAttributeNS(namespace: Текст?FUCKFUCK, qualifiedName: Текст): Attr

  операция createCDATASection(data: Текст): CDATASection

  операция createComment(data: Текст): Comment

  операция createDocumentFragment(): DocumentFragment

  операция createElement<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(tagName: K, options: ElementCreationOptions?FUCKFUCK = пусто): /*(!) HTMLElementTagNameMap[K] */ Объект?

  операция createElement<K = /*(!) keyof HTMLElementDeprecatedTagNameMap */ Объект?>(tagName: K, options: ElementCreationOptions?FUCKFUCK = пусто): /*(!) HTMLElementDeprecatedTagNameMap[K] */ Объект?

  операция createElement(tagName: Текст, options: ElementCreationOptions?FUCKFUCK = пусто): HTMLElement

  операция createElementNS(namespaceURI: "http://www.w3.org/1999/xhtml", qualifiedName: Текст): HTMLElement

  операция createElementNS<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: K): /*(!) SVGElementTagNameMap[K] */ Объект?

  операция createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: Текст): SVGElement

  операция createElementNS<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: K): /*(!) MathMLElementTagNameMap[K] */ Объект?

  операция createElementNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: Текст): MathMLElement

  операция createElementNS(namespaceURI: Текст?FUCKFUCK, qualifiedName: Текст, options: ElementCreationOptions?FUCKFUCK = пусто): Element

  операция createElementNS(namespace: Текст?FUCKFUCK, qualifiedName: Текст, options: Текст | ElementCreationOptions | пусто = пусто): Element

  операция createEvent(eventInterface: "AnimationEvent"): AnimationEvent

  операция createEvent(eventInterface: "AnimationPlaybackEvent"): AnimationPlaybackEvent

  операция createEvent(eventInterface: "AudioProcessingEvent"): AudioProcessingEvent

  операция createEvent(eventInterface: "BeforeUnloadEvent"): BeforeUnloadEvent

  операция createEvent(eventInterface: "BlobEvent"): BlobEvent

  операция createEvent(eventInterface: "ClipboardEvent"): ClipboardEvent

  операция createEvent(eventInterface: "CloseEvent"): CloseEvent

  операция createEvent(eventInterface: "CompositionEvent"): CompositionEvent

  операция createEvent(eventInterface: "CustomEvent"): CustomEvent

  операция createEvent(eventInterface: "DeviceMotionEvent"): DeviceMotionEvent

  операция createEvent(eventInterface: "DeviceOrientationEvent"): DeviceOrientationEvent

  операция createEvent(eventInterface: "DragEvent"): DragEvent

  операция createEvent(eventInterface: "ErrorEvent"): ErrorEvent

  операция createEvent(eventInterface: "Event"): Event

  операция createEvent(eventInterface: "Events"): Event

  операция createEvent(eventInterface: "FocusEvent"): FocusEvent

  операция createEvent(eventInterface: "FontFaceSetLoadEvent"): FontFaceSetLoadEvent

  операция createEvent(eventInterface: "FormDataEvent"): FormDataEvent

  операция createEvent(eventInterface: "GamepadEvent"): GamepadEvent

  операция createEvent(eventInterface: "HashChangeEvent"): HashChangeEvent

  операция createEvent(eventInterface: "IDBVersionChangeEvent"): IDBVersionChangeEvent

  операция createEvent(eventInterface: "InputEvent"): InputEvent

  операция createEvent(eventInterface: "KeyboardEvent"): KeyboardEvent

  операция createEvent(eventInterface: "MIDIConnectionEvent"): MIDIConnectionEvent

  операция createEvent(eventInterface: "MIDIMessageEvent"): MIDIMessageEvent

  операция createEvent(eventInterface: "MediaEncryptedEvent"): MediaEncryptedEvent

  операция createEvent(eventInterface: "MediaKeyMessageEvent"): MediaKeyMessageEvent

  операция createEvent(eventInterface: "MediaQueryListEvent"): MediaQueryListEvent

  операция createEvent(eventInterface: "MediaStreamTrackEvent"): MediaStreamTrackEvent

  операция createEvent(eventInterface: "MessageEvent"): MessageEvent

  операция createEvent(eventInterface: "MouseEvent"): MouseEvent

  операция createEvent(eventInterface: "MouseEvents"): MouseEvent

  операция createEvent(eventInterface: "MutationEvent"): MutationEvent

  операция createEvent(eventInterface: "MutationEvents"): MutationEvent

  операция createEvent(eventInterface: "OfflineAudioCompletionEvent"): OfflineAudioCompletionEvent

  операция createEvent(eventInterface: "PageTransitionEvent"): PageTransitionEvent

  операция createEvent(eventInterface: "PaymentMethodChangeEvent"): PaymentMethodChangeEvent

  операция createEvent(eventInterface: "PaymentRequestUpdateEvent"): PaymentRequestUpdateEvent

  операция createEvent(eventInterface: "PictureInPictureEvent"): PictureInPictureEvent

  операция createEvent(eventInterface: "PointerEvent"): PointerEvent

  операция createEvent(eventInterface: "PopStateEvent"): PopStateEvent

  операция createEvent(eventInterface: "ProgressEvent"): ProgressEvent

  операция createEvent(eventInterface: "PromiseRejectionEvent"): PromiseRejectionEvent

  операция createEvent(eventInterface: "RTCDTMFToneChangeEvent"): RTCDTMFToneChangeEvent

  операция createEvent(eventInterface: "RTCDataChannelEvent"): RTCDataChannelEvent

  операция createEvent(eventInterface: "RTCErrorEvent"): RTCErrorEvent

  операция createEvent(eventInterface: "RTCPeerConnectionIceErrorEvent"): RTCPeerConnectionIceErrorEvent

  операция createEvent(eventInterface: "RTCPeerConnectionIceEvent"): RTCPeerConnectionIceEvent

  операция createEvent(eventInterface: "RTCTrackEvent"): RTCTrackEvent

  операция createEvent(eventInterface: "SecurityPolicyViolationEvent"): SecurityPolicyViolationEvent

  операция createEvent(eventInterface: "SpeechSynthesisErrorEvent"): SpeechSynthesisErrorEvent

  операция createEvent(eventInterface: "SpeechSynthesisEvent"): SpeechSynthesisEvent

  операция createEvent(eventInterface: "StorageEvent"): StorageEvent

  операция createEvent(eventInterface: "SubmitEvent"): SubmitEvent

  операция createEvent(eventInterface: "ToggleEvent"): ToggleEvent

  операция createEvent(eventInterface: "TouchEvent"): TouchEvent

  операция createEvent(eventInterface: "TrackEvent"): TrackEvent

  операция createEvent(eventInterface: "TransitionEvent"): TransitionEvent

  операция createEvent(eventInterface: "UIEvent"): UIEvent

  операция createEvent(eventInterface: "UIEvents"): UIEvent

  операция createEvent(eventInterface: "WebGLContextEvent"): WebGLContextEvent

  операция createEvent(eventInterface: "WheelEvent"): WheelEvent

  операция createEvent(eventInterface: Текст): Event

  операция createNodeIterator(root: Node, whatToShow: Число?FUCKFUCK = пусто, filter: NodeFilter?FUCKFUCK = пусто): NodeIterator

  операция createProcessingInstruction(target: Текст, data: Текст): ProcessingInstruction

  операция createRange(): Range

  операция createTextNode(data: Текст): Text

  операция createTreeWalker(root: Node, whatToShow: Число?FUCKFUCK = пусто, filter: NodeFilter?FUCKFUCK = пусто): TreeWalker

  операция execCommand(commandId: Текст, showUI: ДаНет?FUCKFUCK = пусто, value: Текст?FUCKFUCK = пусто): ДаНет

  операция exitFullscreen(): Promise<Ничего>

  операция exitPictureInPicture(): Promise<Ничего>

  операция exitPointerLock()

  операция getElementById(elementId: Текст): HTMLElement?FUCKFUCK

  операция getElementsByClassName(classNames: Текст): HTMLCollectionOf<Element>

  операция getElementsByName(elementName: Текст): NodeListOf<HTMLElement>

  операция getElementsByTagName<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) HTMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof HTMLElementDeprecatedTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) HTMLElementDeprecatedTagNameMap[K] */ Объект?>

  операция getElementsByTagName(qualifiedName: Текст): HTMLCollectionOf<Element>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: Текст): HTMLCollectionOf<HTMLElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: Текст): HTMLCollectionOf<SVGElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: Текст): HTMLCollectionOf<MathMLElement>

  операция getElementsByTagNameNS(namespace: Текст?FUCKFUCK, localName: Текст): HTMLCollectionOf<Element>

  операция getSelection(): Selection?FUCKFUCK

  операция hasFocus(): ДаНет

  операция hasStorageAccess(): Promise<ДаНет>

  операция importNode<T = Node>(node: T, deep: ДаНет?FUCKFUCK = пусто): T

  операция open(unused1: Текст?FUCKFUCK = пусто, unused2: Текст?FUCKFUCK = пусто): Document

  операция open(url: Текст | URL, name: Текст, features: Текст): WindowProxy?FUCKFUCK

  операция queryCommandEnabled(commandId: Текст): ДаНет

  операция queryCommandIndeterm(commandId: Текст): ДаНет

  операция queryCommandState(commandId: Текст): ДаНет

  операция queryCommandSupported(commandId: Текст): ДаНет

  операция queryCommandValue(commandId: Текст): Текст

  операция releaseEvents()

  операция requestStorageAccess(): Promise<Ничего>

  #js.МассивПараметров
  операция write(text: Список<Текст>)

  #js.МассивПараметров
  операция writeln(text: Список<Текст>)

  операция addEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: Document, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: Document, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Document: объект { prototype: Document; при создании()/*(!) no_type */ Объект? }


/**
* A minimal document object that has no parent. It is used as a lightweight version of Document that stores a segment of a document structure comprised of nodes just like a standard document. The key difference is that because the document fragment isn't part of the active document tree structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentFragment)
*/

тип DocumentFragment = интерфейс
{
  защищено 
  ownerDocument: Document

  операция getElementById(elementId: Текст): HTMLElement?FUCKFUCK
}


внешнее
/*(!) var */ DocumentFragment: объект { prototype: DocumentFragment; при создании()/*(!) no_type */ Объект? }


тип DocumentOrShadowRoot = интерфейс
{
  защищено 
  activeElement: Element?FUCKFUCK

  adoptedStyleSheets: Список<CSSStyleSheet>

  защищено 
  fullscreenElement: Element?FUCKFUCK

  защищено 
  pictureInPictureElement: Element?FUCKFUCK

  защищено 
  pointerLockElement: Element?FUCKFUCK

  защищено 
  styleSheets: StyleSheetList

  операция elementFromPoint(x: Число, y: Число): Element?FUCKFUCK

  операция elementsFromPoint(x: Число, y: Число): Список<Element>

  операция getAnimations(): Список<Animation>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentTimeline) */

тип DocumentTimeline = интерфейс
{

}


внешнее
/*(!) var */ DocumentTimeline: объект { prototype: DocumentTimeline; при создании(options: DocumentTimelineOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A Node containing a doctype.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentType)
*/

тип DocumentType = интерфейс
{
  защищено 
  name: Текст

  защищено 
  ownerDocument: Document

  защищено 
  publicId: Текст

  защищено 
  systemId: Текст
}


внешнее
/*(!) var */ DocumentType: объект { prototype: DocumentType; при создании()/*(!) no_type */ Объект? }


/**
* A DOM event that represents a drag and drop interaction. The user initiates a drag by placing a pointer device (such as a mouse) on the touch surface and then dragging the pointer to a new location (such as another DOM element). Applications are free to interpret a drag and drop interaction in an application-specific way.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DragEvent)
*/

тип DragEvent = интерфейс
{
  защищено 
  dataTransfer: DataTransfer?FUCKFUCK
}


внешнее
/*(!) var */ DragEvent: объект { prototype: DragEvent; при создании(type: Текст, eventInitDict: DragEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Inherits properties from its parent, AudioNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DynamicsCompressorNode)
*/

тип DynamicsCompressorNode = интерфейс
{
  защищено 
  attack: AudioParam

  защищено 
  knee: AudioParam

  защищено 
  ratio: AudioParam

  защищено 
  reduction: Число

  защищено 
  release: AudioParam

  защищено 
  threshold: AudioParam
}


внешнее
/*(!) var */ DynamicsCompressorNode: объект { prototype: DynamicsCompressorNode; при создании(context: BaseAudioContext, options: DynamicsCompressorOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_blend_minmax) */

тип EXT_blend_minmax = интерфейс
{
  защищено 
  MIN_EXT: 0x8007

  защищено 
  MAX_EXT: 0x8008
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_float) */

тип EXT_color_buffer_float = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_half_float) */

тип EXT_color_buffer_half_float = интерфейс
{
  защищено 
  RGBA16F_EXT: 0x881A

  защищено 
  RGB16F_EXT: 0x881B

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_float_blend) */

тип EXT_float_blend = интерфейс
{

}


/**
* The EXT_frag_depth extension is part of the WebGL API and enables to set a depth value of a fragment from within the fragment shader.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_frag_depth)
*/

тип EXT_frag_depth = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_sRGB) */

тип EXT_sRGB = интерфейс
{
  защищено 
  SRGB_EXT: 0x8C40

  защищено 
  SRGB_ALPHA_EXT: 0x8C42

  защищено 
  SRGB8_ALPHA8_EXT: 0x8C43

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_shader_texture_lod) */

тип EXT_shader_texture_lod = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_bptc) */

тип EXT_texture_compression_bptc = интерфейс
{
  защищено 
  COMPRESSED_RGBA_BPTC_UNORM_EXT: 0x8E8C

  защищено 
  COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: 0x8E8D

  защищено 
  COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: 0x8E8E

  защищено 
  COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: 0x8E8F
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_rgtc) */

тип EXT_texture_compression_rgtc = интерфейс
{
  защищено 
  COMPRESSED_RED_RGTC1_EXT: 0x8DBB

  защищено 
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8DBC

  защищено 
  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8DBD

  защищено 
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8DBE
}


/**
* The EXT_texture_filter_anisotropic extension is part of the WebGL API and exposes two constants for anisotropic filtering (AF).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_filter_anisotropic)
*/

тип EXT_texture_filter_anisotropic = интерфейс
{
  защищено 
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE

  защищено 
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_norm16) */

тип EXT_texture_norm16 = интерфейс
{
  защищено 
  R16_EXT: 0x822A

  защищено 
  RG16_EXT: 0x822C

  защищено 
  RGB16_EXT: 0x8054

  защищено 
  RGBA16_EXT: 0x805B

  защищено 
  R16_SNORM_EXT: 0x8F98

  защищено 
  RG16_SNORM_EXT: 0x8F99

  защищено 
  RGB16_SNORM_EXT: 0x8F9A

  защищено 
  RGBA16_SNORM_EXT: 0x8F9B
}


тип ElementEventMap = интерфейс
{
  "fullscreenchange": Event

  "fullscreenerror": Event
}


/**
* Element is the most general base class from which all objects in a Document inherit. It only has methods and properties common to all kinds of elements. More specific classes inherit from Element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element)
*/

тип Element = интерфейс
{
  защищено 
  attributes: NamedNodeMap

  защищено 
  classList: DOMTokenList

  className: Текст

  защищено 
  clientHeight: Число

  защищено 
  clientLeft: Число

  защищено 
  clientTop: Число

  защищено 
  clientWidth: Число

  id: Текст

  защищено 
  localName: Текст

  защищено 
  namespaceURI: Текст?FUCKFUCK

  onfullscreenchange: операция(this: Element, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onfullscreenerror: операция(this: Element, ev: Event): /*(!) any */ Объект??FUCKFUCK

  outerHTML: Текст

  защищено 
  ownerDocument: Document

  защищено 
  part: DOMTokenList

  защищено 
  prefix: Текст?FUCKFUCK

  защищено 
  scrollHeight: Число

  scrollLeft: Число

  scrollTop: Число

  защищено 
  scrollWidth: Число

  защищено 
  shadowRoot: ShadowRoot?FUCKFUCK

  slot: Текст

  защищено 
  tagName: Текст

  операция attachShadow(init: ShadowRootInit): ShadowRoot

  операция checkVisibility(options: CheckVisibilityOptions?FUCKFUCK = пусто): ДаНет

  операция closest<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(selector: K): /*(!) HTMLElementTagNameMap[K] */ Объект??FUCKFUCK

  операция closest<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selector: K): /*(!) SVGElementTagNameMap[K] */ Объект??FUCKFUCK

  операция closest<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selector: K): /*(!) MathMLElementTagNameMap[K] */ Объект??FUCKFUCK

  операция closest<E = Element>(selectors: Текст): E?FUCKFUCK

  операция computedStyleMap(): StylePropertyMapReadOnly

  операция getAttribute(qualifiedName: Текст): Текст?FUCKFUCK

  операция getAttributeNS(namespace: Текст?FUCKFUCK, localName: Текст): Текст?FUCKFUCK

  операция getAttributeNames(): Список<Текст>

  операция getAttributeNode(qualifiedName: Текст): Attr?FUCKFUCK

  операция getAttributeNodeNS(namespace: Текст?FUCKFUCK, localName: Текст): Attr?FUCKFUCK

  операция getBoundingClientRect(): DOMRect

  операция getClientRects(): DOMRectList

  операция getElementsByClassName(classNames: Текст): HTMLCollectionOf<Element>

  операция getElementsByTagName<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) HTMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof HTMLElementDeprecatedTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) HTMLElementDeprecatedTagNameMap[K] */ Объект?>

  операция getElementsByTagName(qualifiedName: Текст): HTMLCollectionOf<Element>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1999/xhtml", localName: Текст): HTMLCollectionOf<HTMLElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: Текст): HTMLCollectionOf<SVGElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: Текст): HTMLCollectionOf<MathMLElement>

  операция getElementsByTagNameNS(namespace: Текст?FUCKFUCK, localName: Текст): HTMLCollectionOf<Element>

  операция hasAttribute(qualifiedName: Текст): ДаНет

  операция hasAttributeNS(namespace: Текст?FUCKFUCK, localName: Текст): ДаНет

  операция hasAttributes(): ДаНет

  операция hasPointerCapture(pointerId: Число): ДаНет

  операция insertAdjacentElement(where: InsertPosition, element: Element): Element?FUCKFUCK

  операция insertAdjacentHTML(position: InsertPosition, text: Текст)

  операция insertAdjacentText(where: InsertPosition, data: Текст)

  операция matches(selectors: Текст): ДаНет

  операция releasePointerCapture(pointerId: Число)

  операция removeAttribute(qualifiedName: Текст)

  операция removeAttributeNS(namespace: Текст?FUCKFUCK, localName: Текст)

  операция removeAttributeNode(attr: Attr): Attr

  операция requestFullscreen(options: FullscreenOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция requestPointerLock()

  операция scroll(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scroll(x: Число, y: Число)

  операция scrollBy(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scrollBy(x: Число, y: Число)

  операция scrollIntoView(arg: ДаНет | ScrollIntoViewOptions | пусто = пусто)

  операция scrollTo(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scrollTo(x: Число, y: Число)

  операция setAttribute(qualifiedName: Текст, value: Текст)

  операция setAttributeNS(namespace: Текст?FUCKFUCK, qualifiedName: Текст, value: Текст)

  операция setAttributeNode(attr: Attr): Attr?FUCKFUCK

  операция setAttributeNodeNS(attr: Attr): Attr?FUCKFUCK

  операция setPointerCapture(pointerId: Число)

  операция toggleAttribute(qualifiedName: Текст, force: ДаНет?FUCKFUCK = пусто): ДаНет

  операция webkitMatchesSelector(selectors: Текст): ДаНет

  операция addEventListener<K = /*(!) keyof ElementEventMap */ Объект?>(type: K, listener: операция(this: Element, ev: /*(!) ElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ElementEventMap */ Объект?>(type: K, listener: операция(this: Element, ev: /*(!) ElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Element: объект { prototype: Element; при создании()/*(!) no_type */ Объект? }


тип ElementCSSInlineStyle = интерфейс
{
  защищено 
  attributeStyleMap: StylePropertyMap

  защищено 
  style: CSSStyleDeclaration
}


тип ElementContentEditable = интерфейс
{
  contentEditable: Текст

  enterKeyHint: Текст

  inputMode: Текст

  защищено 
  isContentEditable: ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ElementInternals) */

тип ElementInternals = интерфейс
{
  защищено 
  form: HTMLFormElement?FUCKFUCK

  защищено 
  labels: NodeList

  защищено 
  shadowRoot: ShadowRoot?FUCKFUCK

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setFormValue(value: File | Текст | FormData | пусто, state: File | Текст | FormData | пусто | пусто = пусто)

  операция setValidity(flags: ValidityStateFlags?FUCKFUCK = пусто, message: Текст?FUCKFUCK = пусто, anchor: HTMLElement?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ ElementInternals: объект { prototype: ElementInternals; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EncodedVideoChunk) */

тип EncodedVideoChunk = интерфейс
{
  защищено 
  byteLength: Число

  защищено 
  duration: Число?FUCKFUCK

  защищено 
  timestamp: Число

  защищено 
  type: EncodedVideoChunkType

  операция copyTo(destination: BufferSource)
}


внешнее
/*(!) var */ EncodedVideoChunk: объект { prototype: EncodedVideoChunk; при создании(init: EncodedVideoChunkInit)/*(!) no_type */ Объект? }


/**
* Events providing information related to errors in scripts or in files.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)
*/

тип ErrorEvent = интерфейс
{
  защищено 
  colno: Число

  защищено 
  error: /*(!) any */ Объект?

  защищено 
  filename: Текст

  защищено 
  lineno: Число

  защищено 
  message: Текст
}


внешнее
/*(!) var */ ErrorEvent: объект { prototype: ErrorEvent; при создании(type: Текст, eventInitDict: ErrorEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An event which takes place in the DOM.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)
*/

тип Event = интерфейс
{
  защищено 
  bubbles: ДаНет

  cancelBubble: ДаНет

  защищено 
  cancelable: ДаНет

  защищено 
  composed: ДаНет

  защищено 
  currentTarget: EventTarget?FUCKFUCK

  защищено 
  defaultPrevented: ДаНет

  защищено 
  eventPhase: Число

  защищено 
  isTrusted: ДаНет

  returnValue: ДаНет

  защищено 
  srcElement: EventTarget?FUCKFUCK

  защищено 
  target: EventTarget?FUCKFUCK

  защищено 
  timeStamp: DOMHighResTimeStamp

  защищено 
  type: Текст

  операция composedPath(): Список<EventTarget>

  операция initEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто)

  операция preventDefault()

  операция stopImmediatePropagation()

  операция stopPropagation()

  защищено 
  NONE: 0

  защищено 
  CAPTURING_PHASE: 1

  защищено 
  AT_TARGET: 2

  защищено 
  BUBBLING_PHASE: 3
}


внешнее
/*(!) var */ Event: объект { prototype: Event; при создании(type: Текст, eventInitDict: EventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  NONE: 0; защищено  CAPTURING_PHASE: 1; защищено  AT_TARGET: 2; защищено  BUBBLING_PHASE: 3 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventCounts) */

тип EventCounts = интерфейс
{
  операция forEach(callbackfn: операция(value: Число, key: Текст, parent: EventCounts), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ EventCounts: объект { prototype: EventCounts; при создании()/*(!) no_type */ Объект? }


тип EventListener = интерфейс
{
  /*(!) (evt: Event): void*/
}


тип EventListenerObject = интерфейс
{
  операция handleEvent(object: Event)
}


тип EventSourceEventMap = интерфейс
{
  "error": Event

  "message": MessageEvent

  "open": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource) */

тип EventSource = интерфейс
{
  onerror: операция(this: EventSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: EventSource, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onopen: операция(this: EventSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: Число

  защищено 
  url: Текст

  защищено 
  withCredentials: ДаНет

  операция close()

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSED: 2

  операция addEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ EventSource: объект { prototype: EventSource; при создании(url: Текст | URL, eventSourceInitDict: EventSourceInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSED: 2 }


/**
* EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)
*/

тип EventTarget = интерфейс
{
  операция addEventListener(type: Текст, callback: EventListenerOrEventListenerObject?FUCKFUCK, options: AddEventListenerOptions | ДаНет | пусто = пусто)

  операция dispatchEvent(event: Event): ДаНет

  операция removeEventListener(type: Текст, callback: EventListenerOrEventListenerObject?FUCKFUCK, options: EventListenerOptions | ДаНет | пусто = пусто)
}


внешнее
/*(!) var */ EventTarget: объект { prototype: EventTarget; при создании()/*(!) no_type */ Объект? }


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/External)
*/

тип External = интерфейс
{
  операция AddSearchProvider()

  операция IsSearchProviderInstalled()
}


/** @deprecated */

внешнее
/*(!) var */ External: объект { prototype: External; при создании()/*(!) no_type */ Объект? }


/**
* Provides information about files and allows JavaScript in a web page to access their content.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)
*/

тип File = интерфейс
{
  защищено 
  lastModified: Число

  защищено 
  name: Текст

  защищено 
  webkitRelativePath: Текст
}


внешнее
/*(!) var */ File: объект { prototype: File; при создании(fileBits: Список<BlobPart>, fileName: Текст, options: FilePropertyBag?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An object of this type is returned by the files property of the HTML <input> element; this lets you access the list of files selected with the <input type="file"> element. It's also used for a list of files dropped into web content when using the drag and drop API; see the DataTransfer object for details on this usage.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileList)
*/

тип FileList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): File?FUCKFUCK

  /*(!) [index: number]: File*/
}


внешнее
/*(!) var */ FileList: объект { prototype: FileList; при создании()/*(!) no_type */ Объект? }


тип FileReaderEventMap = интерфейс
{
  "abort": ProgressEvent<FileReader>

  "error": ProgressEvent<FileReader>

  "load": ProgressEvent<FileReader>

  "loadend": ProgressEvent<FileReader>

  "loadstart": ProgressEvent<FileReader>

  "progress": ProgressEvent<FileReader>
}


/**
* Lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileReader)
*/

тип FileReader = интерфейс
{
  защищено 
  error: DOMException?FUCKFUCK

  onabort: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onload: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onloadend: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onloadstart: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  onprogress: операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: /*(!) typeof FileReader.EMPTY */ Объект? | /*(!) typeof FileReader.LOADING */ Объект? | /*(!) typeof FileReader.DONE */ Объект?

  защищено 
  result: Текст | ArrayBuffer | пусто

  операция abort()

  операция readAsArrayBuffer(blob: Blob)

  операция readAsBinaryString(blob: Blob)

  операция readAsDataURL(blob: Blob)

  операция readAsText(blob: Blob, encoding: Текст?FUCKFUCK = пусто)

  защищено 
  EMPTY: 0

  защищено 
  LOADING: 1

  защищено 
  DONE: 2

  операция addEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ FileReader: объект { prototype: FileReader; при создании()/*(!) no_type */ Объект?; защищено  EMPTY: 0; защищено  LOADING: 1; защищено  DONE: 2 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystem) */

тип FileSystem = интерфейс
{
  защищено 
  name: Текст

  защищено 
  root: FileSystemDirectoryEntry
}


внешнее
/*(!) var */ FileSystem: объект { prototype: FileSystem; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryEntry) */

тип FileSystemDirectoryEntry = интерфейс
{
  операция createReader(): FileSystemDirectoryReader

  операция getDirectory(path: Текст?FUCKFUCK = пусто, options: FileSystemFlags?FUCKFUCK = пусто, successCallback: FileSystemEntryCallback?FUCKFUCK = пусто, errorCallback: ErrorCallback?FUCKFUCK = пусто)

  операция getFile(path: Текст?FUCKFUCK = пусто, options: FileSystemFlags?FUCKFUCK = пусто, successCallback: FileSystemEntryCallback?FUCKFUCK = пусто, errorCallback: ErrorCallback?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FileSystemDirectoryEntry: объект { prototype: FileSystemDirectoryEntry; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryHandle)
*/

тип FileSystemDirectoryHandle = интерфейс
{
  защищено 
  kind: "directory"

  операция getDirectoryHandle(name: Текст, options: FileSystemGetDirectoryOptions?FUCKFUCK = пусто): Promise<FileSystemDirectoryHandle>

  операция getFileHandle(name: Текст, options: FileSystemGetFileOptions?FUCKFUCK = пусто): Promise<FileSystemFileHandle>

  операция removeEntry(name: Текст, options: FileSystemRemoveOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция resolve(possibleDescendant: FileSystemHandle): Promise<Список<Текст>?FUCKFUCK>
}


внешнее
/*(!) var */ FileSystemDirectoryHandle: объект { prototype: FileSystemDirectoryHandle; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryReader) */

тип FileSystemDirectoryReader = интерфейс
{
  операция readEntries(successCallback: FileSystemEntriesCallback, errorCallback: ErrorCallback?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FileSystemDirectoryReader: объект { prototype: FileSystemDirectoryReader; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemEntry) */

тип FileSystemEntry = интерфейс
{
  защищено 
  filesystem: FileSystem

  защищено 
  fullPath: Текст

  защищено 
  isDirectory: ДаНет

  защищено 
  isFile: ДаНет

  защищено 
  name: Текст

  операция getParent(successCallback: FileSystemEntryCallback?FUCKFUCK = пусто, errorCallback: ErrorCallback?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FileSystemEntry: объект { prototype: FileSystemEntry; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemFileEntry) */

тип FileSystemFileEntry = интерфейс
{
  операция file(successCallback: FileCallback, errorCallback: ErrorCallback?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FileSystemFileEntry: объект { prototype: FileSystemFileEntry; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemFileHandle)
*/

тип FileSystemFileHandle = интерфейс
{
  защищено 
  kind: "file"

  операция createWritable(options: FileSystemCreateWritableOptions?FUCKFUCK = пусто): Promise<FileSystemWritableFileStream>

  операция getFile(): Promise<File>
}


внешнее
/*(!) var */ FileSystemFileHandle: объект { prototype: FileSystemFileHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemHandle)
*/

тип FileSystemHandle = интерфейс
{
  защищено 
  kind: FileSystemHandleKind

  защищено 
  name: Текст

  операция isSameEntry(other: FileSystemHandle): Promise<ДаНет>
}


внешнее
/*(!) var */ FileSystemHandle: объект { prototype: FileSystemHandle; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemWritableFileStream)
*/

тип FileSystemWritableFileStream = интерфейс
{
  операция seek(position: Число): Promise<Ничего>

  операция truncate(size: Число): Promise<Ничего>

  операция write(data: FileSystemWriteChunkType): Promise<Ничего>
}


внешнее
/*(!) var */ FileSystemWritableFileStream: объект { prototype: FileSystemWritableFileStream; при создании()/*(!) no_type */ Объект? }


/**
* Focus-related events like focus, blur, focusin, or focusout.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FocusEvent)
*/

тип FocusEvent = интерфейс
{
  защищено 
  relatedTarget: EventTarget?FUCKFUCK
}


внешнее
/*(!) var */ FocusEvent: объект { prototype: FocusEvent; при создании(type: Текст, eventInitDict: FocusEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFace) */

тип FontFace = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  family: Текст

  featureSettings: Текст

  lineGapOverride: Текст

  защищено 
  loaded: Promise<FontFace>

  защищено 
  status: FontFaceLoadStatus

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant: Текст

  weight: Текст

  операция load(): Promise<FontFace>
}


внешнее
/*(!) var */ FontFace: объект { prototype: FontFace; при создании(family: Текст, source: Текст | BinaryData, descriptors: FontFaceDescriptors?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип FontFaceSetEventMap = интерфейс
{
  "loading": Event

  "loadingdone": Event

  "loadingerror": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSet) */

тип FontFaceSet = интерфейс
{
  onloading: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadingdone: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadingerror: операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ready: Promise<FontFaceSet>

  защищено 
  status: FontFaceSetLoadStatus

  операция check(font: Текст, text: Текст?FUCKFUCK = пусто): ДаНет

  операция load(font: Текст, text: Текст?FUCKFUCK = пусто): Promise<Список<FontFace>>

  операция forEach(callbackfn: операция(value: FontFace, key: FontFace, parent: FontFaceSet), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ FontFaceSet: объект { prototype: FontFaceSet; при создании(initialFaces: Список<FontFace>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSetLoadEvent) */

тип FontFaceSetLoadEvent = интерфейс
{
  защищено 
  fontfaces: ReadonlyArray<FontFace>
}


внешнее
/*(!) var */ FontFaceSetLoadEvent: объект { prototype: FontFaceSetLoadEvent; при создании(type: Текст, eventInitDict: FontFaceSetLoadEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип FontFaceSource = интерфейс
{
  защищено 
  fonts: FontFaceSet
}


/**
* Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)
*/

тип FormData = интерфейс
{
  операция append(name: Текст, value: Текст | Blob)

  операция append(name: Текст, value: Текст)

  операция append(name: Текст, blobValue: Blob, filename: Текст?FUCKFUCK = пусто)

  операция delete(name: Текст)

  операция get(name: Текст): FormDataEntryValue?FUCKFUCK

  операция getAll(name: Текст): Список<FormDataEntryValue>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Текст | Blob)

  операция set(name: Текст, value: Текст)

  операция set(name: Текст, blobValue: Blob, filename: Текст?FUCKFUCK = пусто)

  операция forEach(callbackfn: операция(value: FormDataEntryValue, key: Текст, parent: FormData), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ FormData: объект { prototype: FormData; при создании(form: HTMLFormElement?FUCKFUCK = пусто, submitter: HTMLElement?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormDataEvent) */

тип FormDataEvent = интерфейс
{
  защищено 
  formData: FormData
}


внешнее
/*(!) var */ FormDataEvent: объект { prototype: FormDataEvent; при создании(type: Текст, eventInitDict: FormDataEventInit)/*(!) no_type */ Объект? }


/**
* A change in volume. It is an AudioNode audio-processing module that causes a given gain to be applied to the input data before its propagation to the output. A GainNode always has exactly one input and one output, both with the same number of channels.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GainNode)
*/

тип GainNode = интерфейс
{
  защищено 
  gain: AudioParam
}


внешнее
/*(!) var */ GainNode: объект { prototype: GainNode; при создании(context: BaseAudioContext, options: GainOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Gamepad API interface defines an individual gamepad or other controller, allowing access to information such as button presses, axis positions, and id.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Gamepad)
*/

тип Gamepad = интерфейс
{
  защищено 
  axes: ReadonlyArray<Число>

  защищено 
  buttons: ReadonlyArray<GamepadButton>

  защищено 
  connected: ДаНет

  защищено 
  hapticActuators: ReadonlyArray<GamepadHapticActuator>

  защищено 
  id: Текст

  защищено 
  index: Число

  защищено 
  mapping: GamepadMappingType

  защищено 
  timestamp: DOMHighResTimeStamp

  защищено 
  vibrationActuator: GamepadHapticActuator?FUCKFUCK
}


внешнее
/*(!) var */ Gamepad: объект { prototype: Gamepad; при создании()/*(!) no_type */ Объект? }


/**
* An individual button of a gamepad or other controller, allowing access to the current state of different types of buttons available on the control device.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadButton)
*/

тип GamepadButton = интерфейс
{
  защищено 
  pressed: ДаНет

  защищено 
  touched: ДаНет

  защищено 
  value: Число
}


внешнее
/*(!) var */ GamepadButton: объект { prototype: GamepadButton; при создании()/*(!) no_type */ Объект? }


/**
* This Gamepad API interface contains references to gamepads connected to the system, which is what the gamepad events Window.gamepadconnected and Window.gamepaddisconnected are fired in response to.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadEvent)
*/

тип GamepadEvent = интерфейс
{
  защищено 
  gamepad: Gamepad
}


внешнее
/*(!) var */ GamepadEvent: объект { prototype: GamepadEvent; при создании(type: Текст, eventInitDict: GamepadEventInit)/*(!) no_type */ Объект? }


/**
* This Gamepad API interface represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadHapticActuator)
*/

тип GamepadHapticActuator = интерфейс
{
  защищено 
  type: GamepadHapticActuatorType

  операция playEffect(type: GamepadHapticEffectType, params: GamepadEffectParameters?FUCKFUCK = пусто): Promise<GamepadHapticsResult>

  операция reset(): Promise<GamepadHapticsResult>
}


внешнее
/*(!) var */ GamepadHapticActuator: объект { prototype: GamepadHapticActuator; при создании()/*(!) no_type */ Объект? }


тип GenericTransformStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


/**
* An object able to programmatically obtain the position of the device. It gives Web content access to the location of the device. This allows a Web site or app to offer customized results based on the user's location.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Geolocation)
*/

тип Geolocation = интерфейс
{
  операция clearWatch(watchId: Число)

  операция getCurrentPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback?FUCKFUCK = пусто, options: PositionOptions?FUCKFUCK = пусто)

  операция watchPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback?FUCKFUCK = пусто, options: PositionOptions?FUCKFUCK = пусто): Число
}


внешнее
/*(!) var */ Geolocation: объект { prototype: Geolocation; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates)
*/

тип GeolocationCoordinates = интерфейс
{
  защищено 
  accuracy: Число

  защищено 
  altitude: Число?FUCKFUCK

  защищено 
  altitudeAccuracy: Число?FUCKFUCK

  защищено 
  heading: Число?FUCKFUCK

  защищено 
  latitude: Число

  защищено 
  longitude: Число

  защищено 
  speed: Число?FUCKFUCK
}


внешнее
/*(!) var */ GeolocationCoordinates: объект { prototype: GeolocationCoordinates; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationPosition)
*/

тип GeolocationPosition = интерфейс
{
  защищено 
  coords: GeolocationCoordinates

  защищено 
  timestamp: EpochTimeStamp
}


внешнее
/*(!) var */ GeolocationPosition: объект { prototype: GeolocationPosition; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationPositionError) */

тип GeolocationPositionError = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  PERMISSION_DENIED: 1

  защищено 
  POSITION_UNAVAILABLE: 2

  защищено 
  TIMEOUT: 3
}


внешнее
/*(!) var */ GeolocationPositionError: объект { prototype: GeolocationPositionError; при создании()/*(!) no_type */ Объект?; защищено  PERMISSION_DENIED: 1; защищено  POSITION_UNAVAILABLE: 2; защищено  TIMEOUT: 3 }


тип GlobalEventHandlersEventMap = интерфейс
{
  "abort": UIEvent

  "animationcancel": AnimationEvent

  "animationend": AnimationEvent

  "animationiteration": AnimationEvent

  "animationstart": AnimationEvent

  "auxclick": MouseEvent

  "beforeinput": InputEvent

  "blur": FocusEvent

  "cancel": Event

  "canplay": Event

  "canplaythrough": Event

  "change": Event

  "click": MouseEvent

  "close": Event

  "compositionend": CompositionEvent

  "compositionstart": CompositionEvent

  "compositionupdate": CompositionEvent

  "contextmenu": MouseEvent

  "copy": ClipboardEvent

  "cuechange": Event

  "cut": ClipboardEvent

  "dblclick": MouseEvent

  "drag": DragEvent

  "dragend": DragEvent

  "dragenter": DragEvent

  "dragleave": DragEvent

  "dragover": DragEvent

  "dragstart": DragEvent

  "drop": DragEvent

  "durationchange": Event

  "emptied": Event

  "ended": Event

  "error": ErrorEvent

  "focus": FocusEvent

  "focusin": FocusEvent

  "focusout": FocusEvent

  "formdata": FormDataEvent

  "gotpointercapture": PointerEvent

  "input": Event

  "invalid": Event

  "keydown": KeyboardEvent

  "keypress": KeyboardEvent

  "keyup": KeyboardEvent

  "load": Event

  "loadeddata": Event

  "loadedmetadata": Event

  "loadstart": Event

  "lostpointercapture": PointerEvent

  "mousedown": MouseEvent

  "mouseenter": MouseEvent

  "mouseleave": MouseEvent

  "mousemove": MouseEvent

  "mouseout": MouseEvent

  "mouseover": MouseEvent

  "mouseup": MouseEvent

  "paste": ClipboardEvent

  "pause": Event

  "play": Event

  "playing": Event

  "pointercancel": PointerEvent

  "pointerdown": PointerEvent

  "pointerenter": PointerEvent

  "pointerleave": PointerEvent

  "pointermove": PointerEvent

  "pointerout": PointerEvent

  "pointerover": PointerEvent

  "pointerup": PointerEvent

  "progress": ProgressEvent

  "ratechange": Event

  "reset": Event

  "resize": UIEvent

  "scroll": Event

  "scrollend": Event

  "securitypolicyviolation": SecurityPolicyViolationEvent

  "seeked": Event

  "seeking": Event

  "select": Event

  "selectionchange": Event

  "selectstart": Event

  "slotchange": Event

  "stalled": Event

  "submit": SubmitEvent

  "suspend": Event

  "timeupdate": Event

  "toggle": Event

  "touchcancel": TouchEvent

  "touchend": TouchEvent

  "touchmove": TouchEvent

  "touchstart": TouchEvent

  "transitioncancel": TransitionEvent

  "transitionend": TransitionEvent

  "transitionrun": TransitionEvent

  "transitionstart": TransitionEvent

  "volumechange": Event

  "waiting": Event

  "webkitanimationend": Event

  "webkitanimationiteration": Event

  "webkitanimationstart": Event

  "webkittransitionend": Event

  "wheel": WheelEvent
}


тип GlobalEventHandlers = интерфейс
{
  onabort: операция(this: GlobalEventHandlers, ev: UIEvent): /*(!) any */ Объект??FUCKFUCK

  onanimationcancel: операция(this: GlobalEventHandlers, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK

  onanimationend: операция(this: GlobalEventHandlers, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK

  onanimationiteration: операция(this: GlobalEventHandlers, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK

  onanimationstart: операция(this: GlobalEventHandlers, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK

  onauxclick: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onbeforeinput: операция(this: GlobalEventHandlers, ev: InputEvent): /*(!) any */ Объект??FUCKFUCK

  onblur: операция(this: GlobalEventHandlers, ev: FocusEvent): /*(!) any */ Объект??FUCKFUCK

  oncancel: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncanplay: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncanplaythrough: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onchange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclick: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncontextmenu: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  oncopy: операция(this: GlobalEventHandlers, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK

  oncuechange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncut: операция(this: GlobalEventHandlers, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK

  ondblclick: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  ondrag: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondragend: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondragenter: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondragleave: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondragover: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondragstart: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondrop: операция(this: GlobalEventHandlers, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK

  ondurationchange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onemptied: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onended: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: OnErrorEventHandler

  onfocus: операция(this: GlobalEventHandlers, ev: FocusEvent): /*(!) any */ Объект??FUCKFUCK

  onformdata: операция(this: GlobalEventHandlers, ev: FormDataEvent): /*(!) any */ Объект??FUCKFUCK

  ongotpointercapture: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  oninput: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oninvalid: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onkeydown: операция(this: GlobalEventHandlers, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK

  onkeypress: операция(this: GlobalEventHandlers, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK

  onkeyup: операция(this: GlobalEventHandlers, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK

  onload: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadeddata: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadedmetadata: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onloadstart: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onlostpointercapture: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onmousedown: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmouseenter: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmouseleave: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmousemove: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmouseout: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmouseover: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onmouseup: операция(this: GlobalEventHandlers, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK

  onpaste: операция(this: GlobalEventHandlers, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK

  onpause: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onplay: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onplaying: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onpointercancel: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerdown: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerenter: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerleave: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointermove: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerout: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerover: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onpointerup: операция(this: GlobalEventHandlers, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK

  onprogress: операция(this: GlobalEventHandlers, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onratechange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onreset: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onresize: операция(this: GlobalEventHandlers, ev: UIEvent): /*(!) any */ Объект??FUCKFUCK

  onscroll: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onscrollend: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsecuritypolicyviolation: операция(this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent): /*(!) any */ Объект??FUCKFUCK

  onseeked: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onseeking: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onselect: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onselectionchange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onselectstart: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onslotchange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onstalled: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsubmit: операция(this: GlobalEventHandlers, ev: SubmitEvent): /*(!) any */ Объект??FUCKFUCK

  onsuspend: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ontimeupdate: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ontoggle: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ontouchcancel: операция(this: GlobalEventHandlers, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK

  ontouchend: операция(this: GlobalEventHandlers, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK

  ontouchmove: операция(this: GlobalEventHandlers, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK

  ontouchstart: операция(this: GlobalEventHandlers, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK

  ontransitioncancel: операция(this: GlobalEventHandlers, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK

  ontransitionend: операция(this: GlobalEventHandlers, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK

  ontransitionrun: операция(this: GlobalEventHandlers, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK

  ontransitionstart: операция(this: GlobalEventHandlers, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK

  onvolumechange: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwaiting: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwebkitanimationend: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwebkitanimationiteration: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwebkitanimationstart: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwebkittransitionend: операция(this: GlobalEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onwheel: операция(this: GlobalEventHandlers, ev: WheelEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof GlobalEventHandlersEventMap */ Объект?>(type: K, listener: операция(this: GlobalEventHandlers, ev: /*(!) GlobalEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof GlobalEventHandlersEventMap */ Объект?>(type: K, listener: операция(this: GlobalEventHandlers, ev: /*(!) GlobalEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAllCollection) */

тип HTMLAllCollection = интерфейс
{
  защищено 
  length: Число

  операция item(nameOrIndex: Текст?FUCKFUCK = пусто): HTMLCollection | Element | пусто

  операция namedItem(name: Текст): HTMLCollection | Element | пусто

  /*(!) [index: number]: Element*/
}


внешнее
/*(!) var */ HTMLAllCollection: объект { prototype: HTMLAllCollection; при создании()/*(!) no_type */ Объект? }


/**
* Hyperlink elements and provides special properties and methods (beyond those of the regular HTMLElement object interface that they inherit from) for manipulating the layout and presentation of such elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAnchorElement)
*/

тип HTMLAnchorElement = интерфейс
{
  charset: Текст

  coords: Текст

  download: Текст

  hreflang: Текст

  name: Текст

  ping: Текст

  referrerPolicy: Текст

  rel: Текст

  защищено 
  relList: DOMTokenList

  rev: Текст

  shape: Текст

  target: Текст

  text: Текст

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAnchorElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAnchorElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLAnchorElement: объект { prototype: HTMLAnchorElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <area> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAreaElement)
*/

тип HTMLAreaElement = интерфейс
{
  alt: Текст

  coords: Текст

  download: Текст

  noHref: ДаНет

  ping: Текст

  referrerPolicy: Текст

  rel: Текст

  защищено 
  relList: DOMTokenList

  shape: Текст

  target: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLAreaElement: объект { prototype: HTMLAreaElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <audio> elements, as well as methods to manipulate them. It derives from the HTMLMediaElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAudioElement)
*/

тип HTMLAudioElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAudioElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLAudioElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLAudioElement: объект { prototype: HTMLAudioElement; при создании()/*(!) no_type */ Объект? }


/**
* A HTML line break element (<br>). It inherits from HTMLElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBRElement)
*/

тип HTMLBRElement = интерфейс
{
  clear: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLBRElement: объект { prototype: HTMLBRElement; при создании()/*(!) no_type */ Объект? }


/**
* Contains the base URI for a document. This object inherits all of the properties and methods as described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBaseElement)
*/

тип HTMLBaseElement = интерфейс
{
  href: Текст

  target: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBaseElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBaseElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLBaseElement: объект { prototype: HTMLBaseElement; при создании()/*(!) no_type */ Объект? }


тип HTMLBodyElementEventMap = интерфейс
{

}


/**
* Provides special properties (beyond those inherited from the regular HTMLElement interface) for manipulating <body> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBodyElement)
*/

тип HTMLBodyElement = интерфейс
{
  aLink: Текст

  background: Текст

  bgColor: Текст

  link: Текст

  text: Текст

  vLink: Текст

  операция addEventListener<K = /*(!) keyof HTMLBodyElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBodyElement, ev: /*(!) HTMLBodyElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLBodyElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLBodyElement, ev: /*(!) HTMLBodyElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLBodyElement: объект { prototype: HTMLBodyElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <button> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLButtonElement)
*/

тип HTMLButtonElement = интерфейс
{
  disabled: ДаНет

  защищено 
  form: HTMLFormElement?FUCKFUCK

  formAction: Текст

  formEnctype: Текст

  formMethod: Текст

  formNoValidate: ДаНет

  formTarget: Текст

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  name: Текст

  type: "submit" | "reset" | "button"

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLButtonElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLButtonElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLButtonElement: объект { prototype: HTMLButtonElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides properties and methods for manipulating the layout and presentation of <canvas> elements. The HTMLCanvasElement interface also inherits the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement)
*/

тип HTMLCanvasElement = интерфейс
{
  height: Число

  width: Число

  операция captureStream(frameRequestRate: Число?FUCKFUCK = пусто): MediaStream

  операция getContext(contextId: "2d", options: CanvasRenderingContext2DSettings?FUCKFUCK = пусто): CanvasRenderingContext2D?FUCKFUCK

  операция getContext(contextId: "bitmaprenderer", options: ImageBitmapRenderingContextSettings?FUCKFUCK = пусто): ImageBitmapRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl", options: WebGLContextAttributes?FUCKFUCK = пусто): WebGLRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl2", options: WebGLContextAttributes?FUCKFUCK = пусто): WebGL2RenderingContext?FUCKFUCK

  операция getContext(contextId: Текст, options: /*(!) any */ Объект??FUCKFUCK = пусто): RenderingContext?FUCKFUCK

  операция toBlob(callback: BlobCallback, type: Текст?FUCKFUCK = пусто, quality: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция toDataURL(type: Текст?FUCKFUCK = пусто, quality: /*(!) any */ Объект??FUCKFUCK = пусто): Текст

  операция transferControlToOffscreen(): OffscreenCanvas

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLCanvasElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLCanvasElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLCanvasElement: объект { prototype: HTMLCanvasElement; при создании()/*(!) no_type */ Объект? }


/**
* A generic collection (array-like object similar to arguments) of elements (in document order) and offers methods and properties for selecting from the list.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLCollection)
*/

тип HTMLCollectionBase = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Element?FUCKFUCK

  /*(!) [index: number]: Element*/
}


тип HTMLCollection = интерфейс
{
  операция namedItem(name: Текст): Element?FUCKFUCK
}


внешнее
/*(!) var */ HTMLCollection: объект { prototype: HTMLCollection; при создании()/*(!) no_type */ Объект? }


тип HTMLCollectionOf<T = Element> = интерфейс
{
  операция item(index: Число): T?FUCKFUCK

  операция namedItem(name: Текст): T?FUCKFUCK

  /*(!) [index: number]: T*/
}


/**
* Provides special properties (beyond those of the regular HTMLElement interface it also has available to it by inheritance) for manipulating definition list (<dl>) elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDListElement)
*/

тип HTMLDListElement = интерфейс
{
  compact: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDListElement: объект { prototype: HTMLDListElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <data> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDataElement)
*/

тип HTMLDataElement = интерфейс
{
  value: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDataElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDataElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDataElement: объект { prototype: HTMLDataElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the HTMLElement object interface it also has available to it by inheritance) to manipulate <datalist> elements and their content.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDataListElement)
*/

тип HTMLDataListElement = интерфейс
{
  защищено 
  options: HTMLCollectionOf<HTMLOptionElement>

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDataListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDataListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDataListElement: объект { prototype: HTMLDataListElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDetailsElement) */

тип HTMLDetailsElement = интерфейс
{
  open: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDetailsElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDetailsElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDetailsElement: объект { prototype: HTMLDetailsElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement) */

тип HTMLDialogElement = интерфейс
{
  open: ДаНет

  returnValue: Текст

  операция close(returnValue: Текст?FUCKFUCK = пусто)

  операция show()

  операция showModal()

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDialogElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDialogElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDialogElement: объект { prototype: HTMLDialogElement; при создании()/*(!) no_type */ Объект? }


/** @deprecated */

тип HTMLDirectoryElement = интерфейс
{
  compact: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDirectoryElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDirectoryElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLDirectoryElement: объект { prototype: HTMLDirectoryElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <div> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDivElement)
*/

тип HTMLDivElement = интерфейс
{
  align: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDivElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLDivElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLDivElement: объект { prototype: HTMLDivElement; при создании()/*(!) no_type */ Объект? }


/** @deprecated use Document */

тип HTMLDocument = интерфейс
{
  операция addEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: HTMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: HTMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLDocument: объект { prototype: HTMLDocument; при создании()/*(!) no_type */ Объект? }


тип HTMLElementEventMap = интерфейс
{

}


/**
* Any HTML element. Some elements directly implement this interface, while others implement it via an interface that inherits it.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement)
*/

тип HTMLElement = интерфейс
{
  accessKey: Текст

  защищено 
  accessKeyLabel: Текст

  autocapitalize: Текст

  dir: Текст

  draggable: ДаНет

  hidden: ДаНет

  inert: ДаНет

  innerText: Текст

  lang: Текст

  защищено 
  offsetHeight: Число

  защищено 
  offsetLeft: Число

  защищено 
  offsetParent: Element?FUCKFUCK

  защищено 
  offsetTop: Число

  защищено 
  offsetWidth: Число

  outerText: Текст

  popover: Текст?FUCKFUCK

  spellcheck: ДаНет

  title: Текст

  translate: ДаНет

  операция attachInternals(): ElementInternals

  операция click()

  операция hidePopover()

  операция showPopover()

  операция togglePopover(force: ДаНет?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLElement: объект { prototype: HTMLElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <embed> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLEmbedElement)
*/

тип HTMLEmbedElement = интерфейс
{
  align: Текст

  height: Текст

  name: Текст

  src: Текст

  type: Текст

  width: Текст

  операция getSVGDocument(): Document?FUCKFUCK

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLEmbedElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLEmbedElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLEmbedElement: объект { prototype: HTMLEmbedElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <fieldset> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFieldSetElement)
*/

тип HTMLFieldSetElement = интерфейс
{
  disabled: ДаНет

  защищено 
  elements: HTMLCollection

  защищено 
  form: HTMLFormElement?FUCKFUCK

  name: Текст

  защищено 
  type: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFieldSetElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFieldSetElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLFieldSetElement: объект { prototype: HTMLFieldSetElement; при создании()/*(!) no_type */ Объект? }


/**
* Implements the document object model (DOM) representation of the font element. The HTML Font Element <font> defines the font size, font face and color of text.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFontElement)
*/

тип HTMLFontElement = интерфейс
{
  color: Текст

  face: Текст

  size: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFontElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFontElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLFontElement: объект { prototype: HTMLFontElement; при создании()/*(!) no_type */ Объект? }


/**
* A collection of HTML form control elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormControlsCollection)
*/

тип HTMLFormControlsCollection = интерфейс
{
  операция namedItem(name: Текст): RadioNodeList | Element | пусто
}


внешнее
/*(!) var */ HTMLFormControlsCollection: объект { prototype: HTMLFormControlsCollection; при создании()/*(!) no_type */ Объект? }


/**
* A <form> element in the DOM; it allows access to and in some cases modification of aspects of the form, as well as access to its component elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement)
*/

тип HTMLFormElement = интерфейс
{
  acceptCharset: Текст

  action: Текст

  autocomplete: AutoFillBase

  защищено 
  elements: HTMLFormControlsCollection

  encoding: Текст

  enctype: Текст

  защищено 
  length: Число

  method: Текст

  name: Текст

  noValidate: ДаНет

  rel: Текст

  защищено 
  relList: DOMTokenList

  target: Текст

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция requestSubmit(submitter: HTMLElement?FUCKFUCK = пусто)

  операция reset()

  операция submit()

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFormElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFormElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

  /*(!) [index: number]: Element*/

  /*(!) [name: string]: any*/
}


внешнее
/*(!) var */ HTMLFormElement: объект { prototype: HTMLFormElement; при создании()/*(!) no_type */ Объект? }


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFrameElement)
*/

тип HTMLFrameElement = интерфейс
{
  защищено 
  contentDocument: Document?FUCKFUCK

  защищено 
  contentWindow: WindowProxy?FUCKFUCK

  frameBorder: Текст

  longDesc: Текст

  marginHeight: Текст

  marginWidth: Текст

  name: Текст

  noResize: ДаНет

  scrolling: Текст

  src: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLFrameElement: объект { prototype: HTMLFrameElement; при создании()/*(!) no_type */ Объект? }


тип HTMLFrameSetElementEventMap = интерфейс
{

}


/**
* Provides special properties (beyond those of the regular HTMLElement interface they also inherit) for manipulating <frameset> elements.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFrameSetElement)
*/

тип HTMLFrameSetElement = интерфейс
{
  cols: Текст

  rows: Текст

  операция addEventListener<K = /*(!) keyof HTMLFrameSetElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFrameSetElement, ev: /*(!) HTMLFrameSetElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLFrameSetElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLFrameSetElement, ev: /*(!) HTMLFrameSetElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLFrameSetElement: объект { prototype: HTMLFrameSetElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating <hr> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHRElement)
*/

тип HTMLHRElement = интерфейс
{
  align: Текст

  color: Текст

  noShade: ДаНет

  size: Текст

  width: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLHRElement: объект { prototype: HTMLHRElement; при создании()/*(!) no_type */ Объект? }


/**
* Contains the descriptive information, or metadata, for a document. This object inherits all of the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHeadElement)
*/

тип HTMLHeadElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHeadElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHeadElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLHeadElement: объект { prototype: HTMLHeadElement; при создании()/*(!) no_type */ Объект? }


/**
* The different heading elements. It inherits methods and properties from the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHeadingElement)
*/

тип HTMLHeadingElement = интерфейс
{
  align: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHeadingElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHeadingElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLHeadingElement: объект { prototype: HTMLHeadingElement; при создании()/*(!) no_type */ Объект? }


/**
* Serves as the root node for a given HTML document. This object inherits the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHtmlElement)
*/

тип HTMLHtmlElement = интерфейс
{
  version: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHtmlElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLHtmlElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLHtmlElement: объект { prototype: HTMLHtmlElement; при создании()/*(!) no_type */ Объект? }


тип HTMLHyperlinkElementUtils = интерфейс
{
  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  password: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  username: Текст
}


/**
* Provides special properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of inline frame elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLIFrameElement)
*/

тип HTMLIFrameElement = интерфейс
{
  align: Текст

  allow: Текст

  allowFullscreen: ДаНет

  защищено 
  contentDocument: Document?FUCKFUCK

  защищено 
  contentWindow: WindowProxy?FUCKFUCK

  frameBorder: Текст

  height: Текст

  loading: Текст

  longDesc: Текст

  marginHeight: Текст

  marginWidth: Текст

  name: Текст

  referrerPolicy: ReferrerPolicy

  защищено 
  sandbox: DOMTokenList

  scrolling: Текст

  src: Текст

  srcdoc: Текст

  width: Текст

  операция getSVGDocument(): Document?FUCKFUCK

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLIFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLIFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLIFrameElement: объект { prototype: HTMLIFrameElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods for manipulating <img> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
*/

тип HTMLImageElement = интерфейс
{
  align: Текст

  alt: Текст

  border: Текст

  защищено 
  complete: ДаНет

  crossOrigin: Текст?FUCKFUCK

  защищено 
  currentSrc: Текст

  decoding: "async" | "sync" | "auto"

  height: Число

  hspace: Число

  isMap: ДаНет

  loading: "eager" | "lazy"

  longDesc: Текст

  lowsrc: Текст

  name: Текст

  защищено 
  naturalHeight: Число

  защищено 
  naturalWidth: Число

  referrerPolicy: Текст

  sizes: Текст

  src: Текст

  srcset: Текст

  useMap: Текст

  vspace: Число

  width: Число

  защищено 
  x: Число

  защищено 
  y: Число

  операция decode(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLImageElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLImageElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLImageElement: объект { prototype: HTMLImageElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods for manipulating the options, layout, and presentation of <input> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement)
*/

тип HTMLInputElement = интерфейс
{
  accept: Текст

  align: Текст

  alt: Текст

  autocomplete: AutoFill

  capture: Текст

  checked: ДаНет

  defaultChecked: ДаНет

  defaultValue: Текст

  dirName: Текст

  disabled: ДаНет

  files: FileList?FUCKFUCK

  защищено 
  form: HTMLFormElement?FUCKFUCK

  formAction: Текст

  formEnctype: Текст

  formMethod: Текст

  formNoValidate: ДаНет

  formTarget: Текст

  height: Число

  indeterminate: ДаНет

  защищено 
  labels: NodeListOf<HTMLLabelElement>?FUCKFUCK

  защищено 
  list: HTMLDataListElement?FUCKFUCK

  max: Текст

  maxLength: Число

  min: Текст

  minLength: Число

  multiple: ДаНет

  name: Текст

  pattern: Текст

  placeholder: Текст

  readOnly: ДаНет

  required: ДаНет

  selectionDirection: "forward" | "backward" | "none" | пусто

  selectionEnd: Число?FUCKFUCK

  selectionStart: Число?FUCKFUCK

  size: Число

  src: Текст

  step: Текст

  type: Текст

  useMap: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  valueAsDate: Date?FUCKFUCK

  valueAsNumber: Число

  защищено 
  webkitEntries: ReadonlyArray<FileSystemEntry>

  webkitdirectory: ДаНет

  width: Число

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция select()

  операция setCustomValidity(error: Текст)

  операция setRangeText(replacement: Текст)

  операция setRangeText(replacement: Текст, start: Число, end: Число, selectionMode: SelectionMode?FUCKFUCK = пусто)

  операция setSelectionRange(start: Число?FUCKFUCK, end: Число?FUCKFUCK, direction: "forward" | "backward" | "none" | пусто = пусто)

  операция showPicker()

  операция stepDown(n: Число?FUCKFUCK = пусто)

  операция stepUp(n: Число?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLInputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLInputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLInputElement: объект { prototype: HTMLInputElement; при создании()/*(!) no_type */ Объект? }


/**
* Exposes specific properties and methods (beyond those defined by regular HTMLElement interface it also has available to it by inheritance) for manipulating list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLIElement)
*/

тип HTMLLIElement = интерфейс
{
  type: Текст

  value: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLIElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLIElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLLIElement: объект { prototype: HTMLLIElement; при создании()/*(!) no_type */ Объект? }


/**
* Gives access to properties specific to <label> elements. It inherits methods and properties from the base HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLabelElement)
*/

тип HTMLLabelElement = интерфейс
{
  защищено 
  control: HTMLElement?FUCKFUCK

  защищено 
  form: HTMLFormElement?FUCKFUCK

  htmlFor: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLabelElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLabelElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLLabelElement: объект { prototype: HTMLLabelElement; при создании()/*(!) no_type */ Объект? }


/**
* The HTMLLegendElement is an interface allowing to access properties of the <legend> elements. It inherits properties and methods from the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLegendElement)
*/

тип HTMLLegendElement = интерфейс
{
  align: Текст

  защищено 
  form: HTMLFormElement?FUCKFUCK

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLegendElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLegendElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLLegendElement: объект { prototype: HTMLLegendElement; при создании()/*(!) no_type */ Объект? }


/**
* Reference information for external resources and the relationship of those resources to a document and vice-versa. This object inherits all of the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLinkElement)
*/

тип HTMLLinkElement = интерфейс
{
  as: Текст

  charset: Текст

  crossOrigin: Текст?FUCKFUCK

  disabled: ДаНет

  href: Текст

  hreflang: Текст

  imageSizes: Текст

  imageSrcset: Текст

  integrity: Текст

  media: Текст

  referrerPolicy: Текст

  rel: Текст

  защищено 
  relList: DOMTokenList

  rev: Текст

  защищено 
  sizes: DOMTokenList

  target: Текст

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLinkElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLLinkElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLLinkElement: объект { prototype: HTMLLinkElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of map elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMapElement)
*/

тип HTMLMapElement = интерфейс
{
  защищено 
  areas: HTMLCollection

  name: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMapElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMapElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLMapElement: объект { prototype: HTMLMapElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides methods to manipulate <marquee> elements.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMarqueeElement)
*/

тип HTMLMarqueeElement = интерфейс
{
  behavior: Текст

  bgColor: Текст

  direction: Текст

  height: Текст

  hspace: Число

  loop: Число

  scrollAmount: Число

  scrollDelay: Число

  trueSpeed: ДаНет

  vspace: Число

  width: Текст

  операция start()

  операция stop()

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMarqueeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMarqueeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLMarqueeElement: объект { prototype: HTMLMarqueeElement; при создании()/*(!) no_type */ Объект? }


тип HTMLMediaElementEventMap = интерфейс
{
  "encrypted": MediaEncryptedEvent

  "waitingforkey": Event
}


/**
* Adds to HTMLElement the properties and methods needed to support basic media-related capabilities that are common to audio and video.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement)
*/

тип HTMLMediaElement = интерфейс
{
  autoplay: ДаНет

  защищено 
  buffered: TimeRanges

  controls: ДаНет

  crossOrigin: Текст?FUCKFUCK

  защищено 
  currentSrc: Текст

  currentTime: Число

  defaultMuted: ДаНет

  defaultPlaybackRate: Число

  disableRemotePlayback: ДаНет

  защищено 
  duration: Число

  защищено 
  ended: ДаНет

  защищено 
  error: MediaError?FUCKFUCK

  loop: ДаНет

  защищено 
  mediaKeys: MediaKeys?FUCKFUCK

  muted: ДаНет

  защищено 
  networkState: Число

  onencrypted: операция(this: HTMLMediaElement, ev: MediaEncryptedEvent): /*(!) any */ Объект??FUCKFUCK

  onwaitingforkey: операция(this: HTMLMediaElement, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  paused: ДаНет

  playbackRate: Число

  защищено 
  played: TimeRanges

  preload: "none" | "metadata" | "auto" | ""

  preservesPitch: ДаНет

  защищено 
  readyState: Число

  защищено 
  remote: RemotePlayback

  защищено 
  seekable: TimeRanges

  защищено 
  seeking: ДаНет

  src: Текст

  srcObject: MediaProvider?FUCKFUCK

  защищено 
  textTracks: TextTrackList

  volume: Число

  операция addTextTrack(kind: TextTrackKind, label: Текст?FUCKFUCK = пусто, language: Текст?FUCKFUCK = пусто): TextTrack

  операция canPlayType(type: Текст): CanPlayTypeResult

  операция fastSeek(time: Число)

  операция load()

  операция pause()

  операция play(): Promise<Ничего>

  операция setMediaKeys(mediaKeys: MediaKeys?FUCKFUCK): Promise<Ничего>

  защищено 
  NETWORK_EMPTY: 0

  защищено 
  NETWORK_IDLE: 1

  защищено 
  NETWORK_LOADING: 2

  защищено 
  NETWORK_NO_SOURCE: 3

  защищено 
  HAVE_NOTHING: 0

  защищено 
  HAVE_METADATA: 1

  защищено 
  HAVE_CURRENT_DATA: 2

  защищено 
  HAVE_FUTURE_DATA: 3

  защищено 
  HAVE_ENOUGH_DATA: 4

  операция addEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMediaElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMediaElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLMediaElement: объект { prototype: HTMLMediaElement; при создании()/*(!) no_type */ Объект?; защищено  NETWORK_EMPTY: 0; защищено  NETWORK_IDLE: 1; защищено  NETWORK_LOADING: 2; защищено  NETWORK_NO_SOURCE: 3; защищено  HAVE_NOTHING: 0; защищено  HAVE_METADATA: 1; защищено  HAVE_CURRENT_DATA: 2; защищено  HAVE_FUTURE_DATA: 3; защищено  HAVE_ENOUGH_DATA: 4 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMenuElement) */

тип HTMLMenuElement = интерфейс
{
  compact: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMenuElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMenuElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLMenuElement: объект { prototype: HTMLMenuElement; при создании()/*(!) no_type */ Объект? }


/**
* Contains descriptive metadata about a document. It inherits all of the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMetaElement)
*/

тип HTMLMetaElement = интерфейс
{
  content: Текст

  httpEquiv: Текст

  media: Текст

  name: Текст

  scheme: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMetaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMetaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLMetaElement: объект { prototype: HTMLMetaElement; при создании()/*(!) no_type */ Объект? }


/**
* The HTML <meter> elements expose the HTMLMeterElement interface, which provides special properties and methods (beyond the HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <meter> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMeterElement)
*/

тип HTMLMeterElement = интерфейс
{
  high: Число

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  low: Число

  max: Число

  min: Число

  optimum: Число

  value: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMeterElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLMeterElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLMeterElement: объект { prototype: HTMLMeterElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular methods and properties available through the HTMLElement interface they also have available to them by inheritance) for manipulating modification elements, that is <del> and <ins>.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLModElement)
*/

тип HTMLModElement = интерфейс
{
  cite: Текст

  dateTime: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLModElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLModElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLModElement: объект { prototype: HTMLModElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating ordered list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOListElement)
*/

тип HTMLOListElement = интерфейс
{
  compact: ДаНет

  reversed: ДаНет

  start: Число

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLOListElement: объект { prototype: HTMLOListElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond those on the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <object> element, representing external resources.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLObjectElement)
*/

тип HTMLObjectElement = интерфейс
{
  align: Текст

  archive: Текст

  border: Текст

  code: Текст

  codeBase: Текст

  codeType: Текст

  защищено 
  contentDocument: Document?FUCKFUCK

  защищено 
  contentWindow: WindowProxy?FUCKFUCK

  data: Текст

  declare: ДаНет

  защищено 
  form: HTMLFormElement?FUCKFUCK

  height: Текст

  hspace: Число

  name: Текст

  standby: Текст

  type: Текст

  useMap: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  vspace: Число

  width: Текст

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция getSVGDocument(): Document?FUCKFUCK

  операция reportValidity(): ДаНет

  операция setCustomValidity(error: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLObjectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLObjectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLObjectElement: объект { prototype: HTMLObjectElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the regular HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <optgroup> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptGroupElement)
*/

тип HTMLOptGroupElement = интерфейс
{
  disabled: ДаНет

  label: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOptGroupElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOptGroupElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLOptGroupElement: объект { prototype: HTMLOptGroupElement; при создании()/*(!) no_type */ Объект? }


/**
* <option> elements and inherits all classes and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptionElement)
*/

тип HTMLOptionElement = интерфейс
{
  defaultSelected: ДаНет

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?FUCKFUCK

  защищено 
  index: Число

  label: Текст

  selected: ДаНет

  text: Текст

  value: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLOptionElement: объект { prototype: HTMLOptionElement; при создании()/*(!) no_type */ Объект? }


/**
* HTMLOptionsCollection is an interface representing a collection of HTML option elements (in document order) and offers methods and properties for traversing the list as well as optionally altering its items. This type is returned solely by the "options" property of select.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptionsCollection)
*/

тип HTMLOptionsCollection = интерфейс
{
  length: Число

  selectedIndex: Число

  операция add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | Число | пусто | пусто = пусто)

  операция remove(index: Число)
}


внешнее
/*(!) var */ HTMLOptionsCollection: объект { prototype: HTMLOptionsCollection; при создании()/*(!) no_type */ Объект? }


тип HTMLOrSVGElement = интерфейс
{
  autofocus: ДаНет

  защищено 
  dataset: DOMStringMap

  nonce: Текст

  tabIndex: Число

  операция blur()

  операция focus(options: FocusOptions?FUCKFUCK = пусто)
}


/**
* Provides properties and methods (beyond those inherited from HTMLElement) for manipulating the layout and presentation of <output> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOutputElement)
*/

тип HTMLOutputElement = интерфейс
{
  defaultValue: Текст

  защищено 
  form: HTMLFormElement?FUCKFUCK

  защищено 
  htmlFor: DOMTokenList

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  name: Текст

  защищено 
  type: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOutputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLOutputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLOutputElement: объект { prototype: HTMLOutputElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond those of the regular HTMLElement object interface it inherits) for manipulating <p> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLParagraphElement)
*/

тип HTMLParagraphElement = интерфейс
{
  align: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLParagraphElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLParagraphElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLParagraphElement: объект { prototype: HTMLParagraphElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond those of the regular HTMLElement object interface it inherits) for manipulating <param> elements, representing a pair of a key and a value that acts as a parameter for an <object> element.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLParamElement)
*/

тип HTMLParamElement = интерфейс
{
  name: Текст

  type: Текст

  value: Текст

  valueType: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLParamElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLParamElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ HTMLParamElement: объект { prototype: HTMLParamElement; при создании()/*(!) no_type */ Объект? }


/**
* A <picture> HTML element. It doesn't implement specific properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLPictureElement)
*/

тип HTMLPictureElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLPictureElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLPictureElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLPictureElement: объект { prototype: HTMLPictureElement; при создании()/*(!) no_type */ Объект? }


/**
* Exposes specific properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating a block of preformatted text (<pre>).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLPreElement)
*/

тип HTMLPreElement = интерфейс
{
  width: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLPreElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLPreElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLPreElement: объект { prototype: HTMLPreElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <progress> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLProgressElement)
*/

тип HTMLProgressElement = интерфейс
{
  защищено 
  labels: NodeListOf<HTMLLabelElement>

  max: Число

  защищено 
  position: Число

  value: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLProgressElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLProgressElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLProgressElement: объект { prototype: HTMLProgressElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating quoting elements, like <blockquote> and <q>, but not the <cite> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLQuoteElement)
*/

тип HTMLQuoteElement = интерфейс
{
  cite: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLQuoteElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLQuoteElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLQuoteElement: объект { prototype: HTMLQuoteElement; при создании()/*(!) no_type */ Объект? }


/**
* HTML <script> elements expose the HTMLScriptElement interface, which provides special properties and methods for manipulating the behavior and execution of <script> elements (beyond the inherited HTMLElement interface).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLScriptElement)
*/

тип HTMLScriptElement = интерфейс
{
  async: ДаНет

  charset: Текст

  crossOrigin: Текст?FUCKFUCK

  defer: ДаНет

  event: Текст

  htmlFor: Текст

  integrity: Текст

  noModule: ДаНет

  referrerPolicy: Текст

  src: Текст

  text: Текст

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLScriptElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLScriptElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLScriptElement: объект { prototype: HTMLScriptElement; при создании()/*(!) no_type */ Объект?; операция supports(type: Текст): ДаНет }


/**
* A <select> HTML Element. These elements also share all of the properties and methods of other HTML elements via the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSelectElement)
*/

тип HTMLSelectElement = интерфейс
{
  autocomplete: AutoFill

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?FUCKFUCK

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  length: Число

  multiple: ДаНет

  name: Текст

  защищено 
  options: HTMLOptionsCollection

  required: ДаНет

  selectedIndex: Число

  защищено 
  selectedOptions: HTMLCollectionOf<HTMLOptionElement>

  size: Число

  защищено 
  type: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция add(element: HTMLOptionElement | HTMLOptGroupElement, before: HTMLElement | Число | пусто | пусто = пусто)

  операция checkValidity(): ДаНет

  операция item(index: Число): HTMLOptionElement?FUCKFUCK

  операция namedItem(name: Текст): HTMLOptionElement?FUCKFUCK

  операция remove()

  операция remove(index: Число)

  операция reportValidity(): ДаНет

  операция setCustomValidity(error: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSelectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSelectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

  /*(!) [name: number]: HTMLOptionElement | HTMLOptGroupElement*/
}


внешнее
/*(!) var */ HTMLSelectElement: объект { prototype: HTMLSelectElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSlotElement) */

тип HTMLSlotElement = интерфейс
{
  name: Текст

  #js.МассивПараметров
  операция assign(nodes: Список<Element | Text>)

  операция assignedElements(options: AssignedNodesOptions?FUCKFUCK = пусто): Список<Element>

  операция assignedNodes(options: AssignedNodesOptions?FUCKFUCK = пусто): Список<Node>

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSlotElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSlotElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLSlotElement: объект { prototype: HTMLSlotElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating <source> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSourceElement)
*/

тип HTMLSourceElement = интерфейс
{
  height: Число

  media: Текст

  sizes: Текст

  src: Текст

  srcset: Текст

  type: Текст

  width: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSourceElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSourceElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLSourceElement: объект { prototype: HTMLSourceElement; при создании()/*(!) no_type */ Объект? }


/**
* A <span> element and derives from the HTMLElement interface, but without implementing any additional properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSpanElement)
*/

тип HTMLSpanElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSpanElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLSpanElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLSpanElement: объект { prototype: HTMLSpanElement; при создании()/*(!) no_type */ Объект? }


/**
* A <style> element. It inherits properties and methods from its parent, HTMLElement, and from LinkStyle.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLStyleElement)
*/

тип HTMLStyleElement = интерфейс
{
  disabled: ДаНет

  media: Текст

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLStyleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLStyleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLStyleElement: объект { prototype: HTMLStyleElement; при создании()/*(!) no_type */ Объект? }


/**
* Special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating table caption elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableCaptionElement)
*/

тип HTMLTableCaptionElement = интерфейс
{
  align: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableCaptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableCaptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableCaptionElement: объект { prototype: HTMLTableCaptionElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of table cells, either header or data cells, in an HTML document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableCellElement)
*/

тип HTMLTableCellElement = интерфейс
{
  abbr: Текст

  align: Текст

  axis: Текст

  bgColor: Текст

  защищено 
  cellIndex: Число

  ch: Текст

  chOff: Текст

  colSpan: Число

  headers: Текст

  height: Текст

  noWrap: ДаНет

  rowSpan: Число

  scope: Текст

  vAlign: Текст

  width: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableCellElement: объект { prototype: HTMLTableCellElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the HTMLElement interface it also has available to it inheritance) for manipulating single or grouped table column elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableColElement)
*/

тип HTMLTableColElement = интерфейс
{
  align: Текст

  ch: Текст

  chOff: Текст

  span: Число

  vAlign: Текст

  width: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableColElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableColElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableColElement: объект { prototype: HTMLTableColElement; при создании()/*(!) no_type */ Объект? }


/** @deprecated prefer HTMLTableCellElement */

тип HTMLTableDataCellElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableDataCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableDataCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/**
* Provides special properties and methods (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating the layout and presentation of tables in an HTML document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableElement)
*/

тип HTMLTableElement = интерфейс
{
  align: Текст

  bgColor: Текст

  border: Текст

  caption: HTMLTableCaptionElement?FUCKFUCK

  cellPadding: Текст

  cellSpacing: Текст

  frame: Текст

  защищено 
  rows: HTMLCollectionOf<HTMLTableRowElement>

  rules: Текст

  summary: Текст

  защищено 
  tBodies: HTMLCollectionOf<HTMLTableSectionElement>

  tFoot: HTMLTableSectionElement?FUCKFUCK

  tHead: HTMLTableSectionElement?FUCKFUCK

  width: Текст

  операция createCaption(): HTMLTableCaptionElement

  операция createTBody(): HTMLTableSectionElement

  операция createTFoot(): HTMLTableSectionElement

  операция createTHead(): HTMLTableSectionElement

  операция deleteCaption()

  операция deleteRow(index: Число)

  операция deleteTFoot()

  операция deleteTHead()

  операция insertRow(index: Число?FUCKFUCK = пусто): HTMLTableRowElement

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableElement: объект { prototype: HTMLTableElement; при создании()/*(!) no_type */ Объект? }


/** @deprecated prefer HTMLTableCellElement */

тип HTMLTableHeaderCellElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableHeaderCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableHeaderCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/**
* Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of rows in an HTML table.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableRowElement)
*/

тип HTMLTableRowElement = интерфейс
{
  align: Текст

  bgColor: Текст

  защищено 
  cells: HTMLCollectionOf<HTMLTableCellElement>

  ch: Текст

  chOff: Текст

  защищено 
  rowIndex: Число

  защищено 
  sectionRowIndex: Число

  vAlign: Текст

  операция deleteCell(index: Число)

  операция insertCell(index: Число?FUCKFUCK = пусто): HTMLTableCellElement

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableRowElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableRowElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableRowElement: объект { prototype: HTMLTableRowElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of sections, that is headers, footers and bodies, in an HTML table.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableSectionElement)
*/

тип HTMLTableSectionElement = интерфейс
{
  align: Текст

  ch: Текст

  chOff: Текст

  защищено 
  rows: HTMLCollectionOf<HTMLTableRowElement>

  vAlign: Текст

  операция deleteRow(index: Число)

  операция insertRow(index: Число?FUCKFUCK = пусто): HTMLTableRowElement

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableSectionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTableSectionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTableSectionElement: объект { prototype: HTMLTableSectionElement; при создании()/*(!) no_type */ Объект? }


/**
* Enables access to the contents of an HTML <template> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTemplateElement)
*/

тип HTMLTemplateElement = интерфейс
{
  защищено 
  content: DocumentFragment

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTemplateElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTemplateElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTemplateElement: объект { prototype: HTMLTemplateElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties and methods for manipulating the layout and presentation of <textarea> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTextAreaElement)
*/

тип HTMLTextAreaElement = интерфейс
{
  autocomplete: AutoFill

  cols: Число

  defaultValue: Текст

  dirName: Текст

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?FUCKFUCK

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  maxLength: Число

  minLength: Число

  name: Текст

  placeholder: Текст

  readOnly: ДаНет

  required: ДаНет

  rows: Число

  selectionDirection: "forward" | "backward" | "none"

  selectionEnd: Число

  selectionStart: Число

  защищено 
  textLength: Число

  защищено 
  type: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  wrap: Текст

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция select()

  операция setCustomValidity(error: Текст)

  операция setRangeText(replacement: Текст)

  операция setRangeText(replacement: Текст, start: Число, end: Число, selectionMode: SelectionMode?FUCKFUCK = пусто)

  операция setSelectionRange(start: Число?FUCKFUCK, end: Число?FUCKFUCK, direction: "forward" | "backward" | "none" | пусто = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTextAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTextAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTextAreaElement: объект { prototype: HTMLTextAreaElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <time> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTimeElement)
*/

тип HTMLTimeElement = интерфейс
{
  dateTime: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTimeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTimeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTimeElement: объект { prototype: HTMLTimeElement; при создании()/*(!) no_type */ Объект? }


/**
* Contains the title for a document. This element inherits all of the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTitleElement)
*/

тип HTMLTitleElement = интерфейс
{
  text: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTitleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTitleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTitleElement: объект { prototype: HTMLTitleElement; при создании()/*(!) no_type */ Объект? }


/**
* The HTMLTrackElement
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTrackElement)
*/

тип HTMLTrackElement = интерфейс
{
  default: ДаНет

  kind: Текст

  label: Текст

  защищено 
  readyState: Число

  src: Текст

  srclang: Текст

  защищено 
  track: TextTrack

  защищено 
  NONE: 0

  защищено 
  LOADING: 1

  защищено 
  LOADED: 2

  защищено 
  ERROR: 3

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTrackElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLTrackElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLTrackElement: объект { prototype: HTMLTrackElement; при создании()/*(!) no_type */ Объект?; защищено  NONE: 0; защищено  LOADING: 1; защищено  LOADED: 2; защищено  ERROR: 3 }


/**
* Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating unordered list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLUListElement)
*/

тип HTMLUListElement = интерфейс
{
  compact: ДаНет

  type: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLUListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLUListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLUListElement: объект { prototype: HTMLUListElement; при создании()/*(!) no_type */ Объект? }


/**
* An invalid HTML element and derives from the HTMLElement interface, but without implementing any additional properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLUnknownElement)
*/

тип HTMLUnknownElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLUnknownElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLUnknownElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLUnknownElement: объект { prototype: HTMLUnknownElement; при создании()/*(!) no_type */ Объект? }


тип HTMLVideoElementEventMap = интерфейс
{
  "enterpictureinpicture": Event

  "leavepictureinpicture": Event
}


/**
* Provides special properties and methods for manipulating video objects. It also inherits properties and methods of HTMLMediaElement and HTMLElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
*/

тип HTMLVideoElement = интерфейс
{
  disablePictureInPicture: ДаНет

  height: Число

  onenterpictureinpicture: операция(this: HTMLVideoElement, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onleavepictureinpicture: операция(this: HTMLVideoElement, ev: Event): /*(!) any */ Объект??FUCKFUCK

  playsInline: ДаНет

  poster: Текст

  защищено 
  videoHeight: Число

  защищено 
  videoWidth: Число

  width: Число

  операция cancelVideoFrameCallback(handle: Число)

  операция getVideoPlaybackQuality(): VideoPlaybackQuality

  операция requestPictureInPicture(): Promise<PictureInPictureWindow>

  операция requestVideoFrameCallback(callback: VideoFrameRequestCallback): Число

  операция addEventListener<K = /*(!) keyof HTMLVideoElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLVideoElement, ev: /*(!) HTMLVideoElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLVideoElementEventMap */ Объект?>(type: K, listener: операция(this: HTMLVideoElement, ev: /*(!) HTMLVideoElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ HTMLVideoElement: объект { prototype: HTMLVideoElement; при создании()/*(!) no_type */ Объект? }


/**
* Events that fire when the fragment identifier of the URL has changed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HashChangeEvent)
*/

тип HashChangeEvent = интерфейс
{
  защищено 
  newURL: Текст

  защищено 
  oldURL: Текст
}


внешнее
/*(!) var */ HashChangeEvent: объект { prototype: HashChangeEvent; при создании(type: Текст, eventInitDict: HashChangeEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)
*/

тип Headers = интерфейс
{
  операция append(name: Текст, value: Текст)

  операция delete(name: Текст)

  операция get(name: Текст): Текст?FUCKFUCK

  операция getSetCookie(): Список<Текст>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Текст)

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: Headers), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ Headers: объект { prototype: Headers; при создании(init: HeadersInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/History)
*/

тип History = интерфейс
{
  защищено 
  length: Число

  scrollRestoration: ScrollRestoration

  защищено 
  state: /*(!) any */ Объект?

  операция back()

  операция forward()

  операция go(delta: Число?FUCKFUCK = пусто)

  операция pushState(data: /*(!) any */ Объект?, unused: Текст, url: Текст | URL | пусто | пусто = пусто)

  операция replaceState(data: /*(!) any */ Объект?, unused: Текст, url: Текст | URL | пусто | пусто = пусто)
}


внешнее
/*(!) var */ History: объект { prototype: History; при создании()/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursor)
*/

тип IDBCursor = интерфейс
{
  защищено 
  direction: IDBCursorDirection

  защищено 
  key: IDBValidKey

  защищено 
  primaryKey: IDBValidKey

  защищено 
  request: IDBRequest

  защищено 
  source: IDBObjectStore | IDBIndex

  операция advance(count: Число)

  операция continue(key: IDBValidKey?FUCKFUCK = пусто)

  операция continuePrimaryKey(key: IDBValidKey, primaryKey: IDBValidKey)

  операция delete(): IDBRequest<пусто>

  операция update(value: /*(!) any */ Объект?): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBCursor: объект { prototype: IDBCursor; при создании()/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database. It is the same as the IDBCursor, except that it includes the value property.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursorWithValue)
*/

тип IDBCursorWithValue = интерфейс
{
  защищено 
  value: /*(!) any */ Объект?
}


внешнее
/*(!) var */ IDBCursorWithValue: объект { prototype: IDBCursorWithValue; при создании()/*(!) no_type */ Объект? }


тип IDBDatabaseEventMap = интерфейс
{
  "abort": Event

  "close": Event

  "error": Event

  "versionchange": IDBVersionChangeEvent
}


/**
* This IndexedDB API interface provides a connection to a database; you can use an IDBDatabase object to open a transaction on your database then create, manipulate, and delete objects (data) in that database. The interface provides the only way to get and manage versions of the database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase)
*/

тип IDBDatabase = интерфейс
{
  защищено 
  name: Текст

  защищено 
  objectStoreNames: DOMStringList

  onabort: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onversionchange: операция(this: IDBDatabase, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  version: Число

  операция close()

  операция createObjectStore(name: Текст, options: IDBObjectStoreParameters?FUCKFUCK = пусто): IDBObjectStore

  операция deleteObjectStore(name: Текст)

  операция transaction(storeNames: Текст | Список<Текст>, mode: IDBTransactionMode?FUCKFUCK = пусто, options: IDBTransactionOptions?FUCKFUCK = пусто): IDBTransaction

  операция addEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBDatabase: объект { prototype: IDBDatabase; при создании()/*(!) no_type */ Объект? }


/**
* In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBFactory)
*/

тип IDBFactory = интерфейс
{
  операция cmp(first: /*(!) any */ Объект?, second: /*(!) any */ Объект?): Число

  операция databases(): Promise<Список<IDBDatabaseInfo>>

  операция deleteDatabase(name: Текст): IDBOpenDBRequest

  операция open(name: Текст, version: Число?FUCKFUCK = пусто): IDBOpenDBRequest
}


внешнее
/*(!) var */ IDBFactory: объект { prototype: IDBFactory; при создании()/*(!) no_type */ Объект? }


/**
* IDBIndex interface of the IndexedDB API provides asynchronous access to an index in a database. An index is a kind of object store for looking up records in another object store, called the referenced object store. You use this interface to retrieve data.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBIndex)
*/

тип IDBIndex = интерфейс
{
  защищено 
  keyPath: Текст | Список<Текст>

  защищено 
  multiEntry: ДаНет

  name: Текст

  защищено 
  objectStore: IDBObjectStore

  защищено 
  unique: ДаНет

  операция count(query: IDBValidKey | IDBKeyRange | пусто = пусто): IDBRequest<Число>

  операция get(query: IDBValidKey | IDBKeyRange): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey?FUCKFUCK>

  операция openCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursorWithValue?FUCKFUCK>

  операция openKeyCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursor?FUCKFUCK>
}


внешнее
/*(!) var */ IDBIndex: объект { prototype: IDBIndex; при создании()/*(!) no_type */ Объект? }


/**
* A key range can be a single value or a range with upper and lower bounds or endpoints. If the key range has both upper and lower bounds, then it is bounded; if it has no bounds, it is unbounded. A bounded key range can either be open (the endpoints are excluded) or closed (the endpoints are included). To retrieve all keys within a certain range, you can use the following code constructs:
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBKeyRange)
*/

тип IDBKeyRange = интерфейс
{
  защищено 
  lower: /*(!) any */ Объект?

  защищено 
  lowerOpen: ДаНет

  защищено 
  upper: /*(!) any */ Объект?

  защищено 
  upperOpen: ДаНет

  операция includes(key: /*(!) any */ Объект?): ДаНет
}


внешнее
/*(!) var */ IDBKeyRange: объект { prototype: IDBKeyRange; при создании()/*(!) no_type */ Объект?; операция bound(lower: /*(!) any */ Объект?, upper: /*(!) any */ Объект?, lowerOpen: ДаНет?FUCKFUCK = пусто, upperOpen: ДаНет?FUCKFUCK = пусто): IDBKeyRange; операция lowerBound(lower: /*(!) any */ Объект?, open: ДаНет?FUCKFUCK = пусто): IDBKeyRange; операция only(value: /*(!) any */ Объект?): IDBKeyRange; операция upperBound(upper: /*(!) any */ Объект?, open: ДаНет?FUCKFUCK = пусто): IDBKeyRange }


/**
* This example shows a variety of different uses of object stores, from updating the data structure with IDBObjectStore.createIndex inside an onupgradeneeded function, to adding a new item to our object store with IDBObjectStore.add. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore)
*/

тип IDBObjectStore = интерфейс
{
  защищено 
  autoIncrement: ДаНет

  защищено 
  indexNames: DOMStringList

  защищено 
  keyPath: Текст | Список<Текст>

  name: Текст

  защищено 
  transaction: IDBTransaction

  операция add(value: /*(!) any */ Объект?, key: IDBValidKey?FUCKFUCK = пусто): IDBRequest<IDBValidKey>

  операция clear(): IDBRequest<пусто>

  операция count(query: IDBValidKey | IDBKeyRange | пусто = пусто): IDBRequest<Число>

  операция createIndex(name: Текст, keyPath: Текст | Список<Текст>, options: IDBIndexParameters?FUCKFUCK = пусто): IDBIndex

  операция delete(query: IDBValidKey | IDBKeyRange): IDBRequest<пусто>

  операция deleteIndex(name: Текст)

  операция get(query: IDBValidKey | IDBKeyRange): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, count: Число?FUCKFUCK = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: IDBValidKey | IDBKeyRange): IDBRequest<IDBValidKey?FUCKFUCK>

  операция index(name: Текст): IDBIndex

  операция openCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursorWithValue?FUCKFUCK>

  операция openKeyCursor(query: IDBValidKey | IDBKeyRange | пусто | пусто = пусто, direction: IDBCursorDirection?FUCKFUCK = пусто): IDBRequest<IDBCursor?FUCKFUCK>

  операция put(value: /*(!) any */ Объект?, key: IDBValidKey?FUCKFUCK = пусто): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBObjectStore: объект { prototype: IDBObjectStore; при создании()/*(!) no_type */ Объект? }


тип IDBOpenDBRequestEventMap = интерфейс
{
  "blocked": IDBVersionChangeEvent

  "upgradeneeded": IDBVersionChangeEvent
}


/**
* Also inherits methods from its parents IDBRequest and EventTarget.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBOpenDBRequest)
*/

тип IDBOpenDBRequest = интерфейс
{
  onblocked: операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  onupgradeneeded: операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBOpenDBRequest: объект { prototype: IDBOpenDBRequest; при создании()/*(!) no_type */ Объект? }


тип IDBRequestEventMap = интерфейс
{
  "error": Event

  "success": Event
}


/**
* The request object does not initially contain any information about the result of the operation, but once information becomes available, an event is fired on the request, and the information becomes available through the properties of the IDBRequest instance.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBRequest)
*/

тип IDBRequest<T> = интерфейс
{
  защищено 
  error: DOMException?FUCKFUCK

  onerror: операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsuccess: операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: IDBRequestReadyState

  защищено 
  result: T

  защищено 
  source: IDBObjectStore | IDBIndex | IDBCursor

  защищено 
  transaction: IDBTransaction?FUCKFUCK

  операция addEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBRequest: объект { prototype: IDBRequest; при создании()/*(!) no_type */ Объект? }


тип IDBTransactionEventMap = интерфейс
{
  "abort": Event

  "complete": Event

  "error": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBTransaction) */

тип IDBTransaction = интерфейс
{
  защищено 
  db: IDBDatabase

  защищено 
  durability: IDBTransactionDurability

  защищено 
  error: DOMException?FUCKFUCK

  защищено 
  mode: IDBTransactionMode

  защищено 
  objectStoreNames: DOMStringList

  onabort: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncomplete: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция abort()

  операция commit()

  операция objectStore(name: Текст): IDBObjectStore

  операция addEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ IDBTransaction: объект { prototype: IDBTransaction; при создании()/*(!) no_type */ Объект? }


/**
* This IndexedDB API interface indicates that the version of the database has changed, as the result of an IDBOpenDBRequest.onupgradeneeded event handler function.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBVersionChangeEvent)
*/

тип IDBVersionChangeEvent = интерфейс
{
  защищено 
  newVersion: Число?FUCKFUCK

  защищено 
  oldVersion: Число
}


внешнее
/*(!) var */ IDBVersionChangeEvent: объект { prototype: IDBVersionChangeEvent; при создании(type: Текст, eventInitDict: IDBVersionChangeEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The IIRFilterNode interface of the Web Audio API is a AudioNode processor which implements a general infinite impulse response (IIR)  filter; this type of filter can be used to implement tone control devices and graphic equalizers as well. It lets the parameters of the filter response be specified, so that it can be tuned as needed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IIRFilterNode)
*/

тип IIRFilterNode = интерфейс
{
  операция getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array)
}


внешнее
/*(!) var */ IIRFilterNode: объект { prototype: IIRFilterNode; при создании(context: BaseAudioContext, options: IIRFilterOptions)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/IdleDeadline) */

тип IdleDeadline = интерфейс
{
  защищено 
  didTimeout: ДаНет

  операция timeRemaining(): DOMHighResTimeStamp
}


внешнее
/*(!) var */ IdleDeadline: объект { prototype: IdleDeadline; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmap) */

тип ImageBitmap = интерфейс
{
  защищено 
  height: Число

  защищено 
  width: Число

  операция close()
}


внешнее
/*(!) var */ ImageBitmap: объект { prototype: ImageBitmap; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmapRenderingContext) */

тип ImageBitmapRenderingContext = интерфейс
{
  защищено 
  canvas: HTMLCanvasElement | OffscreenCanvas

  операция transferFromImageBitmap(bitmap: ImageBitmap?FUCKFUCK)
}


внешнее
/*(!) var */ ImageBitmapRenderingContext: объект { prototype: ImageBitmapRenderingContext; при создании()/*(!) no_type */ Объект? }


/**
* The underlying pixel data of an area of a <canvas> element. It is created using the ImageData() constructor or creator methods on the CanvasRenderingContext2D object associated with a canvas: createImageData() and getImageData(). It can also be used to set a part of the canvas by using putImageData().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageData)
*/

тип ImageData = интерфейс
{
  защищено 
  colorSpace: PredefinedColorSpace

  защищено 
  data: Uint8ClampedArray

  защищено 
  height: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ ImageData: объект { prototype: ImageData; при создании(sw: Число, sh: Число, settings: ImageDataSettings?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(data: Uint8ClampedArray, sw: Число, sh: Число?FUCKFUCK = пусто, settings: ImageDataSettings?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип InnerHTML = интерфейс
{
  innerHTML: Текст
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/InputDeviceInfo)
*/

тип InputDeviceInfo = интерфейс
{
  операция getCapabilities(): MediaTrackCapabilities
}


внешнее
/*(!) var */ InputDeviceInfo: объект { prototype: InputDeviceInfo; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/InputEvent) */

тип InputEvent = интерфейс
{
  защищено 
  data: Текст?FUCKFUCK

  защищено 
  dataTransfer: DataTransfer?FUCKFUCK

  защищено 
  inputType: Текст

  защищено 
  isComposing: ДаНет

  операция getTargetRanges(): Список<StaticRange>
}


внешнее
/*(!) var */ InputEvent: объект { prototype: InputEvent; при создании(type: Текст, eventInitDict: InputEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IntersectionObserver)
*/

тип IntersectionObserver = интерфейс
{
  защищено 
  root: Element | Document | пусто

  защищено 
  rootMargin: Текст

  защищено 
  thresholds: ReadonlyArray<Число>

  операция disconnect()

  операция observe(target: Element)

  операция takeRecords(): Список<IntersectionObserverEntry>

  операция unobserve(target: Element)
}


внешнее
/*(!) var */ IntersectionObserver: объект { prototype: IntersectionObserver; при создании(callback: IntersectionObserverCallback, options: IntersectionObserverInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Intersection Observer API interface describes the intersection between the target element and its root container at a specific moment of transition.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IntersectionObserverEntry)
*/

тип IntersectionObserverEntry = интерфейс
{
  защищено 
  boundingClientRect: DOMRectReadOnly

  защищено 
  intersectionRatio: Число

  защищено 
  intersectionRect: DOMRectReadOnly

  защищено 
  isIntersecting: ДаНет

  защищено 
  rootBounds: DOMRectReadOnly?FUCKFUCK

  защищено 
  target: Element

  защищено 
  time: DOMHighResTimeStamp
}


внешнее
/*(!) var */ IntersectionObserverEntry: объект { prototype: IntersectionObserverEntry; при создании(intersectionObserverEntryInit: IntersectionObserverEntryInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/KHR_parallel_shader_compile) */

тип KHR_parallel_shader_compile = интерфейс
{
  защищено 
  COMPLETION_STATUS_KHR: 0x91B1
}


/**
* KeyboardEvent objects describe a user interaction with the keyboard; each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/KeyboardEvent)
*/

тип KeyboardEvent = интерфейс
{
  защищено 
  altKey: ДаНет

  защищено 
  charCode: Число

  защищено 
  code: Текст

  защищено 
  ctrlKey: ДаНет

  защищено 
  isComposing: ДаНет

  защищено 
  key: Текст

  защищено 
  keyCode: Число

  защищено 
  location: Число

  защищено 
  metaKey: ДаНет

  защищено 
  repeat: ДаНет

  защищено 
  shiftKey: ДаНет

  операция getModifierState(keyArg: Текст): ДаНет

  операция initKeyboardEvent(typeArg: Текст, bubblesArg: ДаНет?FUCKFUCK = пусто, cancelableArg: ДаНет?FUCKFUCK = пусто, viewArg: Window?FUCKFUCK = пусто, keyArg: Текст?FUCKFUCK = пусто, locationArg: Число?FUCKFUCK = пусто, ctrlKey: ДаНет?FUCKFUCK = пусто, altKey: ДаНет?FUCKFUCK = пусто, shiftKey: ДаНет?FUCKFUCK = пусто, metaKey: ДаНет?FUCKFUCK = пусто)

  защищено 
  DOM_KEY_LOCATION_STANDARD: 0x00

  защищено 
  DOM_KEY_LOCATION_LEFT: 0x01

  защищено 
  DOM_KEY_LOCATION_RIGHT: 0x02

  защищено 
  DOM_KEY_LOCATION_NUMPAD: 0x03
}


внешнее
/*(!) var */ KeyboardEvent: объект { prototype: KeyboardEvent; при создании(type: Текст, eventInitDict: KeyboardEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  DOM_KEY_LOCATION_STANDARD: 0x00; защищено  DOM_KEY_LOCATION_LEFT: 0x01; защищено  DOM_KEY_LOCATION_RIGHT: 0x02; защищено  DOM_KEY_LOCATION_NUMPAD: 0x03 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/KeyframeEffect) */

тип KeyframeEffect = интерфейс
{
  composite: CompositeOperation

  iterationComposite: IterationCompositeOperation

  pseudoElement: Текст?FUCKFUCK

  target: Element?FUCKFUCK

  операция getKeyframes(): Список<ComputedKeyframe>

  операция setKeyframes(keyframes: Список<Keyframe> | PropertyIndexedKeyframes | пусто)
}


внешнее
/*(!) var */ KeyframeEffect: объект { prototype: KeyframeEffect; при создании(target: Element?FUCKFUCK, keyframes: Список<Keyframe> | PropertyIndexedKeyframes | пусто, options: Число | KeyframeEffectOptions | пусто = пусто)/*(!) no_type */ Объект?; при создании(source: KeyframeEffect)/*(!) no_type */ Объект? }


тип LinkStyle = интерфейс
{
  защищено 
  sheet: CSSStyleSheet?FUCKFUCK
}


/**
* The location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Location)
*/

тип Location = интерфейс
{
  защищено 
  ancestorOrigins: DOMStringList

  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  операция assign(url: Текст | URL)

  операция reload()

  операция replace(url: Текст | URL)
}


внешнее
/*(!) var */ Location: объект { prototype: Location; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Lock)
*/

тип Lock = интерфейс
{
  защищено 
  mode: LockMode

  защищено 
  name: Текст
}


внешнее
/*(!) var */ Lock: объект { prototype: Lock; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/LockManager)
*/

тип LockManager = интерфейс
{
  операция query(): Promise<LockManagerSnapshot>

  операция request(name: Текст, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>

  операция request(name: Текст, options: LockOptions, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>
}


внешнее
/*(!) var */ LockManager: объект { prototype: LockManager; при создании()/*(!) no_type */ Объект? }


тип MIDIAccessEventMap = интерфейс
{
  "statechange": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIAccess)
*/

тип MIDIAccess = интерфейс
{
  защищено 
  inputs: MIDIInputMap

  onstatechange: операция(this: MIDIAccess, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  outputs: MIDIOutputMap

  защищено 
  sysexEnabled: ДаНет

  операция addEventListener<K = /*(!) keyof MIDIAccessEventMap */ Объект?>(type: K, listener: операция(this: MIDIAccess, ev: /*(!) MIDIAccessEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIAccessEventMap */ Объект?>(type: K, listener: операция(this: MIDIAccess, ev: /*(!) MIDIAccessEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MIDIAccess: объект { prototype: MIDIAccess; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIConnectionEvent)
*/

тип MIDIConnectionEvent = интерфейс
{
  защищено 
  port: MIDIPort
}


внешнее
/*(!) var */ MIDIConnectionEvent: объект { prototype: MIDIConnectionEvent; при создании(type: Текст, eventInitDict: MIDIConnectionEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип MIDIInputEventMap = интерфейс
{
  "midimessage": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIInput)
*/

тип MIDIInput = интерфейс
{
  onmidimessage: операция(this: MIDIInput, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof MIDIInputEventMap */ Объект?>(type: K, listener: операция(this: MIDIInput, ev: /*(!) MIDIInputEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIInputEventMap */ Объект?>(type: K, listener: операция(this: MIDIInput, ev: /*(!) MIDIInputEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MIDIInput: объект { prototype: MIDIInput; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIInputMap)
*/

тип MIDIInputMap = интерфейс
{
  операция forEach(callbackfn: операция(value: MIDIInput, key: Текст, parent: MIDIInputMap), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MIDIInputMap: объект { prototype: MIDIInputMap; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIMessageEvent)
*/

тип MIDIMessageEvent = интерфейс
{
  защищено 
  data: Uint8Array
}


внешнее
/*(!) var */ MIDIMessageEvent: объект { prototype: MIDIMessageEvent; при создании(type: Текст, eventInitDict: MIDIMessageEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIOutput)
*/

тип MIDIOutput = интерфейс
{
  операция send(data: Список<Число>, timestamp: DOMHighResTimeStamp?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type: K, listener: операция(this: MIDIOutput, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type: K, listener: операция(this: MIDIOutput, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MIDIOutput: объект { prototype: MIDIOutput; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIOutputMap)
*/

тип MIDIOutputMap = интерфейс
{
  операция forEach(callbackfn: операция(value: MIDIOutput, key: Текст, parent: MIDIOutputMap), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MIDIOutputMap: объект { prototype: MIDIOutputMap; при создании()/*(!) no_type */ Объект? }


тип MIDIPortEventMap = интерфейс
{
  "statechange": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIPort)
*/

тип MIDIPort = интерфейс
{
  защищено 
  connection: MIDIPortConnectionState

  защищено 
  id: Текст

  защищено 
  manufacturer: Текст?FUCKFUCK

  защищено 
  name: Текст?FUCKFUCK

  onstatechange: операция(this: MIDIPort, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: MIDIPortDeviceState

  защищено 
  type: MIDIPortType

  защищено 
  version: Текст?FUCKFUCK

  операция close(): Promise<MIDIPort>

  операция open(): Promise<MIDIPort>

  операция addEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type: K, listener: операция(this: MIDIPort, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type: K, listener: операция(this: MIDIPort, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MIDIPort: объект { prototype: MIDIPort; при создании()/*(!) no_type */ Объект? }


тип MathMLElementEventMap = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MathMLElement) */

тип MathMLElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof MathMLElementEventMap */ Объект?>(type: K, listener: операция(this: MathMLElement, ev: /*(!) MathMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MathMLElementEventMap */ Объект?>(type: K, listener: операция(this: MathMLElement, ev: /*(!) MathMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MathMLElement: объект { prototype: MathMLElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaCapabilities) */

тип MediaCapabilities = интерфейс
{
  операция decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>

  операция encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesEncodingInfo>
}


внешнее
/*(!) var */ MediaCapabilities: объект { prototype: MediaCapabilities; при создании()/*(!) no_type */ Объект? }


/**
* The MediaDevicesInfo interface contains information that describes a single media input or output device.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaDeviceInfo)
*/

тип MediaDeviceInfo = интерфейс
{
  защищено 
  deviceId: Текст

  защищено 
  groupId: Текст

  защищено 
  kind: MediaDeviceKind

  защищено 
  label: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ MediaDeviceInfo: объект { prototype: MediaDeviceInfo; при создании()/*(!) no_type */ Объект? }


тип MediaDevicesEventMap = интерфейс
{
  "devicechange": Event
}


/**
* Provides access to connected media input devices like cameras and microphones, as well as screen sharing. In essence, it lets you obtain access to any hardware source of media data.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaDevices)
*/

тип MediaDevices = интерфейс
{
  ondevicechange: операция(this: MediaDevices, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция enumerateDevices(): Promise<Список<MediaDeviceInfo>>

  операция getDisplayMedia(options: DisplayMediaStreamOptions?FUCKFUCK = пусто): Promise<MediaStream>

  операция getSupportedConstraints(): MediaTrackSupportedConstraints

  операция getUserMedia(constraints: MediaStreamConstraints?FUCKFUCK = пусто): Promise<MediaStream>

  операция addEventListener<K = /*(!) keyof MediaDevicesEventMap */ Объект?>(type: K, listener: операция(this: MediaDevices, ev: /*(!) MediaDevicesEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaDevicesEventMap */ Объект?>(type: K, listener: операция(this: MediaDevices, ev: /*(!) MediaDevicesEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaDevices: объект { prototype: MediaDevices; при создании()/*(!) no_type */ Объект? }


/**
* A MediaElementSourceNode has no inputs and exactly one output, and is created using the AudioContext.createMediaElementSource method. The amount of channels in the output equals the number of channels of the audio referenced by the HTMLMediaElement used in the creation of the node, or is 1 if the HTMLMediaElement has no audio.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaElementAudioSourceNode)
*/

тип MediaElementAudioSourceNode = интерфейс
{
  защищено 
  mediaElement: HTMLMediaElement
}


внешнее
/*(!) var */ MediaElementAudioSourceNode: объект { prototype: MediaElementAudioSourceNode; при создании(context: AudioContext, options: MediaElementAudioSourceOptions)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaEncryptedEvent) */

тип MediaEncryptedEvent = интерфейс
{
  защищено 
  initData: ArrayBuffer?FUCKFUCK

  защищено 
  initDataType: Текст
}


внешнее
/*(!) var */ MediaEncryptedEvent: объект { prototype: MediaEncryptedEvent; при создании(type: Текст, eventInitDict: MediaEncryptedEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* An error which occurred while handling media in an HTML media element based on HTMLMediaElement, such as <audio> or <video>.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaError)
*/

тип MediaError = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  MEDIA_ERR_ABORTED: 1

  защищено 
  MEDIA_ERR_NETWORK: 2

  защищено 
  MEDIA_ERR_DECODE: 3

  защищено 
  MEDIA_ERR_SRC_NOT_SUPPORTED: 4
}


внешнее
/*(!) var */ MediaError: объект { prototype: MediaError; при создании()/*(!) no_type */ Объект?; защищено  MEDIA_ERR_ABORTED: 1; защищено  MEDIA_ERR_NETWORK: 2; защищено  MEDIA_ERR_DECODE: 3; защищено  MEDIA_ERR_SRC_NOT_SUPPORTED: 4 }


/**
* This EncryptedMediaExtensions API interface contains the content and related data when the content decryption module generates a message for the session.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeyMessageEvent)
*/

тип MediaKeyMessageEvent = интерфейс
{
  защищено 
  message: ArrayBuffer

  защищено 
  messageType: MediaKeyMessageType
}


внешнее
/*(!) var */ MediaKeyMessageEvent: объект { prototype: MediaKeyMessageEvent; при создании(type: Текст, eventInitDict: MediaKeyMessageEventInit)/*(!) no_type */ Объект? }


тип MediaKeySessionEventMap = интерфейс
{
  "keystatuseschange": Event

  "message": MediaKeyMessageEvent
}


/**
* This EncryptedMediaExtensions API interface represents a context for message exchange with a content decryption module (CDM).
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeySession)
*/

тип MediaKeySession = интерфейс
{
  защищено 
  closed: Promise<MediaKeySessionClosedReason>

  защищено 
  expiration: Число

  защищено 
  keyStatuses: MediaKeyStatusMap

  onkeystatuseschange: операция(this: MediaKeySession, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: MediaKeySession, ev: MediaKeyMessageEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  sessionId: Текст

  операция close(): Promise<Ничего>

  операция generateRequest(initDataType: Текст, initData: BufferSource): Promise<Ничего>

  операция load(sessionId: Текст): Promise<ДаНет>

  операция remove(): Promise<Ничего>

  операция update(response: BufferSource): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof MediaKeySessionEventMap */ Объект?>(type: K, listener: операция(this: MediaKeySession, ev: /*(!) MediaKeySessionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaKeySessionEventMap */ Объект?>(type: K, listener: операция(this: MediaKeySession, ev: /*(!) MediaKeySessionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaKeySession: объект { prototype: MediaKeySession; при создании()/*(!) no_type */ Объект? }


/**
* This EncryptedMediaExtensions API interface is a read-only map of media key statuses by key IDs.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeyStatusMap)
*/

тип MediaKeyStatusMap = интерфейс
{
  защищено 
  size: Число

  операция get(keyId: BufferSource): MediaKeyStatus?FUCKFUCK

  операция has(keyId: BufferSource): ДаНет

  операция forEach(callbackfn: операция(value: MediaKeyStatus, key: BufferSource, parent: MediaKeyStatusMap), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MediaKeyStatusMap: объект { prototype: MediaKeyStatusMap; при создании()/*(!) no_type */ Объект? }


/**
* This EncryptedMediaExtensions API interface provides access to a Key System for decryption and/or a content protection provider. You can request an instance of this object using the Navigator.requestMediaKeySystemAccess method.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeySystemAccess)
*/

тип MediaKeySystemAccess = интерфейс
{
  защищено 
  keySystem: Текст

  операция createMediaKeys(): Promise<MediaKeys>

  операция getConfiguration(): MediaKeySystemConfiguration
}


внешнее
/*(!) var */ MediaKeySystemAccess: объект { prototype: MediaKeySystemAccess; при создании()/*(!) no_type */ Объект? }


/**
* This EncryptedMediaExtensions API interface the represents a set of keys that an associated HTMLMediaElement can use for decryption of media data during playback.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeys)
*/

тип MediaKeys = интерфейс
{
  операция createSession(sessionType: MediaKeySessionType?FUCKFUCK = пусто): MediaKeySession

  операция setServerCertificate(serverCertificate: BufferSource): Promise<ДаНет>
}


внешнее
/*(!) var */ MediaKeys: объект { prototype: MediaKeys; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaList) */

тип MediaList = интерфейс
{
  защищено 
  length: Число

  mediaText: Текст

  операция toString(): Текст

  операция appendMedium(medium: Текст)

  операция deleteMedium(medium: Текст)

  операция item(index: Число): Текст?FUCKFUCK

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ MediaList: объект { prototype: MediaList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaMetadata) */

тип MediaMetadata = интерфейс
{
  album: Текст

  artist: Текст

  artwork: ReadonlyArray<MediaImage>

  title: Текст
}


внешнее
/*(!) var */ MediaMetadata: объект { prototype: MediaMetadata; при создании(init: MediaMetadataInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип MediaQueryListEventMap = интерфейс
{
  "change": MediaQueryListEvent
}


/**
* Stores information on a media query applied to a document, and handles sending notifications to listeners when the media query state change (i.e. when the media query test starts or stops evaluating to true).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaQueryList)
*/

тип MediaQueryList = интерфейс
{
  защищено 
  matches: ДаНет

  защищено 
  media: Текст

  onchange: операция(this: MediaQueryList, ev: MediaQueryListEvent): /*(!) any */ Объект??FUCKFUCK

  операция addListener(callback: операция(this: MediaQueryList, ev: MediaQueryListEvent): /*(!) any */ Объект??FUCKFUCK)

  операция removeListener(callback: операция(this: MediaQueryList, ev: MediaQueryListEvent): /*(!) any */ Объект??FUCKFUCK)

  операция addEventListener<K = /*(!) keyof MediaQueryListEventMap */ Объект?>(type: K, listener: операция(this: MediaQueryList, ev: /*(!) MediaQueryListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaQueryListEventMap */ Объект?>(type: K, listener: операция(this: MediaQueryList, ev: /*(!) MediaQueryListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaQueryList: объект { prototype: MediaQueryList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaQueryListEvent) */

тип MediaQueryListEvent = интерфейс
{
  защищено 
  matches: ДаНет

  защищено 
  media: Текст
}


внешнее
/*(!) var */ MediaQueryListEvent: объект { prototype: MediaQueryListEvent; при создании(type: Текст, eventInitDict: MediaQueryListEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип MediaRecorderEventMap = интерфейс
{
  "dataavailable": BlobEvent

  "error": Event

  "pause": Event

  "resume": Event

  "start": Event

  "stop": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaRecorder) */

тип MediaRecorder = интерфейс
{
  защищено 
  audioBitsPerSecond: Число

  защищено 
  mimeType: Текст

  ondataavailable: операция(this: MediaRecorder, ev: BlobEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onpause: операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onresume: операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onstart: операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onstop: операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: RecordingState

  защищено 
  stream: MediaStream

  защищено 
  videoBitsPerSecond: Число

  операция pause()

  операция requestData()

  операция resume()

  операция start(timeslice: Число?FUCKFUCK = пусто)

  операция stop()

  операция addEventListener<K = /*(!) keyof MediaRecorderEventMap */ Объект?>(type: K, listener: операция(this: MediaRecorder, ev: /*(!) MediaRecorderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaRecorderEventMap */ Объект?>(type: K, listener: операция(this: MediaRecorder, ev: /*(!) MediaRecorderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaRecorder: объект { prototype: MediaRecorder; при создании(stream: MediaStream, options: MediaRecorderOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция isTypeSupported(type: Текст): ДаНет }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaSession) */

тип MediaSession = интерфейс
{
  metadata: MediaMetadata?FUCKFUCK

  playbackState: MediaSessionPlaybackState

  операция setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler?FUCKFUCK)

  операция setPositionState(state: MediaPositionState?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MediaSession: объект { prototype: MediaSession; при создании()/*(!) no_type */ Объект? }


тип MediaSourceEventMap = интерфейс
{
  "sourceclose": Event

  "sourceended": Event

  "sourceopen": Event
}


/**
* This Media Source Extensions API interface represents a source of media data for an HTMLMediaElement object. A MediaSource object can be attached to a HTMLMediaElement to be played in the user agent.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaSource)
*/

тип MediaSource = интерфейс
{
  защищено 
  activeSourceBuffers: SourceBufferList

  duration: Число

  onsourceclose: операция(this: MediaSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsourceended: операция(this: MediaSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsourceopen: операция(this: MediaSource, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: ReadyState

  защищено 
  sourceBuffers: SourceBufferList

  операция addSourceBuffer(type: Текст): SourceBuffer

  операция clearLiveSeekableRange()

  операция endOfStream(error: EndOfStreamError?FUCKFUCK = пусто)

  операция removeSourceBuffer(sourceBuffer: SourceBuffer)

  операция setLiveSeekableRange(start: Число, end: Число)

  операция addEventListener<K = /*(!) keyof MediaSourceEventMap */ Объект?>(type: K, listener: операция(this: MediaSource, ev: /*(!) MediaSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaSourceEventMap */ Объект?>(type: K, listener: операция(this: MediaSource, ev: /*(!) MediaSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaSource: объект { prototype: MediaSource; при создании()/*(!) no_type */ Объект?; операция isTypeSupported(type: Текст): ДаНет }


тип MediaStreamEventMap = интерфейс
{
  "addtrack": MediaStreamTrackEvent

  "removetrack": MediaStreamTrackEvent
}


/**
* A stream of media content. A stream consists of several tracks such as video or audio tracks. Each track is specified as an instance of MediaStreamTrack.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStream)
*/

тип MediaStream = интерфейс
{
  защищено 
  active: ДаНет

  защищено 
  id: Текст

  onaddtrack: операция(this: MediaStream, ev: MediaStreamTrackEvent): /*(!) any */ Объект??FUCKFUCK

  onremovetrack: операция(this: MediaStream, ev: MediaStreamTrackEvent): /*(!) any */ Объект??FUCKFUCK

  операция addTrack(track: MediaStreamTrack)

  операция clone(): MediaStream

  операция getAudioTracks(): Список<MediaStreamTrack>

  операция getTrackById(trackId: Текст): MediaStreamTrack?FUCKFUCK

  операция getTracks(): Список<MediaStreamTrack>

  операция getVideoTracks(): Список<MediaStreamTrack>

  операция removeTrack(track: MediaStreamTrack)

  операция addEventListener<K = /*(!) keyof MediaStreamEventMap */ Объект?>(type: K, listener: операция(this: MediaStream, ev: /*(!) MediaStreamEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamEventMap */ Объект?>(type: K, listener: операция(this: MediaStream, ev: /*(!) MediaStreamEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaStream: объект { prototype: MediaStream; при создании()/*(!) no_type */ Объект?; при создании(stream: MediaStream)/*(!) no_type */ Объект?; при создании(tracks: Список<MediaStreamTrack>)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamAudioDestinationNode) */

тип MediaStreamAudioDestinationNode = интерфейс
{
  защищено 
  stream: MediaStream
}


внешнее
/*(!) var */ MediaStreamAudioDestinationNode: объект { prototype: MediaStreamAudioDestinationNode; при создании(context: AudioContext, options: AudioNodeOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A type of AudioNode which operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamAudioSourceNode)
*/

тип MediaStreamAudioSourceNode = интерфейс
{
  защищено 
  mediaStream: MediaStream
}


внешнее
/*(!) var */ MediaStreamAudioSourceNode: объект { prototype: MediaStreamAudioSourceNode; при создании(context: AudioContext, options: MediaStreamAudioSourceOptions)/*(!) no_type */ Объект? }


тип MediaStreamTrackEventMap = интерфейс
{
  "ended": Event

  "mute": Event

  "unmute": Event
}


/**
* A single media track within a stream; typically, these are audio or video tracks, but other track types may exist as well.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack)
*/

тип MediaStreamTrack = интерфейс
{
  contentHint: Текст

  enabled: ДаНет

  защищено 
  id: Текст

  защищено 
  kind: Текст

  защищено 
  label: Текст

  защищено 
  muted: ДаНет

  onended: операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmute: операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onunmute: операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: MediaStreamTrackState

  операция applyConstraints(constraints: MediaTrackConstraints?FUCKFUCK = пусто): Promise<Ничего>

  операция clone(): MediaStreamTrack

  операция getCapabilities(): MediaTrackCapabilities

  операция getConstraints(): MediaTrackConstraints

  операция getSettings(): MediaTrackSettings

  операция stop()

  операция addEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type: K, listener: операция(this: MediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type: K, listener: операция(this: MediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MediaStreamTrack: объект { prototype: MediaStreamTrack; при создании()/*(!) no_type */ Объект? }


/**
* Events which indicate that a MediaStream has had tracks added to or removed from the stream through calls to Media Stream API methods. These events are sent to the stream when these changes occur.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamTrackEvent)
*/

тип MediaStreamTrackEvent = интерфейс
{
  защищено 
  track: MediaStreamTrack
}


внешнее
/*(!) var */ MediaStreamTrackEvent: объект { prototype: MediaStreamTrackEvent; при создании(type: Текст, eventInitDict: MediaStreamTrackEventInit)/*(!) no_type */ Объект? }


/**
* This Channel Messaging API interface allows us to create a new message channel and send data through it via its two MessagePort properties.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel)
*/

тип MessageChannel = интерфейс
{
  защищено 
  port1: MessagePort

  защищено 
  port2: MessagePort
}


внешнее
/*(!) var */ MessageChannel: объект { prototype: MessageChannel; при создании()/*(!) no_type */ Объект? }


/**
* A message received by a target object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)
*/

тип MessageEvent<T> = интерфейс
{
  защищено 
  data: T

  защищено 
  lastEventId: Текст

  защищено 
  origin: Текст

  защищено 
  ports: ReadonlyArray<MessagePort>

  защищено 
  source: MessageEventSource?FUCKFUCK

  операция initMessageEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто, data: /*(!) any */ Объект??FUCKFUCK = пусто, origin: Текст?FUCKFUCK = пусто, lastEventId: Текст?FUCKFUCK = пусто, source: MessageEventSource?FUCKFUCK = пусто, ports: Список<MessagePort>?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ MessageEvent: объект { prototype: MessageEvent; при создании(type: Текст, eventInitDict: MessageEventInit<T>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип MessagePortEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Channel Messaging API interface represents one of the two ports of a MessageChannel, allowing messages to be sent from one port and listening out for them arriving at the other.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort)
*/

тип MessagePort = интерфейс
{
  onmessage: операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция close()

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция start()

  операция addEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ MessagePort: объект { prototype: MessagePort; при создании()/*(!) no_type */ Объект? }


/**
* Provides contains information about a MIME type associated with a particular plugin. NavigatorPlugins.mimeTypes returns an array of this object.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MimeType)
*/

тип MimeType = интерфейс
{
  защищено 
  description: Текст

  защищено 
  enabledPlugin: Plugin

  защищено 
  suffixes: Текст

  защищено 
  type: Текст
}


/** @deprecated */

внешнее
/*(!) var */ MimeType: объект { prototype: MimeType; при создании()/*(!) no_type */ Объект? }


/**
* Returns an array of MimeType instances, each of which contains information about a supported browser plugins. This object is returned by NavigatorPlugins.mimeTypes.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MimeTypeArray)
*/

тип MimeTypeArray = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): MimeType?FUCKFUCK

  операция namedItem(name: Текст): MimeType?FUCKFUCK

  /*(!) [index: number]: MimeType*/
}


/** @deprecated */

внешнее
/*(!) var */ MimeTypeArray: объект { prototype: MimeTypeArray; при создании()/*(!) no_type */ Объект? }


/**
* Events that occur due to the user interacting with a pointing device (such as a mouse). Common events using this interface include click, dblclick, mouseup, mousedown.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MouseEvent)
*/

тип MouseEvent = интерфейс
{
  защищено 
  altKey: ДаНет

  защищено 
  button: Число

  защищено 
  buttons: Число

  защищено 
  clientX: Число

  защищено 
  clientY: Число

  защищено 
  ctrlKey: ДаНет

  защищено 
  metaKey: ДаНет

  защищено 
  movementX: Число

  защищено 
  movementY: Число

  защищено 
  offsetX: Число

  защищено 
  offsetY: Число

  защищено 
  pageX: Число

  защищено 
  pageY: Число

  защищено 
  relatedTarget: EventTarget?FUCKFUCK

  защищено 
  screenX: Число

  защищено 
  screenY: Число

  защищено 
  shiftKey: ДаНет

  защищено 
  x: Число

  защищено 
  y: Число

  операция getModifierState(keyArg: Текст): ДаНет

  операция initMouseEvent(typeArg: Текст, canBubbleArg: ДаНет, cancelableArg: ДаНет, viewArg: Window, detailArg: Число, screenXArg: Число, screenYArg: Число, clientXArg: Число, clientYArg: Число, ctrlKeyArg: ДаНет, altKeyArg: ДаНет, shiftKeyArg: ДаНет, metaKeyArg: ДаНет, buttonArg: Число, relatedTargetArg: EventTarget?FUCKFUCK)
}


внешнее
/*(!) var */ MouseEvent: объект { prototype: MouseEvent; при создании(type: Текст, eventInitDict: MouseEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Provides event properties that are specific to modifications to the Document Object Model (DOM) hierarchy and nodes.
* @deprecated DOM4 [DOM] provides a new mechanism using a MutationObserver interface which addresses the use cases that mutation events solve, but in a more performant manner. Thus, this specification describes mutation events for reference and completeness of legacy behavior, but deprecates the use of the MutationEvent interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MutationEvent)
*/

тип MutationEvent = интерфейс
{
  защищено 
  attrChange: Число

  защищено 
  attrName: Текст

  защищено 
  newValue: Текст

  защищено 
  prevValue: Текст

  защищено 
  relatedNode: Node?FUCKFUCK

  операция initMutationEvent(typeArg: Текст, bubblesArg: ДаНет?FUCKFUCK = пусто, cancelableArg: ДаНет?FUCKFUCK = пусто, relatedNodeArg: Node?FUCKFUCK = пусто, prevValueArg: Текст?FUCKFUCK = пусто, newValueArg: Текст?FUCKFUCK = пусто, attrNameArg: Текст?FUCKFUCK = пусто, attrChangeArg: Число?FUCKFUCK = пусто)

  защищено 
  MODIFICATION: 1

  защищено 
  ADDITION: 2

  защищено 
  REMOVAL: 3
}


/** @deprecated */

внешнее
/*(!) var */ MutationEvent: объект { prototype: MutationEvent; при создании()/*(!) no_type */ Объект?; защищено  MODIFICATION: 1; защищено  ADDITION: 2; защищено  REMOVAL: 3 }


/**
* Provides the ability to watch for changes being made to the DOM tree. It is designed as a replacement for the older Mutation Events feature which was part of the DOM3 Events specification.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MutationObserver)
*/

тип MutationObserver = интерфейс
{
  операция disconnect()

  операция observe(target: Node, options: MutationObserverInit?FUCKFUCK = пусто)

  операция takeRecords(): Список<MutationRecord>
}


внешнее
/*(!) var */ MutationObserver: объект { prototype: MutationObserver; при создании(callback: MutationCallback)/*(!) no_type */ Объект? }


/**
* A MutationRecord represents an individual DOM mutation. It is the object that is passed to MutationObserver's callback.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MutationRecord)
*/

тип MutationRecord = интерфейс
{
  защищено 
  addedNodes: NodeList

  защищено 
  attributeName: Текст?FUCKFUCK

  защищено 
  attributeNamespace: Текст?FUCKFUCK

  защищено 
  nextSibling: Node?FUCKFUCK

  защищено 
  oldValue: Текст?FUCKFUCK

  защищено 
  previousSibling: Node?FUCKFUCK

  защищено 
  removedNodes: NodeList

  защищено 
  target: Node

  защищено 
  type: MutationRecordType
}


внешнее
/*(!) var */ MutationRecord: объект { prototype: MutationRecord; при создании()/*(!) no_type */ Объект? }


/**
* A collection of Attr objects. Objects inside a NamedNodeMap are not in any particular order, unlike NodeList, although they may be accessed by an index as in an array.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NamedNodeMap)
*/

тип NamedNodeMap = интерфейс
{
  защищено 
  length: Число

  операция getNamedItem(qualifiedName: Текст): Attr?FUCKFUCK

  операция getNamedItemNS(namespace: Текст?FUCKFUCK, localName: Текст): Attr?FUCKFUCK

  операция item(index: Число): Attr?FUCKFUCK

  операция removeNamedItem(qualifiedName: Текст): Attr

  операция removeNamedItemNS(namespace: Текст?FUCKFUCK, localName: Текст): Attr

  операция setNamedItem(attr: Attr): Attr?FUCKFUCK

  операция setNamedItemNS(attr: Attr): Attr?FUCKFUCK

  /*(!) [index: number]: Attr*/
}


внешнее
/*(!) var */ NamedNodeMap: объект { prototype: NamedNodeMap; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NavigationPreloadManager)
*/

тип NavigationPreloadManager = интерфейс
{
  операция disable(): Promise<Ничего>

  операция enable(): Promise<Ничего>

  операция getState(): Promise<NavigationPreloadState>

  операция setHeaderValue(value: Текст): Promise<Ничего>
}


внешнее
/*(!) var */ NavigationPreloadManager: объект { prototype: NavigationPreloadManager; при создании()/*(!) no_type */ Объект? }


/**
* The state and the identity of the user agent. It allows scripts to query it and to register themselves to carry on some activities.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Navigator)
*/

тип Navigator = интерфейс
{
  защищено 
  clipboard: Clipboard

  защищено 
  credentials: CredentialsContainer

  защищено 
  doNotTrack: Текст?FUCKFUCK

  защищено 
  geolocation: Geolocation

  защищено 
  maxTouchPoints: Число

  защищено 
  mediaCapabilities: MediaCapabilities

  защищено 
  mediaDevices: MediaDevices

  защищено 
  mediaSession: MediaSession

  защищено 
  permissions: Permissions

  защищено 
  serviceWorker: ServiceWorkerContainer

  защищено 
  userActivation: UserActivation

  защищено 
  wakeLock: WakeLock

  операция canShare(data: ShareData?FUCKFUCK = пусто): ДаНет

  операция getGamepads(): Список<Gamepad?FUCKFUCK>

  операция requestMIDIAccess(options: MIDIOptions?FUCKFUCK = пусто): Promise<MIDIAccess>

  операция requestMediaKeySystemAccess(keySystem: Текст, supportedConfigurations: Список<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>

  операция sendBeacon(url: Текст | URL, data: BodyInit?FUCKFUCK = пусто): ДаНет

  операция share(data: ShareData?FUCKFUCK = пусто): Promise<Ничего>

  операция vibrate(pattern: VibratePattern): ДаНет
}


внешнее
/*(!) var */ Navigator: объект { prototype: Navigator; при создании()/*(!) no_type */ Объект? }


тип NavigatorAutomationInformation = интерфейс
{
  защищено 
  webdriver: ДаНет
}


/** Available only in secure contexts. */

тип NavigatorBadge = интерфейс
{
  операция clearAppBadge(): Promise<Ничего>

  операция setAppBadge(contents: Число?FUCKFUCK = пусто): Promise<Ничего>
}


тип NavigatorConcurrentHardware = интерфейс
{
  защищено 
  hardwareConcurrency: Число
}


тип NavigatorContentUtils = интерфейс
{
  операция registerProtocolHandler(scheme: Текст, url: Текст | URL)
}


тип NavigatorCookies = интерфейс
{
  защищено 
  cookieEnabled: ДаНет
}


тип NavigatorID = интерфейс
{
  защищено 
  appCodeName: Текст

  защищено 
  appName: Текст

  защищено 
  appVersion: Текст

  защищено 
  platform: Текст

  защищено 
  product: Текст

  защищено 
  productSub: Текст

  защищено 
  userAgent: Текст

  защищено 
  vendor: Текст

  защищено 
  vendorSub: Текст
}


тип NavigatorLanguage = интерфейс
{
  защищено 
  language: Текст

  защищено 
  languages: ReadonlyArray<Текст>
}


/** Available only in secure contexts. */

тип NavigatorLocks = интерфейс
{
  защищено 
  locks: LockManager
}


тип NavigatorOnLine = интерфейс
{
  защищено 
  onLine: ДаНет
}


тип NavigatorPlugins = интерфейс
{
  защищено 
  mimeTypes: MimeTypeArray

  защищено 
  pdfViewerEnabled: ДаНет

  защищено 
  plugins: PluginArray

  операция javaEnabled(): ДаНет
}


/** Available only in secure contexts. */

тип NavigatorStorage = интерфейс
{
  защищено 
  storage: StorageManager
}


/**
* Node is an interface from which a number of DOM API object types inherit. It allows those types to be treated similarly; for example, inheriting the same set of methods, or being tested in the same way.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node)
*/

тип Node = интерфейс
{
  защищено 
  baseURI: Текст

  защищено 
  childNodes: NodeListOf<ChildNode>

  защищено 
  firstChild: ChildNode?FUCKFUCK

  защищено 
  isConnected: ДаНет

  защищено 
  lastChild: ChildNode?FUCKFUCK

  защищено 
  nextSibling: ChildNode?FUCKFUCK

  защищено 
  nodeName: Текст

  защищено 
  nodeType: Число

  nodeValue: Текст?FUCKFUCK

  защищено 
  ownerDocument: Document?FUCKFUCK

  защищено 
  parentElement: HTMLElement?FUCKFUCK

  защищено 
  parentNode: ParentNode?FUCKFUCK

  защищено 
  previousSibling: ChildNode?FUCKFUCK

  textContent: Текст?FUCKFUCK

  операция appendChild<T = Node>(node: T): T

  операция cloneNode(deep: ДаНет?FUCKFUCK = пусто): Node

  операция compareDocumentPosition(other: Node): Число

  операция contains(other: Node?FUCKFUCK): ДаНет

  операция getRootNode(options: GetRootNodeOptions?FUCKFUCK = пусто): Node

  операция hasChildNodes(): ДаНет

  операция insertBefore<T = Node>(node: T, child: Node?FUCKFUCK): T

  операция isDefaultNamespace(namespace: Текст?FUCKFUCK): ДаНет

  операция isEqualNode(otherNode: Node?FUCKFUCK): ДаНет

  операция isSameNode(otherNode: Node?FUCKFUCK): ДаНет

  операция lookupNamespaceURI(prefix: Текст?FUCKFUCK): Текст?FUCKFUCK

  операция lookupPrefix(namespace: Текст?FUCKFUCK): Текст?FUCKFUCK

  операция normalize()

  операция removeChild<T = Node>(child: T): T

  операция replaceChild<T = Node>(node: Node, child: T): T

  защищено 
  ELEMENT_NODE: 1

  защищено 
  ATTRIBUTE_NODE: 2

  защищено 
  TEXT_NODE: 3

  защищено 
  CDATA_SECTION_NODE: 4

  защищено 
  ENTITY_REFERENCE_NODE: 5

  защищено 
  ENTITY_NODE: 6

  защищено 
  PROCESSING_INSTRUCTION_NODE: 7

  защищено 
  COMMENT_NODE: 8

  защищено 
  DOCUMENT_NODE: 9

  защищено 
  DOCUMENT_TYPE_NODE: 10

  защищено 
  DOCUMENT_FRAGMENT_NODE: 11

  защищено 
  NOTATION_NODE: 12

  защищено 
  DOCUMENT_POSITION_DISCONNECTED: 0x01

  защищено 
  DOCUMENT_POSITION_PRECEDING: 0x02

  защищено 
  DOCUMENT_POSITION_FOLLOWING: 0x04

  защищено 
  DOCUMENT_POSITION_CONTAINS: 0x08

  защищено 
  DOCUMENT_POSITION_CONTAINED_BY: 0x10

  защищено 
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
}


внешнее
/*(!) var */ Node: объект { prototype: Node; при создании()/*(!) no_type */ Объект?; защищено  ELEMENT_NODE: 1; защищено  ATTRIBUTE_NODE: 2; защищено  TEXT_NODE: 3; защищено  CDATA_SECTION_NODE: 4; защищено  ENTITY_REFERENCE_NODE: 5; защищено  ENTITY_NODE: 6; защищено  PROCESSING_INSTRUCTION_NODE: 7; защищено  COMMENT_NODE: 8; защищено  DOCUMENT_NODE: 9; защищено  DOCUMENT_TYPE_NODE: 10; защищено  DOCUMENT_FRAGMENT_NODE: 11; защищено  NOTATION_NODE: 12; защищено  DOCUMENT_POSITION_DISCONNECTED: 0x01; защищено  DOCUMENT_POSITION_PRECEDING: 0x02; защищено  DOCUMENT_POSITION_FOLLOWING: 0x04; защищено  DOCUMENT_POSITION_CONTAINS: 0x08; защищено  DOCUMENT_POSITION_CONTAINED_BY: 0x10; защищено  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20 }


/**
* An iterator over the members of a list of the nodes in a subtree of the DOM. The nodes will be returned in document order.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeIterator)
*/

тип NodeIterator = интерфейс
{
  защищено 
  filter: NodeFilter?FUCKFUCK

  защищено 
  pointerBeforeReferenceNode: ДаНет

  защищено 
  referenceNode: Node

  защищено 
  root: Node

  защищено 
  whatToShow: Число

  операция detach()

  операция nextNode(): Node?FUCKFUCK

  операция previousNode(): Node?FUCKFUCK
}


внешнее
/*(!) var */ NodeIterator: объект { prototype: NodeIterator; при создании()/*(!) no_type */ Объект? }


/**
* NodeList objects are collections of nodes, usually returned by properties such as Node.childNodes and methods such as document.querySelectorAll().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeList)
*/

тип NodeList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Node?FUCKFUCK

  операция forEach(callbackfn: операция(value: Node, key: Число, parent: NodeList), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: Node*/
}


внешнее
/*(!) var */ NodeList: объект { prototype: NodeList; при создании()/*(!) no_type */ Объект? }


тип NodeListOf<TNode = Node> = интерфейс
{
  операция item(index: Число): TNode

  операция forEach(callbackfn: операция(value: TNode, key: Число, parent: NodeListOf<TNode>), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)

  /*(!) [index: number]: TNode*/
}


тип NonDocumentTypeChildNode = интерфейс
{
  защищено 
  nextElementSibling: Element?FUCKFUCK

  защищено 
  previousElementSibling: Element?FUCKFUCK
}


тип NonElementParentNode = интерфейс
{
  операция getElementById(elementId: Текст): Element?FUCKFUCK
}


тип NotificationEventMap = интерфейс
{
  "click": Event

  "close": Event

  "error": Event

  "show": Event
}


/**
* This Notifications API interface is used to configure and display desktop notifications to the user.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Notification)
*/

тип Notification = интерфейс
{
  защищено 
  body: Текст

  защищено 
  data: /*(!) any */ Объект?

  защищено 
  dir: NotificationDirection

  защищено 
  icon: Текст

  защищено 
  lang: Текст

  onclick: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onshow: операция(this: Notification, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  silent: ДаНет?FUCKFUCK

  защищено 
  tag: Текст

  защищено 
  title: Текст

  операция close()

  операция addEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Notification: объект { prototype: Notification; при создании(title: Текст, options: NotificationOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  permission: NotificationPermission; операция requestPermission(deprecatedCallback: NotificationPermissionCallback?FUCKFUCK = пусто): Promise<NotificationPermission> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_draw_buffers_indexed) */

тип OES_draw_buffers_indexed = интерфейс
{
  операция blendEquationSeparateiOES(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum)

  операция blendEquationiOES(buf: GLuint, mode: GLenum)

  операция blendFuncSeparateiOES(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция blendFunciOES(buf: GLuint, src: GLenum, dst: GLenum)

  операция colorMaskiOES(buf: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean)

  операция disableiOES(target: GLenum, index: GLuint)

  операция enableiOES(target: GLenum, index: GLuint)
}


/**
* The OES_element_index_uint extension is part of the WebGL API and adds support for gl.UNSIGNED_INT types to WebGLRenderingContext.drawElements().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_element_index_uint)
*/

тип OES_element_index_uint = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_fbo_render_mipmap) */

тип OES_fbo_render_mipmap = интерфейс
{

}


/**
* The OES_standard_derivatives extension is part of the WebGL API and adds the GLSL derivative functions dFdx, dFdy, and fwidth.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_standard_derivatives)
*/

тип OES_standard_derivatives = интерфейс
{
  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B
}


/**
* The OES_texture_float extension is part of the WebGL API and exposes floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float)
*/

тип OES_texture_float = интерфейс
{

}


/**
* The OES_texture_float_linear extension is part of the WebGL API and allows linear filtering with floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float_linear)
*/

тип OES_texture_float_linear = интерфейс
{

}


/**
* The OES_texture_half_float extension is part of the WebGL API and adds texture formats with 16- (aka half float) and 32-bit floating-point components.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float)
*/

тип OES_texture_half_float = интерфейс
{
  защищено 
  HALF_FLOAT_OES: 0x8D61
}


/**
* The OES_texture_half_float_linear extension is part of the WebGL API and allows linear filtering with half floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float_linear)
*/

тип OES_texture_half_float_linear = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_vertex_array_object) */

тип OES_vertex_array_object = интерфейс
{
  операция bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK)

  операция createVertexArrayOES(): WebGLVertexArrayObjectOES?FUCKFUCK

  операция deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK)

  операция isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?FUCKFUCK): GLboolean

  защищено 
  VERTEX_ARRAY_BINDING_OES: 0x85B5
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OVR_multiview2) */

тип OVR_multiview2 = интерфейс
{
  операция framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint, baseViewIndex: GLint, numViews: GLsizei)

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR: 0x9630

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: 0x9632

  защищено 
  MAX_VIEWS_OVR: 0x9631

  защищено 
  FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: 0x9633
}


/**
* The Web Audio API OfflineAudioCompletionEvent interface represents events that occur when the processing of an OfflineAudioContext is terminated. The complete event implements this interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OfflineAudioCompletionEvent)
*/

тип OfflineAudioCompletionEvent = интерфейс
{
  защищено 
  renderedBuffer: AudioBuffer
}


внешнее
/*(!) var */ OfflineAudioCompletionEvent: объект { prototype: OfflineAudioCompletionEvent; при создании(type: Текст, eventInitDict: OfflineAudioCompletionEventInit)/*(!) no_type */ Объект? }


тип OfflineAudioContextEventMap = интерфейс
{
  "complete": OfflineAudioCompletionEvent
}


/**
* An AudioContext interface representing an audio-processing graph built from linked together AudioNodes. In contrast with a standard AudioContext, an OfflineAudioContext doesn't render the audio to the device hardware; instead, it generates it, as fast as it can, and outputs the result to an AudioBuffer.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OfflineAudioContext)
*/

тип OfflineAudioContext = интерфейс
{
  защищено 
  length: Число

  oncomplete: операция(this: OfflineAudioContext, ev: OfflineAudioCompletionEvent): /*(!) any */ Объект??FUCKFUCK

  операция resume(): Promise<Ничего>

  операция startRendering(): Promise<AudioBuffer>

  операция suspend(suspendTime: Число): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof OfflineAudioContextEventMap */ Объект?>(type: K, listener: операция(this: OfflineAudioContext, ev: /*(!) OfflineAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof OfflineAudioContextEventMap */ Объект?>(type: K, listener: операция(this: OfflineAudioContext, ev: /*(!) OfflineAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ OfflineAudioContext: объект { prototype: OfflineAudioContext; при создании(contextOptions: OfflineAudioContextOptions)/*(!) no_type */ Объект?; при создании(numberOfChannels: Число, length: Число, sampleRate: Число)/*(!) no_type */ Объект? }


тип OffscreenCanvasEventMap = интерфейс
{
  "contextlost": Event

  "contextrestored": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvas) */

тип OffscreenCanvas = интерфейс
{
  height: Число

  oncontextlost: операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oncontextrestored: операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект??FUCKFUCK

  width: Число

  операция convertToBlob(options: ImageEncodeOptions?FUCKFUCK = пусто): Promise<Blob>

  операция getContext(contextId: "2d", options: /*(!) any */ Объект??FUCKFUCK = пусто): OffscreenCanvasRenderingContext2D?FUCKFUCK

  операция getContext(contextId: "bitmaprenderer", options: /*(!) any */ Объект??FUCKFUCK = пусто): ImageBitmapRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl", options: /*(!) any */ Объект??FUCKFUCK = пусто): WebGLRenderingContext?FUCKFUCK

  операция getContext(contextId: "webgl2", options: /*(!) any */ Объект??FUCKFUCK = пусто): WebGL2RenderingContext?FUCKFUCK

  операция getContext(contextId: OffscreenRenderingContextId, options: /*(!) any */ Объект??FUCKFUCK = пусто): OffscreenRenderingContext?FUCKFUCK

  операция transferToImageBitmap(): ImageBitmap

  операция addEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ OffscreenCanvas: объект { prototype: OffscreenCanvas; при создании(width: Число, height: Число)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvasRenderingContext2D) */

тип OffscreenCanvasRenderingContext2D = интерфейс
{
  защищено 
  canvas: OffscreenCanvas

  операция commit()
}


внешнее
/*(!) var */ OffscreenCanvasRenderingContext2D: объект { prototype: OffscreenCanvasRenderingContext2D; при создании()/*(!) no_type */ Объект? }


/**
* The OscillatorNode interface represents a periodic waveform, such as a sine wave. It is an AudioScheduledSourceNode audio-processing module that causes a specified frequency of a given wave to be created—in effect, a constant tone.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OscillatorNode)
*/

тип OscillatorNode = интерфейс
{
  защищено 
  detune: AudioParam

  защищено 
  frequency: AudioParam

  type: OscillatorType

  операция setPeriodicWave(periodicWave: PeriodicWave)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: OscillatorNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type: K, listener: операция(this: OscillatorNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ OscillatorNode: объект { prototype: OscillatorNode; при создании(context: BaseAudioContext, options: OscillatorOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OverconstrainedError) */

тип OverconstrainedError = интерфейс
{
  защищено 
  constraint: Текст
}


внешнее
/*(!) var */ OverconstrainedError: объект { prototype: OverconstrainedError; при создании(constraint: Текст, message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The PageTransitionEvent is fired when a document is being loaded or unloaded.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PageTransitionEvent)
*/

тип PageTransitionEvent = интерфейс
{
  защищено 
  persisted: ДаНет
}


внешнее
/*(!) var */ PageTransitionEvent: объект { prototype: PageTransitionEvent; при создании(type: Текст, eventInitDict: PageTransitionEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A PannerNode always has exactly one input and one output: the input can be mono or stereo but the output is always stereo (2 channels); you can't have panning effects without at least two audio channels!
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PannerNode)
*/

тип PannerNode = интерфейс
{
  coneInnerAngle: Число

  coneOuterAngle: Число

  coneOuterGain: Число

  distanceModel: DistanceModelType

  maxDistance: Число

  защищено 
  orientationX: AudioParam

  защищено 
  orientationY: AudioParam

  защищено 
  orientationZ: AudioParam

  panningModel: PanningModelType

  защищено 
  positionX: AudioParam

  защищено 
  positionY: AudioParam

  защищено 
  positionZ: AudioParam

  refDistance: Число

  rolloffFactor: Число

  операция setOrientation(x: Число, y: Число, z: Число)

  операция setPosition(x: Число, y: Число, z: Число)
}


внешнее
/*(!) var */ PannerNode: объект { prototype: PannerNode; при создании(context: BaseAudioContext, options: PannerOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип ParentNode = интерфейс
{
  защищено 
  childElementCount: Число

  защищено 
  children: HTMLCollection

  защищено 
  firstElementChild: Element?FUCKFUCK

  защищено 
  lastElementChild: Element?FUCKFUCK

  #js.МассивПараметров
  операция append(nodes: Список<Node | Текст>)

  #js.МассивПараметров
  операция prepend(nodes: Список<Node | Текст>)

  операция querySelector<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(selectors: K): /*(!) HTMLElementTagNameMap[K] */ Объект??FUCKFUCK

  операция querySelector<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selectors: K): /*(!) SVGElementTagNameMap[K] */ Объект??FUCKFUCK

  операция querySelector<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selectors: K): /*(!) MathMLElementTagNameMap[K] */ Объект??FUCKFUCK

  операция querySelector<K = /*(!) keyof HTMLElementDeprecatedTagNameMap */ Объект?>(selectors: K): /*(!) HTMLElementDeprecatedTagNameMap[K] */ Объект??FUCKFUCK

  операция querySelector<E = Element>(selectors: Текст): E?FUCKFUCK

  операция querySelectorAll<K = /*(!) keyof HTMLElementTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) HTMLElementTagNameMap[K] */ Объект?>

  операция querySelectorAll<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция querySelectorAll<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция querySelectorAll<K = /*(!) keyof HTMLElementDeprecatedTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) HTMLElementDeprecatedTagNameMap[K] */ Объект?>

  операция querySelectorAll<E = Element>(selectors: Текст): NodeListOf<E>

  #js.МассивПараметров
  операция replaceChildren(nodes: Список<Node | Текст>)
}


/**
* This Canvas 2D API interface is used to declare a path that can then be used on a CanvasRenderingContext2D object. The path methods of the CanvasRenderingContext2D interface are also present on this interface, which gives you the convenience of being able to retain and replay your path whenever desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Path2D)
*/

тип Path2D = интерфейс
{
  операция addPath(path: Path2D, transform: DOMMatrix2DInit?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ Path2D: объект { prototype: Path2D; при создании(path: Path2D | Текст | пусто = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentMethodChangeEvent)
*/

тип PaymentMethodChangeEvent = интерфейс
{
  защищено 
  methodDetails: /*(!) any */ Объект?

  защищено 
  methodName: Текст
}


внешнее
/*(!) var */ PaymentMethodChangeEvent: объект { prototype: PaymentMethodChangeEvent; при создании(type: Текст, eventInitDict: PaymentMethodChangeEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип PaymentRequestEventMap = интерфейс
{
  "paymentmethodchange": Event
}


/**
* This Payment Request API interface is the primary access point into the API, and lets web content and apps accept payments from the end user.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentRequest)
*/

тип PaymentRequest = интерфейс
{
  защищено 
  id: Текст

  onpaymentmethodchange: операция(this: PaymentRequest, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция abort(): Promise<Ничего>

  операция canMakePayment(): Promise<ДаНет>

  операция show(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate> | пусто = пусто): Promise<PaymentResponse>

  операция addEventListener<K = /*(!) keyof PaymentRequestEventMap */ Объект?>(type: K, listener: операция(this: PaymentRequest, ev: /*(!) PaymentRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PaymentRequestEventMap */ Объект?>(type: K, listener: операция(this: PaymentRequest, ev: /*(!) PaymentRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ PaymentRequest: объект { prototype: PaymentRequest; при создании(methodData: Список<PaymentMethodData>, details: PaymentDetailsInit)/*(!) no_type */ Объект? }


/**
* This Payment Request API interface enables a web page to update the details of a PaymentRequest in response to a user action.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentRequestUpdateEvent)
*/

тип PaymentRequestUpdateEvent = интерфейс
{
  операция updateWith(detailsPromise: PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>)
}


внешнее
/*(!) var */ PaymentRequestUpdateEvent: объект { prototype: PaymentRequestUpdateEvent; при создании(type: Текст, eventInitDict: PaymentRequestUpdateEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Payment Request API interface is returned after a user selects a payment method and approves a payment request.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentResponse)
*/

тип PaymentResponse = интерфейс
{
  защищено 
  details: /*(!) any */ Объект?

  защищено 
  methodName: Текст

  защищено 
  requestId: Текст

  операция complete(result: PaymentComplete?FUCKFUCK = пусто): Promise<Ничего>

  операция retry(errorFields: PaymentValidationErrors?FUCKFUCK = пусто): Promise<Ничего>

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PaymentResponse: объект { prototype: PaymentResponse; при создании()/*(!) no_type */ Объект? }


тип PerformanceEventMap = интерфейс
{
  "resourcetimingbufferfull": Event
}


/**
* Provides access to performance-related information for the current page. It's part of the High Resolution Time API, but is enhanced by the Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Performance)
*/

тип Performance = интерфейс
{
  защищено 
  eventCounts: EventCounts

  защищено 
  navigation: PerformanceNavigation

  onresourcetimingbufferfull: операция(this: Performance, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  timeOrigin: DOMHighResTimeStamp

  защищено 
  timing: PerformanceTiming

  операция clearMarks(markName: Текст?FUCKFUCK = пусто)

  операция clearMeasures(measureName: Текст?FUCKFUCK = пусто)

  операция clearResourceTimings()

  операция getEntries(): PerformanceEntryList

  операция getEntriesByName(name: Текст, type: Текст?FUCKFUCK = пусто): PerformanceEntryList

  операция getEntriesByType(type: Текст): PerformanceEntryList

  операция mark(markName: Текст, markOptions: PerformanceMarkOptions?FUCKFUCK = пусто): PerformanceMark

  операция measure(measureName: Текст, startOrMeasureOptions: Текст | PerformanceMeasureOptions | пусто = пусто, endMark: Текст?FUCKFUCK = пусто): PerformanceMeasure

  операция now(): DOMHighResTimeStamp

  операция setResourceTimingBufferSize(maxSize: Число)

  операция toJSON(): /*(!) any */ Объект?

  операция addEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Performance: объект { prototype: Performance; при создании()/*(!) no_type */ Объект? }


/**
* Encapsulates a single performance metric that is part of the performance timeline. A performance entry can be directly created by making a performance mark or measure (for example by calling the mark() method) at an explicit point in an application. Performance entries are also created in indirect ways such as loading a resource (such as an image).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry)
*/

тип PerformanceEntry = интерфейс
{
  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  entryType: Текст

  защищено 
  name: Текст

  защищено 
  startTime: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceEntry: объект { prototype: PerformanceEntry; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEventTiming) */

тип PerformanceEventTiming = интерфейс
{
  защищено 
  cancelable: ДаНет

  защищено 
  processingEnd: DOMHighResTimeStamp

  защищено 
  processingStart: DOMHighResTimeStamp

  защищено 
  target: Node?FUCKFUCK

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceEventTiming: объект { prototype: PerformanceEventTiming; при создании()/*(!) no_type */ Объект? }


/**
* PerformanceMark is an abstract interface for PerformanceEntry objects with an entryType of "mark". Entries of this type are created by calling performance.mark() to add a named DOMHighResTimeStamp (the mark) to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMark)
*/

тип PerformanceMark = интерфейс
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMark: объект { prototype: PerformanceMark; при создании(markName: Текст, markOptions: PerformanceMarkOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* PerformanceMeasure is an abstract interface for PerformanceEntry objects with an entryType of "measure". Entries of this type are created by calling performance.measure() to add a named DOMHighResTimeStamp (the measure) between two marks to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMeasure)
*/

тип PerformanceMeasure = интерфейс
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMeasure: объект { prototype: PerformanceMeasure; при создании()/*(!) no_type */ Объект? }


/**
* The legacy PerformanceNavigation interface represents information about how the navigation to the current document was done.
* @deprecated This interface is deprecated in the Navigation Timing Level 2 specification. Please use the PerformanceNavigationTiming interface instead.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceNavigation)
*/

тип PerformanceNavigation = интерфейс
{
  защищено 
  redirectCount: Число

  защищено 
  type: Число

  операция toJSON(): /*(!) any */ Объект?

  защищено 
  TYPE_NAVIGATE: 0

  защищено 
  TYPE_RELOAD: 1

  защищено 
  TYPE_BACK_FORWARD: 2

  защищено 
  TYPE_RESERVED: 255
}


/** @deprecated */

внешнее
/*(!) var */ PerformanceNavigation: объект { prototype: PerformanceNavigation; при создании()/*(!) no_type */ Объект?; защищено  TYPE_NAVIGATE: 0; защищено  TYPE_RELOAD: 1; защищено  TYPE_BACK_FORWARD: 2; защищено  TYPE_RESERVED: 255 }


/**
* Provides methods and properties to store and retrieve metrics regarding the browser's document navigation events. For example, this interface can be used to determine how much time it takes to load or unload a document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming)
*/

тип PerformanceNavigationTiming = интерфейс
{
  защищено 
  domComplete: DOMHighResTimeStamp

  защищено 
  domContentLoadedEventEnd: DOMHighResTimeStamp

  защищено 
  domContentLoadedEventStart: DOMHighResTimeStamp

  защищено 
  domInteractive: DOMHighResTimeStamp

  защищено 
  loadEventEnd: DOMHighResTimeStamp

  защищено 
  loadEventStart: DOMHighResTimeStamp

  защищено 
  redirectCount: Число

  защищено 
  type: NavigationTimingType

  защищено 
  unloadEventEnd: DOMHighResTimeStamp

  защищено 
  unloadEventStart: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceNavigationTiming: объект { prototype: PerformanceNavigationTiming; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) */

тип PerformanceObserver = интерфейс
{
  операция disconnect()

  операция observe(options: PerformanceObserverInit?FUCKFUCK = пусто)

  операция takeRecords(): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserver: объект { prototype: PerformanceObserver; при создании(callback: PerformanceObserverCallback)/*(!) no_type */ Объект?; защищено  supportedEntryTypes: ReadonlyArray<Текст> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserverEntryList) */

тип PerformanceObserverEntryList = интерфейс
{
  операция getEntries(): PerformanceEntryList

  операция getEntriesByName(name: Текст, type: Текст?FUCKFUCK = пусто): PerformanceEntryList

  операция getEntriesByType(type: Текст): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserverEntryList: объект { prototype: PerformanceObserverEntryList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformancePaintTiming) */

тип PerformancePaintTiming = интерфейс
{

}


внешнее
/*(!) var */ PerformancePaintTiming: объект { prototype: PerformancePaintTiming; при создании()/*(!) no_type */ Объект? }


/**
* Enables retrieval and analysis of detailed network timing data regarding the loading of an application's resources. An application can use the timing metrics to determine, for example, the length of time it takes to fetch a specific resource, such as an XMLHttpRequest, <SVG>, image, or script.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming)
*/

тип PerformanceResourceTiming = интерфейс
{
  защищено 
  connectEnd: DOMHighResTimeStamp

  защищено 
  connectStart: DOMHighResTimeStamp

  защищено 
  decodedBodySize: Число

  защищено 
  domainLookupEnd: DOMHighResTimeStamp

  защищено 
  domainLookupStart: DOMHighResTimeStamp

  защищено 
  encodedBodySize: Число

  защищено 
  fetchStart: DOMHighResTimeStamp

  защищено 
  initiatorType: Текст

  защищено 
  nextHopProtocol: Текст

  защищено 
  redirectEnd: DOMHighResTimeStamp

  защищено 
  redirectStart: DOMHighResTimeStamp

  защищено 
  requestStart: DOMHighResTimeStamp

  защищено 
  responseEnd: DOMHighResTimeStamp

  защищено 
  responseStart: DOMHighResTimeStamp

  защищено 
  secureConnectionStart: DOMHighResTimeStamp

  защищено 
  serverTiming: ReadonlyArray<PerformanceServerTiming>

  защищено 
  transferSize: Число

  защищено 
  workerStart: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceResourceTiming: объект { prototype: PerformanceResourceTiming; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceServerTiming) */

тип PerformanceServerTiming = интерфейс
{
  защищено 
  description: Текст

  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  name: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceServerTiming: объект { prototype: PerformanceServerTiming; при создании()/*(!) no_type */ Объект? }


/**
* A legacy interface kept for backwards compatibility and contains properties that offer performance timing information for various events which occur during the loading and use of the current page. You get a PerformanceTiming object describing your page using the window.performance.timing property.
* @deprecated This interface is deprecated in the Navigation Timing Level 2 specification. Please use the PerformanceNavigationTiming interface instead.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceTiming)
*/

тип PerformanceTiming = интерфейс
{
  защищено 
  connectEnd: Число

  защищено 
  connectStart: Число

  защищено 
  domComplete: Число

  защищено 
  domContentLoadedEventEnd: Число

  защищено 
  domContentLoadedEventStart: Число

  защищено 
  domInteractive: Число

  защищено 
  domLoading: Число

  защищено 
  domainLookupEnd: Число

  защищено 
  domainLookupStart: Число

  защищено 
  fetchStart: Число

  защищено 
  loadEventEnd: Число

  защищено 
  loadEventStart: Число

  защищено 
  navigationStart: Число

  защищено 
  redirectEnd: Число

  защищено 
  redirectStart: Число

  защищено 
  requestStart: Число

  защищено 
  responseEnd: Число

  защищено 
  responseStart: Число

  защищено 
  secureConnectionStart: Число

  защищено 
  unloadEventEnd: Число

  защищено 
  unloadEventStart: Число

  операция toJSON(): /*(!) any */ Объект?
}


/** @deprecated */

внешнее
/*(!) var */ PerformanceTiming: объект { prototype: PerformanceTiming; при создании()/*(!) no_type */ Объект? }


/**
* PeriodicWave has no inputs or outputs; it is used to define custom oscillators when calling OscillatorNode.setPeriodicWave(). The PeriodicWave itself is created/returned by AudioContext.createPeriodicWave().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PeriodicWave)
*/

тип PeriodicWave = интерфейс
{

}


внешнее
/*(!) var */ PeriodicWave: объект { prototype: PeriodicWave; при создании(context: BaseAudioContext, options: PeriodicWaveOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип PermissionStatusEventMap = интерфейс
{
  "change": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PermissionStatus) */

тип PermissionStatus = интерфейс
{
  защищено 
  name: Текст

  onchange: операция(this: PermissionStatus, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: PermissionState

  операция addEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ PermissionStatus: объект { prototype: PermissionStatus; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Permissions) */

тип Permissions = интерфейс
{
  операция query(permissionDesc: PermissionDescriptor): Promise<PermissionStatus>
}


внешнее
/*(!) var */ Permissions: объект { prototype: Permissions; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PictureInPictureEvent) */

тип PictureInPictureEvent = интерфейс
{
  защищено 
  pictureInPictureWindow: PictureInPictureWindow
}


внешнее
/*(!) var */ PictureInPictureEvent: объект { prototype: PictureInPictureEvent; при создании(type: Текст, eventInitDict: PictureInPictureEventInit)/*(!) no_type */ Объект? }


тип PictureInPictureWindowEventMap = интерфейс
{
  "resize": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PictureInPictureWindow) */

тип PictureInPictureWindow = интерфейс
{
  защищено 
  height: Число

  onresize: операция(this: PictureInPictureWindow, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  width: Число

  операция addEventListener<K = /*(!) keyof PictureInPictureWindowEventMap */ Объект?>(type: K, listener: операция(this: PictureInPictureWindow, ev: /*(!) PictureInPictureWindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof PictureInPictureWindowEventMap */ Объект?>(type: K, listener: операция(this: PictureInPictureWindow, ev: /*(!) PictureInPictureWindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ PictureInPictureWindow: объект { prototype: PictureInPictureWindow; при создании()/*(!) no_type */ Объект? }


/**
* Provides information about a browser plugin.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Plugin)
*/

тип Plugin = интерфейс
{
  защищено 
  description: Текст

  защищено 
  filename: Текст

  защищено 
  length: Число

  защищено 
  name: Текст

  операция item(index: Число): MimeType?FUCKFUCK

  операция namedItem(name: Текст): MimeType?FUCKFUCK

  /*(!) [index: number]: MimeType*/
}


/** @deprecated */

внешнее
/*(!) var */ Plugin: объект { prototype: Plugin; при создании()/*(!) no_type */ Объект? }


/**
* Used to store a list of Plugin objects describing the available plugins; it's returned by the window.navigator.plugins property. The PluginArray is not a JavaScript array, but has the length property and supports accessing individual items using bracket notation (plugins[2]), as well as via item(index) and namedItem("name") methods.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PluginArray)
*/

тип PluginArray = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Plugin?FUCKFUCK

  операция namedItem(name: Текст): Plugin?FUCKFUCK

  операция refresh()

  /*(!) [index: number]: Plugin*/
}


/** @deprecated */

внешнее
/*(!) var */ PluginArray: объект { prototype: PluginArray; при создании()/*(!) no_type */ Объект? }


/**
* The state of a DOM event produced by a pointer such as the geometry of the contact point, the device type that generated the event, the amount of pressure that was applied on the contact surface, etc.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PointerEvent)
*/

тип PointerEvent = интерфейс
{
  защищено 
  height: Число

  защищено 
  isPrimary: ДаНет

  защищено 
  pointerId: Число

  защищено 
  pointerType: Текст

  защищено 
  pressure: Число

  защищено 
  tangentialPressure: Число

  защищено 
  tiltX: Число

  защищено 
  tiltY: Число

  защищено 
  twist: Число

  защищено 
  width: Число

  операция getCoalescedEvents(): Список<PointerEvent>

  операция getPredictedEvents(): Список<PointerEvent>
}


внешнее
/*(!) var */ PointerEvent: объект { prototype: PointerEvent; при создании(type: Текст, eventInitDict: PointerEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* PopStateEvent is an event handler for the popstate event on the window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PopStateEvent)
*/

тип PopStateEvent = интерфейс
{
  защищено 
  state: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PopStateEvent: объект { prototype: PopStateEvent; при создании(type: Текст, eventInitDict: PopStateEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип PopoverInvokerElement = интерфейс
{
  popoverTargetAction: Текст

  popoverTargetElement: Element?FUCKFUCK
}


/**
* A processing instruction embeds application-specific instructions in XML which can be ignored by other applications that don't recognize them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProcessingInstruction)
*/

тип ProcessingInstruction = интерфейс
{
  защищено 
  ownerDocument: Document

  защищено 
  target: Текст
}


внешнее
/*(!) var */ ProcessingInstruction: объект { prototype: ProcessingInstruction; при создании()/*(!) no_type */ Объект? }


/**
* Events measuring progress of an underlying process, like an HTTP request (for an XMLHttpRequest, or the loading of the underlying resource of an <img>, <audio>, <video>, <style> or <link>).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent)
*/

тип ProgressEvent<T = EventTarget> = интерфейс
{
  защищено 
  lengthComputable: ДаНет

  защищено 
  loaded: Число

  защищено 
  target: T?FUCKFUCK

  защищено 
  total: Число
}


внешнее
/*(!) var */ ProgressEvent: объект { prototype: ProgressEvent; при создании(type: Текст, eventInitDict: ProgressEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */

тип PromiseRejectionEvent = интерфейс
{
  защищено 
  promise: Promise</*(!) any */ Объект?>

  защищено 
  reason: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PromiseRejectionEvent: объект { prototype: PromiseRejectionEvent; при создании(type: Текст, eventInitDict: PromiseRejectionEventInit)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PublicKeyCredential)
*/

тип PublicKeyCredential = интерфейс
{
  защищено 
  authenticatorAttachment: Текст?FUCKFUCK

  защищено 
  rawId: ArrayBuffer

  защищено 
  response: AuthenticatorResponse

  операция getClientExtensionResults(): AuthenticationExtensionsClientOutputs
}


внешнее
/*(!) var */ PublicKeyCredential: объект { prototype: PublicKeyCredential; при создании()/*(!) no_type */ Объект?; операция isConditionalMediationAvailable(): Promise<ДаНет>; операция isUserVerifyingPlatformAuthenticatorAvailable(): Promise<ДаНет> }


/**
* This Push API interface provides a way to receive notifications from third-party servers as well as request URLs for push notifications.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushManager)
*/

тип PushManager = интерфейс
{
  операция getSubscription(): Promise<PushSubscription?FUCKFUCK>

  операция permissionState(options: PushSubscriptionOptionsInit?FUCKFUCK = пусто): Promise<PermissionState>

  операция subscribe(options: PushSubscriptionOptionsInit?FUCKFUCK = пусто): Promise<PushSubscription>
}


внешнее
/*(!) var */ PushManager: объект { prototype: PushManager; при создании()/*(!) no_type */ Объект?; защищено  supportedContentEncodings: ReadonlyArray<Текст> }


/**
* This Push API interface provides a subcription's URL endpoint and allows unsubscription from a push service.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscription)
*/

тип PushSubscription = интерфейс
{
  защищено 
  endpoint: Текст

  защищено 
  expirationTime: EpochTimeStamp?FUCKFUCK

  защищено 
  options: PushSubscriptionOptions

  операция getKey(name: PushEncryptionKeyName): ArrayBuffer?FUCKFUCK

  операция toJSON(): PushSubscriptionJSON

  операция unsubscribe(): Promise<ДаНет>
}


внешнее
/*(!) var */ PushSubscription: объект { prototype: PushSubscription; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscriptionOptions)
*/

тип PushSubscriptionOptions = интерфейс
{
  защищено 
  applicationServerKey: ArrayBuffer?FUCKFUCK

  защищено 
  userVisibleOnly: ДаНет
}


внешнее
/*(!) var */ PushSubscriptionOptions: объект { prototype: PushSubscriptionOptions; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCCertificate) */

тип RTCCertificate = интерфейс
{
  защищено 
  expires: EpochTimeStamp

  операция getFingerprints(): Список<RTCDtlsFingerprint>
}


внешнее
/*(!) var */ RTCCertificate: объект { prototype: RTCCertificate; при создании()/*(!) no_type */ Объект? }


тип RTCDTMFSenderEventMap = интерфейс
{
  "tonechange": RTCDTMFToneChangeEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDTMFSender) */

тип RTCDTMFSender = интерфейс
{
  защищено 
  canInsertDTMF: ДаНет

  ontonechange: операция(this: RTCDTMFSender, ev: RTCDTMFToneChangeEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  toneBuffer: Текст

  операция insertDTMF(tones: Текст, duration: Число?FUCKFUCK = пусто, interToneGap: Число?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof RTCDTMFSenderEventMap */ Объект?>(type: K, listener: операция(this: RTCDTMFSender, ev: /*(!) RTCDTMFSenderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDTMFSenderEventMap */ Объект?>(type: K, listener: операция(this: RTCDTMFSender, ev: /*(!) RTCDTMFSenderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCDTMFSender: объект { prototype: RTCDTMFSender; при создании()/*(!) no_type */ Объект? }


/**
* Events sent to indicate that DTMF tones have started or finished playing. This interface is used by the tonechange event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDTMFToneChangeEvent)
*/

тип RTCDTMFToneChangeEvent = интерфейс
{
  защищено 
  tone: Текст
}


внешнее
/*(!) var */ RTCDTMFToneChangeEvent: объект { prototype: RTCDTMFToneChangeEvent; при создании(type: Текст, eventInitDict: RTCDTMFToneChangeEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип RTCDataChannelEventMap = интерфейс
{
  "bufferedamountlow": Event

  "close": Event

  "closing": Event

  "error": Event

  "message": MessageEvent

  "open": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDataChannel) */

тип RTCDataChannel = интерфейс
{
  binaryType: BinaryType

  защищено 
  bufferedAmount: Число

  bufferedAmountLowThreshold: Число

  защищено 
  id: Число?FUCKFUCK

  защищено 
  label: Текст

  защищено 
  maxPacketLifeTime: Число?FUCKFUCK

  защищено 
  maxRetransmits: Число?FUCKFUCK

  защищено 
  negotiated: ДаНет

  onbufferedamountlow: операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclose: операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onclosing: операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: RTCDataChannel, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onopen: операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ordered: ДаНет

  защищено 
  protocol: Текст

  защищено 
  readyState: RTCDataChannelState

  операция close()

  операция send(data: Текст)

  операция send(data: Blob)

  операция send(data: ArrayBuffer)

  операция send(data: ArrayBufferView)

  операция addEventListener<K = /*(!) keyof RTCDataChannelEventMap */ Объект?>(type: K, listener: операция(this: RTCDataChannel, ev: /*(!) RTCDataChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDataChannelEventMap */ Объект?>(type: K, listener: операция(this: RTCDataChannel, ev: /*(!) RTCDataChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCDataChannel: объект { prototype: RTCDataChannel; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDataChannelEvent) */

тип RTCDataChannelEvent = интерфейс
{
  защищено 
  channel: RTCDataChannel
}


внешнее
/*(!) var */ RTCDataChannelEvent: объект { prototype: RTCDataChannelEvent; при создании(type: Текст, eventInitDict: RTCDataChannelEventInit)/*(!) no_type */ Объект? }


тип RTCDtlsTransportEventMap = интерфейс
{
  "error": Event

  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDtlsTransport) */

тип RTCDtlsTransport = интерфейс
{
  защищено 
  iceTransport: RTCIceTransport

  onerror: операция(this: RTCDtlsTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onstatechange: операция(this: RTCDtlsTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: RTCDtlsTransportState

  операция getRemoteCertificates(): Список<ArrayBuffer>

  операция addEventListener<K = /*(!) keyof RTCDtlsTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCDtlsTransport, ev: /*(!) RTCDtlsTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDtlsTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCDtlsTransport, ev: /*(!) RTCDtlsTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCDtlsTransport: объект { prototype: RTCDtlsTransport; при создании()/*(!) no_type */ Объект? }


тип RTCEncodedAudioFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  операция getMetadata(): RTCEncodedAudioFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedAudioFrame: объект { prototype: RTCEncodedAudioFrame; при создании()/*(!) no_type */ Объект? }


тип RTCEncodedVideoFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  защищено 
  type: RTCEncodedVideoFrameType

  операция getMetadata(): RTCEncodedVideoFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedVideoFrame: объект { prototype: RTCEncodedVideoFrame; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCError) */

тип RTCError = интерфейс
{
  защищено 
  errorDetail: RTCErrorDetailType

  защищено 
  receivedAlert: Число?FUCKFUCK

  защищено 
  sctpCauseCode: Число?FUCKFUCK

  защищено 
  sdpLineNumber: Число?FUCKFUCK

  защищено 
  sentAlert: Число?FUCKFUCK
}


внешнее
/*(!) var */ RTCError: объект { prototype: RTCError; при создании(init: RTCErrorInit, message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCErrorEvent) */

тип RTCErrorEvent = интерфейс
{
  защищено 
  error: RTCError
}


внешнее
/*(!) var */ RTCErrorEvent: объект { prototype: RTCErrorEvent; при создании(type: Текст, eventInitDict: RTCErrorEventInit)/*(!) no_type */ Объект? }


/**
* The RTCIceCandidate interface—part of the WebRTC API—represents a candidate Internet Connectivity Establishment (ICE) configuration which may be used to establish an RTCPeerConnection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCIceCandidate)
*/

тип RTCIceCandidate = интерфейс
{
  защищено 
  address: Текст?FUCKFUCK

  защищено 
  candidate: Текст

  защищено 
  component: RTCIceComponent?FUCKFUCK

  защищено 
  foundation: Текст?FUCKFUCK

  защищено 
  port: Число?FUCKFUCK

  защищено 
  priority: Число?FUCKFUCK

  защищено 
  protocol: RTCIceProtocol?FUCKFUCK

  защищено 
  relatedAddress: Текст?FUCKFUCK

  защищено 
  relatedPort: Число?FUCKFUCK

  защищено 
  sdpMLineIndex: Число?FUCKFUCK

  защищено 
  sdpMid: Текст?FUCKFUCK

  защищено 
  tcpType: RTCIceTcpCandidateType?FUCKFUCK

  защищено 
  type: RTCIceCandidateType?FUCKFUCK

  защищено 
  usernameFragment: Текст?FUCKFUCK

  операция toJSON(): RTCIceCandidateInit
}


внешнее
/*(!) var */ RTCIceCandidate: объект { prototype: RTCIceCandidate; при создании(candidateInitDict: RTCIceCandidateInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип RTCIceTransportEventMap = интерфейс
{
  "gatheringstatechange": Event

  "selectedcandidatepairchange": Event

  "statechange": Event
}


/**
* Provides access to information about the ICE transport layer over which the data is being sent and received.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCIceTransport)
*/

тип RTCIceTransport = интерфейс
{
  защищено 
  gatheringState: RTCIceGathererState

  ongatheringstatechange: операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onselectedcandidatepairchange: операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onstatechange: операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: RTCIceTransportState

  операция getSelectedCandidatePair(): RTCIceCandidatePair?FUCKFUCK

  операция addEventListener<K = /*(!) keyof RTCIceTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCIceTransport, ev: /*(!) RTCIceTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCIceTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCIceTransport, ev: /*(!) RTCIceTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCIceTransport: объект { prototype: RTCIceTransport; при создании()/*(!) no_type */ Объект? }


тип RTCPeerConnectionEventMap = интерфейс
{
  "connectionstatechange": Event

  "datachannel": RTCDataChannelEvent

  "icecandidate": RTCPeerConnectionIceEvent

  "icecandidateerror": Event

  "iceconnectionstatechange": Event

  "icegatheringstatechange": Event

  "negotiationneeded": Event

  "signalingstatechange": Event

  "track": RTCTrackEvent
}


/**
* A WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnection)
*/

тип RTCPeerConnection = интерфейс
{
  защищено 
  canTrickleIceCandidates: ДаНет?FUCKFUCK

  защищено 
  connectionState: RTCPeerConnectionState

  защищено 
  currentLocalDescription: RTCSessionDescription?FUCKFUCK

  защищено 
  currentRemoteDescription: RTCSessionDescription?FUCKFUCK

  защищено 
  iceConnectionState: RTCIceConnectionState

  защищено 
  iceGatheringState: RTCIceGatheringState

  защищено 
  localDescription: RTCSessionDescription?FUCKFUCK

  onconnectionstatechange: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ondatachannel: операция(this: RTCPeerConnection, ev: RTCDataChannelEvent): /*(!) any */ Объект??FUCKFUCK

  onicecandidate: операция(this: RTCPeerConnection, ev: RTCPeerConnectionIceEvent): /*(!) any */ Объект??FUCKFUCK

  onicecandidateerror: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  oniceconnectionstatechange: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onicegatheringstatechange: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onnegotiationneeded: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onsignalingstatechange: операция(this: RTCPeerConnection, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ontrack: операция(this: RTCPeerConnection, ev: RTCTrackEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  pendingLocalDescription: RTCSessionDescription?FUCKFUCK

  защищено 
  pendingRemoteDescription: RTCSessionDescription?FUCKFUCK

  защищено 
  remoteDescription: RTCSessionDescription?FUCKFUCK

  защищено 
  sctp: RTCSctpTransport?FUCKFUCK

  защищено 
  signalingState: RTCSignalingState

  операция addIceCandidate(candidate: RTCIceCandidateInit?FUCKFUCK = пусто): Promise<Ничего>

  операция addIceCandidate(candidate: RTCIceCandidateInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<Ничего>

  #js.МассивПараметров
  операция addTrack(track: MediaStreamTrack, streams: Список<MediaStream>): RTCRtpSender

  операция addTransceiver(trackOrKind: MediaStreamTrack | Текст, init: RTCRtpTransceiverInit?FUCKFUCK = пусто): RTCRtpTransceiver

  операция close()

  операция createAnswer(options: RTCAnswerOptions?FUCKFUCK = пусто): Promise<RTCSessionDescriptionInit>

  операция createAnswer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback): Promise<Ничего>

  операция createDataChannel(label: Текст, dataChannelDict: RTCDataChannelInit?FUCKFUCK = пусто): RTCDataChannel

  операция createOffer(options: RTCOfferOptions?FUCKFUCK = пусто): Promise<RTCSessionDescriptionInit>

  операция createOffer(successCallback: RTCSessionDescriptionCallback, failureCallback: RTCPeerConnectionErrorCallback, options: RTCOfferOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция getConfiguration(): RTCConfiguration

  операция getReceivers(): Список<RTCRtpReceiver>

  операция getSenders(): Список<RTCRtpSender>

  операция getStats(selector: MediaStreamTrack?FUCKFUCK = пусто): Promise<RTCStatsReport>

  операция getTransceivers(): Список<RTCRtpTransceiver>

  операция removeTrack(sender: RTCRtpSender)

  операция restartIce()

  операция setConfiguration(configuration: RTCConfiguration?FUCKFUCK = пусто)

  операция setLocalDescription(description: RTCLocalSessionDescriptionInit?FUCKFUCK = пусто): Promise<Ничего>

  операция setLocalDescription(description: RTCLocalSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<Ничего>

  операция setRemoteDescription(description: RTCSessionDescriptionInit): Promise<Ничего>

  операция setRemoteDescription(description: RTCSessionDescriptionInit, successCallback: VoidFunction, failureCallback: RTCPeerConnectionErrorCallback): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof RTCPeerConnectionEventMap */ Объект?>(type: K, listener: операция(this: RTCPeerConnection, ev: /*(!) RTCPeerConnectionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCPeerConnectionEventMap */ Объект?>(type: K, listener: операция(this: RTCPeerConnection, ev: /*(!) RTCPeerConnectionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCPeerConnection: объект { prototype: RTCPeerConnection; при создании(configuration: RTCConfiguration?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnectionIceErrorEvent) */

тип RTCPeerConnectionIceErrorEvent = интерфейс
{
  защищено 
  address: Текст?FUCKFUCK

  защищено 
  errorCode: Число

  защищено 
  errorText: Текст

  защищено 
  port: Число?FUCKFUCK

  защищено 
  url: Текст
}


внешнее
/*(!) var */ RTCPeerConnectionIceErrorEvent: объект { prototype: RTCPeerConnectionIceErrorEvent; при создании(type: Текст, eventInitDict: RTCPeerConnectionIceErrorEventInit)/*(!) no_type */ Объект? }


/**
* Events that occurs in relation to ICE candidates with the target, usually an RTCPeerConnection. Only one event is of this type: icecandidate.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnectionIceEvent)
*/

тип RTCPeerConnectionIceEvent = интерфейс
{
  защищено 
  candidate: RTCIceCandidate?FUCKFUCK
}


внешнее
/*(!) var */ RTCPeerConnectionIceEvent: объект { prototype: RTCPeerConnectionIceEvent; при создании(type: Текст, eventInitDict: RTCPeerConnectionIceEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This WebRTC API interface manages the reception and decoding of data for a MediaStreamTrack on an RTCPeerConnection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpReceiver)
*/

тип RTCRtpReceiver = интерфейс
{
  защищено 
  track: MediaStreamTrack

  защищено 
  transport: RTCDtlsTransport?FUCKFUCK

  операция getContributingSources(): Список<RTCRtpContributingSource>

  операция getParameters(): RTCRtpReceiveParameters

  операция getStats(): Promise<RTCStatsReport>

  операция getSynchronizationSources(): Список<RTCRtpSynchronizationSource>
}


внешнее
/*(!) var */ RTCRtpReceiver: объект { prototype: RTCRtpReceiver; при создании()/*(!) no_type */ Объект?; операция getCapabilities(kind: Текст): RTCRtpCapabilities?FUCKFUCK }


/**
* Provides the ability to control and obtain details about how a particular MediaStreamTrack is encoded and sent to a remote peer.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpSender)
*/

тип RTCRtpSender = интерфейс
{
  защищено 
  dtmf: RTCDTMFSender?FUCKFUCK

  защищено 
  track: MediaStreamTrack?FUCKFUCK

  защищено 
  transport: RTCDtlsTransport?FUCKFUCK

  операция getParameters(): RTCRtpSendParameters

  операция getStats(): Promise<RTCStatsReport>

  операция replaceTrack(withTrack: MediaStreamTrack?FUCKFUCK): Promise<Ничего>

  операция setParameters(parameters: RTCRtpSendParameters): Promise<Ничего>

  #js.МассивПараметров
  операция setStreams(streams: Список<MediaStream>)
}


внешнее
/*(!) var */ RTCRtpSender: объект { prototype: RTCRtpSender; при создании()/*(!) no_type */ Объект?; операция getCapabilities(kind: Текст): RTCRtpCapabilities?FUCKFUCK }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpTransceiver) */

тип RTCRtpTransceiver = интерфейс
{
  защищено 
  currentDirection: RTCRtpTransceiverDirection?FUCKFUCK

  direction: RTCRtpTransceiverDirection

  защищено 
  mid: Текст?FUCKFUCK

  защищено 
  receiver: RTCRtpReceiver

  защищено 
  sender: RTCRtpSender

  операция setCodecPreferences(codecs: Список<RTCRtpCodecCapability>)

  операция stop()
}


внешнее
/*(!) var */ RTCRtpTransceiver: объект { prototype: RTCRtpTransceiver; при создании()/*(!) no_type */ Объект? }


тип RTCSctpTransportEventMap = интерфейс
{
  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCSctpTransport) */

тип RTCSctpTransport = интерфейс
{
  защищено 
  maxChannels: Число?FUCKFUCK

  защищено 
  maxMessageSize: Число

  onstatechange: операция(this: RTCSctpTransport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: RTCSctpTransportState

  защищено 
  transport: RTCDtlsTransport

  операция addEventListener<K = /*(!) keyof RTCSctpTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCSctpTransport, ev: /*(!) RTCSctpTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RTCSctpTransportEventMap */ Объект?>(type: K, listener: операция(this: RTCSctpTransport, ev: /*(!) RTCSctpTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RTCSctpTransport: объект { prototype: RTCSctpTransport; при создании()/*(!) no_type */ Объект? }


/**
* One end of a connection—or potential connection—and how it's configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCSessionDescription)
*/

тип RTCSessionDescription = интерфейс
{
  защищено 
  sdp: Текст

  защищено 
  type: RTCSdpType

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ RTCSessionDescription: объект { prototype: RTCSessionDescription; при создании(descriptionInitDict: RTCSessionDescriptionInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCStatsReport) */

тип RTCStatsReport = интерфейс
{
  операция forEach(callbackfn: операция(value: /*(!) any */ Объект?, key: Текст, parent: RTCStatsReport), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ RTCStatsReport: объект { prototype: RTCStatsReport; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCTrackEvent) */

тип RTCTrackEvent = интерфейс
{
  защищено 
  receiver: RTCRtpReceiver

  защищено 
  streams: ReadonlyArray<MediaStream>

  защищено 
  track: MediaStreamTrack

  защищено 
  transceiver: RTCRtpTransceiver
}


внешнее
/*(!) var */ RTCTrackEvent: объект { prototype: RTCTrackEvent; при создании(type: Текст, eventInitDict: RTCTrackEventInit)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RadioNodeList) */

тип RadioNodeList = интерфейс
{
  value: Текст
}


внешнее
/*(!) var */ RadioNodeList: объект { prototype: RadioNodeList; при создании()/*(!) no_type */ Объект? }


/**
* A fragment of a document that can contain nodes and parts of text nodes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Range)
*/

тип Range = интерфейс
{
  защищено 
  commonAncestorContainer: Node

  операция cloneContents(): DocumentFragment

  операция cloneRange(): Range

  операция collapse(toStart: ДаНет?FUCKFUCK = пусто)

  операция compareBoundaryPoints(how: Число, sourceRange: Range): Число

  операция comparePoint(node: Node, offset: Число): Число

  операция createContextualFragment(fragment: Текст): DocumentFragment

  операция deleteContents()

  операция detach()

  операция extractContents(): DocumentFragment

  операция getBoundingClientRect(): DOMRect

  операция getClientRects(): DOMRectList

  операция insertNode(node: Node)

  операция intersectsNode(node: Node): ДаНет

  операция isPointInRange(node: Node, offset: Число): ДаНет

  операция selectNode(node: Node)

  операция selectNodeContents(node: Node)

  операция setEnd(node: Node, offset: Число)

  операция setEndAfter(node: Node)

  операция setEndBefore(node: Node)

  операция setStart(node: Node, offset: Число)

  операция setStartAfter(node: Node)

  операция setStartBefore(node: Node)

  операция surroundContents(newParent: Node)

  операция toString(): Текст

  защищено 
  START_TO_START: 0

  защищено 
  START_TO_END: 1

  защищено 
  END_TO_END: 2

  защищено 
  END_TO_START: 3
}


внешнее
/*(!) var */ Range: объект { prototype: Range; при создании()/*(!) no_type */ Объект?; защищено  START_TO_START: 0; защищено  START_TO_END: 1; защищено  END_TO_END: 2; защищено  END_TO_START: 3 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */

тип ReadableByteStreamController = интерфейс
{
  защищено 
  byobRequest: ReadableStreamBYOBRequest?FUCKFUCK

  защищено 
  desiredSize: Число?FUCKFUCK

  операция close()

  операция enqueue(chunk: ArrayBufferView)

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ ReadableByteStreamController: объект { prototype: ReadableByteStreamController; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)
*/

тип ReadableStream<R> = интерфейс
{
  защищено 
  locked: ДаНет

  операция cancel(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция getReader(options: объект { mode: "byob" }): ReadableStreamBYOBReader

  операция getReader(): ReadableStreamDefaultReader<R>

  операция getReader(options: ReadableStreamGetReaderOptions?FUCKFUCK = пусто): ReadableStreamReader<R>

  операция pipeThrough<T>(transform: ReadableWritablePair<T, R>, options: StreamPipeOptions?FUCKFUCK = пусто): ReadableStream<T>

  операция pipeTo(destination: WritableStream<R>, options: StreamPipeOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция tee(): объект { _0: ReadableStream<R>, _1: ReadableStream<R> }
}


внешнее
/*(!) var */ ReadableStream: объект { prototype: ReadableStream; при создании(underlyingSource: UnderlyingByteSource, strategy: объект { highWaterMark: Число }?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(underlyingSource: UnderlyingDefaultSource<R>, strategy: QueuingStrategy<R>?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(underlyingSource: UnderlyingSource<R>?FUCKFUCK = пусто, strategy: QueuingStrategy<R>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */

тип ReadableStreamBYOBReader = интерфейс
{
  операция read<T = ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamBYOBReader: объект { prototype: ReadableStreamBYOBReader; при создании(stream: ReadableStream)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */

тип ReadableStreamBYOBRequest = интерфейс
{
  защищено 
  view: ArrayBufferView?FUCKFUCK

  операция respond(bytesWritten: Число)

  операция respondWithNewView(view: ArrayBufferView)
}


внешнее
/*(!) var */ ReadableStreamBYOBRequest: объект { prototype: ReadableStreamBYOBRequest; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */

тип ReadableStreamDefaultController<R> = интерфейс
{
  защищено 
  desiredSize: Число?FUCKFUCK

  операция close()

  операция enqueue(chunk: R?FUCKFUCK = пусто)

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ ReadableStreamDefaultController: объект { prototype: ReadableStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */

тип ReadableStreamDefaultReader<R> = интерфейс
{
  операция read(): Promise<ReadableStreamReadResult<R>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamDefaultReader: объект { prototype: ReadableStreamDefaultReader; при создании(stream: ReadableStream<R>)/*(!) no_type */ Объект? }


тип ReadableStreamGenericReader = интерфейс
{
  защищено 
  closed: Promise<пусто>

  операция cancel(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>
}


тип RemotePlaybackEventMap = интерфейс
{
  "connect": Event

  "connecting": Event

  "disconnect": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RemotePlayback) */

тип RemotePlayback = интерфейс
{
  onconnect: операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onconnecting: операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ondisconnect: операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: RemotePlaybackState

  операция cancelWatchAvailability(id: Число?FUCKFUCK = пусто): Promise<Ничего>

  операция prompt(): Promise<Ничего>

  операция watchAvailability(callback: RemotePlaybackAvailabilityCallback): Promise<Число>

  операция addEventListener<K = /*(!) keyof RemotePlaybackEventMap */ Объект?>(type: K, listener: операция(this: RemotePlayback, ev: /*(!) RemotePlaybackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof RemotePlaybackEventMap */ Объект?>(type: K, listener: операция(this: RemotePlayback, ev: /*(!) RemotePlaybackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ RemotePlayback: объект { prototype: RemotePlayback; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Report) */

тип Report = интерфейс
{
  защищено 
  body: ReportBody?FUCKFUCK

  защищено 
  type: Текст

  защищено 
  url: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ Report: объект { prototype: Report; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportBody) */

тип ReportBody = интерфейс
{
  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ ReportBody: объект { prototype: ReportBody; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportingObserver) */

тип ReportingObserver = интерфейс
{
  операция disconnect()

  операция observe()

  операция takeRecords(): ReportList
}


внешнее
/*(!) var */ ReportingObserver: объект { prototype: ReportingObserver; при создании(callback: ReportingObserverCallback, options: ReportingObserverOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Fetch API interface represents a resource request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)
*/

тип Request = интерфейс
{
  защищено 
  cache: RequestCache

  защищено 
  credentials: RequestCredentials

  защищено 
  destination: RequestDestination

  защищено 
  headers: Headers

  защищено 
  integrity: Текст

  защищено 
  keepalive: ДаНет

  защищено 
  method: Текст

  защищено 
  mode: RequestMode

  защищено 
  redirect: RequestRedirect

  защищено 
  referrer: Текст

  защищено 
  referrerPolicy: ReferrerPolicy

  защищено 
  signal: AbortSignal

  защищено 
  url: Текст

  операция clone(): Request
}


внешнее
/*(!) var */ Request: объект { prototype: Request; при создании(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserver) */

тип ResizeObserver = интерфейс
{
  операция disconnect()

  операция observe(target: Element, options: ResizeObserverOptions?FUCKFUCK = пусто)

  операция unobserve(target: Element)
}


внешнее
/*(!) var */ ResizeObserver: объект { prototype: ResizeObserver; при создании(callback: ResizeObserverCallback)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserverEntry) */

тип ResizeObserverEntry = интерфейс
{
  защищено 
  borderBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  contentBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  contentRect: DOMRectReadOnly

  защищено 
  devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  target: Element
}


внешнее
/*(!) var */ ResizeObserverEntry: объект { prototype: ResizeObserverEntry; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserverSize) */

тип ResizeObserverSize = интерфейс
{
  защищено 
  blockSize: Число

  защищено 
  inlineSize: Число
}


внешнее
/*(!) var */ ResizeObserverSize: объект { prototype: ResizeObserverSize; при создании()/*(!) no_type */ Объект? }


/**
* This Fetch API interface represents the response to a request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)
*/

тип Response = интерфейс
{
  защищено 
  headers: Headers

  защищено 
  ok: ДаНет

  защищено 
  redirected: ДаНет

  защищено 
  status: Число

  защищено 
  statusText: Текст

  защищено 
  type: ResponseType

  защищено 
  url: Текст

  операция clone(): Response
}


внешнее
/*(!) var */ Response: объект { prototype: Response; при создании(body: BodyInit?FUCKFUCK = пусто, init: ResponseInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; операция error(): Response; операция json(data: /*(!) any */ Объект?, init: ResponseInit?FUCKFUCK = пусто): Response; операция redirect(url: Текст | URL, status: Число?FUCKFUCK = пусто): Response }


/**
* Provides access to the properties of <a> element, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAElement)
*/

тип SVGAElement = интерфейс
{
  rel: Текст

  защищено 
  relList: DOMTokenList

  защищено 
  target: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGAElement: объект { prototype: SVGAElement; при создании()/*(!) no_type */ Объект? }


/**
* Used to represent a value that can be an <angle> or <number> value. An SVGAngle reflected through the animVal attribute is always read only.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAngle)
*/

тип SVGAngle = интерфейс
{
  защищено 
  unitType: Число

  value: Число

  valueAsString: Текст

  valueInSpecifiedUnits: Число

  операция convertToSpecifiedUnits(unitType: Число)

  операция newValueSpecifiedUnits(unitType: Число, valueInSpecifiedUnits: Число)

  защищено 
  SVG_ANGLETYPE_UNKNOWN: 0

  защищено 
  SVG_ANGLETYPE_UNSPECIFIED: 1

  защищено 
  SVG_ANGLETYPE_DEG: 2

  защищено 
  SVG_ANGLETYPE_RAD: 3

  защищено 
  SVG_ANGLETYPE_GRAD: 4
}


внешнее
/*(!) var */ SVGAngle: объект { prototype: SVGAngle; при создании()/*(!) no_type */ Объект?; защищено  SVG_ANGLETYPE_UNKNOWN: 0; защищено  SVG_ANGLETYPE_UNSPECIFIED: 1; защищено  SVG_ANGLETYPE_DEG: 2; защищено  SVG_ANGLETYPE_RAD: 3; защищено  SVG_ANGLETYPE_GRAD: 4 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateElement) */

тип SVGAnimateElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGAnimateElement: объект { prototype: SVGAnimateElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateMotionElement) */

тип SVGAnimateMotionElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateMotionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateMotionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGAnimateMotionElement: объект { prototype: SVGAnimateMotionElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateTransformElement) */

тип SVGAnimateTransformElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateTransformElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimateTransformElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGAnimateTransformElement: объект { prototype: SVGAnimateTransformElement; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of basic type <angle> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedAngle)
*/

тип SVGAnimatedAngle = интерфейс
{
  защищено 
  animVal: SVGAngle

  защищено 
  baseVal: SVGAngle
}


внешнее
/*(!) var */ SVGAnimatedAngle: объект { prototype: SVGAnimatedAngle; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of type boolean which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedBoolean)
*/

тип SVGAnimatedBoolean = интерфейс
{
  защищено 
  animVal: ДаНет

  baseVal: ДаНет
}


внешнее
/*(!) var */ SVGAnimatedBoolean: объект { prototype: SVGAnimatedBoolean; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes whose value must be a constant from a particular enumeration and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedEnumeration)
*/

тип SVGAnimatedEnumeration = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedEnumeration: объект { prototype: SVGAnimatedEnumeration; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of basic type <integer> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedInteger)
*/

тип SVGAnimatedInteger = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedInteger: объект { prototype: SVGAnimatedInteger; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of basic type <length> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedLength)
*/

тип SVGAnimatedLength = интерфейс
{
  защищено 
  animVal: SVGLength

  защищено 
  baseVal: SVGLength
}


внешнее
/*(!) var */ SVGAnimatedLength: объект { prototype: SVGAnimatedLength; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of type SVGLengthList which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedLengthList)
*/

тип SVGAnimatedLengthList = интерфейс
{
  защищено 
  animVal: SVGLengthList

  защищено 
  baseVal: SVGLengthList
}


внешнее
/*(!) var */ SVGAnimatedLengthList: объект { prototype: SVGAnimatedLengthList; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of basic type <Number> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedNumber)
*/

тип SVGAnimatedNumber = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedNumber: объект { prototype: SVGAnimatedNumber; при создании()/*(!) no_type */ Объект? }


/**
* The SVGAnimatedNumber interface is used for attributes which take a list of numbers and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedNumberList)
*/

тип SVGAnimatedNumberList = интерфейс
{
  защищено 
  animVal: SVGNumberList

  защищено 
  baseVal: SVGNumberList
}


внешнее
/*(!) var */ SVGAnimatedNumberList: объект { prototype: SVGAnimatedNumberList; при создании()/*(!) no_type */ Объект? }


тип SVGAnimatedPoints = интерфейс
{
  защищено 
  animatedPoints: SVGPointList

  защищено 
  points: SVGPointList
}


/**
* Used for attributes of type SVGPreserveAspectRatio which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedPreserveAspectRatio)
*/

тип SVGAnimatedPreserveAspectRatio = интерфейс
{
  защищено 
  animVal: SVGPreserveAspectRatio

  защищено 
  baseVal: SVGPreserveAspectRatio
}


внешнее
/*(!) var */ SVGAnimatedPreserveAspectRatio: объект { prototype: SVGAnimatedPreserveAspectRatio; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes of basic SVGRect which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedRect)
*/

тип SVGAnimatedRect = интерфейс
{
  защищено 
  animVal: DOMRectReadOnly

  защищено 
  baseVal: DOMRect
}


внешнее
/*(!) var */ SVGAnimatedRect: объект { prototype: SVGAnimatedRect; при создании()/*(!) no_type */ Объект? }


/**
* The SVGAnimatedString interface represents string attributes which can be animated from each SVG declaration. You need to create SVG attribute before doing anything else, everything should be declared inside this.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedString)
*/

тип SVGAnimatedString = интерфейс
{
  защищено 
  animVal: Текст

  baseVal: Текст
}


внешнее
/*(!) var */ SVGAnimatedString: объект { prototype: SVGAnimatedString; при создании()/*(!) no_type */ Объект? }


/**
* Used for attributes which take a list of numbers and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedTransformList)
*/

тип SVGAnimatedTransformList = интерфейс
{
  защищено 
  animVal: SVGTransformList

  защищено 
  baseVal: SVGTransformList
}


внешнее
/*(!) var */ SVGAnimatedTransformList: объект { prototype: SVGAnimatedTransformList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimationElement) */

тип SVGAnimationElement = интерфейс
{
  защищено 
  targetElement: SVGElement?FUCKFUCK

  операция beginElement()

  операция beginElementAt(offset: Число)

  операция endElement()

  операция endElementAt(offset: Число)

  операция getCurrentTime(): Число

  операция getSimpleDuration(): Число

  операция getStartTime(): Число

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimationElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGAnimationElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGAnimationElement: объект { prototype: SVGAnimationElement; при создании()/*(!) no_type */ Объект? }


/**
* An interface for the <circle> element. The circle element is defined by the cx and cy attributes that denote the coordinates of the centre of the circle.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGCircleElement)
*/

тип SVGCircleElement = интерфейс
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  r: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGCircleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGCircleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGCircleElement: объект { prototype: SVGCircleElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <clipPath> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGClipPathElement)
*/

тип SVGClipPathElement = интерфейс
{
  защищено 
  clipPathUnits: SVGAnimatedEnumeration

  защищено 
  transform: SVGAnimatedTransformList

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGClipPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGClipPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGClipPathElement: объект { prototype: SVGClipPathElement; при создании()/*(!) no_type */ Объект? }


/**
* A base interface used by the component transfer function interfaces.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGComponentTransferFunctionElement)
*/

тип SVGComponentTransferFunctionElement = интерфейс
{
  защищено 
  amplitude: SVGAnimatedNumber

  защищено 
  exponent: SVGAnimatedNumber

  защищено 
  intercept: SVGAnimatedNumber

  защищено 
  offset: SVGAnimatedNumber

  защищено 
  slope: SVGAnimatedNumber

  защищено 
  tableValues: SVGAnimatedNumberList

  защищено 
  type: SVGAnimatedEnumeration

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGComponentTransferFunctionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGComponentTransferFunctionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGComponentTransferFunctionElement: объект { prototype: SVGComponentTransferFunctionElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0; защищено  SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1; защищено  SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2; защищено  SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3; защищено  SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4; защищено  SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5 }


/**
* Corresponds to the <defs> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGDefsElement)
*/

тип SVGDefsElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGDefsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGDefsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGDefsElement: объект { prototype: SVGDefsElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <desc> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGDescElement)
*/

тип SVGDescElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGDescElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGDescElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGDescElement: объект { prototype: SVGDescElement; при создании()/*(!) no_type */ Объект? }


тип SVGElementEventMap = интерфейс
{

}


/**
* All of the SVG DOM interfaces that correspond directly to elements in the SVG language derive from the SVGElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGElement)
*/

тип SVGElement = интерфейс
{
  защищено 
  className: /*(!) any */ Объект?

  защищено 
  ownerSVGElement: SVGSVGElement?FUCKFUCK

  защищено 
  viewportElement: SVGElement?FUCKFUCK

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGElement: объект { prototype: SVGElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <ellipse> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGEllipseElement)
*/

тип SVGEllipseElement = интерфейс
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  rx: SVGAnimatedLength

  защищено 
  ry: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGEllipseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGEllipseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGEllipseElement: объект { prototype: SVGEllipseElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feBlend> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEBlendElement)
*/

тип SVGFEBlendElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  mode: SVGAnimatedEnumeration

  защищено 
  SVG_FEBLEND_MODE_UNKNOWN: 0

  защищено 
  SVG_FEBLEND_MODE_NORMAL: 1

  защищено 
  SVG_FEBLEND_MODE_MULTIPLY: 2

  защищено 
  SVG_FEBLEND_MODE_SCREEN: 3

  защищено 
  SVG_FEBLEND_MODE_DARKEN: 4

  защищено 
  SVG_FEBLEND_MODE_LIGHTEN: 5

  защищено 
  SVG_FEBLEND_MODE_OVERLAY: 6

  защищено 
  SVG_FEBLEND_MODE_COLOR_DODGE: 7

  защищено 
  SVG_FEBLEND_MODE_COLOR_BURN: 8

  защищено 
  SVG_FEBLEND_MODE_HARD_LIGHT: 9

  защищено 
  SVG_FEBLEND_MODE_SOFT_LIGHT: 10

  защищено 
  SVG_FEBLEND_MODE_DIFFERENCE: 11

  защищено 
  SVG_FEBLEND_MODE_EXCLUSION: 12

  защищено 
  SVG_FEBLEND_MODE_HUE: 13

  защищено 
  SVG_FEBLEND_MODE_SATURATION: 14

  защищено 
  SVG_FEBLEND_MODE_COLOR: 15

  защищено 
  SVG_FEBLEND_MODE_LUMINOSITY: 16

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEBlendElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEBlendElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEBlendElement: объект { prototype: SVGFEBlendElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_FEBLEND_MODE_UNKNOWN: 0; защищено  SVG_FEBLEND_MODE_NORMAL: 1; защищено  SVG_FEBLEND_MODE_MULTIPLY: 2; защищено  SVG_FEBLEND_MODE_SCREEN: 3; защищено  SVG_FEBLEND_MODE_DARKEN: 4; защищено  SVG_FEBLEND_MODE_LIGHTEN: 5; защищено  SVG_FEBLEND_MODE_OVERLAY: 6; защищено  SVG_FEBLEND_MODE_COLOR_DODGE: 7; защищено  SVG_FEBLEND_MODE_COLOR_BURN: 8; защищено  SVG_FEBLEND_MODE_HARD_LIGHT: 9; защищено  SVG_FEBLEND_MODE_SOFT_LIGHT: 10; защищено  SVG_FEBLEND_MODE_DIFFERENCE: 11; защищено  SVG_FEBLEND_MODE_EXCLUSION: 12; защищено  SVG_FEBLEND_MODE_HUE: 13; защищено  SVG_FEBLEND_MODE_SATURATION: 14; защищено  SVG_FEBLEND_MODE_COLOR: 15; защищено  SVG_FEBLEND_MODE_LUMINOSITY: 16 }


/**
* Corresponds to the <feColorMatrix> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEColorMatrixElement)
*/

тип SVGFEColorMatrixElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  type: SVGAnimatedEnumeration

  защищено 
  values: SVGAnimatedNumberList

  защищено 
  SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0

  защищено 
  SVG_FECOLORMATRIX_TYPE_MATRIX: 1

  защищено 
  SVG_FECOLORMATRIX_TYPE_SATURATE: 2

  защищено 
  SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3

  защищено 
  SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEColorMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEColorMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEColorMatrixElement: объект { prototype: SVGFEColorMatrixElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0; защищено  SVG_FECOLORMATRIX_TYPE_MATRIX: 1; защищено  SVG_FECOLORMATRIX_TYPE_SATURATE: 2; защищено  SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3; защищено  SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4 }


/**
* Corresponds to the <feComponentTransfer> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEComponentTransferElement)
*/

тип SVGFEComponentTransferElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEComponentTransferElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEComponentTransferElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEComponentTransferElement: объект { prototype: SVGFEComponentTransferElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feComposite> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFECompositeElement)
*/

тип SVGFECompositeElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  k1: SVGAnimatedNumber

  защищено 
  k2: SVGAnimatedNumber

  защищено 
  k3: SVGAnimatedNumber

  защищено 
  k4: SVGAnimatedNumber

  защищено 
  operator: SVGAnimatedEnumeration

  защищено 
  SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0

  защищено 
  SVG_FECOMPOSITE_OPERATOR_OVER: 1

  защищено 
  SVG_FECOMPOSITE_OPERATOR_IN: 2

  защищено 
  SVG_FECOMPOSITE_OPERATOR_OUT: 3

  защищено 
  SVG_FECOMPOSITE_OPERATOR_ATOP: 4

  защищено 
  SVG_FECOMPOSITE_OPERATOR_XOR: 5

  защищено 
  SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFECompositeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFECompositeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFECompositeElement: объект { prototype: SVGFECompositeElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0; защищено  SVG_FECOMPOSITE_OPERATOR_OVER: 1; защищено  SVG_FECOMPOSITE_OPERATOR_IN: 2; защищено  SVG_FECOMPOSITE_OPERATOR_OUT: 3; защищено  SVG_FECOMPOSITE_OPERATOR_ATOP: 4; защищено  SVG_FECOMPOSITE_OPERATOR_XOR: 5; защищено  SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6 }


/**
* Corresponds to the <feConvolveMatrix> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEConvolveMatrixElement)
*/

тип SVGFEConvolveMatrixElement = интерфейс
{
  защищено 
  bias: SVGAnimatedNumber

  защищено 
  divisor: SVGAnimatedNumber

  защищено 
  edgeMode: SVGAnimatedEnumeration

  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelMatrix: SVGAnimatedNumberList

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  orderX: SVGAnimatedInteger

  защищено 
  orderY: SVGAnimatedInteger

  защищено 
  preserveAlpha: SVGAnimatedBoolean

  защищено 
  targetX: SVGAnimatedInteger

  защищено 
  targetY: SVGAnimatedInteger

  защищено 
  SVG_EDGEMODE_UNKNOWN: 0

  защищено 
  SVG_EDGEMODE_DUPLICATE: 1

  защищено 
  SVG_EDGEMODE_WRAP: 2

  защищено 
  SVG_EDGEMODE_NONE: 3

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEConvolveMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEConvolveMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEConvolveMatrixElement: объект { prototype: SVGFEConvolveMatrixElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_EDGEMODE_UNKNOWN: 0; защищено  SVG_EDGEMODE_DUPLICATE: 1; защищено  SVG_EDGEMODE_WRAP: 2; защищено  SVG_EDGEMODE_NONE: 3 }


/**
* Corresponds to the <feDiffuseLighting> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDiffuseLightingElement)
*/

тип SVGFEDiffuseLightingElement = интерфейс
{
  защищено 
  diffuseConstant: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  surfaceScale: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDiffuseLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDiffuseLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEDiffuseLightingElement: объект { prototype: SVGFEDiffuseLightingElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feDisplacementMap> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDisplacementMapElement)
*/

тип SVGFEDisplacementMapElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  scale: SVGAnimatedNumber

  защищено 
  xChannelSelector: SVGAnimatedEnumeration

  защищено 
  yChannelSelector: SVGAnimatedEnumeration

  защищено 
  SVG_CHANNEL_UNKNOWN: 0

  защищено 
  SVG_CHANNEL_R: 1

  защищено 
  SVG_CHANNEL_G: 2

  защищено 
  SVG_CHANNEL_B: 3

  защищено 
  SVG_CHANNEL_A: 4

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDisplacementMapElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDisplacementMapElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEDisplacementMapElement: объект { prototype: SVGFEDisplacementMapElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_CHANNEL_UNKNOWN: 0; защищено  SVG_CHANNEL_R: 1; защищено  SVG_CHANNEL_G: 2; защищено  SVG_CHANNEL_B: 3; защищено  SVG_CHANNEL_A: 4 }


/**
* Corresponds to the <feDistantLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDistantLightElement)
*/

тип SVGFEDistantLightElement = интерфейс
{
  защищено 
  azimuth: SVGAnimatedNumber

  защищено 
  elevation: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDistantLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDistantLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEDistantLightElement: объект { prototype: SVGFEDistantLightElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDropShadowElement) */

тип SVGFEDropShadowElement = интерфейс
{
  защищено 
  dx: SVGAnimatedNumber

  защищено 
  dy: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  защищено 
  stdDeviationX: SVGAnimatedNumber

  защищено 
  stdDeviationY: SVGAnimatedNumber

  операция setStdDeviation(stdDeviationX: Число, stdDeviationY: Число)

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDropShadowElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEDropShadowElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEDropShadowElement: объект { prototype: SVGFEDropShadowElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feFlood> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFloodElement)
*/

тип SVGFEFloodElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFloodElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFloodElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEFloodElement: объект { prototype: SVGFEFloodElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feFuncA> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncAElement)
*/

тип SVGFEFuncAElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEFuncAElement: объект { prototype: SVGFEFuncAElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feFuncB> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncBElement)
*/

тип SVGFEFuncBElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncBElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncBElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEFuncBElement: объект { prototype: SVGFEFuncBElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feFuncG> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncGElement)
*/

тип SVGFEFuncGElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEFuncGElement: объект { prototype: SVGFEFuncGElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feFuncR> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncRElement)
*/

тип SVGFEFuncRElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncRElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEFuncRElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEFuncRElement: объект { prototype: SVGFEFuncRElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feGaussianBlur> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEGaussianBlurElement)
*/

тип SVGFEGaussianBlurElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  stdDeviationX: SVGAnimatedNumber

  защищено 
  stdDeviationY: SVGAnimatedNumber

  операция setStdDeviation(stdDeviationX: Число, stdDeviationY: Число)

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEGaussianBlurElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEGaussianBlurElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEGaussianBlurElement: объект { prototype: SVGFEGaussianBlurElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feImage> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEImageElement)
*/

тип SVGFEImageElement = интерфейс
{
  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEImageElement: объект { prototype: SVGFEImageElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feMerge> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMergeElement)
*/

тип SVGFEMergeElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMergeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMergeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEMergeElement: объект { prototype: SVGFEMergeElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feMergeNode> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMergeNodeElement)
*/

тип SVGFEMergeNodeElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMergeNodeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMergeNodeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEMergeNodeElement: объект { prototype: SVGFEMergeNodeElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feMorphology> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMorphologyElement)
*/

тип SVGFEMorphologyElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  operator: SVGAnimatedEnumeration

  защищено 
  radiusX: SVGAnimatedNumber

  защищено 
  radiusY: SVGAnimatedNumber

  защищено 
  SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0

  защищено 
  SVG_MORPHOLOGY_OPERATOR_ERODE: 1

  защищено 
  SVG_MORPHOLOGY_OPERATOR_DILATE: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMorphologyElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEMorphologyElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEMorphologyElement: объект { prototype: SVGFEMorphologyElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0; защищено  SVG_MORPHOLOGY_OPERATOR_ERODE: 1; защищено  SVG_MORPHOLOGY_OPERATOR_DILATE: 2 }


/**
* Corresponds to the <feOffset> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEOffsetElement)
*/

тип SVGFEOffsetElement = интерфейс
{
  защищено 
  dx: SVGAnimatedNumber

  защищено 
  dy: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEOffsetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEOffsetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEOffsetElement: объект { prototype: SVGFEOffsetElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <fePointLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEPointLightElement)
*/

тип SVGFEPointLightElement = интерфейс
{
  защищено 
  x: SVGAnimatedNumber

  защищено 
  y: SVGAnimatedNumber

  защищено 
  z: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEPointLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFEPointLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFEPointLightElement: объект { prototype: SVGFEPointLightElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feSpecularLighting> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFESpecularLightingElement)
*/

тип SVGFESpecularLightingElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  specularConstant: SVGAnimatedNumber

  защищено 
  specularExponent: SVGAnimatedNumber

  защищено 
  surfaceScale: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFESpecularLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFESpecularLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFESpecularLightingElement: объект { prototype: SVGFESpecularLightingElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feSpotLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFESpotLightElement)
*/

тип SVGFESpotLightElement = интерфейс
{
  защищено 
  limitingConeAngle: SVGAnimatedNumber

  защищено 
  pointsAtX: SVGAnimatedNumber

  защищено 
  pointsAtY: SVGAnimatedNumber

  защищено 
  pointsAtZ: SVGAnimatedNumber

  защищено 
  specularExponent: SVGAnimatedNumber

  защищено 
  x: SVGAnimatedNumber

  защищено 
  y: SVGAnimatedNumber

  защищено 
  z: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFESpotLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFESpotLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFESpotLightElement: объект { prototype: SVGFESpotLightElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feTile> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFETileElement)
*/

тип SVGFETileElement = интерфейс
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFETileElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFETileElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFETileElement: объект { prototype: SVGFETileElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <feTurbulence> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFETurbulenceElement)
*/

тип SVGFETurbulenceElement = интерфейс
{
  защищено 
  baseFrequencyX: SVGAnimatedNumber

  защищено 
  baseFrequencyY: SVGAnimatedNumber

  защищено 
  numOctaves: SVGAnimatedInteger

  защищено 
  seed: SVGAnimatedNumber

  защищено 
  stitchTiles: SVGAnimatedEnumeration

  защищено 
  type: SVGAnimatedEnumeration

  защищено 
  SVG_TURBULENCE_TYPE_UNKNOWN: 0

  защищено 
  SVG_TURBULENCE_TYPE_FRACTALNOISE: 1

  защищено 
  SVG_TURBULENCE_TYPE_TURBULENCE: 2

  защищено 
  SVG_STITCHTYPE_UNKNOWN: 0

  защищено 
  SVG_STITCHTYPE_STITCH: 1

  защищено 
  SVG_STITCHTYPE_NOSTITCH: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFETurbulenceElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFETurbulenceElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFETurbulenceElement: объект { prototype: SVGFETurbulenceElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_TURBULENCE_TYPE_UNKNOWN: 0; защищено  SVG_TURBULENCE_TYPE_FRACTALNOISE: 1; защищено  SVG_TURBULENCE_TYPE_TURBULENCE: 2; защищено  SVG_STITCHTYPE_UNKNOWN: 0; защищено  SVG_STITCHTYPE_STITCH: 1; защищено  SVG_STITCHTYPE_NOSTITCH: 2 }


/**
* Provides access to the properties of <filter> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFilterElement)
*/

тип SVGFilterElement = интерфейс
{
  защищено 
  filterUnits: SVGAnimatedEnumeration

  защищено 
  height: SVGAnimatedLength

  защищено 
  primitiveUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFilterElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGFilterElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGFilterElement: объект { prototype: SVGFilterElement; при создании()/*(!) no_type */ Объект? }


тип SVGFilterPrimitiveStandardAttributes = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  result: SVGAnimatedString

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength
}


тип SVGFitToViewBox = интерфейс
{
  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  защищено 
  viewBox: SVGAnimatedRect
}


/**
* Provides access to the properties of <foreignObject> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGForeignObjectElement)
*/

тип SVGForeignObjectElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGForeignObjectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGForeignObjectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGForeignObjectElement: объект { prototype: SVGForeignObjectElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <g> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGElement)
*/

тип SVGGElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGGElement: объект { prototype: SVGGElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGeometryElement) */

тип SVGGeometryElement = интерфейс
{
  защищено 
  pathLength: SVGAnimatedNumber

  операция getPointAtLength(distance: Число): DOMPoint

  операция getTotalLength(): Число

  операция isPointInFill(point: DOMPointInit?FUCKFUCK = пусто): ДаНет

  операция isPointInStroke(point: DOMPointInit?FUCKFUCK = пусто): ДаНет

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGeometryElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGeometryElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGGeometryElement: объект { prototype: SVGGeometryElement; при создании()/*(!) no_type */ Объект? }


/**
* The SVGGradient interface is a base interface used by SVGLinearGradientElement and SVGRadialGradientElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGradientElement)
*/

тип SVGGradientElement = интерфейс
{
  защищено 
  gradientTransform: SVGAnimatedTransformList

  защищено 
  gradientUnits: SVGAnimatedEnumeration

  защищено 
  spreadMethod: SVGAnimatedEnumeration

  защищено 
  SVG_SPREADMETHOD_UNKNOWN: 0

  защищено 
  SVG_SPREADMETHOD_PAD: 1

  защищено 
  SVG_SPREADMETHOD_REFLECT: 2

  защищено 
  SVG_SPREADMETHOD_REPEAT: 3

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGGradientElement: объект { prototype: SVGGradientElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_SPREADMETHOD_UNKNOWN: 0; защищено  SVG_SPREADMETHOD_PAD: 1; защищено  SVG_SPREADMETHOD_REFLECT: 2; защищено  SVG_SPREADMETHOD_REPEAT: 3 }


/**
* SVG elements whose primary purpose is to directly render graphics into a group.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGraphicsElement)
*/

тип SVGGraphicsElement = интерфейс
{
  защищено 
  transform: SVGAnimatedTransformList

  операция getBBox(options: SVGBoundingBoxOptions?FUCKFUCK = пусто): DOMRect

  операция getCTM(): DOMMatrix?FUCKFUCK

  операция getScreenCTM(): DOMMatrix?FUCKFUCK

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGraphicsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGGraphicsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGGraphicsElement: объект { prototype: SVGGraphicsElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <image> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGImageElement)
*/

тип SVGImageElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGImageElement: объект { prototype: SVGImageElement; при создании()/*(!) no_type */ Объект? }


/**
* Correspond to the <length> basic data type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLength)
*/

тип SVGLength = интерфейс
{
  защищено 
  unitType: Число

  value: Число

  valueAsString: Текст

  valueInSpecifiedUnits: Число

  операция convertToSpecifiedUnits(unitType: Число)

  операция newValueSpecifiedUnits(unitType: Число, valueInSpecifiedUnits: Число)

  защищено 
  SVG_LENGTHTYPE_UNKNOWN: 0

  защищено 
  SVG_LENGTHTYPE_NUMBER: 1

  защищено 
  SVG_LENGTHTYPE_PERCENTAGE: 2

  защищено 
  SVG_LENGTHTYPE_EMS: 3

  защищено 
  SVG_LENGTHTYPE_EXS: 4

  защищено 
  SVG_LENGTHTYPE_PX: 5

  защищено 
  SVG_LENGTHTYPE_CM: 6

  защищено 
  SVG_LENGTHTYPE_MM: 7

  защищено 
  SVG_LENGTHTYPE_IN: 8

  защищено 
  SVG_LENGTHTYPE_PT: 9

  защищено 
  SVG_LENGTHTYPE_PC: 10
}


внешнее
/*(!) var */ SVGLength: объект { prototype: SVGLength; при создании()/*(!) no_type */ Объект?; защищено  SVG_LENGTHTYPE_UNKNOWN: 0; защищено  SVG_LENGTHTYPE_NUMBER: 1; защищено  SVG_LENGTHTYPE_PERCENTAGE: 2; защищено  SVG_LENGTHTYPE_EMS: 3; защищено  SVG_LENGTHTYPE_EXS: 4; защищено  SVG_LENGTHTYPE_PX: 5; защищено  SVG_LENGTHTYPE_CM: 6; защищено  SVG_LENGTHTYPE_MM: 7; защищено  SVG_LENGTHTYPE_IN: 8; защищено  SVG_LENGTHTYPE_PT: 9; защищено  SVG_LENGTHTYPE_PC: 10 }


/**
* The SVGLengthList defines a list of SVGLength objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLengthList)
*/

тип SVGLengthList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGLength): SVGLength

  операция clear()

  операция getItem(index: Число): SVGLength

  операция initialize(newItem: SVGLength): SVGLength

  операция insertItemBefore(newItem: SVGLength, index: Число): SVGLength

  операция removeItem(index: Число): SVGLength

  операция replaceItem(newItem: SVGLength, index: Число): SVGLength

  /*(!) [index: number]: SVGLength*/
}


внешнее
/*(!) var */ SVGLengthList: объект { prototype: SVGLengthList; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <line> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLineElement)
*/

тип SVGLineElement = интерфейс
{
  защищено 
  x1: SVGAnimatedLength

  защищено 
  x2: SVGAnimatedLength

  защищено 
  y1: SVGAnimatedLength

  защищено 
  y2: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGLineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGLineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGLineElement: объект { prototype: SVGLineElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <linearGradient> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLinearGradientElement)
*/

тип SVGLinearGradientElement = интерфейс
{
  защищено 
  x1: SVGAnimatedLength

  защищено 
  x2: SVGAnimatedLength

  защищено 
  y1: SVGAnimatedLength

  защищено 
  y2: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGLinearGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGLinearGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGLinearGradientElement: объект { prototype: SVGLinearGradientElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMPathElement) */

тип SVGMPathElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGMPathElement: объект { prototype: SVGMPathElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMarkerElement) */

тип SVGMarkerElement = интерфейс
{
  защищено 
  markerHeight: SVGAnimatedLength

  защищено 
  markerUnits: SVGAnimatedEnumeration

  защищено 
  markerWidth: SVGAnimatedLength

  защищено 
  orientAngle: SVGAnimatedAngle

  защищено 
  orientType: SVGAnimatedEnumeration

  защищено 
  refX: SVGAnimatedLength

  защищено 
  refY: SVGAnimatedLength

  операция setOrientToAngle(angle: SVGAngle)

  операция setOrientToAuto()

  защищено 
  SVG_MARKERUNITS_UNKNOWN: 0

  защищено 
  SVG_MARKERUNITS_USERSPACEONUSE: 1

  защищено 
  SVG_MARKERUNITS_STROKEWIDTH: 2

  защищено 
  SVG_MARKER_ORIENT_UNKNOWN: 0

  защищено 
  SVG_MARKER_ORIENT_AUTO: 1

  защищено 
  SVG_MARKER_ORIENT_ANGLE: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMarkerElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMarkerElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGMarkerElement: объект { prototype: SVGMarkerElement; при создании()/*(!) no_type */ Объект?; защищено  SVG_MARKERUNITS_UNKNOWN: 0; защищено  SVG_MARKERUNITS_USERSPACEONUSE: 1; защищено  SVG_MARKERUNITS_STROKEWIDTH: 2; защищено  SVG_MARKER_ORIENT_UNKNOWN: 0; защищено  SVG_MARKER_ORIENT_AUTO: 1; защищено  SVG_MARKER_ORIENT_ANGLE: 2 }


/**
* Provides access to the properties of <mask> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMaskElement)
*/

тип SVGMaskElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  maskContentUnits: SVGAnimatedEnumeration

  защищено 
  maskUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMaskElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMaskElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGMaskElement: объект { prototype: SVGMaskElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <metadata> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMetadataElement)
*/

тип SVGMetadataElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMetadataElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGMetadataElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGMetadataElement: объект { prototype: SVGMetadataElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <number> basic data type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGNumber)
*/

тип SVGNumber = интерфейс
{
  value: Число
}


внешнее
/*(!) var */ SVGNumber: объект { prototype: SVGNumber; при создании()/*(!) no_type */ Объект? }


/**
* The SVGNumberList defines a list of SVGNumber objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGNumberList)
*/

тип SVGNumberList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGNumber): SVGNumber

  операция clear()

  операция getItem(index: Число): SVGNumber

  операция initialize(newItem: SVGNumber): SVGNumber

  операция insertItemBefore(newItem: SVGNumber, index: Число): SVGNumber

  операция removeItem(index: Число): SVGNumber

  операция replaceItem(newItem: SVGNumber, index: Число): SVGNumber

  /*(!) [index: number]: SVGNumber*/
}


внешнее
/*(!) var */ SVGNumberList: объект { prototype: SVGNumberList; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <path> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPathElement)
*/

тип SVGPathElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGPathElement: объект { prototype: SVGPathElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <pattern> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPatternElement)
*/

тип SVGPatternElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  patternContentUnits: SVGAnimatedEnumeration

  защищено 
  patternTransform: SVGAnimatedTransformList

  защищено 
  patternUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPatternElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPatternElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGPatternElement: объект { prototype: SVGPatternElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPointList) */

тип SVGPointList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: DOMPoint): DOMPoint

  операция clear()

  операция getItem(index: Число): DOMPoint

  операция initialize(newItem: DOMPoint): DOMPoint

  операция insertItemBefore(newItem: DOMPoint, index: Число): DOMPoint

  операция removeItem(index: Число): DOMPoint

  операция replaceItem(newItem: DOMPoint, index: Число): DOMPoint

  /*(!) [index: number]: DOMPoint*/
}


внешнее
/*(!) var */ SVGPointList: объект { prototype: SVGPointList; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <polygon> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPolygonElement)
*/

тип SVGPolygonElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPolygonElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPolygonElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGPolygonElement: объект { prototype: SVGPolygonElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <polyline> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPolylineElement)
*/

тип SVGPolylineElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPolylineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGPolylineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGPolylineElement: объект { prototype: SVGPolylineElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the preserveAspectRatio attribute, which is available for some of SVG's elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPreserveAspectRatio)
*/

тип SVGPreserveAspectRatio = интерфейс
{
  align: Число

  meetOrSlice: Число

  защищено 
  SVG_PRESERVEASPECTRATIO_UNKNOWN: 0

  защищено 
  SVG_PRESERVEASPECTRATIO_NONE: 1

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMIN: 2

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMID: 5

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMID: 6

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMID: 7

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMAX: 8

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10

  защищено 
  SVG_MEETORSLICE_UNKNOWN: 0

  защищено 
  SVG_MEETORSLICE_MEET: 1

  защищено 
  SVG_MEETORSLICE_SLICE: 2
}


внешнее
/*(!) var */ SVGPreserveAspectRatio: объект { prototype: SVGPreserveAspectRatio; при создании()/*(!) no_type */ Объект?; защищено  SVG_PRESERVEASPECTRATIO_UNKNOWN: 0; защищено  SVG_PRESERVEASPECTRATIO_NONE: 1; защищено  SVG_PRESERVEASPECTRATIO_XMINYMIN: 2; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4; защищено  SVG_PRESERVEASPECTRATIO_XMINYMID: 5; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMID: 6; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMID: 7; защищено  SVG_PRESERVEASPECTRATIO_XMINYMAX: 8; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10; защищено  SVG_MEETORSLICE_UNKNOWN: 0; защищено  SVG_MEETORSLICE_MEET: 1; защищено  SVG_MEETORSLICE_SLICE: 2 }


/**
* Corresponds to the <RadialGradient> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGRadialGradientElement)
*/

тип SVGRadialGradientElement = интерфейс
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  fr: SVGAnimatedLength

  защищено 
  fx: SVGAnimatedLength

  защищено 
  fy: SVGAnimatedLength

  защищено 
  r: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGRadialGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGRadialGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGRadialGradientElement: объект { prototype: SVGRadialGradientElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <rect> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGRectElement)
*/

тип SVGRectElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  rx: SVGAnimatedLength

  защищено 
  ry: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGRectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGRectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGRectElement: объект { prototype: SVGRectElement; при создании()/*(!) no_type */ Объект? }


тип SVGSVGElementEventMap = интерфейс
{

}


/**
* Provides access to the properties of <svg> elements, as well as methods to manipulate them. This interface contains also various miscellaneous commonly-used utility methods, such as matrix operations and the ability to control the time of redraw on visual rendering devices.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSVGElement)
*/

тип SVGSVGElement = интерфейс
{
  currentScale: Число

  защищено 
  currentTranslate: DOMPointReadOnly

  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция animationsPaused(): ДаНет

  операция checkEnclosure(element: SVGElement, rect: DOMRectReadOnly): ДаНет

  операция checkIntersection(element: SVGElement, rect: DOMRectReadOnly): ДаНет

  операция createSVGAngle(): SVGAngle

  операция createSVGLength(): SVGLength

  операция createSVGMatrix(): DOMMatrix

  операция createSVGNumber(): SVGNumber

  операция createSVGPoint(): DOMPoint

  операция createSVGRect(): DOMRect

  операция createSVGTransform(): SVGTransform

  операция createSVGTransformFromMatrix(matrix: DOMMatrix2DInit?FUCKFUCK = пусто): SVGTransform

  операция deselectAll()

  операция forceRedraw()

  операция getCurrentTime(): Число

  операция getElementById(elementId: Текст): Element

  операция getEnclosureList(rect: DOMRectReadOnly, referenceElement: SVGElement?FUCKFUCK): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>

  операция getIntersectionList(rect: DOMRectReadOnly, referenceElement: SVGElement?FUCKFUCK): NodeListOf<SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement>

  операция pauseAnimations()

  операция setCurrentTime(seconds: Число)

  операция suspendRedraw(maxWaitMilliseconds: Число): Число

  операция unpauseAnimations()

  операция unsuspendRedraw(suspendHandleID: Число)

  операция unsuspendRedrawAll()

  операция addEventListener<K = /*(!) keyof SVGSVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSVGElement, ev: /*(!) SVGSVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGSVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSVGElement, ev: /*(!) SVGSVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGSVGElement: объект { prototype: SVGSVGElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the SVG <script> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGScriptElement)
*/

тип SVGScriptElement = интерфейс
{
  type: Текст

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGScriptElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGScriptElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGScriptElement: объект { prototype: SVGScriptElement; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSetElement) */

тип SVGSetElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGSetElement: объект { prototype: SVGSetElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <stop> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStopElement)
*/

тип SVGStopElement = интерфейс
{
  защищено 
  offset: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGStopElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGStopElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGStopElement: объект { prototype: SVGStopElement; при создании()/*(!) no_type */ Объект? }


/**
* The SVGStringList defines a list of DOMString objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStringList)
*/

тип SVGStringList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: Текст): Текст

  операция clear()

  операция getItem(index: Число): Текст

  операция initialize(newItem: Текст): Текст

  операция insertItemBefore(newItem: Текст, index: Число): Текст

  операция removeItem(index: Число): Текст

  операция replaceItem(newItem: Текст, index: Число): Текст

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ SVGStringList: объект { prototype: SVGStringList; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the SVG <style> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStyleElement)
*/

тип SVGStyleElement = интерфейс
{
  disabled: ДаНет

  media: Текст

  title: Текст

  type: Текст

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGStyleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGStyleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGStyleElement: объект { prototype: SVGStyleElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <switch> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSwitchElement)
*/

тип SVGSwitchElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSwitchElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSwitchElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGSwitchElement: объект { prototype: SVGSwitchElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <symbol> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSymbolElement)
*/

тип SVGSymbolElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSymbolElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGSymbolElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGSymbolElement: объект { prototype: SVGSymbolElement; при создании()/*(!) no_type */ Объект? }


/**
* A <tspan> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTSpanElement)
*/

тип SVGTSpanElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTSpanElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTSpanElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTSpanElement: объект { prototype: SVGTSpanElement; при создании()/*(!) no_type */ Объект? }


тип SVGTests = интерфейс
{
  защищено 
  requiredExtensions: SVGStringList

  защищено 
  systemLanguage: SVGStringList
}


/**
* Implemented by elements that support rendering child text content. It is inherited by various text-related interfaces, such as SVGTextElement, SVGTSpanElement, SVGTRefElement, SVGAltGlyphElement and SVGTextPathElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextContentElement)
*/

тип SVGTextContentElement = интерфейс
{
  защищено 
  lengthAdjust: SVGAnimatedEnumeration

  защищено 
  textLength: SVGAnimatedLength

  операция getCharNumAtPosition(point: DOMPointInit?FUCKFUCK = пусто): Число

  операция getComputedTextLength(): Число

  операция getEndPositionOfChar(charnum: Число): DOMPoint

  операция getExtentOfChar(charnum: Число): DOMRect

  операция getNumberOfChars(): Число

  операция getRotationOfChar(charnum: Число): Число

  операция getStartPositionOfChar(charnum: Число): DOMPoint

  операция getSubStringLength(charnum: Число, nchars: Число): Число

  операция selectSubString(charnum: Число, nchars: Число)

  защищено 
  LENGTHADJUST_UNKNOWN: 0

  защищено 
  LENGTHADJUST_SPACING: 1

  защищено 
  LENGTHADJUST_SPACINGANDGLYPHS: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextContentElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextContentElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTextContentElement: объект { prototype: SVGTextContentElement; при создании()/*(!) no_type */ Объект?; защищено  LENGTHADJUST_UNKNOWN: 0; защищено  LENGTHADJUST_SPACING: 1; защищено  LENGTHADJUST_SPACINGANDGLYPHS: 2 }


/**
* Corresponds to the <text> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextElement)
*/

тип SVGTextElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTextElement: объект { prototype: SVGTextElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <textPath> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextPathElement)
*/

тип SVGTextPathElement = интерфейс
{
  защищено 
  method: SVGAnimatedEnumeration

  защищено 
  spacing: SVGAnimatedEnumeration

  защищено 
  startOffset: SVGAnimatedLength

  защищено 
  TEXTPATH_METHODTYPE_UNKNOWN: 0

  защищено 
  TEXTPATH_METHODTYPE_ALIGN: 1

  защищено 
  TEXTPATH_METHODTYPE_STRETCH: 2

  защищено 
  TEXTPATH_SPACINGTYPE_UNKNOWN: 0

  защищено 
  TEXTPATH_SPACINGTYPE_AUTO: 1

  защищено 
  TEXTPATH_SPACINGTYPE_EXACT: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTextPathElement: объект { prototype: SVGTextPathElement; при создании()/*(!) no_type */ Объект?; защищено  TEXTPATH_METHODTYPE_UNKNOWN: 0; защищено  TEXTPATH_METHODTYPE_ALIGN: 1; защищено  TEXTPATH_METHODTYPE_STRETCH: 2; защищено  TEXTPATH_SPACINGTYPE_UNKNOWN: 0; защищено  TEXTPATH_SPACINGTYPE_AUTO: 1; защищено  TEXTPATH_SPACINGTYPE_EXACT: 2 }


/**
* Implemented by elements that support attributes that position individual text glyphs. It is inherited by SVGTextElement, SVGTSpanElement, SVGTRefElement and SVGAltGlyphElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextPositioningElement)
*/

тип SVGTextPositioningElement = интерфейс
{
  защищено 
  dx: SVGAnimatedLengthList

  защищено 
  dy: SVGAnimatedLengthList

  защищено 
  rotate: SVGAnimatedNumberList

  защищено 
  x: SVGAnimatedLengthList

  защищено 
  y: SVGAnimatedLengthList

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextPositioningElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTextPositioningElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTextPositioningElement: объект { prototype: SVGTextPositioningElement; при создании()/*(!) no_type */ Объект? }


/**
* Corresponds to the <title> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTitleElement)
*/

тип SVGTitleElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTitleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGTitleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGTitleElement: объект { prototype: SVGTitleElement; при создании()/*(!) no_type */ Объект? }


/**
* SVGTransform is the interface for one of the component transformations within an SVGTransformList; thus, an SVGTransform object corresponds to a single component (e.g., scale(…) or matrix(…)) within a transform attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTransform)
*/

тип SVGTransform = интерфейс
{
  защищено 
  angle: Число

  защищено 
  matrix: DOMMatrix

  защищено 
  type: Число

  операция setMatrix(matrix: DOMMatrix2DInit?FUCKFUCK = пусто)

  операция setRotate(angle: Число, cx: Число, cy: Число)

  операция setScale(sx: Число, sy: Число)

  операция setSkewX(angle: Число)

  операция setSkewY(angle: Число)

  операция setTranslate(tx: Число, ty: Число)

  защищено 
  SVG_TRANSFORM_UNKNOWN: 0

  защищено 
  SVG_TRANSFORM_MATRIX: 1

  защищено 
  SVG_TRANSFORM_TRANSLATE: 2

  защищено 
  SVG_TRANSFORM_SCALE: 3

  защищено 
  SVG_TRANSFORM_ROTATE: 4

  защищено 
  SVG_TRANSFORM_SKEWX: 5

  защищено 
  SVG_TRANSFORM_SKEWY: 6
}


внешнее
/*(!) var */ SVGTransform: объект { prototype: SVGTransform; при создании()/*(!) no_type */ Объект?; защищено  SVG_TRANSFORM_UNKNOWN: 0; защищено  SVG_TRANSFORM_MATRIX: 1; защищено  SVG_TRANSFORM_TRANSLATE: 2; защищено  SVG_TRANSFORM_SCALE: 3; защищено  SVG_TRANSFORM_ROTATE: 4; защищено  SVG_TRANSFORM_SKEWX: 5; защищено  SVG_TRANSFORM_SKEWY: 6 }


/**
* The SVGTransformList defines a list of SVGTransform objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTransformList)
*/

тип SVGTransformList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGTransform): SVGTransform

  операция clear()

  операция consolidate(): SVGTransform?FUCKFUCK

  операция createSVGTransformFromMatrix(matrix: DOMMatrix2DInit?FUCKFUCK = пусто): SVGTransform

  операция getItem(index: Число): SVGTransform

  операция initialize(newItem: SVGTransform): SVGTransform

  операция insertItemBefore(newItem: SVGTransform, index: Число): SVGTransform

  операция removeItem(index: Число): SVGTransform

  операция replaceItem(newItem: SVGTransform, index: Число): SVGTransform

  /*(!) [index: number]: SVGTransform*/
}


внешнее
/*(!) var */ SVGTransformList: объект { prototype: SVGTransformList; при создании()/*(!) no_type */ Объект? }


тип SVGURIReference = интерфейс
{
  защищено 
  href: SVGAnimatedString
}


/**
* A commonly used set of constants used for reflecting gradientUnits, patternContentUnits and other similar attributes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGUnitTypes)
*/

тип SVGUnitTypes = интерфейс
{
  защищено 
  SVG_UNIT_TYPE_UNKNOWN: 0

  защищено 
  SVG_UNIT_TYPE_USERSPACEONUSE: 1

  защищено 
  SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2
}


внешнее
/*(!) var */ SVGUnitTypes: объект { prototype: SVGUnitTypes; при создании()/*(!) no_type */ Объект?; защищено  SVG_UNIT_TYPE_UNKNOWN: 0; защищено  SVG_UNIT_TYPE_USERSPACEONUSE: 1; защищено  SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2 }


/**
* Corresponds to the <use> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGUseElement)
*/

тип SVGUseElement = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGUseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGUseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGUseElement: объект { prototype: SVGUseElement; при создании()/*(!) no_type */ Объект? }


/**
* Provides access to the properties of <view> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGViewElement)
*/

тип SVGViewElement = интерфейс
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGViewElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type: K, listener: операция(this: SVGViewElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SVGViewElement: объект { prototype: SVGViewElement; при создании()/*(!) no_type */ Объект? }


/**
* A screen, usually the one on which the current window is being rendered, and is obtained using window.screen.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Screen)
*/

тип Screen = интерфейс
{
  защищено 
  availHeight: Число

  защищено 
  availWidth: Число

  защищено 
  colorDepth: Число

  защищено 
  height: Число

  защищено 
  orientation: ScreenOrientation

  защищено 
  pixelDepth: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ Screen: объект { prototype: Screen; при создании()/*(!) no_type */ Объект? }


тип ScreenOrientationEventMap = интерфейс
{
  "change": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ScreenOrientation) */

тип ScreenOrientation = интерфейс
{
  защищено 
  angle: Число

  onchange: операция(this: ScreenOrientation, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  type: OrientationType

  операция unlock()

  операция addEventListener<K = /*(!) keyof ScreenOrientationEventMap */ Объект?>(type: K, listener: операция(this: ScreenOrientation, ev: /*(!) ScreenOrientationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ScreenOrientationEventMap */ Объект?>(type: K, listener: операция(this: ScreenOrientation, ev: /*(!) ScreenOrientationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ScreenOrientation: объект { prototype: ScreenOrientation; при создании()/*(!) no_type */ Объект? }


тип ScriptProcessorNodeEventMap = интерфейс
{
  "audioprocess": AudioProcessingEvent
}


/**
* Allows the generation, processing, or analyzing of audio using JavaScript.
* @deprecated As of the August 29 2014 Web Audio API spec publication, this feature has been marked as deprecated, and was replaced by AudioWorklet (see AudioWorkletNode).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ScriptProcessorNode)
*/

тип ScriptProcessorNode = интерфейс
{
  защищено 
  bufferSize: Число

  onaudioprocess: операция(this: ScriptProcessorNode, ev: AudioProcessingEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof ScriptProcessorNodeEventMap */ Объект?>(type: K, listener: операция(this: ScriptProcessorNode, ev: /*(!) ScriptProcessorNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ScriptProcessorNodeEventMap */ Объект?>(type: K, listener: операция(this: ScriptProcessorNode, ev: /*(!) ScriptProcessorNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


/** @deprecated */

внешнее
/*(!) var */ ScriptProcessorNode: объект { prototype: ScriptProcessorNode; при создании()/*(!) no_type */ Объект? }


/**
* Inherits from Event, and represents the event object of an event sent on a document or worker when its content security policy is violated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SecurityPolicyViolationEvent)
*/

тип SecurityPolicyViolationEvent = интерфейс
{
  защищено 
  blockedURI: Текст

  защищено 
  columnNumber: Число

  защищено 
  disposition: SecurityPolicyViolationEventDisposition

  защищено 
  documentURI: Текст

  защищено 
  effectiveDirective: Текст

  защищено 
  lineNumber: Число

  защищено 
  originalPolicy: Текст

  защищено 
  referrer: Текст

  защищено 
  sample: Текст

  защищено 
  sourceFile: Текст

  защищено 
  statusCode: Число

  защищено 
  violatedDirective: Текст
}


внешнее
/*(!) var */ SecurityPolicyViolationEvent: объект { prototype: SecurityPolicyViolationEvent; при создании(type: Текст, eventInitDict: SecurityPolicyViolationEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A Selection object represents the range of text selected by the user or the current position of the caret. To obtain a Selection object for examination or modification, call Window.getSelection().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Selection)
*/

тип Selection = интерфейс
{
  защищено 
  anchorNode: Node?FUCKFUCK

  защищено 
  anchorOffset: Число

  защищено 
  focusNode: Node?FUCKFUCK

  защищено 
  focusOffset: Число

  защищено 
  isCollapsed: ДаНет

  защищено 
  rangeCount: Число

  защищено 
  type: Текст

  операция addRange(range: Range)

  операция collapse(node: Node?FUCKFUCK, offset: Число?FUCKFUCK = пусто)

  операция collapseToEnd()

  операция collapseToStart()

  операция containsNode(node: Node, allowPartialContainment: ДаНет?FUCKFUCK = пусто): ДаНет

  операция deleteFromDocument()

  операция empty()

  операция extend(node: Node, offset: Число?FUCKFUCK = пусто)

  операция getRangeAt(index: Число): Range

  операция modify(alter: Текст?FUCKFUCK = пусто, direction: Текст?FUCKFUCK = пусто, granularity: Текст?FUCKFUCK = пусто)

  операция removeAllRanges()

  операция removeRange(range: Range)

  операция selectAllChildren(node: Node)

  операция setBaseAndExtent(anchorNode: Node, anchorOffset: Число, focusNode: Node, focusOffset: Число)

  операция setPosition(node: Node?FUCKFUCK, offset: Число?FUCKFUCK = пусто)

  операция toString(): Текст
}


внешнее
/*(!) var */ Selection: объект { prototype: Selection; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerEventMap = интерфейс
{
  "statechange": Event
}


/**
* This ServiceWorker API interface provides a reference to a service worker. Multiple browsing contexts (e.g. pages, workers, etc.) can be associated with the same service worker, each through a unique ServiceWorker object.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorker)
*/

тип ServiceWorker = интерфейс
{
  onstatechange: операция(this: ServiceWorker, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  scriptURL: Текст

  защищено 
  state: ServiceWorkerState

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция addEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorker: объект { prototype: ServiceWorker; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerContainerEventMap = интерфейс
{
  "controllerchange": Event

  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* The ServiceWorkerContainer interface of the ServiceWorker API provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister and update service workers, and access the state of service workers and their registrations.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerContainer)
*/

тип ServiceWorkerContainer = интерфейс
{
  защищено 
  controller: ServiceWorker?FUCKFUCK

  oncontrollerchange: операция(this: ServiceWorkerContainer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  защищено 
  ready: Promise<ServiceWorkerRegistration>

  операция getRegistration(clientURL: Текст | URL | пусто = пусто): Promise<ServiceWorkerRegistration?FUCKFUCK>

  операция getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>

  операция register(scriptURL: Текст | URL, options: RegistrationOptions?FUCKFUCK = пусто): Promise<ServiceWorkerRegistration>

  операция startMessages()

  операция addEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorkerContainer: объект { prototype: ServiceWorkerContainer; при создании()/*(!) no_type */ Объект? }


тип ServiceWorkerRegistrationEventMap = интерфейс
{
  "updatefound": Event
}


/**
* This ServiceWorker API interface represents the service worker registration. You register a service worker to control one or more pages that share the same origin.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration)
*/

тип ServiceWorkerRegistration = интерфейс
{
  защищено 
  active: ServiceWorker?FUCKFUCK

  защищено 
  installing: ServiceWorker?FUCKFUCK

  защищено 
  navigationPreload: NavigationPreloadManager

  onupdatefound: операция(this: ServiceWorkerRegistration, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  pushManager: PushManager

  защищено 
  scope: Текст

  защищено 
  updateViaCache: ServiceWorkerUpdateViaCache

  защищено 
  waiting: ServiceWorker?FUCKFUCK

  операция getNotifications(filter: GetNotificationOptions?FUCKFUCK = пусто): Promise<Список<Notification>>

  операция showNotification(title: Текст, options: NotificationOptions?FUCKFUCK = пусто): Promise<Ничего>

  операция unregister(): Promise<ДаНет>

  операция update(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ServiceWorkerRegistration: объект { prototype: ServiceWorkerRegistration; при создании()/*(!) no_type */ Объект? }


тип ShadowRootEventMap = интерфейс
{
  "slotchange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ShadowRoot) */

тип ShadowRoot = интерфейс
{
  защищено 
  delegatesFocus: ДаНет

  защищено 
  host: Element

  защищено 
  mode: ShadowRootMode

  onslotchange: операция(this: ShadowRoot, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  slotAssignment: SlotAssignmentMode

  операция addEventListener<K = /*(!) keyof ShadowRootEventMap */ Объект?>(type: K, listener: операция(this: ShadowRoot, ev: /*(!) ShadowRootEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof ShadowRootEventMap */ Объект?>(type: K, listener: операция(this: ShadowRoot, ev: /*(!) ShadowRootEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ ShadowRoot: объект { prototype: ShadowRoot; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SharedWorker) */

тип SharedWorker = интерфейс
{
  защищено 
  port: MessagePort

  операция addEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: SharedWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type: K, listener: операция(this: SharedWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SharedWorker: объект { prototype: SharedWorker; при создании(scriptURL: Текст | URL, options: Текст | WorkerOptions | пусто = пусто)/*(!) no_type */ Объект? }


тип Slottable = интерфейс
{
  защищено 
  assignedSlot: HTMLSlotElement?FUCKFUCK
}


тип SourceBufferEventMap = интерфейс
{
  "abort": Event

  "error": Event

  "update": Event

  "updateend": Event

  "updatestart": Event
}


/**
* A chunk of media to be passed into an HTMLMediaElement and played, via a MediaSource object. This can be made up of one or several media segments.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SourceBuffer)
*/

тип SourceBuffer = интерфейс
{
  appendWindowEnd: Число

  appendWindowStart: Число

  защищено 
  buffered: TimeRanges

  mode: AppendMode

  onabort: операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onupdate: операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onupdateend: операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onupdatestart: операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект??FUCKFUCK

  timestampOffset: Число

  защищено 
  updating: ДаНет

  операция abort()

  операция appendBuffer(data: BufferSource)

  операция changeType(type: Текст)

  операция remove(start: Число, end: Число)

  операция addEventListener<K = /*(!) keyof SourceBufferEventMap */ Объект?>(type: K, listener: операция(this: SourceBuffer, ev: /*(!) SourceBufferEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SourceBufferEventMap */ Объект?>(type: K, listener: операция(this: SourceBuffer, ev: /*(!) SourceBufferEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SourceBuffer: объект { prototype: SourceBuffer; при создании()/*(!) no_type */ Объект? }


тип SourceBufferListEventMap = интерфейс
{
  "addsourcebuffer": Event

  "removesourcebuffer": Event
}


/**
* A simple container list for multiple SourceBuffer objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SourceBufferList)
*/

тип SourceBufferList = интерфейс
{
  защищено 
  length: Число

  onaddsourcebuffer: операция(this: SourceBufferList, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onremovesourcebuffer: операция(this: SourceBufferList, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof SourceBufferListEventMap */ Объект?>(type: K, listener: операция(this: SourceBufferList, ev: /*(!) SourceBufferListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SourceBufferListEventMap */ Объект?>(type: K, listener: операция(this: SourceBufferList, ev: /*(!) SourceBufferListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

  /*(!) [index: number]: SourceBuffer*/
}


внешнее
/*(!) var */ SourceBufferList: объект { prototype: SourceBufferList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionAlternative) */

тип SpeechRecognitionAlternative = интерфейс
{
  защищено 
  confidence: Число

  защищено 
  transcript: Текст
}


внешнее
/*(!) var */ SpeechRecognitionAlternative: объект { prototype: SpeechRecognitionAlternative; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionResult) */

тип SpeechRecognitionResult = интерфейс
{
  защищено 
  isFinal: ДаНет

  защищено 
  length: Число

  операция item(index: Число): SpeechRecognitionAlternative

  /*(!) [index: number]: SpeechRecognitionAlternative*/
}


внешнее
/*(!) var */ SpeechRecognitionResult: объект { prototype: SpeechRecognitionResult; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionResultList) */

тип SpeechRecognitionResultList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): SpeechRecognitionResult

  /*(!) [index: number]: SpeechRecognitionResult*/
}


внешнее
/*(!) var */ SpeechRecognitionResultList: объект { prototype: SpeechRecognitionResultList; при создании()/*(!) no_type */ Объект? }


тип SpeechSynthesisEventMap = интерфейс
{
  "voiceschanged": Event
}


/**
* This Web Speech API interface is the controller interface for the speech service; this can be used to retrieve information about the synthesis voices available on the device, start and pause speech, and other commands besides.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesis)
*/

тип SpeechSynthesis = интерфейс
{
  onvoiceschanged: операция(this: SpeechSynthesis, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  paused: ДаНет

  защищено 
  pending: ДаНет

  защищено 
  speaking: ДаНет

  операция cancel()

  операция getVoices(): Список<SpeechSynthesisVoice>

  операция pause()

  операция resume()

  операция speak(utterance: SpeechSynthesisUtterance)

  операция addEventListener<K = /*(!) keyof SpeechSynthesisEventMap */ Объект?>(type: K, listener: операция(this: SpeechSynthesis, ev: /*(!) SpeechSynthesisEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SpeechSynthesisEventMap */ Объект?>(type: K, listener: операция(this: SpeechSynthesis, ev: /*(!) SpeechSynthesisEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SpeechSynthesis: объект { prototype: SpeechSynthesis; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisErrorEvent) */

тип SpeechSynthesisErrorEvent = интерфейс
{
  защищено 
  error: SpeechSynthesisErrorCode
}


внешнее
/*(!) var */ SpeechSynthesisErrorEvent: объект { prototype: SpeechSynthesisErrorEvent; при создании(type: Текст, eventInitDict: SpeechSynthesisErrorEventInit)/*(!) no_type */ Объект? }


/**
* This Web Speech API interface contains information about the current state of SpeechSynthesisUtterance objects that have been processed in the speech service.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisEvent)
*/

тип SpeechSynthesisEvent = интерфейс
{
  защищено 
  charIndex: Число

  защищено 
  charLength: Число

  защищено 
  elapsedTime: Число

  защищено 
  name: Текст

  защищено 
  utterance: SpeechSynthesisUtterance
}


внешнее
/*(!) var */ SpeechSynthesisEvent: объект { prototype: SpeechSynthesisEvent; при создании(type: Текст, eventInitDict: SpeechSynthesisEventInit)/*(!) no_type */ Объект? }


тип SpeechSynthesisUtteranceEventMap = интерфейс
{
  "boundary": SpeechSynthesisEvent

  "end": SpeechSynthesisEvent

  "error": SpeechSynthesisErrorEvent

  "mark": SpeechSynthesisEvent

  "pause": SpeechSynthesisEvent

  "resume": SpeechSynthesisEvent

  "start": SpeechSynthesisEvent
}


/**
* This Web Speech API interface represents a speech request. It contains the content the speech service should read and information about how to read it (e.g. language, pitch and volume.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisUtterance)
*/

тип SpeechSynthesisUtterance = интерфейс
{
  lang: Текст

  onboundary: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  onend: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisErrorEvent): /*(!) any */ Объект??FUCKFUCK

  onmark: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  onpause: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  onresume: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  onstart: операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект??FUCKFUCK

  pitch: Число

  rate: Число

  text: Текст

  voice: SpeechSynthesisVoice?FUCKFUCK

  volume: Число

  операция addEventListener<K = /*(!) keyof SpeechSynthesisUtteranceEventMap */ Объект?>(type: K, listener: операция(this: SpeechSynthesisUtterance, ev: /*(!) SpeechSynthesisUtteranceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof SpeechSynthesisUtteranceEventMap */ Объект?>(type: K, listener: операция(this: SpeechSynthesisUtterance, ev: /*(!) SpeechSynthesisUtteranceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ SpeechSynthesisUtterance: объект { prototype: SpeechSynthesisUtterance; при создании(text: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Web Speech API interface represents a voice that the system supports. Every SpeechSynthesisVoice has its own relative speech service including information about language, name and URI.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisVoice)
*/

тип SpeechSynthesisVoice = интерфейс
{
  защищено 
  default: ДаНет

  защищено 
  lang: Текст

  защищено 
  localService: ДаНет

  защищено 
  name: Текст

  защищено 
  voiceURI: Текст
}


внешнее
/*(!) var */ SpeechSynthesisVoice: объект { prototype: SpeechSynthesisVoice; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StaticRange) */

тип StaticRange = интерфейс
{

}


внешнее
/*(!) var */ StaticRange: объект { prototype: StaticRange; при создании(init: StaticRangeInit)/*(!) no_type */ Объект? }


/**
* The pan property takes a unitless value between -1 (full left pan) and 1 (full right pan). This interface was introduced as a much simpler way to apply a simple panning effect than having to use a full PannerNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StereoPannerNode)
*/

тип StereoPannerNode = интерфейс
{
  защищено 
  pan: AudioParam
}


внешнее
/*(!) var */ StereoPannerNode: объект { prototype: StereoPannerNode; при создании(context: BaseAudioContext, options: StereoPannerOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Web Storage API interface provides access to a particular domain's session or local storage. It allows, for example, the addition, modification, or deletion of stored data items.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage)
*/

тип Storage = интерфейс
{
  защищено 
  length: Число

  операция clear()

  операция getItem(key: Текст): Текст?FUCKFUCK

  операция key(index: Число): Текст?FUCKFUCK

  операция removeItem(key: Текст)

  операция setItem(key: Текст, value: Текст)

  /*(!) [name: string]: any*/
}


внешнее
/*(!) var */ Storage: объект { prototype: Storage; при создании()/*(!) no_type */ Объект? }


/**
* A StorageEvent is sent to a window when a storage area it has access to is changed within the context of another document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StorageEvent)
*/

тип StorageEvent = интерфейс
{
  защищено 
  key: Текст?FUCKFUCK

  защищено 
  newValue: Текст?FUCKFUCK

  защищено 
  oldValue: Текст?FUCKFUCK

  защищено 
  storageArea: Storage?FUCKFUCK

  защищено 
  url: Текст

  операция initStorageEvent(type: Текст, bubbles: ДаНет?FUCKFUCK = пусто, cancelable: ДаНет?FUCKFUCK = пусто, key: Текст?FUCKFUCK = пусто, oldValue: Текст?FUCKFUCK = пусто, newValue: Текст?FUCKFUCK = пусто, url: Текст | URL | пусто = пусто, storageArea: Storage?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ StorageEvent: объект { prototype: StorageEvent; при создании(type: Текст, eventInitDict: StorageEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StorageManager)
*/

тип StorageManager = интерфейс
{
  операция estimate(): Promise<StorageEstimate>

  операция getDirectory(): Promise<FileSystemDirectoryHandle>

  операция persist(): Promise<ДаНет>

  операция persisted(): Promise<ДаНет>
}


внешнее
/*(!) var */ StorageManager: объект { prototype: StorageManager; при создании()/*(!) no_type */ Объект? }


/** @deprecated */

тип StyleMedia = интерфейс
{
  type: Текст

  операция matchMedium(mediaquery: Текст): ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StylePropertyMap) */

тип StylePropertyMap = интерфейс
{
  #js.МассивПараметров
  операция append(property: Текст, values: Список<CSSStyleValue | Текст>)

  операция clear()

  операция delete(property: Текст)

  #js.МассивПараметров
  операция set(property: Текст, values: Список<CSSStyleValue | Текст>)
}


внешнее
/*(!) var */ StylePropertyMap: объект { prototype: StylePropertyMap; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StylePropertyMapReadOnly) */

тип StylePropertyMapReadOnly = интерфейс
{
  защищено 
  size: Число

  операция get(property: Текст): CSSStyleValue?FUCKFUCK

  операция getAll(property: Текст): Список<CSSStyleValue>

  операция has(property: Текст): ДаНет

  операция forEach(callbackfn: операция(value: Список<CSSStyleValue>, key: Текст, parent: StylePropertyMapReadOnly), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ StylePropertyMapReadOnly: объект { prototype: StylePropertyMapReadOnly; при создании()/*(!) no_type */ Объект? }


/**
* A single style sheet. CSS style sheets will further implement the more specialized CSSStyleSheet interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StyleSheet)
*/

тип StyleSheet = интерфейс
{
  disabled: ДаНет

  защищено 
  href: Текст?FUCKFUCK

  защищено 
  media: MediaList

  защищено 
  ownerNode: Element | ProcessingInstruction | пусто

  защищено 
  parentStyleSheet: CSSStyleSheet?FUCKFUCK

  защищено 
  title: Текст?FUCKFUCK

  защищено 
  type: Текст
}


внешнее
/*(!) var */ StyleSheet: объект { prototype: StyleSheet; при создании()/*(!) no_type */ Объект? }


/**
* A list of StyleSheet.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StyleSheetList)
*/

тип StyleSheetList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): CSSStyleSheet?FUCKFUCK

  /*(!) [index: number]: CSSStyleSheet*/
}


внешнее
/*(!) var */ StyleSheetList: объект { prototype: StyleSheetList; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubmitEvent) */

тип SubmitEvent = интерфейс
{
  защищено 
  submitter: HTMLElement?FUCKFUCK
}


внешнее
/*(!) var */ SubmitEvent: объект { prototype: SubmitEvent; при создании(type: Текст, eventInitDict: SubmitEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)
*/

тип SubtleCrypto = интерфейс
{
  операция decrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция deriveBits(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, length: Число): Promise<ArrayBuffer>

  операция deriveKey(algorithm: AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params, baseKey: CryptoKey, derivedKeyType: AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>

  операция encrypt(algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>

  операция exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>

  операция exportKey(format: KeyFormat, key: CryptoKey): Promise<ArrayBuffer | JsonWebKey>

  операция generateKey(algorithm: "Ed25519", extractable: ДаНет, keyUsages: ReadonlyArray<"sign" | "verify">): Promise<CryptoKeyPair>

  операция generateKey(algorithm: RsaHashedKeyGenParams | EcKeyGenParams, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>

  операция generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция generateKey(algorithm: AlgorithmIdentifier, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKeyPair | CryptoKey>

  операция importKey(format: "jwk", keyData: JsonWebKey, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция importKey(format: Exclude<KeyFormat, "jwk">, keyData: BufferSource, algorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция sign(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams, unwrappedKeyAlgorithm: AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция verify(algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<ДаНет>

  операция wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams): Promise<ArrayBuffer>
}


внешнее
/*(!) var */ SubtleCrypto: объект { prototype: SubtleCrypto; при создании()/*(!) no_type */ Объект? }


/**
* The textual content of Element or Attr. If an element has no markup within its content, it has a single child implementing Text that contains the element's text. However, if the element contains markup, it is parsed into information items and Text nodes that form its children.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Text)
*/

тип Text = интерфейс
{
  защищено 
  wholeText: Текст

  операция splitText(offset: Число): Text
}


внешнее
/*(!) var */ Text: объект { prototype: Text; при создании(data: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)
*/

тип TextDecoder = интерфейс
{
  операция decode(input: AllowSharedBufferSource?FUCKFUCK = пусто, options: TextDecodeOptions?FUCKFUCK = пусто): Текст
}


внешнее
/*(!) var */ TextDecoder: объект { prototype: TextDecoder; при создании(label: Текст?FUCKFUCK = пусто, options: TextDecoderOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип TextDecoderCommon = интерфейс
{
  защищено 
  encoding: Текст

  защищено 
  fatal: ДаНет

  защищено 
  ignoreBOM: ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */

тип TextDecoderStream = интерфейс
{
  защищено 
  readable: ReadableStream<Текст>

  защищено 
  writable: WritableStream<BufferSource>
}


внешнее
/*(!) var */ TextDecoderStream: объект { prototype: TextDecoderStream; при создании(label: Текст?FUCKFUCK = пусто, options: TextDecoderOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)
*/

тип TextEncoder = интерфейс
{
  операция encode(input: Текст?FUCKFUCK = пусто): Uint8Array

  операция encodeInto(source: Текст, destination: Uint8Array): TextEncoderEncodeIntoResult
}


внешнее
/*(!) var */ TextEncoder: объект { prototype: TextEncoder; при создании()/*(!) no_type */ Объект? }


тип TextEncoderCommon = интерфейс
{
  защищено 
  encoding: Текст
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */

тип TextEncoderStream = интерфейс
{
  защищено 
  readable: ReadableStream<Uint8Array>

  защищено 
  writable: WritableStream<Текст>
}


внешнее
/*(!) var */ TextEncoderStream: объект { prototype: TextEncoderStream; при создании()/*(!) no_type */ Объект? }


/**
* The dimensions of a piece of text in the canvas, as created by the CanvasRenderingContext2D.measureText() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextMetrics)
*/

тип TextMetrics = интерфейс
{
  защищено 
  actualBoundingBoxAscent: Число

  защищено 
  actualBoundingBoxDescent: Число

  защищено 
  actualBoundingBoxLeft: Число

  защищено 
  actualBoundingBoxRight: Число

  защищено 
  fontBoundingBoxAscent: Число

  защищено 
  fontBoundingBoxDescent: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ TextMetrics: объект { prototype: TextMetrics; при создании()/*(!) no_type */ Объект? }


тип TextTrackEventMap = интерфейс
{
  "cuechange": Event
}


/**
* This interface also inherits properties from EventTarget.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrack)
*/

тип TextTrack = интерфейс
{
  защищено 
  activeCues: TextTrackCueList?FUCKFUCK

  защищено 
  cues: TextTrackCueList?FUCKFUCK

  защищено 
  id: Текст

  защищено 
  inBandMetadataTrackDispatchType: Текст

  защищено 
  kind: TextTrackKind

  защищено 
  label: Текст

  защищено 
  language: Текст

  mode: TextTrackMode

  oncuechange: операция(this: TextTrack, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция addCue(cue: TextTrackCue)

  операция removeCue(cue: TextTrackCue)

  операция addEventListener<K = /*(!) keyof TextTrackEventMap */ Объект?>(type: K, listener: операция(this: TextTrack, ev: /*(!) TextTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackEventMap */ Объект?>(type: K, listener: операция(this: TextTrack, ev: /*(!) TextTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ TextTrack: объект { prototype: TextTrack; при создании()/*(!) no_type */ Объект? }


тип TextTrackCueEventMap = интерфейс
{
  "enter": Event

  "exit": Event
}


/**
* TextTrackCues represent a string of text that will be displayed for some duration of time on a TextTrack. This includes the start and end times that the cue will be displayed. A TextTrackCue cannot be used directly, instead one of the derived types (e.g. VTTCue) must be used.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackCue)
*/

тип TextTrackCue = интерфейс
{
  endTime: Число

  id: Текст

  onenter: операция(this: TextTrackCue, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onexit: операция(this: TextTrackCue, ev: Event): /*(!) any */ Объект??FUCKFUCK

  pauseOnExit: ДаНет

  startTime: Число

  защищено 
  track: TextTrack?FUCKFUCK

  операция addEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type: K, listener: операция(this: TextTrackCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type: K, listener: операция(this: TextTrackCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ TextTrackCue: объект { prototype: TextTrackCue; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackCueList) */

тип TextTrackCueList = интерфейс
{
  защищено 
  length: Число

  операция getCueById(id: Текст): TextTrackCue?FUCKFUCK

  /*(!) [index: number]: TextTrackCue*/
}


внешнее
/*(!) var */ TextTrackCueList: объект { prototype: TextTrackCueList; при создании()/*(!) no_type */ Объект? }


тип TextTrackListEventMap = интерфейс
{
  "addtrack": TrackEvent

  "change": Event

  "removetrack": TrackEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackList) */

тип TextTrackList = интерфейс
{
  защищено 
  length: Число

  onaddtrack: операция(this: TextTrackList, ev: TrackEvent): /*(!) any */ Объект??FUCKFUCK

  onchange: операция(this: TextTrackList, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onremovetrack: операция(this: TextTrackList, ev: TrackEvent): /*(!) any */ Объект??FUCKFUCK

  операция getTrackById(id: Текст): TextTrack?FUCKFUCK

  операция addEventListener<K = /*(!) keyof TextTrackListEventMap */ Объект?>(type: K, listener: операция(this: TextTrackList, ev: /*(!) TextTrackListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackListEventMap */ Объект?>(type: K, listener: операция(this: TextTrackList, ev: /*(!) TextTrackListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

  /*(!) [index: number]: TextTrack*/
}


внешнее
/*(!) var */ TextTrackList: объект { prototype: TextTrackList; при создании()/*(!) no_type */ Объект? }


/**
* Used to represent a set of time ranges, primarily for the purpose of tracking which portions of media have been buffered when loading it for use by the <audio> and <video> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TimeRanges)
*/

тип TimeRanges = интерфейс
{
  защищено 
  length: Число

  операция end(index: Число): Число

  операция start(index: Число): Число
}


внешнее
/*(!) var */ TimeRanges: объект { prototype: TimeRanges; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ToggleEvent) */

тип ToggleEvent = интерфейс
{
  защищено 
  newState: Текст

  защищено 
  oldState: Текст
}


внешнее
/*(!) var */ ToggleEvent: объект { prototype: ToggleEvent; при создании(type: Текст, eventInitDict: ToggleEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A single contact point on a touch-sensitive device. The contact point is commonly a finger or stylus and the device may be a touchscreen or trackpad.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Touch)
*/

тип Touch = интерфейс
{
  защищено 
  clientX: Число

  защищено 
  clientY: Число

  защищено 
  force: Число

  защищено 
  identifier: Число

  защищено 
  pageX: Число

  защищено 
  pageY: Число

  защищено 
  radiusX: Число

  защищено 
  radiusY: Число

  защищено 
  rotationAngle: Число

  защищено 
  screenX: Число

  защищено 
  screenY: Число

  защищено 
  target: EventTarget
}


внешнее
/*(!) var */ Touch: объект { prototype: Touch; при создании(touchInitDict: TouchInit)/*(!) no_type */ Объект? }


/**
* An event sent when the state of contacts with a touch-sensitive surface changes. This surface can be a touch screen or trackpad, for example. The event can describe one or more points of contact with the screen and includes support for detecting movement, addition and removal of contact points, and so forth.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TouchEvent)
*/

тип TouchEvent = интерфейс
{
  защищено 
  altKey: ДаНет

  защищено 
  changedTouches: TouchList

  защищено 
  ctrlKey: ДаНет

  защищено 
  metaKey: ДаНет

  защищено 
  shiftKey: ДаНет

  защищено 
  targetTouches: TouchList

  защищено 
  touches: TouchList
}


внешнее
/*(!) var */ TouchEvent: объект { prototype: TouchEvent; при создании(type: Текст, eventInitDict: TouchEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* A list of contact points on a touch surface. For example, if the user has three fingers on the touch surface (such as a screen or trackpad), the corresponding TouchList object would have one Touch object for each finger, for a total of three entries.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TouchList)
*/

тип TouchList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Touch?FUCKFUCK

  /*(!) [index: number]: Touch*/
}


внешнее
/*(!) var */ TouchList: объект { prototype: TouchList; при создании()/*(!) no_type */ Объект? }


/**
* The TrackEvent interface, part of the HTML DOM specification, is used for events which represent changes to the set of available tracks on an HTML media element; these events are addtrack and removetrack.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TrackEvent)
*/

тип TrackEvent = интерфейс
{
  защищено 
  track: TextTrack?FUCKFUCK
}


внешнее
/*(!) var */ TrackEvent: объект { prototype: TrackEvent; при создании(type: Текст, eventInitDict: TrackEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */

тип TransformStream<I, O> = интерфейс
{
  защищено 
  readable: ReadableStream<O>

  защищено 
  writable: WritableStream<I>
}


внешнее
/*(!) var */ TransformStream: объект { prototype: TransformStream; при создании(transformer: Transformer<I, O>?FUCKFUCK = пусто, writableStrategy: QueuingStrategy<I>?FUCKFUCK = пусто, readableStrategy: QueuingStrategy<O>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */

тип TransformStreamDefaultController<O> = интерфейс
{
  защищено 
  desiredSize: Число?FUCKFUCK

  операция enqueue(chunk: O?FUCKFUCK = пусто)

  операция error(reason: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция terminate()
}


внешнее
/*(!) var */ TransformStreamDefaultController: объект { prototype: TransformStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/**
* Events providing information related to transitions.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransitionEvent)
*/

тип TransitionEvent = интерфейс
{
  защищено 
  elapsedTime: Число

  защищено 
  propertyName: Текст

  защищено 
  pseudoElement: Текст
}


внешнее
/*(!) var */ TransitionEvent: объект { prototype: TransitionEvent; при создании(type: Текст, transitionEventInitDict: TransitionEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The nodes of a document subtree and a position within them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TreeWalker)
*/

тип TreeWalker = интерфейс
{
  currentNode: Node

  защищено 
  filter: NodeFilter?FUCKFUCK

  защищено 
  root: Node

  защищено 
  whatToShow: Число

  операция firstChild(): Node?FUCKFUCK

  операция lastChild(): Node?FUCKFUCK

  операция nextNode(): Node?FUCKFUCK

  операция nextSibling(): Node?FUCKFUCK

  операция parentNode(): Node?FUCKFUCK

  операция previousNode(): Node?FUCKFUCK

  операция previousSibling(): Node?FUCKFUCK
}


внешнее
/*(!) var */ TreeWalker: объект { prototype: TreeWalker; при создании()/*(!) no_type */ Объект? }


/**
* Simple user interface events.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/UIEvent)
*/

тип UIEvent = интерфейс
{
  защищено 
  detail: Число

  защищено 
  view: Window?FUCKFUCK

  защищено 
  which: Число

  операция initUIEvent(typeArg: Текст, bubblesArg: ДаНет?FUCKFUCK = пусто, cancelableArg: ДаНет?FUCKFUCK = пусто, viewArg: Window?FUCKFUCK = пусто, detailArg: Число?FUCKFUCK = пусто)
}


внешнее
/*(!) var */ UIEvent: объект { prototype: UIEvent; при создании(type: Текст, eventInitDict: UIEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* The URL interface represents an object providing static methods used for creating object URLs.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)
*/

тип URL = интерфейс
{
  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  password: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  защищено 
  searchParams: URLSearchParams

  username: Текст

  операция toJSON(): Текст
}


внешнее
/*(!) var */ URL: объект { prototype: URL; при создании(url: Текст | URL, base: Текст | URL | пусто = пусто)/*(!) no_type */ Объект?; операция canParse(url: Текст | URL, base: Текст?FUCKFUCK = пусто): ДаНет; операция createObjectURL(obj: Blob | MediaSource): Текст; операция revokeObjectURL(url: Текст) }


тип webkitURL = URL

внешнее
/*(!) var */ webkitURL: /*(!) typeof URL */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */

тип URLSearchParams = интерфейс
{
  защищено 
  size: Число

  операция append(name: Текст, value: Текст)

  операция delete(name: Текст, value: Текст?FUCKFUCK = пусто)

  операция get(name: Текст): Текст?FUCKFUCK

  операция getAll(name: Текст): Список<Текст>

  операция has(name: Текст, value: Текст?FUCKFUCK = пусто): ДаНет

  операция set(name: Текст, value: Текст)

  операция sort()

  операция toString(): Текст

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: URLSearchParams), thisArg: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ URLSearchParams: объект { prototype: URLSearchParams; при создании(init: Список<Список<Текст>> | Record<Текст, Текст> | Текст | URLSearchParams | пусто = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/UserActivation) */

тип UserActivation = интерфейс
{
  защищено 
  hasBeenActive: ДаНет

  защищено 
  isActive: ДаНет
}


внешнее
/*(!) var */ UserActivation: объект { prototype: UserActivation; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VTTCue) */

тип VTTCue = интерфейс
{
  align: AlignSetting

  line: LineAndPositionSetting

  lineAlign: LineAlignSetting

  position: LineAndPositionSetting

  positionAlign: PositionAlignSetting

  region: VTTRegion?FUCKFUCK

  size: Число

  snapToLines: ДаНет

  text: Текст

  vertical: DirectionSetting

  операция getCueAsHTML(): DocumentFragment

  операция addEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type: K, listener: операция(this: VTTCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type: K, listener: операция(this: VTTCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VTTCue: объект { prototype: VTTCue; при создании(startTime: Число, endTime: Число, text: Текст)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VTTRegion) */

тип VTTRegion = интерфейс
{
  id: Текст

  lines: Число

  regionAnchorX: Число

  regionAnchorY: Число

  scroll: ScrollSetting

  viewportAnchorX: Число

  viewportAnchorY: Число

  width: Число
}


внешнее
/*(!) var */ VTTRegion: объект { prototype: VTTRegion; при создании()/*(!) no_type */ Объект? }


/**
* The validity states that an element can be in, with respect to constraint validation. Together, they help explain why an element's value fails to validate, if it's not valid.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ValidityState)
*/

тип ValidityState = интерфейс
{
  защищено 
  badInput: ДаНет

  защищено 
  customError: ДаНет

  защищено 
  patternMismatch: ДаНет

  защищено 
  rangeOverflow: ДаНет

  защищено 
  rangeUnderflow: ДаНет

  защищено 
  stepMismatch: ДаНет

  защищено 
  tooLong: ДаНет

  защищено 
  tooShort: ДаНет

  защищено 
  typeMismatch: ДаНет

  защищено 
  valid: ДаНет

  защищено 
  valueMissing: ДаНет
}


внешнее
/*(!) var */ ValidityState: объект { prototype: ValidityState; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoColorSpace) */

тип VideoColorSpace = интерфейс
{
  защищено 
  fullRange: ДаНет?FUCKFUCK

  защищено 
  matrix: VideoMatrixCoefficients?FUCKFUCK

  защищено 
  primaries: VideoColorPrimaries?FUCKFUCK

  защищено 
  transfer: VideoTransferCharacteristics?FUCKFUCK

  операция toJSON(): VideoColorSpaceInit
}


внешнее
/*(!) var */ VideoColorSpace: объект { prototype: VideoColorSpace; при создании(init: VideoColorSpaceInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип VideoDecoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoDecoder)
*/

тип VideoDecoder = интерфейс
{
  защищено 
  decodeQueueSize: Число

  ondequeue: операция(this: VideoDecoder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoDecoderConfig)

  операция decode(chunk: EncodedVideoChunk)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VideoDecoder: объект { prototype: VideoDecoder; при создании(init: VideoDecoderInit)/*(!) no_type */ Объект?; операция isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport> }


тип VideoEncoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoEncoder)
*/

тип VideoEncoder = интерфейс
{
  защищено 
  encodeQueueSize: Число

  ondequeue: операция(this: VideoEncoder, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoEncoderConfig)

  операция encode(frame: VideoFrame, options: VideoEncoderEncodeOptions?FUCKFUCK = пусто)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VideoEncoder: объект { prototype: VideoEncoder; при создании(init: VideoEncoderInit)/*(!) no_type */ Объект?; операция isConfigSupported(config: VideoEncoderConfig): Promise<VideoEncoderSupport> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoFrame) */

тип VideoFrame = интерфейс
{
  защищено 
  codedHeight: Число

  защищено 
  codedRect: DOMRectReadOnly?FUCKFUCK

  защищено 
  codedWidth: Число

  защищено 
  colorSpace: VideoColorSpace

  защищено 
  displayHeight: Число

  защищено 
  displayWidth: Число

  защищено 
  duration: Число?FUCKFUCK

  защищено 
  format: VideoPixelFormat?FUCKFUCK

  защищено 
  timestamp: Число

  защищено 
  visibleRect: DOMRectReadOnly?FUCKFUCK

  операция allocationSize(options: VideoFrameCopyToOptions?FUCKFUCK = пусто): Число

  операция clone(): VideoFrame

  операция close()

  операция copyTo(destination: BufferSource, options: VideoFrameCopyToOptions?FUCKFUCK = пусто): Promise<Список<PlaneLayout>>
}


внешнее
/*(!) var */ VideoFrame: объект { prototype: VideoFrame; при создании(image: CanvasImageSource, init: VideoFrameInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; при создании(data: BufferSource, init: VideoFrameBufferInit)/*(!) no_type */ Объект? }


/**
* Returned by the HTMLVideoElement.getVideoPlaybackQuality() method and contains metrics that can be used to determine the playback quality of a video.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoPlaybackQuality)
*/

тип VideoPlaybackQuality = интерфейс
{
  защищено 
  corruptedVideoFrames: Число

  защищено 
  creationTime: DOMHighResTimeStamp

  защищено 
  droppedVideoFrames: Число

  защищено 
  totalVideoFrames: Число
}


внешнее
/*(!) var */ VideoPlaybackQuality: объект { prototype: VideoPlaybackQuality; при создании()/*(!) no_type */ Объект? }


тип VisualViewportEventMap = интерфейс
{
  "resize": Event

  "scroll": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VisualViewport) */

тип VisualViewport = интерфейс
{
  защищено 
  height: Число

  защищено 
  offsetLeft: Число

  защищено 
  offsetTop: Число

  onresize: операция(this: VisualViewport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onscroll: операция(this: VisualViewport, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  pageLeft: Число

  защищено 
  pageTop: Число

  защищено 
  scale: Число

  защищено 
  width: Число

  операция addEventListener<K = /*(!) keyof VisualViewportEventMap */ Объект?>(type: K, listener: операция(this: VisualViewport, ev: /*(!) VisualViewportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof VisualViewportEventMap */ Объект?>(type: K, listener: операция(this: VisualViewport, ev: /*(!) VisualViewportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ VisualViewport: объект { prototype: VisualViewport; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_color_buffer_float) */

тип WEBGL_color_buffer_float = интерфейс
{
  защищено 
  RGBA32F_EXT: 0x8814

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_astc) */

тип WEBGL_compressed_texture_astc = интерфейс
{
  операция getSupportedProfiles(): Список<Текст>

  защищено 
  COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93B0

  защищено 
  COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93B1

  защищено 
  COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93B2

  защищено 
  COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93B3

  защищено 
  COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93B4

  защищено 
  COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93B5

  защищено 
  COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93B6

  защищено 
  COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93B7

  защищено 
  COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93B8

  защищено 
  COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93B9

  защищено 
  COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93BA

  защищено 
  COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93BB

  защищено 
  COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93BC

  защищено 
  COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93BD

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93D0

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93D1

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93D2

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93D3

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93D4

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93D5

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93D6

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93D7

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93D8

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93D9

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93DA

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93DB

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93DC

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93DD
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc) */

тип WEBGL_compressed_texture_etc = интерфейс
{
  защищено 
  COMPRESSED_R11_EAC: 0x9270

  защищено 
  COMPRESSED_SIGNED_R11_EAC: 0x9271

  защищено 
  COMPRESSED_RG11_EAC: 0x9272

  защищено 
  COMPRESSED_SIGNED_RG11_EAC: 0x9273

  защищено 
  COMPRESSED_RGB8_ETC2: 0x9274

  защищено 
  COMPRESSED_SRGB8_ETC2: 0x9275

  защищено 
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276

  защищено 
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277

  защищено 
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc1) */

тип WEBGL_compressed_texture_etc1 = интерфейс
{
  защищено 
  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_pvrtc) */

тип WEBGL_compressed_texture_pvrtc = интерфейс
{
  защищено 
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00

  защищено 
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01

  защищено 
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02

  защищено 
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03
}


/**
* The WEBGL_compressed_texture_s3tc extension is part of the WebGL API and exposes four S3TC compressed texture formats.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc)
*/

тип WEBGL_compressed_texture_s3tc = интерфейс
{
  защищено 
  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0

  защищено 
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1

  защищено 
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2

  защищено 
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc_srgb) */

тип WEBGL_compressed_texture_s3tc_srgb = интерфейс
{
  защищено 
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8C4C

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8C4D

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8C4E

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8C4F
}


/**
* The WEBGL_debug_renderer_info extension is part of the WebGL API and exposes two constants with information about the graphics driver for debugging purposes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_renderer_info)
*/

тип WEBGL_debug_renderer_info = интерфейс
{
  защищено 
  UNMASKED_VENDOR_WEBGL: 0x9245

  защищено 
  UNMASKED_RENDERER_WEBGL: 0x9246
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_shaders) */

тип WEBGL_debug_shaders = интерфейс
{
  операция getTranslatedShaderSource(shader: WebGLShader): Текст
}


/**
* The WEBGL_depth_texture extension is part of the WebGL API and defines 2D depth and depth-stencil textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_depth_texture)
*/

тип WEBGL_depth_texture = интерфейс
{
  защищено 
  UNSIGNED_INT_24_8_WEBGL: 0x84FA
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers) */

тип WEBGL_draw_buffers = интерфейс
{
  операция drawBuffersWEBGL(buffers: Список<GLenum>)

  защищено 
  COLOR_ATTACHMENT0_WEBGL: 0x8CE0

  защищено 
  COLOR_ATTACHMENT1_WEBGL: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2_WEBGL: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3_WEBGL: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4_WEBGL: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5_WEBGL: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6_WEBGL: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7_WEBGL: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8_WEBGL: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9_WEBGL: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10_WEBGL: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11_WEBGL: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12_WEBGL: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13_WEBGL: 0x8CED

  защищено 
  COLOR_ATTACHMENT14_WEBGL: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15_WEBGL: 0x8CEF

  защищено 
  DRAW_BUFFER0_WEBGL: 0x8825

  защищено 
  DRAW_BUFFER1_WEBGL: 0x8826

  защищено 
  DRAW_BUFFER2_WEBGL: 0x8827

  защищено 
  DRAW_BUFFER3_WEBGL: 0x8828

  защищено 
  DRAW_BUFFER4_WEBGL: 0x8829

  защищено 
  DRAW_BUFFER5_WEBGL: 0x882A

  защищено 
  DRAW_BUFFER6_WEBGL: 0x882B

  защищено 
  DRAW_BUFFER7_WEBGL: 0x882C

  защищено 
  DRAW_BUFFER8_WEBGL: 0x882D

  защищено 
  DRAW_BUFFER9_WEBGL: 0x882E

  защищено 
  DRAW_BUFFER10_WEBGL: 0x882F

  защищено 
  DRAW_BUFFER11_WEBGL: 0x8830

  защищено 
  DRAW_BUFFER12_WEBGL: 0x8831

  защищено 
  DRAW_BUFFER13_WEBGL: 0x8832

  защищено 
  DRAW_BUFFER14_WEBGL: 0x8833

  защищено 
  DRAW_BUFFER15_WEBGL: 0x8834

  защищено 
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF

  защищено 
  MAX_DRAW_BUFFERS_WEBGL: 0x8824
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_lose_context) */

тип WEBGL_lose_context = интерфейс
{
  операция loseContext()

  операция restoreContext()
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw) */

тип WEBGL_multi_draw = интерфейс
{
  операция multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Int32Array | Список<GLint>, firstsOffset: GLuint, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, instanceCountsList: Int32Array | Список<GLsizei>, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawArraysWEBGL(mode: GLenum, firstsList: Int32Array | Список<GLint>, firstsOffset: GLuint, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | Список<GLsizei>, offsetsOffset: GLuint, instanceCountsList: Int32Array | Список<GLsizei>, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsWEBGL(mode: GLenum, countsList: Int32Array | Список<GLsizei>, countsOffset: GLuint, type: GLenum, offsetsList: Int32Array | Список<GLsizei>, offsetsOffset: GLuint, drawcount: GLsizei)
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WakeLock)
*/

тип WakeLock = интерфейс
{
  операция request(type: WakeLockType?FUCKFUCK = пусто): Promise<WakeLockSentinel>
}


внешнее
/*(!) var */ WakeLock: объект { prototype: WakeLock; при создании()/*(!) no_type */ Объект? }


тип WakeLockSentinelEventMap = интерфейс
{
  "release": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WakeLockSentinel)
*/

тип WakeLockSentinel = интерфейс
{
  onrelease: операция(this: WakeLockSentinel, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  released: ДаНет

  защищено 
  type: WakeLockType

  операция release(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof WakeLockSentinelEventMap */ Объект?>(type: K, listener: операция(this: WakeLockSentinel, ev: /*(!) WakeLockSentinelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WakeLockSentinelEventMap */ Объект?>(type: K, listener: операция(this: WakeLockSentinel, ev: /*(!) WakeLockSentinelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ WakeLockSentinel: объект { prototype: WakeLockSentinel; при создании()/*(!) no_type */ Объект? }


/**
* A WaveShaperNode always has exactly one input and one output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WaveShaperNode)
*/

тип WaveShaperNode = интерфейс
{
  curve: Float32Array?FUCKFUCK

  oversample: OverSampleType
}


внешнее
/*(!) var */ WaveShaperNode: объект { prototype: WaveShaperNode; при создании(context: BaseAudioContext, options: WaveShaperOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext) */

тип WebGL2RenderingContext = интерфейс
{

}


внешнее
/*(!) var */ WebGL2RenderingContext: объект { prototype: WebGL2RenderingContext; при создании()/*(!) no_type */ Объект?; защищено  READ_BUFFER: 0x0C02; защищено  UNPACK_ROW_LENGTH: 0x0CF2; защищено  UNPACK_SKIP_ROWS: 0x0CF3; защищено  UNPACK_SKIP_PIXELS: 0x0CF4; защищено  PACK_ROW_LENGTH: 0x0D02; защищено  PACK_SKIP_ROWS: 0x0D03; защищено  PACK_SKIP_PIXELS: 0x0D04; защищено  COLOR: 0x1800; защищено  DEPTH: 0x1801; защищено  STENCIL: 0x1802; защищено  RED: 0x1903; защищено  RGB8: 0x8051; защищено  RGBA8: 0x8058; защищено  RGB10_A2: 0x8059; защищено  TEXTURE_BINDING_3D: 0x806A; защищено  UNPACK_SKIP_IMAGES: 0x806D; защищено  UNPACK_IMAGE_HEIGHT: 0x806E; защищено  TEXTURE_3D: 0x806F; защищено  TEXTURE_WRAP_R: 0x8072; защищено  MAX_3D_TEXTURE_SIZE: 0x8073; защищено  UNSIGNED_INT_2_10_10_10_REV: 0x8368; защищено  MAX_ELEMENTS_VERTICES: 0x80E8; защищено  MAX_ELEMENTS_INDICES: 0x80E9; защищено  TEXTURE_MIN_LOD: 0x813A; защищено  TEXTURE_MAX_LOD: 0x813B; защищено  TEXTURE_BASE_LEVEL: 0x813C; защищено  TEXTURE_MAX_LEVEL: 0x813D; защищено  MIN: 0x8007; защищено  MAX: 0x8008; защищено  DEPTH_COMPONENT24: 0x81A6; защищено  MAX_TEXTURE_LOD_BIAS: 0x84FD; защищено  TEXTURE_COMPARE_MODE: 0x884C; защищено  TEXTURE_COMPARE_FUNC: 0x884D; защищено  CURRENT_QUERY: 0x8865; защищено  QUERY_RESULT: 0x8866; защищено  QUERY_RESULT_AVAILABLE: 0x8867; защищено  STREAM_READ: 0x88E1; защищено  STREAM_COPY: 0x88E2; защищено  STATIC_READ: 0x88E5; защищено  STATIC_COPY: 0x88E6; защищено  DYNAMIC_READ: 0x88E9; защищено  DYNAMIC_COPY: 0x88EA; защищено  MAX_DRAW_BUFFERS: 0x8824; защищено  DRAW_BUFFER0: 0x8825; защищено  DRAW_BUFFER1: 0x8826; защищено  DRAW_BUFFER2: 0x8827; защищено  DRAW_BUFFER3: 0x8828; защищено  DRAW_BUFFER4: 0x8829; защищено  DRAW_BUFFER5: 0x882A; защищено  DRAW_BUFFER6: 0x882B; защищено  DRAW_BUFFER7: 0x882C; защищено  DRAW_BUFFER8: 0x882D; защищено  DRAW_BUFFER9: 0x882E; защищено  DRAW_BUFFER10: 0x882F; защищено  DRAW_BUFFER11: 0x8830; защищено  DRAW_BUFFER12: 0x8831; защищено  DRAW_BUFFER13: 0x8832; защищено  DRAW_BUFFER14: 0x8833; защищено  DRAW_BUFFER15: 0x8834; защищено  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49; защищено  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A; защищено  SAMPLER_3D: 0x8B5F; защищено  SAMPLER_2D_SHADOW: 0x8B62; защищено  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B; защищено  PIXEL_PACK_BUFFER: 0x88EB; защищено  PIXEL_UNPACK_BUFFER: 0x88EC; защищено  PIXEL_PACK_BUFFER_BINDING: 0x88ED; защищено  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF; защищено  FLOAT_MAT2x3: 0x8B65; защищено  FLOAT_MAT2x4: 0x8B66; защищено  FLOAT_MAT3x2: 0x8B67; защищено  FLOAT_MAT3x4: 0x8B68; защищено  FLOAT_MAT4x2: 0x8B69; защищено  FLOAT_MAT4x3: 0x8B6A; защищено  SRGB: 0x8C40; защищено  SRGB8: 0x8C41; защищено  SRGB8_ALPHA8: 0x8C43; защищено  COMPARE_REF_TO_TEXTURE: 0x884E; защищено  RGBA32F: 0x8814; защищено  RGB32F: 0x8815; защищено  RGBA16F: 0x881A; защищено  RGB16F: 0x881B; защищено  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD; защищено  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF; защищено  MIN_PROGRAM_TEXEL_OFFSET: 0x8904; защищено  MAX_PROGRAM_TEXEL_OFFSET: 0x8905; защищено  MAX_VARYING_COMPONENTS: 0x8B4B; защищено  TEXTURE_2D_ARRAY: 0x8C1A; защищено  TEXTURE_BINDING_2D_ARRAY: 0x8C1D; защищено  R11F_G11F_B10F: 0x8C3A; защищено  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B; защищено  RGB9_E5: 0x8C3D; защищено  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E; защищено  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80; защищено  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83; защищено  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84; защищено  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85; защищено  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88; защищено  RASTERIZER_DISCARD: 0x8C89; защищено  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B; защищено  INTERLEAVED_ATTRIBS: 0x8C8C; защищено  SEPARATE_ATTRIBS: 0x8C8D; защищено  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E; защищено  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F; защищено  RGBA32UI: 0x8D70; защищено  RGB32UI: 0x8D71; защищено  RGBA16UI: 0x8D76; защищено  RGB16UI: 0x8D77; защищено  RGBA8UI: 0x8D7C; защищено  RGB8UI: 0x8D7D; защищено  RGBA32I: 0x8D82; защищено  RGB32I: 0x8D83; защищено  RGBA16I: 0x8D88; защищено  RGB16I: 0x8D89; защищено  RGBA8I: 0x8D8E; защищено  RGB8I: 0x8D8F; защищено  RED_INTEGER: 0x8D94; защищено  RGB_INTEGER: 0x8D98; защищено  RGBA_INTEGER: 0x8D99; защищено  SAMPLER_2D_ARRAY: 0x8DC1; защищено  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4; защищено  SAMPLER_CUBE_SHADOW: 0x8DC5; защищено  UNSIGNED_INT_VEC2: 0x8DC6; защищено  UNSIGNED_INT_VEC3: 0x8DC7; защищено  UNSIGNED_INT_VEC4: 0x8DC8; защищено  INT_SAMPLER_2D: 0x8DCA; защищено  INT_SAMPLER_3D: 0x8DCB; защищено  INT_SAMPLER_CUBE: 0x8DCC; защищено  INT_SAMPLER_2D_ARRAY: 0x8DCF; защищено  UNSIGNED_INT_SAMPLER_2D: 0x8DD2; защищено  UNSIGNED_INT_SAMPLER_3D: 0x8DD3; защищено  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4; защищено  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7; защищено  DEPTH_COMPONENT32F: 0x8CAC; защищено  DEPTH32F_STENCIL8: 0x8CAD; защищено  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD; защищено  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210; защищено  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211; защищено  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212; защищено  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213; защищено  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214; защищено  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215; защищено  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216; защищено  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217; защищено  FRAMEBUFFER_DEFAULT: 0x8218; защищено  UNSIGNED_INT_24_8: 0x84FA; защищено  DEPTH24_STENCIL8: 0x88F0; защищено  UNSIGNED_NORMALIZED: 0x8C17; защищено  DRAW_FRAMEBUFFER_BINDING: 0x8CA6; защищено  READ_FRAMEBUFFER: 0x8CA8; защищено  DRAW_FRAMEBUFFER: 0x8CA9; защищено  READ_FRAMEBUFFER_BINDING: 0x8CAA; защищено  RENDERBUFFER_SAMPLES: 0x8CAB; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4; защищено  MAX_COLOR_ATTACHMENTS: 0x8CDF; защищено  COLOR_ATTACHMENT1: 0x8CE1; защищено  COLOR_ATTACHMENT2: 0x8CE2; защищено  COLOR_ATTACHMENT3: 0x8CE3; защищено  COLOR_ATTACHMENT4: 0x8CE4; защищено  COLOR_ATTACHMENT5: 0x8CE5; защищено  COLOR_ATTACHMENT6: 0x8CE6; защищено  COLOR_ATTACHMENT7: 0x8CE7; защищено  COLOR_ATTACHMENT8: 0x8CE8; защищено  COLOR_ATTACHMENT9: 0x8CE9; защищено  COLOR_ATTACHMENT10: 0x8CEA; защищено  COLOR_ATTACHMENT11: 0x8CEB; защищено  COLOR_ATTACHMENT12: 0x8CEC; защищено  COLOR_ATTACHMENT13: 0x8CED; защищено  COLOR_ATTACHMENT14: 0x8CEE; защищено  COLOR_ATTACHMENT15: 0x8CEF; защищено  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56; защищено  MAX_SAMPLES: 0x8D57; защищено  HALF_FLOAT: 0x140B; защищено  RG: 0x8227; защищено  RG_INTEGER: 0x8228; защищено  R8: 0x8229; защищено  RG8: 0x822B; защищено  R16F: 0x822D; защищено  R32F: 0x822E; защищено  RG16F: 0x822F; защищено  RG32F: 0x8230; защищено  R8I: 0x8231; защищено  R8UI: 0x8232; защищено  R16I: 0x8233; защищено  R16UI: 0x8234; защищено  R32I: 0x8235; защищено  R32UI: 0x8236; защищено  RG8I: 0x8237; защищено  RG8UI: 0x8238; защищено  RG16I: 0x8239; защищено  RG16UI: 0x823A; защищено  RG32I: 0x823B; защищено  RG32UI: 0x823C; защищено  VERTEX_ARRAY_BINDING: 0x85B5; защищено  R8_SNORM: 0x8F94; защищено  RG8_SNORM: 0x8F95; защищено  RGB8_SNORM: 0x8F96; защищено  RGBA8_SNORM: 0x8F97; защищено  SIGNED_NORMALIZED: 0x8F9C; защищено  COPY_READ_BUFFER: 0x8F36; защищено  COPY_WRITE_BUFFER: 0x8F37; защищено  COPY_READ_BUFFER_BINDING: 0x8F36; защищено  COPY_WRITE_BUFFER_BINDING: 0x8F37; защищено  UNIFORM_BUFFER: 0x8A11; защищено  UNIFORM_BUFFER_BINDING: 0x8A28; защищено  UNIFORM_BUFFER_START: 0x8A29; защищено  UNIFORM_BUFFER_SIZE: 0x8A2A; защищено  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B; защищено  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D; защищено  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E; защищено  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F; защищено  MAX_UNIFORM_BLOCK_SIZE: 0x8A30; защищено  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31; защищено  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33; защищено  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34; защищено  ACTIVE_UNIFORM_BLOCKS: 0x8A36; защищено  UNIFORM_TYPE: 0x8A37; защищено  UNIFORM_SIZE: 0x8A38; защищено  UNIFORM_BLOCK_INDEX: 0x8A3A; защищено  UNIFORM_OFFSET: 0x8A3B; защищено  UNIFORM_ARRAY_STRIDE: 0x8A3C; защищено  UNIFORM_MATRIX_STRIDE: 0x8A3D; защищено  UNIFORM_IS_ROW_MAJOR: 0x8A3E; защищено  UNIFORM_BLOCK_BINDING: 0x8A3F; защищено  UNIFORM_BLOCK_DATA_SIZE: 0x8A40; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43; защищено  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44; защищено  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46; защищено  INVALID_INDEX: 0xFFFFFFFF; защищено  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122; защищено  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125; защищено  MAX_SERVER_WAIT_TIMEOUT: 0x9111; защищено  OBJECT_TYPE: 0x9112; защищено  SYNC_CONDITION: 0x9113; защищено  SYNC_STATUS: 0x9114; защищено  SYNC_FLAGS: 0x9115; защищено  SYNC_FENCE: 0x9116; защищено  SYNC_GPU_COMMANDS_COMPLETE: 0x9117; защищено  UNSIGNALED: 0x9118; защищено  SIGNALED: 0x9119; защищено  ALREADY_SIGNALED: 0x911A; защищено  TIMEOUT_EXPIRED: 0x911B; защищено  CONDITION_SATISFIED: 0x911C; защищено  WAIT_FAILED: 0x911D; защищено  SYNC_FLUSH_COMMANDS_BIT: 0x00000001; защищено  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE; защищено  ANY_SAMPLES_PASSED: 0x8C2F; защищено  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A; защищено  SAMPLER_BINDING: 0x8919; защищено  RGB10_A2UI: 0x906F; защищено  INT_2_10_10_10_REV: 0x8D9F; защищено  TRANSFORM_FEEDBACK: 0x8E22; защищено  TRANSFORM_FEEDBACK_PAUSED: 0x8E23; защищено  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24; защищено  TRANSFORM_FEEDBACK_BINDING: 0x8E25; защищено  TEXTURE_IMMUTABLE_FORMAT: 0x912F; защищено  MAX_ELEMENT_INDEX: 0x8D6B; защищено  TEXTURE_IMMUTABLE_LEVELS: 0x82DF; защищено  TIMEOUT_IGNORED: -1; защищено  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGL2RenderingContextBase = интерфейс
{
  операция beginQuery(target: GLenum, query: WebGLQuery)

  операция beginTransformFeedback(primitiveMode: GLenum)

  операция bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer?FUCKFUCK)

  операция bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer?FUCKFUCK, offset: GLintptr, size: GLsizeiptr)

  операция bindSampler(unit: GLuint, sampler: WebGLSampler?FUCKFUCK)

  операция bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback?FUCKFUCK)

  операция bindVertexArray(array: WebGLVertexArrayObject?FUCKFUCK)

  операция blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum)

  операция clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint)

  операция clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто)

  операция clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr)

  операция copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createQuery(): WebGLQuery?FUCKFUCK

  операция createSampler(): WebGLSampler?FUCKFUCK

  операция createTransformFeedback(): WebGLTransformFeedback?FUCKFUCK

  операция createVertexArray(): WebGLVertexArrayObject?FUCKFUCK

  операция deleteQuery(query: WebGLQuery?FUCKFUCK)

  операция deleteSampler(sampler: WebGLSampler?FUCKFUCK)

  операция deleteSync(sync: WebGLSync?FUCKFUCK)

  операция deleteTransformFeedback(tf: WebGLTransformFeedback?FUCKFUCK)

  операция deleteVertexArray(vertexArray: WebGLVertexArrayObject?FUCKFUCK)

  операция drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei)

  операция drawBuffers(buffers: Список<GLenum>)

  операция drawElementsInstanced(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr, instanceCount: GLsizei)

  операция drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type: GLenum, offset: GLintptr)

  операция endQuery(target: GLenum)

  операция endTransformFeedback()

  операция fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync?FUCKFUCK

  операция framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint, layer: GLint)

  операция getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): Текст?FUCKFUCK

  операция getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getActiveUniforms(program: WebGLProgram, uniformIndices: Список<GLuint>, pname: GLenum): /*(!) any */ Объект?

  операция getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint?FUCKFUCK = пусто, length: GLuint?FUCKFUCK = пусто)

  операция getFragDataLocation(program: WebGLProgram, name: Текст): GLint

  операция getIndexedParameter(target: GLenum, index: GLuint): /*(!) any */ Объект?

  операция getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getQuery(target: GLenum, pname: GLenum): WebGLQuery?FUCKFUCK

  операция getQueryParameter(query: WebGLQuery, pname: GLenum): /*(!) any */ Объект?

  операция getSamplerParameter(sampler: WebGLSampler, pname: GLenum): /*(!) any */ Объект?

  операция getSyncParameter(sync: WebGLSync, pname: GLenum): /*(!) any */ Объект?

  операция getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getUniformBlockIndex(program: WebGLProgram, uniformBlockName: Текст): GLuint

  операция getUniformIndices(program: WebGLProgram, uniformNames: Список<Текст>): Список<GLuint>?FUCKFUCK

  операция invalidateFramebuffer(target: GLenum, attachments: Список<GLenum>)

  операция invalidateSubFramebuffer(target: GLenum, attachments: Список<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция isQuery(query: WebGLQuery?FUCKFUCK): GLboolean

  операция isSampler(sampler: WebGLSampler?FUCKFUCK): GLboolean

  операция isSync(sync: WebGLSync?FUCKFUCK): GLboolean

  операция isTransformFeedback(tf: WebGLTransformFeedback?FUCKFUCK): GLboolean

  операция isVertexArray(vertexArray: WebGLVertexArrayObject?FUCKFUCK): GLboolean

  операция pauseTransformFeedback()

  операция readBuffer(src: GLenum)

  операция renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция resumeTransformFeedback()

  операция samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat)

  операция samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView?FUCKFUCK)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView?FUCKFUCK, srcOffset: GLuint?FUCKFUCK = пусто)

  операция transformFeedbackVaryings(program: WebGLProgram, varyings: Список<Текст>, bufferMode: GLenum)

  операция uniform1ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint)

  операция uniform1uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint)

  операция uniform2uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint, v2: GLuint)

  операция uniform3uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4ui(location: WebGLUniformLocation?FUCKFUCK, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint)

  операция uniform4uiv(location: WebGLUniformLocation?FUCKFUCK, data: Uint32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint)

  операция uniformMatrix2x3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix2x4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3x2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3x4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4x2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4x3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция vertexAttribDivisor(index: GLuint, divisor: GLuint)

  операция vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint)

  операция vertexAttribI4iv(index: GLuint, values: Int32List)

  операция vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint)

  операция vertexAttribI4uiv(index: GLuint, values: Uint32List)

  операция vertexAttribIPointer(index: GLuint, size: GLint, type: GLenum, stride: GLsizei, offset: GLintptr)

  операция waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64)

  защищено 
  READ_BUFFER: 0x0C02

  защищено 
  UNPACK_ROW_LENGTH: 0x0CF2

  защищено 
  UNPACK_SKIP_ROWS: 0x0CF3

  защищено 
  UNPACK_SKIP_PIXELS: 0x0CF4

  защищено 
  PACK_ROW_LENGTH: 0x0D02

  защищено 
  PACK_SKIP_ROWS: 0x0D03

  защищено 
  PACK_SKIP_PIXELS: 0x0D04

  защищено 
  COLOR: 0x1800

  защищено 
  DEPTH: 0x1801

  защищено 
  STENCIL: 0x1802

  защищено 
  RED: 0x1903

  защищено 
  RGB8: 0x8051

  защищено 
  RGBA8: 0x8058

  защищено 
  RGB10_A2: 0x8059

  защищено 
  TEXTURE_BINDING_3D: 0x806A

  защищено 
  UNPACK_SKIP_IMAGES: 0x806D

  защищено 
  UNPACK_IMAGE_HEIGHT: 0x806E

  защищено 
  TEXTURE_3D: 0x806F

  защищено 
  TEXTURE_WRAP_R: 0x8072

  защищено 
  MAX_3D_TEXTURE_SIZE: 0x8073

  защищено 
  UNSIGNED_INT_2_10_10_10_REV: 0x8368

  защищено 
  MAX_ELEMENTS_VERTICES: 0x80E8

  защищено 
  MAX_ELEMENTS_INDICES: 0x80E9

  защищено 
  TEXTURE_MIN_LOD: 0x813A

  защищено 
  TEXTURE_MAX_LOD: 0x813B

  защищено 
  TEXTURE_BASE_LEVEL: 0x813C

  защищено 
  TEXTURE_MAX_LEVEL: 0x813D

  защищено 
  MIN: 0x8007

  защищено 
  MAX: 0x8008

  защищено 
  DEPTH_COMPONENT24: 0x81A6

  защищено 
  MAX_TEXTURE_LOD_BIAS: 0x84FD

  защищено 
  TEXTURE_COMPARE_MODE: 0x884C

  защищено 
  TEXTURE_COMPARE_FUNC: 0x884D

  защищено 
  CURRENT_QUERY: 0x8865

  защищено 
  QUERY_RESULT: 0x8866

  защищено 
  QUERY_RESULT_AVAILABLE: 0x8867

  защищено 
  STREAM_READ: 0x88E1

  защищено 
  STREAM_COPY: 0x88E2

  защищено 
  STATIC_READ: 0x88E5

  защищено 
  STATIC_COPY: 0x88E6

  защищено 
  DYNAMIC_READ: 0x88E9

  защищено 
  DYNAMIC_COPY: 0x88EA

  защищено 
  MAX_DRAW_BUFFERS: 0x8824

  защищено 
  DRAW_BUFFER0: 0x8825

  защищено 
  DRAW_BUFFER1: 0x8826

  защищено 
  DRAW_BUFFER2: 0x8827

  защищено 
  DRAW_BUFFER3: 0x8828

  защищено 
  DRAW_BUFFER4: 0x8829

  защищено 
  DRAW_BUFFER5: 0x882A

  защищено 
  DRAW_BUFFER6: 0x882B

  защищено 
  DRAW_BUFFER7: 0x882C

  защищено 
  DRAW_BUFFER8: 0x882D

  защищено 
  DRAW_BUFFER9: 0x882E

  защищено 
  DRAW_BUFFER10: 0x882F

  защищено 
  DRAW_BUFFER11: 0x8830

  защищено 
  DRAW_BUFFER12: 0x8831

  защищено 
  DRAW_BUFFER13: 0x8832

  защищено 
  DRAW_BUFFER14: 0x8833

  защищено 
  DRAW_BUFFER15: 0x8834

  защищено 
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49

  защищено 
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A

  защищено 
  SAMPLER_3D: 0x8B5F

  защищено 
  SAMPLER_2D_SHADOW: 0x8B62

  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B

  защищено 
  PIXEL_PACK_BUFFER: 0x88EB

  защищено 
  PIXEL_UNPACK_BUFFER: 0x88EC

  защищено 
  PIXEL_PACK_BUFFER_BINDING: 0x88ED

  защищено 
  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF

  защищено 
  FLOAT_MAT2x3: 0x8B65

  защищено 
  FLOAT_MAT2x4: 0x8B66

  защищено 
  FLOAT_MAT3x2: 0x8B67

  защищено 
  FLOAT_MAT3x4: 0x8B68

  защищено 
  FLOAT_MAT4x2: 0x8B69

  защищено 
  FLOAT_MAT4x3: 0x8B6A

  защищено 
  SRGB: 0x8C40

  защищено 
  SRGB8: 0x8C41

  защищено 
  SRGB8_ALPHA8: 0x8C43

  защищено 
  COMPARE_REF_TO_TEXTURE: 0x884E

  защищено 
  RGBA32F: 0x8814

  защищено 
  RGB32F: 0x8815

  защищено 
  RGBA16F: 0x881A

  защищено 
  RGB16F: 0x881B

  защищено 
  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD

  защищено 
  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF

  защищено 
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904

  защищено 
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905

  защищено 
  MAX_VARYING_COMPONENTS: 0x8B4B

  защищено 
  TEXTURE_2D_ARRAY: 0x8C1A

  защищено 
  TEXTURE_BINDING_2D_ARRAY: 0x8C1D

  защищено 
  R11F_G11F_B10F: 0x8C3A

  защищено 
  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B

  защищено 
  RGB9_E5: 0x8C3D

  защищено 
  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80

  защищено 
  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85

  защищено 
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88

  защищено 
  RASTERIZER_DISCARD: 0x8C89

  защищено 
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B

  защищено 
  INTERLEAVED_ATTRIBS: 0x8C8C

  защищено 
  SEPARATE_ATTRIBS: 0x8C8D

  защищено 
  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F

  защищено 
  RGBA32UI: 0x8D70

  защищено 
  RGB32UI: 0x8D71

  защищено 
  RGBA16UI: 0x8D76

  защищено 
  RGB16UI: 0x8D77

  защищено 
  RGBA8UI: 0x8D7C

  защищено 
  RGB8UI: 0x8D7D

  защищено 
  RGBA32I: 0x8D82

  защищено 
  RGB32I: 0x8D83

  защищено 
  RGBA16I: 0x8D88

  защищено 
  RGB16I: 0x8D89

  защищено 
  RGBA8I: 0x8D8E

  защищено 
  RGB8I: 0x8D8F

  защищено 
  RED_INTEGER: 0x8D94

  защищено 
  RGB_INTEGER: 0x8D98

  защищено 
  RGBA_INTEGER: 0x8D99

  защищено 
  SAMPLER_2D_ARRAY: 0x8DC1

  защищено 
  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4

  защищено 
  SAMPLER_CUBE_SHADOW: 0x8DC5

  защищено 
  UNSIGNED_INT_VEC2: 0x8DC6

  защищено 
  UNSIGNED_INT_VEC3: 0x8DC7

  защищено 
  UNSIGNED_INT_VEC4: 0x8DC8

  защищено 
  INT_SAMPLER_2D: 0x8DCA

  защищено 
  INT_SAMPLER_3D: 0x8DCB

  защищено 
  INT_SAMPLER_CUBE: 0x8DCC

  защищено 
  INT_SAMPLER_2D_ARRAY: 0x8DCF

  защищено 
  UNSIGNED_INT_SAMPLER_2D: 0x8DD2

  защищено 
  UNSIGNED_INT_SAMPLER_3D: 0x8DD3

  защищено 
  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4

  защищено 
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7

  защищено 
  DEPTH_COMPONENT32F: 0x8CAC

  защищено 
  DEPTH32F_STENCIL8: 0x8CAD

  защищено 
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211

  защищено 
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212

  защищено 
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213

  защищено 
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214

  защищено 
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215

  защищено 
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216

  защищено 
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217

  защищено 
  FRAMEBUFFER_DEFAULT: 0x8218

  защищено 
  UNSIGNED_INT_24_8: 0x84FA

  защищено 
  DEPTH24_STENCIL8: 0x88F0

  защищено 
  UNSIGNED_NORMALIZED: 0x8C17

  защищено 
  DRAW_FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  READ_FRAMEBUFFER: 0x8CA8

  защищено 
  DRAW_FRAMEBUFFER: 0x8CA9

  защищено 
  READ_FRAMEBUFFER_BINDING: 0x8CAA

  защищено 
  RENDERBUFFER_SAMPLES: 0x8CAB

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4

  защищено 
  MAX_COLOR_ATTACHMENTS: 0x8CDF

  защищено 
  COLOR_ATTACHMENT1: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13: 0x8CED

  защищено 
  COLOR_ATTACHMENT14: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15: 0x8CEF

  защищено 
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56

  защищено 
  MAX_SAMPLES: 0x8D57

  защищено 
  HALF_FLOAT: 0x140B

  защищено 
  RG: 0x8227

  защищено 
  RG_INTEGER: 0x8228

  защищено 
  R8: 0x8229

  защищено 
  RG8: 0x822B

  защищено 
  R16F: 0x822D

  защищено 
  R32F: 0x822E

  защищено 
  RG16F: 0x822F

  защищено 
  RG32F: 0x8230

  защищено 
  R8I: 0x8231

  защищено 
  R8UI: 0x8232

  защищено 
  R16I: 0x8233

  защищено 
  R16UI: 0x8234

  защищено 
  R32I: 0x8235

  защищено 
  R32UI: 0x8236

  защищено 
  RG8I: 0x8237

  защищено 
  RG8UI: 0x8238

  защищено 
  RG16I: 0x8239

  защищено 
  RG16UI: 0x823A

  защищено 
  RG32I: 0x823B

  защищено 
  RG32UI: 0x823C

  защищено 
  VERTEX_ARRAY_BINDING: 0x85B5

  защищено 
  R8_SNORM: 0x8F94

  защищено 
  RG8_SNORM: 0x8F95

  защищено 
  RGB8_SNORM: 0x8F96

  защищено 
  RGBA8_SNORM: 0x8F97

  защищено 
  SIGNED_NORMALIZED: 0x8F9C

  защищено 
  COPY_READ_BUFFER: 0x8F36

  защищено 
  COPY_WRITE_BUFFER: 0x8F37

  защищено 
  COPY_READ_BUFFER_BINDING: 0x8F36

  защищено 
  COPY_WRITE_BUFFER_BINDING: 0x8F37

  защищено 
  UNIFORM_BUFFER: 0x8A11

  защищено 
  UNIFORM_BUFFER_BINDING: 0x8A28

  защищено 
  UNIFORM_BUFFER_START: 0x8A29

  защищено 
  UNIFORM_BUFFER_SIZE: 0x8A2A

  защищено 
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B

  защищено 
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D

  защищено 
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E

  защищено 
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F

  защищено 
  MAX_UNIFORM_BLOCK_SIZE: 0x8A30

  защищено 
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31

  защищено 
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33

  защищено 
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34

  защищено 
  ACTIVE_UNIFORM_BLOCKS: 0x8A36

  защищено 
  UNIFORM_TYPE: 0x8A37

  защищено 
  UNIFORM_SIZE: 0x8A38

  защищено 
  UNIFORM_BLOCK_INDEX: 0x8A3A

  защищено 
  UNIFORM_OFFSET: 0x8A3B

  защищено 
  UNIFORM_ARRAY_STRIDE: 0x8A3C

  защищено 
  UNIFORM_MATRIX_STRIDE: 0x8A3D

  защищено 
  UNIFORM_IS_ROW_MAJOR: 0x8A3E

  защищено 
  UNIFORM_BLOCK_BINDING: 0x8A3F

  защищено 
  UNIFORM_BLOCK_DATA_SIZE: 0x8A40

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46

  защищено 
  INVALID_INDEX: 0xFFFFFFFF

  защищено 
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122

  защищено 
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125

  защищено 
  MAX_SERVER_WAIT_TIMEOUT: 0x9111

  защищено 
  OBJECT_TYPE: 0x9112

  защищено 
  SYNC_CONDITION: 0x9113

  защищено 
  SYNC_STATUS: 0x9114

  защищено 
  SYNC_FLAGS: 0x9115

  защищено 
  SYNC_FENCE: 0x9116

  защищено 
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117

  защищено 
  UNSIGNALED: 0x9118

  защищено 
  SIGNALED: 0x9119

  защищено 
  ALREADY_SIGNALED: 0x911A

  защищено 
  TIMEOUT_EXPIRED: 0x911B

  защищено 
  CONDITION_SATISFIED: 0x911C

  защищено 
  WAIT_FAILED: 0x911D

  защищено 
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE

  защищено 
  ANY_SAMPLES_PASSED: 0x8C2F

  защищено 
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A

  защищено 
  SAMPLER_BINDING: 0x8919

  защищено 
  RGB10_A2UI: 0x906F

  защищено 
  INT_2_10_10_10_REV: 0x8D9F

  защищено 
  TRANSFORM_FEEDBACK: 0x8E22

  защищено 
  TRANSFORM_FEEDBACK_PAUSED: 0x8E23

  защищено 
  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24

  защищено 
  TRANSFORM_FEEDBACK_BINDING: 0x8E25

  защищено 
  TEXTURE_IMMUTABLE_FORMAT: 0x912F

  защищено 
  MAX_ELEMENT_INDEX: 0x8D6B

  защищено 
  TEXTURE_IMMUTABLE_LEVELS: 0x82DF

  защищено 
  TIMEOUT_IGNORED: -1

  защищено 
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247
}


тип WebGL2RenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, srcData: BufferSource?FUCKFUCK, usage: GLenum)

  операция bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length: GLuint?FUCKFUCK = пусто)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: BufferSource)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: ArrayBufferView, srcOffset: GLuint, length: GLuint?FUCKFUCK = пусто)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint?FUCKFUCK = пусто, srcLengthOverride: GLuint?FUCKFUCK = пусто)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView?FUCKFUCK)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, offset: GLintptr)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, dstData: ArrayBufferView, dstOffset: GLuint)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pboOffset: GLintptr)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция uniform1fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform1iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform2iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform3iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4fv(location: WebGLUniformLocation?FUCKFUCK, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniform4iv(location: WebGLUniformLocation?FUCKFUCK, data: Int32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)

  операция uniformMatrix4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, data: Float32List, srcOffset: GLuint?FUCKFUCK = пусто, srcLength: GLuint?FUCKFUCK = пусто)
}


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getActiveAttrib() and WebGLRenderingContext.getActiveUniform() methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLActiveInfo)
*/

тип WebGLActiveInfo = интерфейс
{
  защищено 
  name: Текст

  защищено 
  size: GLint

  защищено 
  type: GLenum
}


внешнее
/*(!) var */ WebGLActiveInfo: объект { prototype: WebGLActiveInfo; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents an opaque buffer object storing data such as vertices or colors.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLBuffer)
*/

тип WebGLBuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLBuffer: объект { prototype: WebGLBuffer; при создании()/*(!) no_type */ Объект? }


/**
* The WebContextEvent interface is part of the WebGL API and is an interface for an event that is generated in response to a status change to the WebGL rendering context.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLContextEvent)
*/

тип WebGLContextEvent = интерфейс
{
  защищено 
  statusMessage: Текст
}


внешнее
/*(!) var */ WebGLContextEvent: объект { prototype: WebGLContextEvent; при создании(type: Текст, eventInit: WebGLContextEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents a collection of buffers that serve as a rendering destination.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLFramebuffer)
*/

тип WebGLFramebuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLFramebuffer: объект { prototype: WebGLFramebuffer; при создании()/*(!) no_type */ Объект? }


/**
* The WebGLProgram is part of the WebGL API and is a combination of two compiled WebGLShaders consisting of a vertex shader and a fragment shader (both written in GLSL).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLProgram)
*/

тип WebGLProgram = интерфейс
{

}


внешнее
/*(!) var */ WebGLProgram: объект { prototype: WebGLProgram; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLQuery) */

тип WebGLQuery = интерфейс
{

}


внешнее
/*(!) var */ WebGLQuery: объект { prototype: WebGLQuery; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents a buffer that can contain an image, or can be source or target of an rendering operation.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderbuffer)
*/

тип WebGLRenderbuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLRenderbuffer: объект { prototype: WebGLRenderbuffer; при создании()/*(!) no_type */ Объект? }


/**
* Provides an interface to the OpenGL ES 2.0 graphics rendering context for the drawing surface of an HTML <canvas> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext)
*/

тип WebGLRenderingContext = интерфейс
{

}


внешнее
/*(!) var */ WebGLRenderingContext: объект { prototype: WebGLRenderingContext; при создании()/*(!) no_type */ Объект?; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGLRenderingContextBase = интерфейс
{
  защищено 
  canvas: HTMLCanvasElement | OffscreenCanvas

  drawingBufferColorSpace: PredefinedColorSpace

  защищено 
  drawingBufferHeight: GLsizei

  защищено 
  drawingBufferWidth: GLsizei

  операция activeTexture(texture: GLenum)

  операция attachShader(program: WebGLProgram, shader: WebGLShader)

  операция bindAttribLocation(program: WebGLProgram, index: GLuint, name: Текст)

  операция bindBuffer(target: GLenum, buffer: WebGLBuffer?FUCKFUCK)

  операция bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer?FUCKFUCK)

  операция bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция bindTexture(target: GLenum, texture: WebGLTexture?FUCKFUCK)

  операция blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция blendEquation(mode: GLenum)

  операция blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum)

  операция blendFunc(sfactor: GLenum, dfactor: GLenum)

  операция blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция checkFramebufferStatus(target: GLenum): GLenum

  операция clear(mask: GLbitfield)

  операция clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция clearDepth(depth: GLclampf)

  операция clearStencil(s: GLint)

  операция colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean)

  операция compileShader(shader: WebGLShader)

  операция copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint)

  операция copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createBuffer(): WebGLBuffer?FUCKFUCK

  операция createFramebuffer(): WebGLFramebuffer?FUCKFUCK

  операция createProgram(): WebGLProgram?FUCKFUCK

  операция createRenderbuffer(): WebGLRenderbuffer?FUCKFUCK

  операция createShader(type: GLenum): WebGLShader?FUCKFUCK

  операция createTexture(): WebGLTexture?FUCKFUCK

  операция cullFace(mode: GLenum)

  операция deleteBuffer(buffer: WebGLBuffer?FUCKFUCK)

  операция deleteFramebuffer(framebuffer: WebGLFramebuffer?FUCKFUCK)

  операция deleteProgram(program: WebGLProgram?FUCKFUCK)

  операция deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция deleteShader(shader: WebGLShader?FUCKFUCK)

  операция deleteTexture(texture: WebGLTexture?FUCKFUCK)

  операция depthFunc(func: GLenum)

  операция depthMask(flag: GLboolean)

  операция depthRange(zNear: GLclampf, zFar: GLclampf)

  операция detachShader(program: WebGLProgram, shader: WebGLShader)

  операция disable(cap: GLenum)

  операция disableVertexAttribArray(index: GLuint)

  операция drawArrays(mode: GLenum, first: GLint, count: GLsizei)

  операция drawElements(mode: GLenum, count: GLsizei, type: GLenum, offset: GLintptr)

  операция enable(cap: GLenum)

  операция enableVertexAttribArray(index: GLuint)

  операция finish()

  операция flush()

  операция framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer?FUCKFUCK)

  операция framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture?FUCKFUCK, level: GLint)

  операция frontFace(mode: GLenum)

  операция generateMipmap(target: GLenum)

  операция getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo?FUCKFUCK

  операция getAttachedShaders(program: WebGLProgram): Список<WebGLShader>?FUCKFUCK

  операция getAttribLocation(program: WebGLProgram, name: Текст): GLint

  операция getBufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getContextAttributes(): WebGLContextAttributes?FUCKFUCK

  операция getError(): GLenum

  операция getExtension(extensionName: "ANGLE_instanced_arrays"): ANGLE_instanced_arrays?FUCKFUCK

  операция getExtension(extensionName: "EXT_blend_minmax"): EXT_blend_minmax?FUCKFUCK

  операция getExtension(extensionName: "EXT_color_buffer_float"): EXT_color_buffer_float?FUCKFUCK

  операция getExtension(extensionName: "EXT_color_buffer_half_float"): EXT_color_buffer_half_float?FUCKFUCK

  операция getExtension(extensionName: "EXT_float_blend"): EXT_float_blend?FUCKFUCK

  операция getExtension(extensionName: "EXT_frag_depth"): EXT_frag_depth?FUCKFUCK

  операция getExtension(extensionName: "EXT_sRGB"): EXT_sRGB?FUCKFUCK

  операция getExtension(extensionName: "EXT_shader_texture_lod"): EXT_shader_texture_lod?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_compression_bptc"): EXT_texture_compression_bptc?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_compression_rgtc"): EXT_texture_compression_rgtc?FUCKFUCK

  операция getExtension(extensionName: "EXT_texture_filter_anisotropic"): EXT_texture_filter_anisotropic?FUCKFUCK

  операция getExtension(extensionName: "KHR_parallel_shader_compile"): KHR_parallel_shader_compile?FUCKFUCK

  операция getExtension(extensionName: "OES_element_index_uint"): OES_element_index_uint?FUCKFUCK

  операция getExtension(extensionName: "OES_fbo_render_mipmap"): OES_fbo_render_mipmap?FUCKFUCK

  операция getExtension(extensionName: "OES_standard_derivatives"): OES_standard_derivatives?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_float"): OES_texture_float?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_float_linear"): OES_texture_float_linear?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_half_float"): OES_texture_half_float?FUCKFUCK

  операция getExtension(extensionName: "OES_texture_half_float_linear"): OES_texture_half_float_linear?FUCKFUCK

  операция getExtension(extensionName: "OES_vertex_array_object"): OES_vertex_array_object?FUCKFUCK

  операция getExtension(extensionName: "OVR_multiview2"): OVR_multiview2?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_color_buffer_float"): WEBGL_color_buffer_float?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_astc"): WEBGL_compressed_texture_astc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc"): WEBGL_compressed_texture_etc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc1"): WEBGL_compressed_texture_etc1?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_pvrtc"): WEBGL_compressed_texture_pvrtc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc"): WEBGL_compressed_texture_s3tc?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc_srgb"): WEBGL_compressed_texture_s3tc_srgb?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_debug_renderer_info"): WEBGL_debug_renderer_info?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_debug_shaders"): WEBGL_debug_shaders?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_depth_texture"): WEBGL_depth_texture?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_draw_buffers"): WEBGL_draw_buffers?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_lose_context"): WEBGL_lose_context?FUCKFUCK

  операция getExtension(extensionName: "WEBGL_multi_draw"): WEBGL_multi_draw?FUCKFUCK

  операция getExtension(name: Текст): /*(!) any */ Объект?

  операция getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getParameter(pname: GLenum): /*(!) any */ Объект?

  операция getProgramInfoLog(program: WebGLProgram): Текст?FUCKFUCK

  операция getProgramParameter(program: WebGLProgram, pname: GLenum): /*(!) any */ Объект?

  операция getRenderbufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getShaderInfoLog(shader: WebGLShader): Текст?FUCKFUCK

  операция getShaderParameter(shader: WebGLShader, pname: GLenum): /*(!) any */ Объект?

  операция getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat?FUCKFUCK

  операция getShaderSource(shader: WebGLShader): Текст?FUCKFUCK

  операция getSupportedExtensions(): Список<Текст>?FUCKFUCK

  операция getTexParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getUniform(program: WebGLProgram, location: WebGLUniformLocation): /*(!) any */ Объект?

  операция getUniformLocation(program: WebGLProgram, name: Текст): WebGLUniformLocation?FUCKFUCK

  операция getVertexAttrib(index: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr

  операция hint(target: GLenum, mode: GLenum)

  операция isBuffer(buffer: WebGLBuffer?FUCKFUCK): GLboolean

  операция isContextLost(): ДаНет

  операция isEnabled(cap: GLenum): GLboolean

  операция isFramebuffer(framebuffer: WebGLFramebuffer?FUCKFUCK): GLboolean

  операция isProgram(program: WebGLProgram?FUCKFUCK): GLboolean

  операция isRenderbuffer(renderbuffer: WebGLRenderbuffer?FUCKFUCK): GLboolean

  операция isShader(shader: WebGLShader?FUCKFUCK): GLboolean

  операция isTexture(texture: WebGLTexture?FUCKFUCK): GLboolean

  операция lineWidth(width: GLfloat)

  операция linkProgram(program: WebGLProgram)

  операция pixelStorei(pname: GLenum, param: GLint | GLboolean)

  операция polygonOffset(factor: GLfloat, units: GLfloat)

  операция renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция sampleCoverage(value: GLclampf, invert: GLboolean)

  операция scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция shaderSource(shader: WebGLShader, source: Текст)

  операция stencilFunc(func: GLenum, ref: GLint, mask: GLuint)

  операция stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint)

  операция stencilMask(mask: GLuint)

  операция stencilMaskSeparate(face: GLenum, mask: GLuint)

  операция stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция texParameterf(target: GLenum, pname: GLenum, param: GLfloat)

  операция texParameteri(target: GLenum, pname: GLenum, param: GLint)

  операция uniform1f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat)

  операция uniform1i(location: WebGLUniformLocation?FUCKFUCK, x: GLint)

  операция uniform2f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat)

  операция uniform2i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint)

  операция uniform3f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat, z: GLfloat)

  операция uniform3i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint, z: GLint)

  операция uniform4f(location: WebGLUniformLocation?FUCKFUCK, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция uniform4i(location: WebGLUniformLocation?FUCKFUCK, x: GLint, y: GLint, z: GLint, w: GLint)

  операция useProgram(program: WebGLProgram?FUCKFUCK)

  операция validateProgram(program: WebGLProgram)

  операция vertexAttrib1f(index: GLuint, x: GLfloat)

  операция vertexAttrib1fv(index: GLuint, values: Float32List)

  операция vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat)

  операция vertexAttrib2fv(index: GLuint, values: Float32List)

  операция vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat)

  операция vertexAttrib3fv(index: GLuint, values: Float32List)

  операция vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция vertexAttrib4fv(index: GLuint, values: Float32List)

  операция vertexAttribPointer(index: GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr)

  операция viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  защищено 
  DEPTH_BUFFER_BIT: 0x00000100

  защищено 
  STENCIL_BUFFER_BIT: 0x00000400

  защищено 
  COLOR_BUFFER_BIT: 0x00004000

  защищено 
  POINTS: 0x0000

  защищено 
  LINES: 0x0001

  защищено 
  LINE_LOOP: 0x0002

  защищено 
  LINE_STRIP: 0x0003

  защищено 
  TRIANGLES: 0x0004

  защищено 
  TRIANGLE_STRIP: 0x0005

  защищено 
  TRIANGLE_FAN: 0x0006

  защищено 
  ZERO: 0

  защищено 
  ONE: 1

  защищено 
  SRC_COLOR: 0x0300

  защищено 
  ONE_MINUS_SRC_COLOR: 0x0301

  защищено 
  SRC_ALPHA: 0x0302

  защищено 
  ONE_MINUS_SRC_ALPHA: 0x0303

  защищено 
  DST_ALPHA: 0x0304

  защищено 
  ONE_MINUS_DST_ALPHA: 0x0305

  защищено 
  DST_COLOR: 0x0306

  защищено 
  ONE_MINUS_DST_COLOR: 0x0307

  защищено 
  SRC_ALPHA_SATURATE: 0x0308

  защищено 
  FUNC_ADD: 0x8006

  защищено 
  BLEND_EQUATION: 0x8009

  защищено 
  BLEND_EQUATION_RGB: 0x8009

  защищено 
  BLEND_EQUATION_ALPHA: 0x883D

  защищено 
  FUNC_SUBTRACT: 0x800A

  защищено 
  FUNC_REVERSE_SUBTRACT: 0x800B

  защищено 
  BLEND_DST_RGB: 0x80C8

  защищено 
  BLEND_SRC_RGB: 0x80C9

  защищено 
  BLEND_DST_ALPHA: 0x80CA

  защищено 
  BLEND_SRC_ALPHA: 0x80CB

  защищено 
  CONSTANT_COLOR: 0x8001

  защищено 
  ONE_MINUS_CONSTANT_COLOR: 0x8002

  защищено 
  CONSTANT_ALPHA: 0x8003

  защищено 
  ONE_MINUS_CONSTANT_ALPHA: 0x8004

  защищено 
  BLEND_COLOR: 0x8005

  защищено 
  ARRAY_BUFFER: 0x8892

  защищено 
  ELEMENT_ARRAY_BUFFER: 0x8893

  защищено 
  ARRAY_BUFFER_BINDING: 0x8894

  защищено 
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895

  защищено 
  STREAM_DRAW: 0x88E0

  защищено 
  STATIC_DRAW: 0x88E4

  защищено 
  DYNAMIC_DRAW: 0x88E8

  защищено 
  BUFFER_SIZE: 0x8764

  защищено 
  BUFFER_USAGE: 0x8765

  защищено 
  CURRENT_VERTEX_ATTRIB: 0x8626

  защищено 
  FRONT: 0x0404

  защищено 
  BACK: 0x0405

  защищено 
  FRONT_AND_BACK: 0x0408

  защищено 
  CULL_FACE: 0x0B44

  защищено 
  BLEND: 0x0BE2

  защищено 
  DITHER: 0x0BD0

  защищено 
  STENCIL_TEST: 0x0B90

  защищено 
  DEPTH_TEST: 0x0B71

  защищено 
  SCISSOR_TEST: 0x0C11

  защищено 
  POLYGON_OFFSET_FILL: 0x8037

  защищено 
  SAMPLE_ALPHA_TO_COVERAGE: 0x809E

  защищено 
  SAMPLE_COVERAGE: 0x80A0

  защищено 
  NO_ERROR: 0

  защищено 
  INVALID_ENUM: 0x0500

  защищено 
  INVALID_VALUE: 0x0501

  защищено 
  INVALID_OPERATION: 0x0502

  защищено 
  OUT_OF_MEMORY: 0x0505

  защищено 
  CW: 0x0900

  защищено 
  CCW: 0x0901

  защищено 
  LINE_WIDTH: 0x0B21

  защищено 
  ALIASED_POINT_SIZE_RANGE: 0x846D

  защищено 
  ALIASED_LINE_WIDTH_RANGE: 0x846E

  защищено 
  CULL_FACE_MODE: 0x0B45

  защищено 
  FRONT_FACE: 0x0B46

  защищено 
  DEPTH_RANGE: 0x0B70

  защищено 
  DEPTH_WRITEMASK: 0x0B72

  защищено 
  DEPTH_CLEAR_VALUE: 0x0B73

  защищено 
  DEPTH_FUNC: 0x0B74

  защищено 
  STENCIL_CLEAR_VALUE: 0x0B91

  защищено 
  STENCIL_FUNC: 0x0B92

  защищено 
  STENCIL_FAIL: 0x0B94

  защищено 
  STENCIL_PASS_DEPTH_FAIL: 0x0B95

  защищено 
  STENCIL_PASS_DEPTH_PASS: 0x0B96

  защищено 
  STENCIL_REF: 0x0B97

  защищено 
  STENCIL_VALUE_MASK: 0x0B93

  защищено 
  STENCIL_WRITEMASK: 0x0B98

  защищено 
  STENCIL_BACK_FUNC: 0x8800

  защищено 
  STENCIL_BACK_FAIL: 0x8801

  защищено 
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802

  защищено 
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803

  защищено 
  STENCIL_BACK_REF: 0x8CA3

  защищено 
  STENCIL_BACK_VALUE_MASK: 0x8CA4

  защищено 
  STENCIL_BACK_WRITEMASK: 0x8CA5

  защищено 
  VIEWPORT: 0x0BA2

  защищено 
  SCISSOR_BOX: 0x0C10

  защищено 
  COLOR_CLEAR_VALUE: 0x0C22

  защищено 
  COLOR_WRITEMASK: 0x0C23

  защищено 
  UNPACK_ALIGNMENT: 0x0CF5

  защищено 
  PACK_ALIGNMENT: 0x0D05

  защищено 
  MAX_TEXTURE_SIZE: 0x0D33

  защищено 
  MAX_VIEWPORT_DIMS: 0x0D3A

  защищено 
  SUBPIXEL_BITS: 0x0D50

  защищено 
  RED_BITS: 0x0D52

  защищено 
  GREEN_BITS: 0x0D53

  защищено 
  BLUE_BITS: 0x0D54

  защищено 
  ALPHA_BITS: 0x0D55

  защищено 
  DEPTH_BITS: 0x0D56

  защищено 
  STENCIL_BITS: 0x0D57

  защищено 
  POLYGON_OFFSET_UNITS: 0x2A00

  защищено 
  POLYGON_OFFSET_FACTOR: 0x8038

  защищено 
  TEXTURE_BINDING_2D: 0x8069

  защищено 
  SAMPLE_BUFFERS: 0x80A8

  защищено 
  SAMPLES: 0x80A9

  защищено 
  SAMPLE_COVERAGE_VALUE: 0x80AA

  защищено 
  SAMPLE_COVERAGE_INVERT: 0x80AB

  защищено 
  COMPRESSED_TEXTURE_FORMATS: 0x86A3

  защищено 
  DONT_CARE: 0x1100

  защищено 
  FASTEST: 0x1101

  защищено 
  NICEST: 0x1102

  защищено 
  GENERATE_MIPMAP_HINT: 0x8192

  защищено 
  BYTE: 0x1400

  защищено 
  UNSIGNED_BYTE: 0x1401

  защищено 
  SHORT: 0x1402

  защищено 
  UNSIGNED_SHORT: 0x1403

  защищено 
  INT: 0x1404

  защищено 
  UNSIGNED_INT: 0x1405

  защищено 
  FLOAT: 0x1406

  защищено 
  DEPTH_COMPONENT: 0x1902

  защищено 
  ALPHA: 0x1906

  защищено 
  RGB: 0x1907

  защищено 
  RGBA: 0x1908

  защищено 
  LUMINANCE: 0x1909

  защищено 
  LUMINANCE_ALPHA: 0x190A

  защищено 
  UNSIGNED_SHORT_4_4_4_4: 0x8033

  защищено 
  UNSIGNED_SHORT_5_5_5_1: 0x8034

  защищено 
  UNSIGNED_SHORT_5_6_5: 0x8363

  защищено 
  FRAGMENT_SHADER: 0x8B30

  защищено 
  VERTEX_SHADER: 0x8B31

  защищено 
  MAX_VERTEX_ATTRIBS: 0x8869

  защищено 
  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB

  защищено 
  MAX_VARYING_VECTORS: 0x8DFC

  защищено 
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D

  защищено 
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C

  защищено 
  MAX_TEXTURE_IMAGE_UNITS: 0x8872

  защищено 
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD

  защищено 
  SHADER_TYPE: 0x8B4F

  защищено 
  DELETE_STATUS: 0x8B80

  защищено 
  LINK_STATUS: 0x8B82

  защищено 
  VALIDATE_STATUS: 0x8B83

  защищено 
  ATTACHED_SHADERS: 0x8B85

  защищено 
  ACTIVE_UNIFORMS: 0x8B86

  защищено 
  ACTIVE_ATTRIBUTES: 0x8B89

  защищено 
  SHADING_LANGUAGE_VERSION: 0x8B8C

  защищено 
  CURRENT_PROGRAM: 0x8B8D

  защищено 
  NEVER: 0x0200

  защищено 
  LESS: 0x0201

  защищено 
  EQUAL: 0x0202

  защищено 
  LEQUAL: 0x0203

  защищено 
  GREATER: 0x0204

  защищено 
  NOTEQUAL: 0x0205

  защищено 
  GEQUAL: 0x0206

  защищено 
  ALWAYS: 0x0207

  защищено 
  KEEP: 0x1E00

  защищено 
  REPLACE: 0x1E01

  защищено 
  INCR: 0x1E02

  защищено 
  DECR: 0x1E03

  защищено 
  INVERT: 0x150A

  защищено 
  INCR_WRAP: 0x8507

  защищено 
  DECR_WRAP: 0x8508

  защищено 
  VENDOR: 0x1F00

  защищено 
  RENDERER: 0x1F01

  защищено 
  VERSION: 0x1F02

  защищено 
  NEAREST: 0x2600

  защищено 
  LINEAR: 0x2601

  защищено 
  NEAREST_MIPMAP_NEAREST: 0x2700

  защищено 
  LINEAR_MIPMAP_NEAREST: 0x2701

  защищено 
  NEAREST_MIPMAP_LINEAR: 0x2702

  защищено 
  LINEAR_MIPMAP_LINEAR: 0x2703

  защищено 
  TEXTURE_MAG_FILTER: 0x2800

  защищено 
  TEXTURE_MIN_FILTER: 0x2801

  защищено 
  TEXTURE_WRAP_S: 0x2802

  защищено 
  TEXTURE_WRAP_T: 0x2803

  защищено 
  TEXTURE_2D: 0x0DE1

  защищено 
  TEXTURE: 0x1702

  защищено 
  TEXTURE_CUBE_MAP: 0x8513

  защищено 
  TEXTURE_BINDING_CUBE_MAP: 0x8514

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A

  защищено 
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C

  защищено 
  TEXTURE0: 0x84C0

  защищено 
  TEXTURE1: 0x84C1

  защищено 
  TEXTURE2: 0x84C2

  защищено 
  TEXTURE3: 0x84C3

  защищено 
  TEXTURE4: 0x84C4

  защищено 
  TEXTURE5: 0x84C5

  защищено 
  TEXTURE6: 0x84C6

  защищено 
  TEXTURE7: 0x84C7

  защищено 
  TEXTURE8: 0x84C8

  защищено 
  TEXTURE9: 0x84C9

  защищено 
  TEXTURE10: 0x84CA

  защищено 
  TEXTURE11: 0x84CB

  защищено 
  TEXTURE12: 0x84CC

  защищено 
  TEXTURE13: 0x84CD

  защищено 
  TEXTURE14: 0x84CE

  защищено 
  TEXTURE15: 0x84CF

  защищено 
  TEXTURE16: 0x84D0

  защищено 
  TEXTURE17: 0x84D1

  защищено 
  TEXTURE18: 0x84D2

  защищено 
  TEXTURE19: 0x84D3

  защищено 
  TEXTURE20: 0x84D4

  защищено 
  TEXTURE21: 0x84D5

  защищено 
  TEXTURE22: 0x84D6

  защищено 
  TEXTURE23: 0x84D7

  защищено 
  TEXTURE24: 0x84D8

  защищено 
  TEXTURE25: 0x84D9

  защищено 
  TEXTURE26: 0x84DA

  защищено 
  TEXTURE27: 0x84DB

  защищено 
  TEXTURE28: 0x84DC

  защищено 
  TEXTURE29: 0x84DD

  защищено 
  TEXTURE30: 0x84DE

  защищено 
  TEXTURE31: 0x84DF

  защищено 
  ACTIVE_TEXTURE: 0x84E0

  защищено 
  REPEAT: 0x2901

  защищено 
  CLAMP_TO_EDGE: 0x812F

  защищено 
  MIRRORED_REPEAT: 0x8370

  защищено 
  FLOAT_VEC2: 0x8B50

  защищено 
  FLOAT_VEC3: 0x8B51

  защищено 
  FLOAT_VEC4: 0x8B52

  защищено 
  INT_VEC2: 0x8B53

  защищено 
  INT_VEC3: 0x8B54

  защищено 
  INT_VEC4: 0x8B55

  защищено 
  BOOL: 0x8B56

  защищено 
  BOOL_VEC2: 0x8B57

  защищено 
  BOOL_VEC3: 0x8B58

  защищено 
  BOOL_VEC4: 0x8B59

  защищено 
  FLOAT_MAT2: 0x8B5A

  защищено 
  FLOAT_MAT3: 0x8B5B

  защищено 
  FLOAT_MAT4: 0x8B5C

  защищено 
  SAMPLER_2D: 0x8B5E

  защищено 
  SAMPLER_CUBE: 0x8B60

  защищено 
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622

  защищено 
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623

  защищено 
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624

  защищено 
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625

  защищено 
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A

  защищено 
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645

  защищено 
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F

  защищено 
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A

  защищено 
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B

  защищено 
  COMPILE_STATUS: 0x8B81

  защищено 
  LOW_FLOAT: 0x8DF0

  защищено 
  MEDIUM_FLOAT: 0x8DF1

  защищено 
  HIGH_FLOAT: 0x8DF2

  защищено 
  LOW_INT: 0x8DF3

  защищено 
  MEDIUM_INT: 0x8DF4

  защищено 
  HIGH_INT: 0x8DF5

  защищено 
  FRAMEBUFFER: 0x8D40

  защищено 
  RENDERBUFFER: 0x8D41

  защищено 
  RGBA4: 0x8056

  защищено 
  RGB5_A1: 0x8057

  защищено 
  RGB565: 0x8D62

  защищено 
  DEPTH_COMPONENT16: 0x81A5

  защищено 
  STENCIL_INDEX8: 0x8D48

  защищено 
  DEPTH_STENCIL: 0x84F9

  защищено 
  RENDERBUFFER_WIDTH: 0x8D42

  защищено 
  RENDERBUFFER_HEIGHT: 0x8D43

  защищено 
  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44

  защищено 
  RENDERBUFFER_RED_SIZE: 0x8D50

  защищено 
  RENDERBUFFER_GREEN_SIZE: 0x8D51

  защищено 
  RENDERBUFFER_BLUE_SIZE: 0x8D52

  защищено 
  RENDERBUFFER_ALPHA_SIZE: 0x8D53

  защищено 
  RENDERBUFFER_DEPTH_SIZE: 0x8D54

  защищено 
  RENDERBUFFER_STENCIL_SIZE: 0x8D55

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3

  защищено 
  COLOR_ATTACHMENT0: 0x8CE0

  защищено 
  DEPTH_ATTACHMENT: 0x8D00

  защищено 
  STENCIL_ATTACHMENT: 0x8D20

  защищено 
  DEPTH_STENCIL_ATTACHMENT: 0x821A

  защищено 
  NONE: 0

  защищено 
  FRAMEBUFFER_COMPLETE: 0x8CD5

  защищено 
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6

  защищено 
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7

  защищено 
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9

  защищено 
  FRAMEBUFFER_UNSUPPORTED: 0x8CDD

  защищено 
  FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  RENDERBUFFER_BINDING: 0x8CA7

  защищено 
  MAX_RENDERBUFFER_SIZE: 0x84E8

  защищено 
  INVALID_FRAMEBUFFER_OPERATION: 0x0506

  защищено 
  UNPACK_FLIP_Y_WEBGL: 0x9240

  защищено 
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241

  защищено 
  CONTEXT_LOST_WEBGL: 0x9242

  защищено 
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243

  защищено 
  BROWSER_DEFAULT_WEBGL: 0x9244
}


тип WebGLRenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, data: BufferSource?FUCKFUCK, usage: GLenum)

  операция bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type: GLenum, pixels: ArrayBufferView?FUCKFUCK)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type: GLenum, source: TexImageSource)

  операция uniform1fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform1iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform2fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform2iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform3fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform3iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniform4fv(location: WebGLUniformLocation?FUCKFUCK, v: Float32List)

  операция uniform4iv(location: WebGLUniformLocation?FUCKFUCK, v: Int32List)

  операция uniformMatrix2fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)

  операция uniformMatrix3fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)

  операция uniformMatrix4fv(location: WebGLUniformLocation?FUCKFUCK, transpose: GLboolean, value: Float32List)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSampler) */

тип WebGLSampler = интерфейс
{

}


внешнее
/*(!) var */ WebGLSampler: объект { prototype: WebGLSampler; при создании()/*(!) no_type */ Объект? }


/**
* The WebGLShader is part of the WebGL API and can either be a vertex or a fragment shader. A WebGLProgram requires both types of shaders.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShader)
*/

тип WebGLShader = интерфейс
{

}


внешнее
/*(!) var */ WebGLShader: объект { prototype: WebGLShader; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getShaderPrecisionFormat() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShaderPrecisionFormat)
*/

тип WebGLShaderPrecisionFormat = интерфейс
{
  защищено 
  precision: GLint

  защищено 
  rangeMax: GLint

  защищено 
  rangeMin: GLint
}


внешнее
/*(!) var */ WebGLShaderPrecisionFormat: объект { prototype: WebGLShaderPrecisionFormat; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSync) */

тип WebGLSync = интерфейс
{

}


внешнее
/*(!) var */ WebGLSync: объект { prototype: WebGLSync; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents an opaque texture object providing storage and state for texturing operations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTexture)
*/

тип WebGLTexture = интерфейс
{

}


внешнее
/*(!) var */ WebGLTexture: объект { prototype: WebGLTexture; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTransformFeedback) */

тип WebGLTransformFeedback = интерфейс
{

}


внешнее
/*(!) var */ WebGLTransformFeedback: объект { prototype: WebGLTransformFeedback; при создании()/*(!) no_type */ Объект? }


/**
* Part of the WebGL API and represents the location of a uniform variable in a shader program.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLUniformLocation)
*/

тип WebGLUniformLocation = интерфейс
{

}


внешнее
/*(!) var */ WebGLUniformLocation: объект { prototype: WebGLUniformLocation; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObject) */

тип WebGLVertexArrayObject = интерфейс
{

}


внешнее
/*(!) var */ WebGLVertexArrayObject: объект { prototype: WebGLVertexArrayObject; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObjectOES) */

тип WebGLVertexArrayObjectOES = интерфейс
{

}


тип WebSocketEventMap = интерфейс
{
  "close": CloseEvent

  "error": Event

  "message": MessageEvent

  "open": Event
}


/**
* Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)
*/

тип WebSocket = интерфейс
{
  binaryType: BinaryType

  защищено 
  bufferedAmount: Число

  защищено 
  extensions: Текст

  onclose: операция(this: WebSocket, ev: CloseEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: WebSocket, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: WebSocket, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onopen: операция(this: WebSocket, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  protocol: Текст

  защищено 
  readyState: Число

  защищено 
  url: Текст

  операция close(code: Число?FUCKFUCK = пусто, reason: Текст?FUCKFUCK = пусто)

  операция send(data: Текст | ArrayBufferLike | Blob | ArrayBufferView)

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSING: 2

  защищено 
  CLOSED: 3

  операция addEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ WebSocket: объект { prototype: WebSocket; при создании(url: Текст | URL, protocols: Текст | Список<Текст> | пусто = пусто)/*(!) no_type */ Объект?; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSING: 2; защищено  CLOSED: 3 }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransport)
*/

тип WebTransport = интерфейс
{
  защищено 
  closed: Promise<WebTransportCloseInfo>

  защищено 
  datagrams: WebTransportDatagramDuplexStream

  защищено 
  incomingBidirectionalStreams: ReadableStream

  защищено 
  incomingUnidirectionalStreams: ReadableStream

  защищено 
  ready: Promise<пусто>

  операция close(closeInfo: WebTransportCloseInfo?FUCKFUCK = пусто)

  операция createBidirectionalStream(options: WebTransportSendStreamOptions?FUCKFUCK = пусто): Promise<WebTransportBidirectionalStream>

  операция createUnidirectionalStream(options: WebTransportSendStreamOptions?FUCKFUCK = пусто): Promise<WritableStream>
}


внешнее
/*(!) var */ WebTransport: объект { prototype: WebTransport; при создании(url: Текст | URL, options: WebTransportOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportBidirectionalStream)
*/

тип WebTransportBidirectionalStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportBidirectionalStream: объект { prototype: WebTransportBidirectionalStream; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportDatagramDuplexStream)
*/

тип WebTransportDatagramDuplexStream = интерфейс
{
  incomingHighWaterMark: Число

  incomingMaxAge: Число

  защищено 
  maxDatagramSize: Число

  outgoingHighWaterMark: Число

  outgoingMaxAge: Число

  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportDatagramDuplexStream: объект { prototype: WebTransportDatagramDuplexStream; при создании()/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportError)
*/

тип WebTransportError = интерфейс
{
  защищено 
  source: WebTransportErrorSource

  защищено 
  streamErrorCode: Число?FUCKFUCK
}


внешнее
/*(!) var */ WebTransportError: объект { prototype: WebTransportError; при создании(message: Текст?FUCKFUCK = пусто, options: WebTransportErrorOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Events that occur due to the user moving a mouse wheel or similar input device.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WheelEvent)
*/

тип WheelEvent = интерфейс
{
  защищено 
  deltaMode: Число

  защищено 
  deltaX: Число

  защищено 
  deltaY: Число

  защищено 
  deltaZ: Число

  защищено 
  DOM_DELTA_PIXEL: 0x00

  защищено 
  DOM_DELTA_LINE: 0x01

  защищено 
  DOM_DELTA_PAGE: 0x02
}


внешнее
/*(!) var */ WheelEvent: объект { prototype: WheelEvent; при создании(type: Текст, eventInitDict: WheelEventInit?FUCKFUCK = пусто)/*(!) no_type */ Объект?; защищено  DOM_DELTA_PIXEL: 0x00; защищено  DOM_DELTA_LINE: 0x01; защищено  DOM_DELTA_PAGE: 0x02 }


тип WindowEventMap = интерфейс
{
  "DOMContentLoaded": Event

  "devicemotion": DeviceMotionEvent

  "deviceorientation": DeviceOrientationEvent

  "gamepadconnected": GamepadEvent

  "gamepaddisconnected": GamepadEvent

  "orientationchange": Event
}


/**
* A window containing a DOM document; the document property points to the DOM document loaded in that window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window)
*/

тип Window = интерфейс
{
  защищено 
  clientInformation: Navigator

  защищено 
  closed: ДаНет

  защищено 
  customElements: CustomElementRegistry

  защищено 
  devicePixelRatio: Число

  защищено 
  document: Document

  защищено 
  event: Event?FUCKFUCK

  защищено 
  external: External

  защищено 
  frameElement: Element?FUCKFUCK

  защищено 
  frames: WindowProxy

  защищено 
  history: History

  защищено 
  innerHeight: Число

  защищено 
  innerWidth: Число

  защищено 
  length: Число

  операция location(): Location

  операция location(href: Текст | Location)/*(!) no_type */ Объект?

  защищено 
  locationbar: BarProp

  защищено 
  menubar: BarProp

  name: Текст

  защищено 
  navigator: Navigator

  ondevicemotion: операция(this: Window, ev: DeviceMotionEvent): /*(!) any */ Объект??FUCKFUCK

  ondeviceorientation: операция(this: Window, ev: DeviceOrientationEvent): /*(!) any */ Объект??FUCKFUCK

  onorientationchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK

  opener: /*(!) any */ Объект?

  защищено 
  orientation: Число

  защищено 
  outerHeight: Число

  защищено 
  outerWidth: Число

  защищено 
  pageXOffset: Число

  защищено 
  pageYOffset: Число

  защищено 
  parent: WindowProxy

  защищено 
  personalbar: BarProp

  защищено 
  screen: Screen

  защищено 
  screenLeft: Число

  защищено 
  screenTop: Число

  защищено 
  screenX: Число

  защищено 
  screenY: Число

  защищено 
  scrollX: Число

  защищено 
  scrollY: Число

  защищено 
  scrollbars: BarProp

  защищено 
  self: /*(!) Window & typeof globalThis */ Объект?

  защищено 
  speechSynthesis: SpeechSynthesis

  status: Текст

  защищено 
  statusbar: BarProp

  защищено 
  toolbar: BarProp

  защищено 
  top: WindowProxy?FUCKFUCK

  защищено 
  visualViewport: VisualViewport?FUCKFUCK

  защищено 
  window: /*(!) Window & typeof globalThis */ Объект?

  операция alert(message: /*(!) any */ Объект??FUCKFUCK = пусто)

  операция blur()

  операция cancelIdleCallback(handle: Число)

  операция captureEvents()

  операция close()

  операция confirm(message: Текст?FUCKFUCK = пусто): ДаНет

  операция focus()

  операция getComputedStyle(elt: Element, pseudoElt: Текст?FUCKFUCK = пусто): CSSStyleDeclaration

  операция getSelection(): Selection?FUCKFUCK

  операция matchMedia(query: Текст): MediaQueryList

  операция moveBy(x: Число, y: Число)

  операция moveTo(x: Число, y: Число)

  операция open(url: Текст | URL | пусто = пусто, target: Текст?FUCKFUCK = пусто, features: Текст?FUCKFUCK = пусто): WindowProxy?FUCKFUCK

  операция postMessage(message: /*(!) any */ Объект?, targetOrigin: Текст, transfer: Список<Transferable>?FUCKFUCK = пусто)

  операция postMessage(message: /*(!) any */ Объект?, options: WindowPostMessageOptions?FUCKFUCK = пусто)

  операция print()

  операция prompt(message: Текст?FUCKFUCK = пусто, _default: Текст?FUCKFUCK = пусто): Текст?FUCKFUCK

  операция releaseEvents()

  операция requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions?FUCKFUCK = пусто): Число

  операция resizeBy(x: Число, y: Число)

  операция resizeTo(width: Число, height: Число)

  операция scroll(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scroll(x: Число, y: Число)

  операция scrollBy(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scrollBy(x: Число, y: Число)

  операция scrollTo(options: ScrollToOptions?FUCKFUCK = пусто)

  операция scrollTo(x: Число, y: Число)

  операция stop()

  операция addEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

  /*(!) [index: number]: Window*/
}


внешнее
/*(!) var */ Window: объект { prototype: Window; при создании()/*(!) no_type */ Объект? }


тип WindowEventHandlersEventMap = интерфейс
{
  "afterprint": Event

  "beforeprint": Event

  "beforeunload": BeforeUnloadEvent

  "gamepadconnected": GamepadEvent

  "gamepaddisconnected": GamepadEvent

  "hashchange": HashChangeEvent

  "languagechange": Event

  "message": MessageEvent

  "messageerror": MessageEvent

  "offline": Event

  "online": Event

  "pagehide": PageTransitionEvent

  "pageshow": PageTransitionEvent

  "popstate": PopStateEvent

  "rejectionhandled": PromiseRejectionEvent

  "storage": StorageEvent

  "unhandledrejection": PromiseRejectionEvent

  "unload": Event
}


тип WindowEventHandlers = интерфейс
{
  onafterprint: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onbeforeprint: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onbeforeunload: операция(this: WindowEventHandlers, ev: BeforeUnloadEvent): /*(!) any */ Объект??FUCKFUCK

  ongamepadconnected: операция(this: WindowEventHandlers, ev: GamepadEvent): /*(!) any */ Объект??FUCKFUCK

  ongamepaddisconnected: операция(this: WindowEventHandlers, ev: GamepadEvent): /*(!) any */ Объект??FUCKFUCK

  onhashchange: операция(this: WindowEventHandlers, ev: HashChangeEvent): /*(!) any */ Объект??FUCKFUCK

  onlanguagechange: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onmessage: операция(this: WindowEventHandlers, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: WindowEventHandlers, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onoffline: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  ononline: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  onpagehide: операция(this: WindowEventHandlers, ev: PageTransitionEvent): /*(!) any */ Объект??FUCKFUCK

  onpageshow: операция(this: WindowEventHandlers, ev: PageTransitionEvent): /*(!) any */ Объект??FUCKFUCK

  onpopstate: операция(this: WindowEventHandlers, ev: PopStateEvent): /*(!) any */ Объект??FUCKFUCK

  onrejectionhandled: операция(this: WindowEventHandlers, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK

  onstorage: операция(this: WindowEventHandlers, ev: StorageEvent): /*(!) any */ Объект??FUCKFUCK

  onunhandledrejection: операция(this: WindowEventHandlers, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK

  onunload: операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof WindowEventHandlersEventMap */ Объект?>(type: K, listener: операция(this: WindowEventHandlers, ev: /*(!) WindowEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WindowEventHandlersEventMap */ Объект?>(type: K, listener: операция(this: WindowEventHandlers, ev: /*(!) WindowEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


тип WindowLocalStorage = интерфейс
{
  защищено 
  localStorage: Storage
}


тип WindowOrWorkerGlobalScope = интерфейс
{
  защищено 
  caches: CacheStorage

  защищено 
  crossOriginIsolated: ДаНет

  защищено 
  crypto: Crypto

  защищено 
  indexedDB: IDBFactory

  защищено 
  isSecureContext: ДаНет

  защищено 
  origin: Текст

  защищено 
  performance: Performance

  операция atob(data: Текст): Текст

  операция btoa(data: Текст): Текст

  операция clearInterval(id: Число?FUCKFUCK)

  операция clearTimeout(id: Число?FUCKFUCK)

  операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

  операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

  операция fetch(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто): Promise<Response>

  операция queueMicrotask(callback: VoidFunction)

  операция reportError(e: /*(!) any */ Объект?)

  #js.МассивПараметров
  операция setInterval(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

  #js.МассивПараметров
  операция setTimeout(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

  операция structuredClone<T>(value: T, options: StructuredSerializeOptions?FUCKFUCK = пусто): T
}


тип WindowSessionStorage = интерфейс
{
  защищено 
  sessionStorage: Storage
}


тип WorkerEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Web Workers API interface represents a background task that can be easily created and can send messages back to its creator. Creating a worker is as simple as calling the Worker() constructor and specifying a script to be run in the worker thread.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Worker)
*/

тип Worker = интерфейс
{
  onmessage: операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  onmessageerror: операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions?FUCKFUCK = пусто)

  операция terminate()

  операция addEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ Worker: объект { prototype: Worker; при создании(scriptURL: Текст | URL, options: WorkerOptions?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Worklet)
*/

тип Worklet = интерфейс
{
  операция addModule(moduleURL: Текст | URL, options: WorkletOptions?FUCKFUCK = пусто): Promise<Ничего>
}


внешнее
/*(!) var */ Worklet: объект { prototype: Worklet; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)
*/

тип WritableStream<W> = интерфейс
{
  защищено 
  locked: ДаНет

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция getWriter(): WritableStreamDefaultWriter<W>
}


внешнее
/*(!) var */ WritableStream: объект { prototype: WritableStream; при создании(underlyingSink: UnderlyingSink<W>?FUCKFUCK = пусто, strategy: QueuingStrategy<W>?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)
*/

тип WritableStreamDefaultController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция error(e: /*(!) any */ Объект??FUCKFUCK = пусто)
}


внешнее
/*(!) var */ WritableStreamDefaultController: объект { prototype: WritableStreamDefaultController; при создании()/*(!) no_type */ Объект? }


/**
* This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the < writer to the WritableStream ensuring that no other streams can write to the underlying sink.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)
*/

тип WritableStreamDefaultWriter<W> = интерфейс
{
  защищено 
  closed: Promise<пусто>

  защищено 
  desiredSize: Число?FUCKFUCK

  защищено 
  ready: Promise<пусто>

  операция abort(reason: /*(!) any */ Объект??FUCKFUCK = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция releaseLock()

  операция write(chunk: W?FUCKFUCK = пусто): Promise<Ничего>
}


внешнее
/*(!) var */ WritableStreamDefaultWriter: объект { prototype: WritableStreamDefaultWriter; при создании(stream: WritableStream<W>)/*(!) no_type */ Объект? }


/**
* An XML document. It inherits from the generic Document and does not add any specific methods or properties to it: nevertheless, several algorithms behave differently with the two types of documents.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLDocument)
*/

тип XMLDocument = интерфейс
{
  операция addEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: XMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type: K, listener: операция(this: XMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLDocument: объект { prototype: XMLDocument; при создании()/*(!) no_type */ Объект? }


тип XMLHttpRequestEventMap = интерфейс
{
  "readystatechange": Event
}


/**
* Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest)
*/

тип XMLHttpRequest = интерфейс
{
  onreadystatechange: операция(this: XMLHttpRequest, ev: Event): /*(!) any */ Объект??FUCKFUCK

  защищено 
  readyState: Число

  защищено 
  response: /*(!) any */ Объект?

  защищено 
  responseText: Текст

  responseType: XMLHttpRequestResponseType

  защищено 
  responseURL: Текст

  защищено 
  responseXML: Document?FUCKFUCK

  защищено 
  status: Число

  защищено 
  statusText: Текст

  timeout: Число

  защищено 
  upload: XMLHttpRequestUpload

  withCredentials: ДаНет

  операция abort()

  операция getAllResponseHeaders(): Текст

  операция getResponseHeader(name: Текст): Текст?FUCKFUCK

  операция open(method: Текст, url: Текст | URL)

  операция open(method: Текст, url: Текст | URL, async: ДаНет, username: Текст?FUCKFUCK = пусто, password: Текст?FUCKFUCK = пусто)

  операция overrideMimeType(mime: Текст)

  операция send(body: Document | XMLHttpRequestBodyInit | пусто | пусто = пусто)

  операция setRequestHeader(name: Текст, value: Текст)

  защищено 
  UNSENT: 0

  защищено 
  OPENED: 1

  защищено 
  HEADERS_RECEIVED: 2

  защищено 
  LOADING: 3

  защищено 
  DONE: 4

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequest: объект { prototype: XMLHttpRequest; при создании()/*(!) no_type */ Объект?; защищено  UNSENT: 0; защищено  OPENED: 1; защищено  HEADERS_RECEIVED: 2; защищено  LOADING: 3; защищено  DONE: 4 }


тип XMLHttpRequestEventTargetEventMap = интерфейс
{
  "abort": ProgressEvent<XMLHttpRequestEventTarget>

  "error": ProgressEvent<XMLHttpRequestEventTarget>

  "load": ProgressEvent<XMLHttpRequestEventTarget>

  "loadend": ProgressEvent<XMLHttpRequestEventTarget>

  "loadstart": ProgressEvent<XMLHttpRequestEventTarget>

  "progress": ProgressEvent<XMLHttpRequestEventTarget>

  "timeout": ProgressEvent<XMLHttpRequestEventTarget>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestEventTarget) */

тип XMLHttpRequestEventTarget = интерфейс
{
  onabort: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onerror: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onload: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onloadend: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onloadstart: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  onprogress: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  ontimeout: операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestEventTarget: объект { prototype: XMLHttpRequestEventTarget; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestUpload) */

тип XMLHttpRequestUpload = интерфейс
{
  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

  операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestUpload: объект { prototype: XMLHttpRequestUpload; при создании()/*(!) no_type */ Объект? }


/**
* Provides the serializeToString() method to construct an XML string representing a DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLSerializer)
*/

тип XMLSerializer = интерфейс
{
  операция serializeToString(root: Node): Текст
}


внешнее
/*(!) var */ XMLSerializer: объект { prototype: XMLSerializer; при создании()/*(!) no_type */ Объект? }


/**
* The XPathEvaluator interface allows to compile and evaluate XPath expressions.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathEvaluator)
*/

тип XPathEvaluator = интерфейс
{

}


внешнее
/*(!) var */ XPathEvaluator: объект { prototype: XPathEvaluator; при создании()/*(!) no_type */ Объект? }


тип XPathEvaluatorBase = интерфейс
{
  операция createExpression(expression: Текст, resolver: XPathNSResolver?FUCKFUCK = пусто): XPathExpression

  операция createNSResolver(nodeResolver: Node): Node

  операция evaluate(expression: Текст, contextNode: Node, resolver: XPathNSResolver?FUCKFUCK = пусто, type: Число?FUCKFUCK = пусто, result: XPathResult?FUCKFUCK = пусто): XPathResult
}


/**
* This interface is a compiled XPath expression that can be evaluated on a document or specific node to return information its DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathExpression)
*/

тип XPathExpression = интерфейс
{
  операция evaluate(contextNode: Node, type: Число?FUCKFUCK = пусто, result: XPathResult?FUCKFUCK = пусто): XPathResult
}


внешнее
/*(!) var */ XPathExpression: объект { prototype: XPathExpression; при создании()/*(!) no_type */ Объект? }


/**
* The results generated by evaluating an XPath expression within the context of a given node.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathResult)
*/

тип XPathResult = интерфейс
{
  защищено 
  booleanValue: ДаНет

  защищено 
  invalidIteratorState: ДаНет

  защищено 
  numberValue: Число

  защищено 
  resultType: Число

  защищено 
  singleNodeValue: Node?FUCKFUCK

  защищено 
  snapshotLength: Число

  защищено 
  stringValue: Текст

  операция iterateNext(): Node?FUCKFUCK

  операция snapshotItem(index: Число): Node?FUCKFUCK

  защищено 
  ANY_TYPE: 0

  защищено 
  NUMBER_TYPE: 1

  защищено 
  STRING_TYPE: 2

  защищено 
  BOOLEAN_TYPE: 3

  защищено 
  UNORDERED_NODE_ITERATOR_TYPE: 4

  защищено 
  ORDERED_NODE_ITERATOR_TYPE: 5

  защищено 
  UNORDERED_NODE_SNAPSHOT_TYPE: 6

  защищено 
  ORDERED_NODE_SNAPSHOT_TYPE: 7

  защищено 
  ANY_UNORDERED_NODE_TYPE: 8

  защищено 
  FIRST_ORDERED_NODE_TYPE: 9
}


внешнее
/*(!) var */ XPathResult: объект { prototype: XPathResult; при создании()/*(!) no_type */ Объект?; защищено  ANY_TYPE: 0; защищено  NUMBER_TYPE: 1; защищено  STRING_TYPE: 2; защищено  BOOLEAN_TYPE: 3; защищено  UNORDERED_NODE_ITERATOR_TYPE: 4; защищено  ORDERED_NODE_ITERATOR_TYPE: 5; защищено  UNORDERED_NODE_SNAPSHOT_TYPE: 6; защищено  ORDERED_NODE_SNAPSHOT_TYPE: 7; защищено  ANY_UNORDERED_NODE_TYPE: 8; защищено  FIRST_ORDERED_NODE_TYPE: 9 }


/**
* An XSLTProcessor applies an XSLT stylesheet transformation to an XML document to produce a new XML document as output. It has methods to load the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to apply the transformation to documents.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XSLTProcessor)
*/

тип XSLTProcessor = интерфейс
{
  операция clearParameters()

  операция getParameter(namespaceURI: Текст?FUCKFUCK, localName: Текст): /*(!) any */ Объект?

  операция importStylesheet(style: Node)

  операция removeParameter(namespaceURI: Текст?FUCKFUCK, localName: Текст)

  операция reset()

  операция setParameter(namespaceURI: Текст?FUCKFUCK, localName: Текст, value: /*(!) any */ Объект?)

  операция transformToDocument(source: Node): Document

  операция transformToFragment(source: Node, output: Document): DocumentFragment
}


внешнее
/*(!) var */ XSLTProcessor: объект { prototype: XSLTProcessor; при создании()/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */

тип Console = интерфейс
{
  #js.МассивПараметров
  операция assert(condition: ДаНет?FUCKFUCK = пусто, data: Список</*(!) any */ Объект?>)

  операция clear()

  операция count(label: Текст?FUCKFUCK = пусто)

  операция countReset(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция debug(data: Список</*(!) any */ Объект?>)

  операция dir(item: /*(!) any */ Объект??FUCKFUCK = пусто, options: /*(!) any */ Объект??FUCKFUCK = пусто)

  #js.МассивПараметров
  операция dirxml(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция error(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция group(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция groupCollapsed(data: Список</*(!) any */ Объект?>)

  операция groupEnd()

  #js.МассивПараметров
  операция info(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция log(data: Список</*(!) any */ Объект?>)

  операция table(tabularData: /*(!) any */ Объект??FUCKFUCK = пусто, properties: Список<Текст>?FUCKFUCK = пусто)

  операция time(label: Текст?FUCKFUCK = пусто)

  операция timeEnd(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция timeLog(label: Текст?FUCKFUCK = пусто, data: Список</*(!) any */ Объект?>)

  операция timeStamp(label: Текст?FUCKFUCK = пусто)

  #js.МассивПараметров
  операция trace(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция warn(data: Список</*(!) any */ Объект?>)
}


внешнее
/*(!) var */ console: Console


/** Holds useful CSS-related methods. No object with this interface are implemented: it contains only static methods and therefore is a utilitarian interface. */

внешнее
/*(!) CSS */
{
/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция Hz(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция Q(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция ch(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cm(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqb(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqh(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqmax(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqmin(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция cqw(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция deg(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dpcm(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dpi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dppx(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvb(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvh(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvmax(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvmin(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция dvw(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция em(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/escape_static) */

операция escape(ident: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция ex(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция fr(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция grad(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция kHz(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvb(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvh(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvmax(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvmin(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция lvw(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция mm(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция ms(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция number(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция pc(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция percent(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция pt(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция px(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция rad(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/registerProperty_static) */

операция registerProperty(definition: PropertyDefinition)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция rem(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция s(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/supports_static) */

операция supports(property: Текст, value: Текст): ДаНет

операция supports(conditionText: Текст): ДаНет

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svb(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svh(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svmax(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svmin(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция svw(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция turn(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vb(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vh(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vi(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vmax(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vmin(value: Число): CSSUnitValue

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

операция vw(value: Число): CSSUnitValue
}

внешнее
/*(!) WebAssembly */
{
тип CompileError = интерфейс
{

}


/*(!) var */ CompileError: объект { prototype: CompileError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): CompileError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Global) */

тип Global<T = ValueType> = интерфейс
{
  value: /*(!) ValueTypeMap[T] */ Объект?

  операция valueOf(): /*(!) ValueTypeMap[T] */ Объект?
}


/*(!) var */ Global: объект { prototype: Global; при создании(descriptor: GlobalDescriptor<T>, v: /*(!) ValueTypeMap[T] */ Объект??FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance) */

тип Instance = интерфейс
{
  защищено 
  exports: Exports
}


/*(!) var */ Instance: объект { prototype: Instance; при создании(module: Module, importObject: Imports?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип LinkError = интерфейс
{

}


/*(!) var */ LinkError: объект { prototype: LinkError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): LinkError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory) */

тип Memory = интерфейс
{
  защищено 
  buffer: ArrayBuffer

  операция grow(delta: Число): Число
}


/*(!) var */ Memory: объект { prototype: Memory; при создании(descriptor: MemoryDescriptor)/*(!) no_type */ Объект? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) */

тип Module = интерфейс
{

}


/*(!) var */ Module: объект { prototype: Module; при создании(bytes: BufferSource)/*(!) no_type */ Объект?; операция customSections(moduleObject: Module, sectionName: Текст): Список<ArrayBuffer>; операция exports(moduleObject: Module): Список<ModuleExportDescriptor>; операция imports(moduleObject: Module): Список<ModuleImportDescriptor> }


тип RuntimeError = интерфейс
{

}


/*(!) var */ RuntimeError: объект { prototype: RuntimeError; при создании(message: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект?; /*(!) (message?: string): RuntimeError*/ }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Table) */

тип Table = интерфейс
{
  защищено 
  length: Число

  операция get(index: Число): /*(!) any */ Объект?

  операция grow(delta: Число, value: /*(!) any */ Объект??FUCKFUCK = пусто): Число

  операция set(index: Число, value: /*(!) any */ Объект??FUCKFUCK = пусто)
}


/*(!) var */ Table: объект { prototype: Table; при создании(descriptor: TableDescriptor, value: /*(!) any */ Объект??FUCKFUCK = пусто)/*(!) no_type */ Объект? }


тип GlobalDescriptor<T = ValueType> = интерфейс
{
  mutable: ДаНет

  value: T
}


тип MemoryDescriptor = интерфейс
{
  initial: Число

  maximum: Число

  shared: ДаНет
}


тип ModuleExportDescriptor = интерфейс
{
  kind: ImportExportKind

  name: Текст
}


тип ModuleImportDescriptor = интерфейс
{
  kind: ImportExportKind

  module: Текст

  name: Текст
}


тип TableDescriptor = интерфейс
{
  element: TableKind

  initial: Число

  maximum: Число
}


тип ValueTypeMap = интерфейс
{
  anyfunc: Function

  externref: /*(!) any */ Объект?

  f32: Число

  f64: Число

  i32: Число

  i64: bigint

  v128: Никогда
}


тип WebAssemblyInstantiatedSource = интерфейс
{
  instance: Instance

  module: Module
}


тип ImportExportKind = "function" | "global" | "memory" | "table"

тип TableKind = "anyfunc" | "externref"

тип ExportValue = Function | Global | Memory | Table

тип Exports = Record<Текст, ExportValue>

тип ImportValue = ExportValue | Число

тип Imports = Record<Текст, ModuleImports>

тип ModuleImports = Record<Текст, ImportValue>

тип ValueType = /*(!) keyof ValueTypeMap */ Объект?

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile) */

операция compile(bytes: BufferSource): Promise<Module>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compileStreaming) */

операция compileStreaming(source: Response | PromiseLike<Response>): Promise<Module>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate) */

операция instantiate(bytes: BufferSource, importObject: Imports?FUCKFUCK = пусто): Promise<WebAssemblyInstantiatedSource>

операция instantiate(moduleObject: Module, importObject: Imports?FUCKFUCK = пусто): Promise<Instance>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming) */

операция instantiateStreaming(source: Response | PromiseLike<Response>, importObject: Imports?FUCKFUCK = пусто): Promise<WebAssemblyInstantiatedSource>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/validate) */

операция validate(bytes: BufferSource): ДаНет
}

тип BlobCallback = интерфейс
{
  /*(!) (blob: Blob | null): void*/
}


тип CustomElementConstructor = интерфейс
{
  #js.МассивПараметров
  при создании(params: Список</*(!) any */ Объект?>)/*(!) no_type */ Объект?
}


тип DecodeErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип DecodeSuccessCallback = интерфейс
{
  /*(!) (decodedData: AudioBuffer): void*/
}


тип EncodedVideoChunkOutputCallback = интерфейс
{
  /*(!) (chunk: EncodedVideoChunk, metadata?: EncodedVideoChunkMetadata): void*/
}


тип ErrorCallback = интерфейс
{
  /*(!) (err: DOMException): void*/
}


тип FileCallback = интерфейс
{
  /*(!) (file: File): void*/
}


тип FileSystemEntriesCallback = интерфейс
{
  /*(!) (entries: FileSystemEntry[]): void*/
}


тип FileSystemEntryCallback = интерфейс
{
  /*(!) (entry: FileSystemEntry): void*/
}


тип FrameRequestCallback = интерфейс
{
  /*(!) (time: DOMHighResTimeStamp): void*/
}


тип FunctionStringCallback = интерфейс
{
  /*(!) (data: string): void*/
}


тип IdleRequestCallback = интерфейс
{
  /*(!) (deadline: IdleDeadline): void*/
}


тип IntersectionObserverCallback = интерфейс
{
  /*(!) (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void*/
}


тип LockGrantedCallback = интерфейс
{
  /*(!) (lock: Lock | null): any*/
}


тип MediaSessionActionHandler = интерфейс
{
  /*(!) (details: MediaSessionActionDetails): void*/
}


тип MutationCallback = интерфейс
{
  /*(!) (mutations: MutationRecord[], observer: MutationObserver): void*/
}


тип NotificationPermissionCallback = интерфейс
{
  /*(!) (permission: NotificationPermission): void*/
}


тип OnBeforeUnloadEventHandlerNonNull = интерфейс
{
  /*(!) (event: Event): string | null*/
}


тип OnErrorEventHandlerNonNull = интерфейс
{
  /*(!) (event: Event | string, source?: string, lineno?: number, colno?: number, error?: Error): any*/
}


тип PerformanceObserverCallback = интерфейс
{
  /*(!) (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void*/
}


тип PositionCallback = интерфейс
{
  /*(!) (position: GeolocationPosition): void*/
}


тип PositionErrorCallback = интерфейс
{
  /*(!) (positionError: GeolocationPositionError): void*/
}


тип QueuingStrategySize<T> = интерфейс
{
  /*(!) (chunk: T): number*/
}


тип RTCPeerConnectionErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип RTCSessionDescriptionCallback = интерфейс
{
  /*(!) (description: RTCSessionDescriptionInit): void*/
}


тип RemotePlaybackAvailabilityCallback = интерфейс
{
  /*(!) (available: boolean): void*/
}


тип ReportingObserverCallback = интерфейс
{
  /*(!) (reports: Report[], observer: ReportingObserver): void*/
}


тип ResizeObserverCallback = интерфейс
{
  /*(!) (entries: ResizeObserverEntry[], observer: ResizeObserver): void*/
}


тип TransformerFlushCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип TransformerStartCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): any*/
}


тип TransformerTransformCallback<I, O> = интерфейс
{
  /*(!) (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип UnderlyingSinkAbortCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSinkCloseCallback = интерфейс
{
  /*(!) (): void | PromiseLike<void>*/
}


тип UnderlyingSinkStartCallback = интерфейс
{
  /*(!) (controller: WritableStreamDefaultController): any*/
}


тип UnderlyingSinkWriteCallback<W> = интерфейс
{
  /*(!) (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>*/
}


тип UnderlyingSourceCancelCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSourcePullCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): void | PromiseLike<void>*/
}


тип UnderlyingSourceStartCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): any*/
}


тип VideoFrameOutputCallback = интерфейс
{
  /*(!) (output: VideoFrame): void*/
}


тип VideoFrameRequestCallback = интерфейс
{
  /*(!) (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadata): void*/
}


тип VoidFunction = интерфейс
{
  /*(!) (): void*/
}


тип WebCodecsErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип HTMLElementTagNameMap = интерфейс
{
  "a": HTMLAnchorElement

  "abbr": HTMLElement

  "address": HTMLElement

  "area": HTMLAreaElement

  "article": HTMLElement

  "aside": HTMLElement

  "audio": HTMLAudioElement

  "b": HTMLElement

  "base": HTMLBaseElement

  "bdi": HTMLElement

  "bdo": HTMLElement

  "blockquote": HTMLQuoteElement

  "body": HTMLBodyElement

  "br": HTMLBRElement

  "button": HTMLButtonElement

  "canvas": HTMLCanvasElement

  "caption": HTMLTableCaptionElement

  "cite": HTMLElement

  "code": HTMLElement

  "col": HTMLTableColElement

  "colgroup": HTMLTableColElement

  "data": HTMLDataElement

  "datalist": HTMLDataListElement

  "dd": HTMLElement

  "del": HTMLModElement

  "details": HTMLDetailsElement

  "dfn": HTMLElement

  "dialog": HTMLDialogElement

  "div": HTMLDivElement

  "dl": HTMLDListElement

  "dt": HTMLElement

  "em": HTMLElement

  "embed": HTMLEmbedElement

  "fieldset": HTMLFieldSetElement

  "figcaption": HTMLElement

  "figure": HTMLElement

  "footer": HTMLElement

  "form": HTMLFormElement

  "h1": HTMLHeadingElement

  "h2": HTMLHeadingElement

  "h3": HTMLHeadingElement

  "h4": HTMLHeadingElement

  "h5": HTMLHeadingElement

  "h6": HTMLHeadingElement

  "head": HTMLHeadElement

  "header": HTMLElement

  "hgroup": HTMLElement

  "hr": HTMLHRElement

  "html": HTMLHtmlElement

  "i": HTMLElement

  "iframe": HTMLIFrameElement

  "img": HTMLImageElement

  "input": HTMLInputElement

  "ins": HTMLModElement

  "kbd": HTMLElement

  "label": HTMLLabelElement

  "legend": HTMLLegendElement

  "li": HTMLLIElement

  "link": HTMLLinkElement

  "main": HTMLElement

  "map": HTMLMapElement

  "mark": HTMLElement

  "menu": HTMLMenuElement

  "meta": HTMLMetaElement

  "meter": HTMLMeterElement

  "nav": HTMLElement

  "noscript": HTMLElement

  "object": HTMLObjectElement

  "ol": HTMLOListElement

  "optgroup": HTMLOptGroupElement

  "option": HTMLOptionElement

  "output": HTMLOutputElement

  "p": HTMLParagraphElement

  "picture": HTMLPictureElement

  "pre": HTMLPreElement

  "progress": HTMLProgressElement

  "q": HTMLQuoteElement

  "rp": HTMLElement

  "rt": HTMLElement

  "ruby": HTMLElement

  "s": HTMLElement

  "samp": HTMLElement

  "script": HTMLScriptElement

  "search": HTMLElement

  "section": HTMLElement

  "select": HTMLSelectElement

  "slot": HTMLSlotElement

  "small": HTMLElement

  "source": HTMLSourceElement

  "span": HTMLSpanElement

  "strong": HTMLElement

  "style": HTMLStyleElement

  "sub": HTMLElement

  "summary": HTMLElement

  "sup": HTMLElement

  "table": HTMLTableElement

  "tbody": HTMLTableSectionElement

  "td": HTMLTableCellElement

  "template": HTMLTemplateElement

  "textarea": HTMLTextAreaElement

  "tfoot": HTMLTableSectionElement

  "th": HTMLTableCellElement

  "thead": HTMLTableSectionElement

  "time": HTMLTimeElement

  "title": HTMLTitleElement

  "tr": HTMLTableRowElement

  "track": HTMLTrackElement

  "u": HTMLElement

  "ul": HTMLUListElement

  "var": HTMLElement

  "video": HTMLVideoElement

  "wbr": HTMLElement
}


тип HTMLElementDeprecatedTagNameMap = интерфейс
{
  "acronym": HTMLElement

  "applet": HTMLUnknownElement

  "basefont": HTMLElement

  "bgsound": HTMLUnknownElement

  "big": HTMLElement

  "blink": HTMLUnknownElement

  "center": HTMLElement

  "dir": HTMLDirectoryElement

  "font": HTMLFontElement

  "frame": HTMLFrameElement

  "frameset": HTMLFrameSetElement

  "isindex": HTMLUnknownElement

  "keygen": HTMLUnknownElement

  "listing": HTMLPreElement

  "marquee": HTMLMarqueeElement

  "menuitem": HTMLElement

  "multicol": HTMLUnknownElement

  "nextid": HTMLUnknownElement

  "nobr": HTMLElement

  "noembed": HTMLElement

  "noframes": HTMLElement

  "param": HTMLParamElement

  "plaintext": HTMLElement

  "rb": HTMLElement

  "rtc": HTMLElement

  "spacer": HTMLUnknownElement

  "strike": HTMLElement

  "tt": HTMLElement

  "xmp": HTMLPreElement
}


тип SVGElementTagNameMap = интерфейс
{
  "a": SVGAElement

  "animate": SVGAnimateElement

  "animateMotion": SVGAnimateMotionElement

  "animateTransform": SVGAnimateTransformElement

  "circle": SVGCircleElement

  "clipPath": SVGClipPathElement

  "defs": SVGDefsElement

  "desc": SVGDescElement

  "ellipse": SVGEllipseElement

  "feBlend": SVGFEBlendElement

  "feColorMatrix": SVGFEColorMatrixElement

  "feComponentTransfer": SVGFEComponentTransferElement

  "feComposite": SVGFECompositeElement

  "feConvolveMatrix": SVGFEConvolveMatrixElement

  "feDiffuseLighting": SVGFEDiffuseLightingElement

  "feDisplacementMap": SVGFEDisplacementMapElement

  "feDistantLight": SVGFEDistantLightElement

  "feDropShadow": SVGFEDropShadowElement

  "feFlood": SVGFEFloodElement

  "feFuncA": SVGFEFuncAElement

  "feFuncB": SVGFEFuncBElement

  "feFuncG": SVGFEFuncGElement

  "feFuncR": SVGFEFuncRElement

  "feGaussianBlur": SVGFEGaussianBlurElement

  "feImage": SVGFEImageElement

  "feMerge": SVGFEMergeElement

  "feMergeNode": SVGFEMergeNodeElement

  "feMorphology": SVGFEMorphologyElement

  "feOffset": SVGFEOffsetElement

  "fePointLight": SVGFEPointLightElement

  "feSpecularLighting": SVGFESpecularLightingElement

  "feSpotLight": SVGFESpotLightElement

  "feTile": SVGFETileElement

  "feTurbulence": SVGFETurbulenceElement

  "filter": SVGFilterElement

  "foreignObject": SVGForeignObjectElement

  "g": SVGGElement

  "image": SVGImageElement

  "line": SVGLineElement

  "linearGradient": SVGLinearGradientElement

  "marker": SVGMarkerElement

  "mask": SVGMaskElement

  "metadata": SVGMetadataElement

  "mpath": SVGMPathElement

  "path": SVGPathElement

  "pattern": SVGPatternElement

  "polygon": SVGPolygonElement

  "polyline": SVGPolylineElement

  "radialGradient": SVGRadialGradientElement

  "rect": SVGRectElement

  "script": SVGScriptElement

  "set": SVGSetElement

  "stop": SVGStopElement

  "style": SVGStyleElement

  "svg": SVGSVGElement

  "switch": SVGSwitchElement

  "symbol": SVGSymbolElement

  "text": SVGTextElement

  "textPath": SVGTextPathElement

  "title": SVGTitleElement

  "tspan": SVGTSpanElement

  "use": SVGUseElement

  "view": SVGViewElement
}


тип MathMLElementTagNameMap = интерфейс
{
  "annotation": MathMLElement

  "annotation-xml": MathMLElement

  "maction": MathMLElement

  "math": MathMLElement

  "merror": MathMLElement

  "mfrac": MathMLElement

  "mi": MathMLElement

  "mmultiscripts": MathMLElement

  "mn": MathMLElement

  "mo": MathMLElement

  "mover": MathMLElement

  "mpadded": MathMLElement

  "mphantom": MathMLElement

  "mprescripts": MathMLElement

  "mroot": MathMLElement

  "mrow": MathMLElement

  "ms": MathMLElement

  "mspace": MathMLElement

  "msqrt": MathMLElement

  "mstyle": MathMLElement

  "msub": MathMLElement

  "msubsup": MathMLElement

  "msup": MathMLElement

  "mtable": MathMLElement

  "mtd": MathMLElement

  "mtext": MathMLElement

  "mtr": MathMLElement

  "munder": MathMLElement

  "munderover": MathMLElement

  "semantics": MathMLElement
}


/** @deprecated Directly use HTMLElementTagNameMap or SVGElementTagNameMap as appropriate, instead. */

тип ElementTagNameMap = /*(!) HTMLElementTagNameMap & Pick<SVGElementTagNameMap, Exclude<keyof SVGElementTagNameMap, keyof HTMLElementTagNameMap>> */ Объект?

внешнее
/*(!) var */ Audio: объект { при создании(src: Текст?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


внешнее
/*(!) var */ Image: объект { при создании(width: Число?FUCKFUCK = пусто, height: Число?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


внешнее
/*(!) var */ Option: объект { при создании(text: Текст?FUCKFUCK = пусто, value: Текст?FUCKFUCK = пусто, defaultSelected: ДаНет?FUCKFUCK = пусто, selected: ДаНет?FUCKFUCK = пусто)/*(!) no_type */ Объект? }


/**
* @deprecated This is a legacy alias of `navigator`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/navigator)
*/

внешнее
/*(!) var */ clientInformation: Navigator


/**
* Returns true if the window has been closed, false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/closed)
*/

внешнее
/*(!) var */ closed: ДаНет


/**
* Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/customElements)
*/

внешнее
/*(!) var */ customElements: CustomElementRegistry


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/devicePixelRatio) */

внешнее
/*(!) var */ devicePixelRatio: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/document) */

внешнее
/*(!) var */ document: Document


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/event)
*/

внешнее
/*(!) var */ event: Event?FUCKFUCK


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/external)
*/

внешнее
/*(!) var */ external: External


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/frameElement) */

внешнее
/*(!) var */ frameElement: Element?FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/frames) */

внешнее
/*(!) var */ frames: WindowProxy


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/history) */

внешнее
/*(!) var */ history: History


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/innerHeight) */

внешнее
/*(!) var */ innerHeight: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/innerWidth) */

внешнее
/*(!) var */ innerWidth: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/length) */

внешнее
/*(!) var */ length: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/location) */

внешнее
/*(!) var */ location: Location


/**
* Returns true if the location bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/locationbar)
*/

внешнее
/*(!) var */ locationbar: BarProp


/**
* Returns true if the menu bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/menubar)
*/

внешнее
/*(!) var */ menubar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/name) */

/** @deprecated */

внешнее
конст name: Ничего


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/navigator) */

внешнее
/*(!) var */ navigator: Navigator


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/devicemotion_event)
*/

внешнее
/*(!) var */ ondevicemotion: операция(this: Window, ev: DeviceMotionEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/deviceorientation_event)
*/

внешнее
/*(!) var */ ondeviceorientation: операция(this: Window, ev: DeviceOrientationEvent): /*(!) any */ Объект??FUCKFUCK


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/orientationchange_event)
*/

внешнее
/*(!) var */ onorientationchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/opener) */

внешнее
/*(!) var */ opener: /*(!) any */ Объект?


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/orientation)
*/

внешнее
/*(!) var */ orientation: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/outerHeight) */

внешнее
/*(!) var */ outerHeight: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/outerWidth) */

внешнее
/*(!) var */ outerWidth: Число


/**
* @deprecated This is a legacy alias of `scrollX`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollX)
*/

внешнее
/*(!) var */ pageXOffset: Число


/**
* @deprecated This is a legacy alias of `scrollY`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollY)
*/

внешнее
/*(!) var */ pageYOffset: Число


/**
* Refers to either the parent WindowProxy, or itself.
*
* It can rarely be null e.g. for contentWindow of an iframe that is already removed from the parent.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/parent)
*/

внешнее
/*(!) var */ parent: WindowProxy


/**
* Returns true if the personal bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/personalbar)
*/

внешнее
/*(!) var */ personalbar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screen) */

внешнее
/*(!) var */ screen: Screen


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenLeft) */

внешнее
/*(!) var */ screenLeft: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenTop) */

внешнее
/*(!) var */ screenTop: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenX) */

внешнее
/*(!) var */ screenX: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenY) */

внешнее
/*(!) var */ screenY: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollX) */

внешнее
/*(!) var */ scrollX: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollY) */

внешнее
/*(!) var */ scrollY: Число


/**
* Returns true if the scrollbars are visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollbars)
*/

внешнее
/*(!) var */ scrollbars: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/self) */

внешнее
/*(!) var */ self: /*(!) Window & typeof globalThis */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/speechSynthesis) */

внешнее
/*(!) var */ speechSynthesis: SpeechSynthesis


/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/status)
*/

внешнее
/*(!) var */ status: Текст


/**
* Returns true if the status bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/statusbar)
*/

внешнее
/*(!) var */ statusbar: BarProp


/**
* Returns true if the toolbar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/toolbar)
*/

внешнее
/*(!) var */ toolbar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/top) */

внешнее
/*(!) var */ top: WindowProxy?FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/visualViewport) */

внешнее
/*(!) var */ visualViewport: VisualViewport?FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/window) */

внешнее
/*(!) var */ window: /*(!) Window & typeof globalThis */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/alert) */

внешнее
операция alert(message: /*(!) any */ Объект??FUCKFUCK = пусто)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/blur) */

внешнее
операция blur()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/cancelIdleCallback) */

внешнее
операция cancelIdleCallback(handle: Число)

/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/captureEvents)
*/

внешнее
операция captureEvents()

/**
* Closes the window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/close)
*/

внешнее
операция close()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/confirm) */

внешнее
операция confirm(message: Текст?FUCKFUCK = пусто): ДаНет

/**
* Moves the focus to the window's browsing context, if any.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/focus)
*/

внешнее
операция focus()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/getComputedStyle) */

внешнее
операция getComputedStyle(elt: Element, pseudoElt: Текст?FUCKFUCK = пусто): CSSStyleDeclaration

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/getSelection) */

внешнее
операция getSelection(): Selection?FUCKFUCK

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/matchMedia) */

внешнее
операция matchMedia(query: Текст): MediaQueryList

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/moveBy) */

внешнее
операция moveBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/moveTo) */

внешнее
операция moveTo(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/open) */

внешнее
операция open(url: Текст | URL | пусто = пусто, target: Текст?FUCKFUCK = пусто, features: Текст?FUCKFUCK = пусто): WindowProxy?FUCKFUCK

/**
* Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
*
* Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
*
* A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
*
* If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
*
* Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/postMessage)
*/

внешнее
операция postMessage(message: /*(!) any */ Объект?, targetOrigin: Текст, transfer: Список<Transferable>?FUCKFUCK = пусто)

внешнее
операция postMessage(message: /*(!) any */ Объект?, options: WindowPostMessageOptions?FUCKFUCK = пусто)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/print) */

внешнее
операция print()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/prompt) */

внешнее
операция prompt(message: Текст?FUCKFUCK = пусто, _default: Текст?FUCKFUCK = пусто): Текст?FUCKFUCK

/**
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/releaseEvents)
*/

внешнее
операция releaseEvents()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/requestIdleCallback) */

внешнее
операция requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions?FUCKFUCK = пусто): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/resizeBy) */

внешнее
операция resizeBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/resizeTo) */

внешнее
операция resizeTo(width: Число, height: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scroll) */

внешнее
операция scroll(options: ScrollToOptions?FUCKFUCK = пусто)

внешнее
операция scroll(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollBy) */

внешнее
операция scrollBy(options: ScrollToOptions?FUCKFUCK = пусто)

внешнее
операция scrollBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollTo) */

внешнее
операция scrollTo(options: ScrollToOptions?FUCKFUCK = пусто)

внешнее
операция scrollTo(x: Число, y: Число)

/**
* Cancels the document load.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/stop)
*/

внешнее
операция stop()

внешнее
операция toString(): Текст

/**
* Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
*/

внешнее
операция dispatchEvent(event: Event): ДаНет

внешнее
операция cancelAnimationFrame(handle: Число)

внешнее
операция requestAnimationFrame(callback: FrameRequestCallback): Число

/**
* Fires when the user aborts the download.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/abort_event)
*/

внешнее
/*(!) var */ onabort: операция(this: Window, ev: UIEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationcancel_event) */

внешнее
/*(!) var */ onanimationcancel: операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationend_event) */

внешнее
/*(!) var */ onanimationend: операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationiteration_event) */

внешнее
/*(!) var */ onanimationiteration: операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationstart_event) */

внешнее
/*(!) var */ onanimationstart: операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/auxclick_event) */

внешнее
/*(!) var */ onauxclick: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/beforeinput_event) */

внешнее
/*(!) var */ onbeforeinput: операция(this: Window, ev: InputEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the object loses the input focus.
* @param ev The focus event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/blur_event)
*/

внешнее
/*(!) var */ onblur: операция(this: Window, ev: FocusEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement/cancel_event) */

внешнее
/*(!) var */ oncancel: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when playback is possible, but would require further buffering.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/canplay_event)
*/

внешнее
/*(!) var */ oncanplay: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/canplaythrough_event) */

внешнее
/*(!) var */ oncanplaythrough: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the contents of the object or selection have changed.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/change_event)
*/

внешнее
/*(!) var */ onchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user clicks the left mouse button on the object
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/click_event)
*/

внешнее
/*(!) var */ onclick: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement/close_event) */

внешнее
/*(!) var */ onclose: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user clicks the right mouse button in the client area, opening the context menu.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/contextmenu_event)
*/

внешнее
/*(!) var */ oncontextmenu: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/copy_event) */

внешнее
/*(!) var */ oncopy: операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTrackElement/cuechange_event) */

внешнее
/*(!) var */ oncuechange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/cut_event) */

внешнее
/*(!) var */ oncut: операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user double-clicks the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/dblclick_event)
*/

внешнее
/*(!) var */ ondblclick: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the source object continuously during a drag operation.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/drag_event)
*/

внешнее
/*(!) var */ ondrag: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the source object when the user releases the mouse at the close of a drag operation.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragend_event)
*/

внешнее
/*(!) var */ ondragend: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the target element when the user drags the object to a valid drop target.
* @param ev The drag event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragenter_event)
*/

внешнее
/*(!) var */ ondragenter: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.
* @param ev The drag event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragleave_event)
*/

внешнее
/*(!) var */ ondragleave: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the target element continuously while the user drags the object over a valid drop target.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragover_event)
*/

внешнее
/*(!) var */ ondragover: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires on the source object when the user starts to drag a text selection or selected object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragstart_event)
*/

внешнее
/*(!) var */ ondragstart: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/drop_event) */

внешнее
/*(!) var */ ondrop: операция(this: Window, ev: DragEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the duration attribute is updated.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/durationchange_event)
*/

внешнее
/*(!) var */ ondurationchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the media element is reset to its initial state.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/emptied_event)
*/

внешнее
/*(!) var */ onemptied: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the end of playback is reached.
* @param ev The event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/ended_event)
*/

внешнее
/*(!) var */ onended: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when an error occurs during object loading.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/error_event)
*/

внешнее
/*(!) var */ onerror: OnErrorEventHandler


/**
* Fires when the object receives focus.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/focus_event)
*/

внешнее
/*(!) var */ onfocus: операция(this: Window, ev: FocusEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/formdata_event) */

внешнее
/*(!) var */ onformdata: операция(this: Window, ev: FormDataEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/gotpointercapture_event) */

внешнее
/*(!) var */ ongotpointercapture: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/input_event) */

внешнее
/*(!) var */ oninput: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement/invalid_event) */

внешнее
/*(!) var */ oninvalid: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user presses a key.
* @param ev The keyboard event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/keydown_event)
*/

внешнее
/*(!) var */ onkeydown: операция(this: Window, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user presses an alphanumeric key.
* @param ev The event.
* @deprecated
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/keypress_event)
*/

внешнее
/*(!) var */ onkeypress: операция(this: Window, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user releases a key.
* @param ev The keyboard event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/keyup_event)
*/

внешнее
/*(!) var */ onkeyup: операция(this: Window, ev: KeyboardEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires immediately after the browser loads the object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGElement/load_event)
*/

внешнее
/*(!) var */ onload: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when media data is loaded at the current playback position.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadeddata_event)
*/

внешнее
/*(!) var */ onloadeddata: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the duration and dimensions of the media have been determined.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadedmetadata_event)
*/

внешнее
/*(!) var */ onloadedmetadata: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when Internet Explorer begins looking for media data.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadstart_event)
*/

внешнее
/*(!) var */ onloadstart: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/lostpointercapture_event) */

внешнее
/*(!) var */ onlostpointercapture: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user clicks the object with either mouse button.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mousedown_event)
*/

внешнее
/*(!) var */ onmousedown: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseenter_event) */

внешнее
/*(!) var */ onmouseenter: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseleave_event) */

внешнее
/*(!) var */ onmouseleave: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user moves the mouse over the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mousemove_event)
*/

внешнее
/*(!) var */ onmousemove: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user moves the mouse pointer outside the boundaries of the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseout_event)
*/

внешнее
/*(!) var */ onmouseout: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user moves the mouse pointer into the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseover_event)
*/

внешнее
/*(!) var */ onmouseover: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user releases a mouse button while the mouse is over the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseup_event)
*/

внешнее
/*(!) var */ onmouseup: операция(this: Window, ev: MouseEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/paste_event) */

внешнее
/*(!) var */ onpaste: операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when playback is paused.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/pause_event)
*/

внешнее
/*(!) var */ onpause: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the play method is requested.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/play_event)
*/

внешнее
/*(!) var */ onplay: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the audio or video has started playing.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/playing_event)
*/

внешнее
/*(!) var */ onplaying: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointercancel_event) */

внешнее
/*(!) var */ onpointercancel: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerdown_event) */

внешнее
/*(!) var */ onpointerdown: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerenter_event) */

внешнее
/*(!) var */ onpointerenter: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerleave_event) */

внешнее
/*(!) var */ onpointerleave: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointermove_event) */

внешнее
/*(!) var */ onpointermove: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerout_event) */

внешнее
/*(!) var */ onpointerout: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerover_event) */

внешнее
/*(!) var */ onpointerover: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerup_event) */

внешнее
/*(!) var */ onpointerup: операция(this: Window, ev: PointerEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs to indicate progress while downloading media data.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/progress_event)
*/

внешнее
/*(!) var */ onprogress: операция(this: Window, ev: ProgressEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the playback rate is increased or decreased.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/ratechange_event)
*/

внешнее
/*(!) var */ onratechange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user resets a form.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/reset_event)
*/

внешнее
/*(!) var */ onreset: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement/resize_event) */

внешнее
/*(!) var */ onresize: операция(this: Window, ev: UIEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the user repositions the scroll box in the scroll bar on the object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/scroll_event)
*/

внешнее
/*(!) var */ onscroll: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/scrollend_event) */

внешнее
/*(!) var */ onscrollend: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/securitypolicyviolation_event) */

внешнее
/*(!) var */ onsecuritypolicyviolation: операция(this: Window, ev: SecurityPolicyViolationEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the seek operation ends.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/seeked_event)
*/

внешнее
/*(!) var */ onseeked: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the current playback position is moved.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/seeking_event)
*/

внешнее
/*(!) var */ onseeking: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Fires when the current selection changes.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement/select_event)
*/

внешнее
/*(!) var */ onselect: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/selectionchange_event) */

внешнее
/*(!) var */ onselectionchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node/selectstart_event) */

внешнее
/*(!) var */ onselectstart: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSlotElement/slotchange_event) */

внешнее
/*(!) var */ onslotchange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the download has stopped.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/stalled_event)
*/

внешнее
/*(!) var */ onstalled: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/submit_event) */

внешнее
/*(!) var */ onsubmit: операция(this: Window, ev: SubmitEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs if the load operation has been intentionally halted.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/suspend_event)
*/

внешнее
/*(!) var */ onsuspend: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs to indicate the current playback position.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/timeupdate_event)
*/

внешнее
/*(!) var */ ontimeupdate: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDetailsElement/toggle_event) */

внешнее
/*(!) var */ ontoggle: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchcancel_event) */

внешнее
/*(!) var */ ontouchcancel: операция(this: Window, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchend_event) */

внешнее
/*(!) var */ ontouchend: операция(this: Window, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchmove_event) */

внешнее
/*(!) var */ ontouchmove: операция(this: Window, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchstart_event) */

внешнее
/*(!) var */ ontouchstart: операция(this: Window, ev: TouchEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitioncancel_event) */

внешнее
/*(!) var */ ontransitioncancel: операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionend_event) */

внешнее
/*(!) var */ ontransitionend: операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionrun_event) */

внешнее
/*(!) var */ ontransitionrun: операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionstart_event) */

внешнее
/*(!) var */ ontransitionstart: операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when the volume is changed, or playback is muted or unmuted.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/volumechange_event)
*/

внешнее
/*(!) var */ onvolumechange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* Occurs when playback stops because the next frame of a video resource is not available.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/waiting_event)
*/

внешнее
/*(!) var */ onwaiting: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* @deprecated This is a legacy alias of `onanimationend`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationend_event)
*/

внешнее
/*(!) var */ onwebkitanimationend: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* @deprecated This is a legacy alias of `onanimationiteration`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationiteration_event)
*/

внешнее
/*(!) var */ onwebkitanimationiteration: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* @deprecated This is a legacy alias of `onanimationstart`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationstart_event)
*/

внешнее
/*(!) var */ onwebkitanimationstart: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/**
* @deprecated This is a legacy alias of `ontransitionend`.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionend_event)
*/

внешнее
/*(!) var */ onwebkittransitionend: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/wheel_event) */

внешнее
/*(!) var */ onwheel: операция(this: Window, ev: WheelEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/afterprint_event) */

внешнее
/*(!) var */ onafterprint: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/beforeprint_event) */

внешнее
/*(!) var */ onbeforeprint: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/beforeunload_event) */

внешнее
/*(!) var */ onbeforeunload: операция(this: Window, ev: BeforeUnloadEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/gamepadconnected_event) */

внешнее
/*(!) var */ ongamepadconnected: операция(this: Window, ev: GamepadEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/gamepaddisconnected_event) */

внешнее
/*(!) var */ ongamepaddisconnected: операция(this: Window, ev: GamepadEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/hashchange_event) */

внешнее
/*(!) var */ onhashchange: операция(this: Window, ev: HashChangeEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/languagechange_event) */

внешнее
/*(!) var */ onlanguagechange: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/message_event) */

внешнее
/*(!) var */ onmessage: операция(this: Window, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/messageerror_event) */

внешнее
/*(!) var */ onmessageerror: операция(this: Window, ev: MessageEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/offline_event) */

внешнее
/*(!) var */ onoffline: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/online_event) */

внешнее
/*(!) var */ ononline: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/pagehide_event) */

внешнее
/*(!) var */ onpagehide: операция(this: Window, ev: PageTransitionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/pageshow_event) */

внешнее
/*(!) var */ onpageshow: операция(this: Window, ev: PageTransitionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/popstate_event) */

внешнее
/*(!) var */ onpopstate: операция(this: Window, ev: PopStateEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/rejectionhandled_event) */

внешнее
/*(!) var */ onrejectionhandled: операция(this: Window, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/storage_event) */

внешнее
/*(!) var */ onstorage: операция(this: Window, ev: StorageEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/unhandledrejection_event) */

внешнее
/*(!) var */ onunhandledrejection: операция(this: Window, ev: PromiseRejectionEvent): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/unload_event) */

внешнее
/*(!) var */ onunload: операция(this: Window, ev: Event): /*(!) any */ Объект??FUCKFUCK


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/localStorage) */

внешнее
/*(!) var */ localStorage: Storage


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/caches)
*/

внешнее
/*(!) var */ caches: CacheStorage


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crossOriginIsolated) */

внешнее
/*(!) var */ crossOriginIsolated: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crypto_property) */

внешнее
/*(!) var */ crypto: Crypto


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/indexedDB) */

внешнее
/*(!) var */ indexedDB: IDBFactory


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/isSecureContext) */

внешнее
/*(!) var */ isSecureContext: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/origin) */

внешнее
/*(!) var */ origin: Текст


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/performance_property) */

внешнее
/*(!) var */ performance: Performance


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/atob) */

внешнее
операция atob(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/btoa) */

внешнее
операция btoa(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearInterval) */

внешнее
операция clearInterval(id: Число?FUCKFUCK)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearTimeout) */

внешнее
операция clearTimeout(id: Число?FUCKFUCK)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/createImageBitmap) */

внешнее
операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

внешнее
операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions?FUCKFUCK = пусто): Promise<ImageBitmap>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/fetch) */

внешнее
операция fetch(input: RequestInfo | URL, init: RequestInit?FUCKFUCK = пусто): Promise<Response>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/queueMicrotask) */

внешнее
операция queueMicrotask(callback: VoidFunction)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/reportError) */

внешнее
операция reportError(e: /*(!) any */ Объект?)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setInterval) */

внешнее
#js.МассивПараметров
операция setInterval(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setTimeout) */

внешнее
#js.МассивПараметров
операция setTimeout(handler: TimerHandler, timeout: Число?FUCKFUCK = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/structuredClone) */

внешнее
операция structuredClone<T>(value: T, options: StructuredSerializeOptions?FUCKFUCK = пусто): T

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage) */

внешнее
/*(!) var */ sessionStorage: Storage


внешнее
операция addEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | AddEventListenerOptions | пусто = пусто)

внешнее
операция addEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | AddEventListenerOptions | пусто = пусто)

внешнее
операция removeEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: ДаНет | EventListenerOptions | пусто = пусто)

внешнее
операция removeEventListener(type: Текст, listener: EventListenerOrEventListenerObject, options: ДаНет | EventListenerOptions | пусто = пусто)

тип AlgorithmIdentifier = Algorithm | Текст

тип AllowSharedBufferSource = ArrayBuffer | ArrayBufferView

тип AutoFill = AutoFillBase | /*(!) `${OptionalPrefixToken<AutoFillSection>}${OptionalPrefixToken<AutoFillAddressKind>}${AutoFillField}${OptionalPostfixToken<AutoFillCredentialField>}` */ Объект?

тип AutoFillField = AutoFillNormalField | /*(!) `${OptionalPrefixToken<AutoFillContactKind>}${AutoFillContactField}` */ Объект?

тип AutoFillSection = /*(!) `section-${string}` */ Объект?

тип BigInteger = Uint8Array

тип BinaryData = ArrayBuffer | ArrayBufferView

тип BlobPart = BufferSource | Blob | Текст

тип BodyInit = ReadableStream | XMLHttpRequestBodyInit

тип BufferSource = ArrayBufferView | ArrayBuffer

тип COSEAlgorithmIdentifier = Число

тип CSSKeywordish = Текст | CSSKeywordValue

тип CSSNumberish = Число | CSSNumericValue

тип CSSPerspectiveValue = CSSNumericValue | CSSKeywordish

тип CSSUnparsedSegment = Текст | CSSVariableReferenceValue

тип CanvasImageSource = HTMLOrSVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas | VideoFrame

тип ClipboardItemData = Promise<Текст | Blob>

тип ClipboardItems = Список<ClipboardItem>

тип ConstrainBoolean = ДаНет | ConstrainBooleanParameters

тип ConstrainDOMString = Текст | Список<Текст> | ConstrainDOMStringParameters

тип ConstrainDouble = Число | ConstrainDoubleRange

тип ConstrainULong = Число | ConstrainULongRange

тип DOMHighResTimeStamp = Число

тип EpochTimeStamp = Число

тип EventListenerOrEventListenerObject = EventListener | EventListenerObject

тип FileSystemWriteChunkType = BufferSource | Blob | Текст | WriteParams

тип Float32List = Float32Array | Список<GLfloat>

тип FormDataEntryValue = File | Текст

тип GLbitfield = Число

тип GLboolean = ДаНет

тип GLclampf = Число

тип GLenum = Число

тип GLfloat = Число

тип GLint = Число

тип GLint64 = Число

тип GLintptr = Число

тип GLsizei = Число

тип GLsizeiptr = Число

тип GLuint = Число

тип GLuint64 = Число

тип HTMLOrSVGImageElement = HTMLImageElement | SVGImageElement

тип HTMLOrSVGScriptElement = HTMLScriptElement | SVGScriptElement

тип HashAlgorithmIdentifier = AlgorithmIdentifier

тип HeadersInit = Список<объект { _0: Текст, _1: Текст }> | Record<Текст, Текст> | Headers

тип IDBValidKey = Число | Текст | Date | BufferSource | Список<IDBValidKey>

тип ImageBitmapSource = CanvasImageSource | Blob | ImageData

тип Int32List = Int32Array | Список<GLint>

тип LineAndPositionSetting = Число | AutoKeyword

тип MediaProvider = MediaStream | MediaSource | Blob

тип MessageEventSource = WindowProxy | MessagePort | ServiceWorker

тип MutationRecordType = "attributes" | "characterData" | "childList"

тип NamedCurve = Текст

тип OffscreenRenderingContext = OffscreenCanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext

тип OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?FUCKFUCK

тип OnErrorEventHandler = OnErrorEventHandlerNonNull?FUCKFUCK

тип OptionalPostfixToken<T = Текст> = /*(!) ` ${T}` */ Объект? | ""

тип OptionalPrefixToken<T = Текст> = /*(!) `${T} ` */ Объект? | ""

тип PerformanceEntryList = Список<PerformanceEntry>

тип ReadableStreamController<T> = ReadableStreamDefaultController<T> | ReadableByteStreamController

тип ReadableStreamReadResult<T> = ReadableStreamReadValueResult<T> | ReadableStreamReadDoneResult<T>

тип ReadableStreamReader<T> = ReadableStreamDefaultReader<T> | ReadableStreamBYOBReader

тип RenderingContext = CanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext

тип ReportList = Список<Report>

тип RequestInfo = Request | Текст

тип TexImageSource = ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | VideoFrame

тип TimerHandler = Текст | Function

тип Transferable = OffscreenCanvas | ImageBitmap | MessagePort | ReadableStream | WritableStream | TransformStream | VideoFrame | ArrayBuffer

тип Uint32List = Uint32Array | Список<GLuint>

тип VibratePattern = Число | Список<Число>

тип WindowProxy = Window

тип XMLHttpRequestBodyInit = Blob | BufferSource | FormData | URLSearchParams | Текст

тип AlignSetting = "center" | "end" | "left" | "right" | "start"

тип AlphaOption = "discard" | "keep"

тип AnimationPlayState = "finished" | "idle" | "paused" | "running"

тип AnimationReplaceState = "active" | "persisted" | "removed"

тип AppendMode = "segments" | "sequence"

тип AttestationConveyancePreference = "direct" | "enterprise" | "indirect" | "none"

тип AudioContextLatencyCategory = "balanced" | "interactive" | "playback"

тип AudioContextState = "closed" | "running" | "suspended"

тип AuthenticatorAttachment = "cross-platform" | "platform"

тип AuthenticatorTransport = "ble" | "hybrid" | "internal" | "nfc" | "usb"

тип AutoFillAddressKind = "billing" | "shipping"

тип AutoFillBase = "" | "off" | "on"

тип AutoFillContactField = "email" | "tel" | "tel-area-code" | "tel-country-code" | "tel-extension" | "tel-local" | "tel-local-prefix" | "tel-local-suffix" | "tel-national"

тип AutoFillContactKind = "home" | "mobile" | "work"

тип AutoFillCredentialField = "webauthn"

тип AutoFillNormalField = "additional-name" | "address-level1" | "address-level2" | "address-level3" | "address-level4" | "address-line1" | "address-line2" | "address-line3" | "bday-day" | "bday-month" | "bday-year" | "cc-csc" | "cc-exp" | "cc-exp-month" | "cc-exp-year" | "cc-family-name" | "cc-given-name" | "cc-name" | "cc-number" | "cc-type" | "country" | "country-name" | "current-password" | "family-name" | "given-name" | "honorific-prefix" | "honorific-suffix" | "name" | "new-password" | "one-time-code" | "organization" | "postal-code" | "street-address" | "transaction-amount" | "transaction-currency" | "username"

тип AutoKeyword = "auto"

тип AutomationRate = "a-rate" | "k-rate"

тип AvcBitstreamFormat = "annexb" | "avc"

тип BinaryType = "arraybuffer" | "blob"

тип BiquadFilterType = "allpass" | "bandpass" | "highpass" | "highshelf" | "lowpass" | "lowshelf" | "notch" | "peaking"

тип CSSMathOperator = "clamp" | "invert" | "max" | "min" | "negate" | "product" | "sum"

тип CSSNumericBaseType = "angle" | "flex" | "frequency" | "length" | "percent" | "resolution" | "time"

тип CanPlayTypeResult = "" | "maybe" | "probably"

тип CanvasDirection = "inherit" | "ltr" | "rtl"

тип CanvasFillRule = "evenodd" | "nonzero"

тип CanvasFontKerning = "auto" | "none" | "normal"

тип CanvasFontStretch = "condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded"

тип CanvasFontVariantCaps = "all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase"

тип CanvasLineCap = "butt" | "round" | "square"

тип CanvasLineJoin = "bevel" | "miter" | "round"

тип CanvasTextAlign = "center" | "end" | "left" | "right" | "start"

тип CanvasTextBaseline = "alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top"

тип CanvasTextRendering = "auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed"

тип ChannelCountMode = "clamped-max" | "explicit" | "max"

тип ChannelInterpretation = "discrete" | "speakers"

тип ClientTypes = "all" | "sharedworker" | "window" | "worker"

тип CodecState = "closed" | "configured" | "unconfigured"

тип ColorGamut = "p3" | "rec2020" | "srgb"

тип ColorSpaceConversion = "default" | "none"

тип CompositeOperation = "accumulate" | "add" | "replace"

тип CompositeOperationOrAuto = "accumulate" | "add" | "auto" | "replace"

тип CompressionFormat = "deflate" | "deflate-raw" | "gzip"

тип CredentialMediationRequirement = "conditional" | "optional" | "required" | "silent"

тип DOMParserSupportedType = "application/xhtml+xml" | "application/xml" | "image/svg+xml" | "text/html" | "text/xml"

тип DirectionSetting = "" | "lr" | "rl"

тип DisplayCaptureSurfaceType = "browser" | "monitor" | "window"

тип DistanceModelType = "exponential" | "inverse" | "linear"

тип DocumentReadyState = "complete" | "interactive" | "loading"

тип DocumentVisibilityState = "hidden" | "visible"

тип EncodedVideoChunkType = "delta" | "key"

тип EndOfStreamError = "decode" | "network"

тип EndingType = "native" | "transparent"

тип FileSystemHandleKind = "directory" | "file"

тип FillMode = "auto" | "backwards" | "both" | "forwards" | "none"

тип FontDisplay = "auto" | "block" | "fallback" | "optional" | "swap"

тип FontFaceLoadStatus = "error" | "loaded" | "loading" | "unloaded"

тип FontFaceSetLoadStatus = "loaded" | "loading"

тип FullscreenNavigationUI = "auto" | "hide" | "show"

тип GamepadHapticActuatorType = "vibration"

тип GamepadHapticEffectType = "dual-rumble"

тип GamepadHapticsResult = "complete" | "preempted"

тип GamepadMappingType = "" | "standard" | "xr-standard"

тип GlobalCompositeOperation = "color" | "color-burn" | "color-dodge" | "copy" | "darken" | "destination-atop" | "destination-in" | "destination-out" | "destination-over" | "difference" | "exclusion" | "hard-light" | "hue" | "lighten" | "lighter" | "luminosity" | "multiply" | "overlay" | "saturation" | "screen" | "soft-light" | "source-atop" | "source-in" | "source-out" | "source-over" | "xor"

тип HardwareAcceleration = "no-preference" | "prefer-hardware" | "prefer-software"

тип HdrMetadataType = "smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40"

тип IDBCursorDirection = "next" | "nextunique" | "prev" | "prevunique"

тип IDBRequestReadyState = "done" | "pending"

тип IDBTransactionDurability = "default" | "relaxed" | "strict"

тип IDBTransactionMode = "readonly" | "readwrite" | "versionchange"

тип ImageOrientation = "flipY" | "from-image" | "none"

тип ImageSmoothingQuality = "high" | "low" | "medium"

тип InsertPosition = "afterbegin" | "afterend" | "beforebegin" | "beforeend"

тип IterationCompositeOperation = "accumulate" | "replace"

тип KeyFormat = "jwk" | "pkcs8" | "raw" | "spki"

тип KeyType = "private" | "public" | "secret"

тип KeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey"

тип LatencyMode = "quality" | "realtime"

тип LineAlignSetting = "center" | "end" | "start"

тип LockMode = "exclusive" | "shared"

тип MIDIPortConnectionState = "closed" | "open" | "pending"

тип MIDIPortDeviceState = "connected" | "disconnected"

тип MIDIPortType = "input" | "output"

тип MediaDecodingType = "file" | "media-source" | "webrtc"

тип MediaDeviceKind = "audioinput" | "audiooutput" | "videoinput"

тип MediaEncodingType = "record" | "webrtc"

тип MediaKeyMessageType = "individualization-request" | "license-release" | "license-renewal" | "license-request"

тип MediaKeySessionClosedReason = "closed-by-application" | "hardware-context-reset" | "internal-error" | "release-acknowledged" | "resource-evicted"

тип MediaKeySessionType = "persistent-license" | "temporary"

тип MediaKeyStatus = "expired" | "internal-error" | "output-downscaled" | "output-restricted" | "released" | "status-pending" | "usable" | "usable-in-future"

тип MediaKeysRequirement = "not-allowed" | "optional" | "required"

тип MediaSessionAction = "nexttrack" | "pause" | "play" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop"

тип MediaSessionPlaybackState = "none" | "paused" | "playing"

тип MediaStreamTrackState = "ended" | "live"

тип NavigationTimingType = "back_forward" | "navigate" | "prerender" | "reload"

тип NotificationDirection = "auto" | "ltr" | "rtl"

тип NotificationPermission = "default" | "denied" | "granted"

тип OffscreenRenderingContextId = "2d" | "bitmaprenderer" | "webgl" | "webgl2" | "webgpu"

тип OrientationType = "landscape-primary" | "landscape-secondary" | "portrait-primary" | "portrait-secondary"

тип OscillatorType = "custom" | "sawtooth" | "sine" | "square" | "triangle"

тип OverSampleType = "2x" | "4x" | "none"

тип PanningModelType = "HRTF" | "equalpower"

тип PaymentComplete = "fail" | "success" | "unknown"

тип PermissionName = "geolocation" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock" | "xr-spatial-tracking"

тип PermissionState = "denied" | "granted" | "prompt"

тип PlaybackDirection = "alternate" | "alternate-reverse" | "normal" | "reverse"

тип PositionAlignSetting = "auto" | "center" | "line-left" | "line-right"

тип PredefinedColorSpace = "display-p3" | "srgb"

тип PremultiplyAlpha = "default" | "none" | "premultiply"

тип PresentationStyle = "attachment" | "inline" | "unspecified"

тип PublicKeyCredentialType = "public-key"

тип PushEncryptionKeyName = "auth" | "p256dh"

тип RTCBundlePolicy = "balanced" | "max-bundle" | "max-compat"

тип RTCDataChannelState = "closed" | "closing" | "connecting" | "open"

тип RTCDegradationPreference = "balanced" | "maintain-framerate" | "maintain-resolution"

тип RTCDtlsTransportState = "closed" | "connected" | "connecting" | "failed" | "new"

тип RTCEncodedVideoFrameType = "delta" | "empty" | "key"

тип RTCErrorDetailType = "data-channel-failure" | "dtls-failure" | "fingerprint-failure" | "hardware-encoder-error" | "hardware-encoder-not-available" | "sctp-failure" | "sdp-syntax-error"

тип RTCIceCandidateType = "host" | "prflx" | "relay" | "srflx"

тип RTCIceComponent = "rtcp" | "rtp"

тип RTCIceConnectionState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new"

тип RTCIceGathererState = "complete" | "gathering" | "new"

тип RTCIceGatheringState = "complete" | "gathering" | "new"

тип RTCIceProtocol = "tcp" | "udp"

тип RTCIceTcpCandidateType = "active" | "passive" | "so"

тип RTCIceTransportPolicy = "all" | "relay"

тип RTCIceTransportState = "checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new"

тип RTCPeerConnectionState = "closed" | "connected" | "connecting" | "disconnected" | "failed" | "new"

тип RTCPriorityType = "high" | "low" | "medium" | "very-low"

тип RTCRtcpMuxPolicy = "require"

тип RTCRtpTransceiverDirection = "inactive" | "recvonly" | "sendonly" | "sendrecv" | "stopped"

тип RTCSctpTransportState = "closed" | "connected" | "connecting"

тип RTCSdpType = "answer" | "offer" | "pranswer" | "rollback"

тип RTCSignalingState = "closed" | "have-local-offer" | "have-local-pranswer" | "have-remote-offer" | "have-remote-pranswer" | "stable"

тип RTCStatsIceCandidatePairState = "failed" | "frozen" | "in-progress" | "inprogress" | "succeeded" | "waiting"

тип RTCStatsType = "candidate-pair" | "certificate" | "codec" | "data-channel" | "inbound-rtp" | "local-candidate" | "media-source" | "outbound-rtp" | "peer-connection" | "remote-candidate" | "remote-inbound-rtp" | "remote-outbound-rtp" | "transport"

тип ReadableStreamReaderMode = "byob"

тип ReadableStreamType = "bytes"

тип ReadyState = "closed" | "ended" | "open"

тип RecordingState = "inactive" | "paused" | "recording"

тип ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url"

тип RemotePlaybackState = "connected" | "connecting" | "disconnected"

тип RequestCache = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload"

тип RequestCredentials = "include" | "omit" | "same-origin"

тип RequestDestination = "" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt"

тип RequestMode = "cors" | "navigate" | "no-cors" | "same-origin"

тип RequestRedirect = "error" | "follow" | "manual"

тип ResidentKeyRequirement = "discouraged" | "preferred" | "required"

тип ResizeObserverBoxOptions = "border-box" | "content-box" | "device-pixel-content-box"

тип ResizeQuality = "high" | "low" | "medium" | "pixelated"

тип ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect"

тип ScrollBehavior = "auto" | "instant" | "smooth"

тип ScrollLogicalPosition = "center" | "end" | "nearest" | "start"

тип ScrollRestoration = "auto" | "manual"

тип ScrollSetting = "" | "up"

тип SecurityPolicyViolationEventDisposition = "enforce" | "report"

тип SelectionMode = "end" | "preserve" | "select" | "start"

тип ServiceWorkerState = "activated" | "activating" | "installed" | "installing" | "parsed" | "redundant"

тип ServiceWorkerUpdateViaCache = "all" | "imports" | "none"

тип ShadowRootMode = "closed" | "open"

тип SlotAssignmentMode = "manual" | "named"

тип SpeechSynthesisErrorCode = "audio-busy" | "audio-hardware" | "canceled" | "interrupted" | "invalid-argument" | "language-unavailable" | "network" | "not-allowed" | "synthesis-failed" | "synthesis-unavailable" | "text-too-long" | "voice-unavailable"

тип TextTrackKind = "captions" | "chapters" | "descriptions" | "metadata" | "subtitles"

тип TextTrackMode = "disabled" | "hidden" | "showing"

тип TouchType = "direct" | "stylus"

тип TransferFunction = "hlg" | "pq" | "srgb"

тип UserVerificationRequirement = "discouraged" | "preferred" | "required"

тип VideoColorPrimaries = "bt470bg" | "bt709" | "smpte170m"

тип VideoEncoderBitrateMode = "constant" | "quantizer" | "variable"

тип VideoFacingModeEnum = "environment" | "left" | "right" | "user"

тип VideoMatrixCoefficients = "bt470bg" | "bt709" | "rgb" | "smpte170m"

тип VideoPixelFormat = "BGRA" | "BGRX" | "I420" | "I420A" | "I422" | "I444" | "NV12" | "RGBA" | "RGBX"

тип VideoTransferCharacteristics = "bt709" | "iec61966-2-1" | "smpte170m"

тип WakeLockType = "screen"

тип WebGLPowerPreference = "default" | "high-performance" | "low-power"

тип WebTransportCongestionControl = "default" | "low-latency" | "throughput"

тип WebTransportErrorSource = "session" | "stream"

тип WorkerType = "classic" | "module"

тип WriteCommandType = "seek" | "truncate" | "write"

тип XMLHttpRequestResponseType = "" | "arraybuffer" | "blob" | "document" | "json" | "text"
