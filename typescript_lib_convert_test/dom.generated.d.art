/////////////////////////////

/// Window APIs

/////////////////////////////

тип AddEventListenerOptions = интерфейс на основе EventListenerOptions
{
  once: ДаНет

  passive: ДаНет

  signal: AbortSignal
}


тип AesCbcParams = интерфейс на основе Algorithm
{
  iv: BufferSource
}


тип AesCtrParams = интерфейс на основе Algorithm
{
  counter: BufferSource

  length: Число
}


тип AesDerivedKeyParams = интерфейс на основе Algorithm
{
  length: Число
}


тип AesGcmParams = интерфейс на основе Algorithm
{
  additionalData: BufferSource

  iv: BufferSource

  tagLength: Число
}


тип AesKeyAlgorithm = интерфейс на основе KeyAlgorithm
{
  length: Число
}


тип AesKeyGenParams = интерфейс на основе Algorithm
{
  length: Число
}


тип Algorithm = интерфейс
{
  name: Текст
}


тип AnalyserOptions = интерфейс на основе AudioNodeOptions
{
  fftSize: Число

  maxDecibels: Число

  minDecibels: Число

  smoothingTimeConstant: Число
}


тип AnimationEventInit = интерфейс на основе EventInit
{
  animationName: Текст

  elapsedTime: Число

  pseudoElement: Текст
}


тип AnimationPlaybackEventInit = интерфейс на основе EventInit
{
  currentTime: CSSNumberish?

  timelineTime: CSSNumberish?
}


тип AssignedNodesOptions = интерфейс
{
  flatten: ДаНет
}


тип AudioBufferOptions = интерфейс
{
  length: Число

  numberOfChannels: Число

  sampleRate: Число
}


тип AudioBufferSourceOptions = интерфейс
{
  buffer: AudioBuffer?

  detune: Число

  loop: ДаНет

  loopEnd: Число

  loopStart: Число

  playbackRate: Число
}


тип AudioConfiguration = интерфейс
{
  bitrate: Число

  channels: Текст

  contentType: Текст

  samplerate: Число

  spatialRendering: ДаНет
}


тип AudioContextOptions = интерфейс
{
  latencyHint: Объект? /*(!)AudioContextLatencyCategory | Число*/

  sampleRate: Число
}


тип AudioNodeOptions = интерфейс
{
  channelCount: Число

  channelCountMode: ChannelCountMode

  channelInterpretation: ChannelInterpretation
}


тип AudioProcessingEventInit = интерфейс на основе EventInit
{
  inputBuffer: AudioBuffer

  outputBuffer: AudioBuffer

  playbackTime: Число
}


тип AudioTimestamp = интерфейс
{
  contextTime: Число

  performanceTime: DOMHighResTimeStamp
}


тип AudioWorkletNodeOptions = интерфейс на основе AudioNodeOptions
{
  numberOfInputs: Число

  numberOfOutputs: Число

  outputChannelCount: Список<Число>

  parameterData: Record<Текст, Число>

  processorOptions: /*(!) any */ Объект?
}


тип AuthenticationExtensionsClientInputs = интерфейс
{
  appid: Текст

  credProps: ДаНет

  hmacCreateSecret: ДаНет
}


тип AuthenticationExtensionsClientOutputs = интерфейс
{
  appid: ДаНет

  credProps: CredentialPropertiesOutput

  hmacCreateSecret: ДаНет
}


тип AuthenticatorSelectionCriteria = интерфейс
{
  authenticatorAttachment: AuthenticatorAttachment

  requireResidentKey: ДаНет

  residentKey: ResidentKeyRequirement

  userVerification: UserVerificationRequirement
}


тип AvcEncoderConfig = интерфейс
{
  format: AvcBitstreamFormat
}


тип BiquadFilterOptions = интерфейс на основе AudioNodeOptions
{
  Q: Число

  detune: Число

  frequency: Число

  gain: Число

  type`: BiquadFilterType
}


тип BlobEventInit = интерфейс
{
  data: Blob

  timecode: DOMHighResTimeStamp
}


тип BlobPropertyBag = интерфейс
{
  endings: EndingType

  type`: Текст
}


тип CSSMatrixComponentOptions = интерфейс
{
  is2D: ДаНет
}


тип CSSNumericType = интерфейс
{
  angle: Число

  flex: Число

  frequency: Число

  length: Число

  percent: Число

  percentHint: CSSNumericBaseType

  resolution: Число

  time: Число
}


тип CSSStyleSheetInit = интерфейс
{
  baseURL: Текст

  disabled: ДаНет

  media: Объект? /*(!)MediaList | Текст*/
}


тип CacheQueryOptions = интерфейс
{
  ignoreMethod: ДаНет

  ignoreSearch: ДаНет

  ignoreVary: ДаНет
}


тип CanvasRenderingContext2DSettings = интерфейс
{
  alpha: ДаНет

  colorSpace: PredefinedColorSpace

  desynchronized: ДаНет

  willReadFrequently: ДаНет
}


тип ChannelMergerOptions = интерфейс на основе AudioNodeOptions
{
  numberOfInputs: Число
}


тип ChannelSplitterOptions = интерфейс на основе AudioNodeOptions
{
  numberOfOutputs: Число
}


тип CheckVisibilityOptions = интерфейс
{
  checkOpacity: ДаНет

  checkVisibilityCSS: ДаНет
}


тип ClientQueryOptions = интерфейс
{
  includeUncontrolled: ДаНет

  type`: ClientTypes
}


тип ClipboardEventInit = интерфейс на основе EventInit
{
  clipboardData: DataTransfer?
}


тип ClipboardItemOptions = интерфейс
{
  presentationStyle: PresentationStyle
}


тип CloseEventInit = интерфейс на основе EventInit
{
  code: Число

  reason: Текст

  wasClean: ДаНет
}


тип CompositionEventInit = интерфейс на основе UIEventInit
{
  data: Текст
}


тип ComputedEffectTiming = интерфейс на основе EffectTiming
{
  activeDuration: CSSNumberish

  currentIteration: Число?

  endTime: CSSNumberish

  localTime: CSSNumberish?

  progress: Число?

  startTime: CSSNumberish
}


тип ComputedKeyframe = интерфейс
{
  composite: CompositeOperationOrAuto

  computedOffset: Число

  easing: Текст

  offset: Число?

  /*(!) [property: string]: string | number | null | undefined*/
}


тип ConstantSourceOptions = интерфейс
{
  offset: Число
}


тип ConstrainBooleanParameters = интерфейс
{
  exact: ДаНет

  ideal: ДаНет
}


тип ConstrainDOMStringParameters = интерфейс
{
  exact: Объект? /*(!)Текст | Список<Текст>*/

  ideal: Объект? /*(!)Текст | Список<Текст>*/
}


тип ConstrainDoubleRange = интерфейс на основе DoubleRange
{
  exact: Число

  ideal: Число
}


тип ConstrainULongRange = интерфейс на основе ULongRange
{
  exact: Число

  ideal: Число
}


тип ConvolverOptions = интерфейс на основе AudioNodeOptions
{
  buffer: AudioBuffer?

  disableNormalization: ДаНет
}


тип CredentialCreationOptions = интерфейс
{
  publicKey: PublicKeyCredentialCreationOptions

  signal: AbortSignal
}


тип CredentialPropertiesOutput = интерфейс
{
  rk: ДаНет
}


тип CredentialRequestOptions = интерфейс
{
  mediation: CredentialMediationRequirement

  publicKey: PublicKeyCredentialRequestOptions

  signal: AbortSignal
}


тип CryptoKeyPair = интерфейс
{
  privateKey: CryptoKey

  publicKey: CryptoKey
}


тип CustomEventInit<T> = интерфейс на основе EventInit
{
  detail: T
}


тип DOMMatrix2DInit = интерфейс
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m21: Число

  m22: Число

  m41: Число

  m42: Число
}


тип DOMMatrixInit = интерфейс на основе DOMMatrix2DInit
{
  is2D: ДаНет

  m13: Число

  m14: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m43: Число

  m44: Число
}


тип DOMPointInit = интерфейс
{
  w: Число

  x: Число

  y: Число

  z: Число
}


тип DOMQuadInit = интерфейс
{
  p1: DOMPointInit

  p2: DOMPointInit

  p3: DOMPointInit

  p4: DOMPointInit
}


тип DOMRectInit = интерфейс
{
  height: Число

  width: Число

  x: Число

  y: Число
}


тип DelayOptions = интерфейс на основе AudioNodeOptions
{
  delayTime: Число

  maxDelayTime: Число
}


тип DeviceMotionEventAccelerationInit = интерфейс
{
  x: Число?

  y: Число?

  z: Число?
}


тип DeviceMotionEventInit = интерфейс на основе EventInit
{
  acceleration: DeviceMotionEventAccelerationInit

  accelerationIncludingGravity: DeviceMotionEventAccelerationInit

  interval: Число

  rotationRate: DeviceMotionEventRotationRateInit
}


тип DeviceMotionEventRotationRateInit = интерфейс
{
  alpha: Число?

  beta: Число?

  gamma: Число?
}


тип DeviceOrientationEventInit = интерфейс на основе EventInit
{
  absolute: ДаНет

  alpha: Число?

  beta: Число?

  gamma: Число?
}


тип DisplayMediaStreamOptions = интерфейс
{
  audio: Объект? /*(!)ДаНет | MediaTrackConstraints*/

  video: Объект? /*(!)ДаНет | MediaTrackConstraints*/
}


тип DocumentTimelineOptions = интерфейс
{
  originTime: DOMHighResTimeStamp
}


тип DoubleRange = интерфейс
{
  max: Число

  min: Число
}


тип DragEventInit = интерфейс на основе MouseEventInit
{
  dataTransfer: DataTransfer?
}


тип DynamicsCompressorOptions = интерфейс на основе AudioNodeOptions
{
  attack: Число

  knee: Число

  ratio: Число

  release: Число

  threshold: Число
}


тип EcKeyAlgorithm = интерфейс на основе KeyAlgorithm
{
  namedCurve: NamedCurve
}


тип EcKeyGenParams = интерфейс на основе Algorithm
{
  namedCurve: NamedCurve
}


тип EcKeyImportParams = интерфейс на основе Algorithm
{
  namedCurve: NamedCurve
}


тип EcdhKeyDeriveParams = интерфейс на основе Algorithm
{
  public: CryptoKey
}


тип EcdsaParams = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier
}


тип EffectTiming = интерфейс
{
  delay: Число

  direction: PlaybackDirection

  duration: Объект? /*(!)Число | CSSNumericValue | Текст*/

  easing: Текст

  endDelay: Число

  fill: FillMode

  iterationStart: Число

  iterations: Число

  playbackRate: Число
}


тип ElementCreationOptions = интерфейс
{
  is`: Текст
}


тип ElementDefinitionOptions = интерфейс
{
  extends: Текст
}


тип EncodedVideoChunkInit = интерфейс
{
  data: BufferSource

  duration: Число

  timestamp: Число

  type`: EncodedVideoChunkType
}


тип EncodedVideoChunkMetadata = интерфейс
{
  decoderConfig: VideoDecoderConfig
}


тип ErrorEventInit = интерфейс на основе EventInit
{
  colno: Число

  error`: /*(!) any */ Объект?

  filename: Текст

  lineno: Число

  message: Текст
}


тип EventInit = интерфейс
{
  bubbles: ДаНет

  cancelable: ДаНет

  composed: ДаНет
}


тип EventListenerOptions = интерфейс
{
  capture: ДаНет
}


тип EventModifierInit = интерфейс на основе UIEventInit
{
  altKey: ДаНет

  ctrlKey: ДаНет

  metaKey: ДаНет

  modifierAltGraph: ДаНет

  modifierCapsLock: ДаНет

  modifierFn: ДаНет

  modifierFnLock: ДаНет

  modifierHyper: ДаНет

  modifierNumLock: ДаНет

  modifierScrollLock: ДаНет

  modifierSuper: ДаНет

  modifierSymbol: ДаНет

  modifierSymbolLock: ДаНет

  shiftKey: ДаНет
}


тип EventSourceInit = интерфейс
{
  withCredentials: ДаНет
}


тип FilePropertyBag = интерфейс на основе BlobPropertyBag
{
  lastModified: Число
}


тип FileSystemCreateWritableOptions = интерфейс
{
  keepExistingData: ДаНет
}


тип FileSystemFlags = интерфейс
{
  create: ДаНет

  exclusive: ДаНет
}


тип FileSystemGetDirectoryOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemGetFileOptions = интерфейс
{
  create: ДаНет
}


тип FileSystemRemoveOptions = интерфейс
{
  recursive: ДаНет
}


тип FocusEventInit = интерфейс на основе UIEventInit
{
  relatedTarget: EventTarget?
}


тип FocusOptions = интерфейс
{
  preventScroll: ДаНет
}


тип FontFaceDescriptors = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  featureSettings: Текст

  lineGapOverride: Текст

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant`: Текст

  weight: Текст
}


тип FontFaceSetLoadEventInit = интерфейс на основе EventInit
{
  fontfaces: Список<FontFace>
}


тип FormDataEventInit = интерфейс на основе EventInit
{
  formData: FormData
}


тип FullscreenOptions = интерфейс
{
  navigationUI: FullscreenNavigationUI
}


тип GainOptions = интерфейс на основе AudioNodeOptions
{
  gain: Число
}


тип GamepadEffectParameters = интерфейс
{
  duration: Число

  startDelay: Число

  strongMagnitude: Число

  weakMagnitude: Число
}


тип GamepadEventInit = интерфейс на основе EventInit
{
  gamepad: Gamepad
}


тип GetAnimationsOptions = интерфейс
{
  subtree: ДаНет
}


тип GetNotificationOptions = интерфейс
{
  tag: Текст
}


тип GetRootNodeOptions = интерфейс
{
  composed: ДаНет
}


тип HashChangeEventInit = интерфейс на основе EventInit
{
  newURL: Текст

  oldURL: Текст
}


тип HkdfParams = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier

  info: BufferSource

  salt: BufferSource
}


тип HmacImportParams = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип HmacKeyAlgorithm = интерфейс на основе KeyAlgorithm
{
  hash: KeyAlgorithm

  length: Число
}


тип HmacKeyGenParams = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier

  length: Число
}


тип IDBDatabaseInfo = интерфейс
{
  name: Текст

  version: Число
}


тип IDBIndexParameters = интерфейс
{
  multiEntry: ДаНет

  unique: ДаНет
}


тип IDBObjectStoreParameters = интерфейс
{
  autoIncrement: ДаНет

  keyPath: Объект? /*(!)Текст | Список<Текст> | пусто*/
}


тип IDBTransactionOptions = интерфейс
{
  durability: IDBTransactionDurability
}


тип IDBVersionChangeEventInit = интерфейс на основе EventInit
{
  newVersion: Число?

  oldVersion: Число
}


тип IIRFilterOptions = интерфейс на основе AudioNodeOptions
{
  feedback: Список<Число>

  feedforward: Список<Число>
}


тип IdleRequestOptions = интерфейс
{
  timeout: Число
}


тип ImageBitmapOptions = интерфейс
{
  colorSpaceConversion: ColorSpaceConversion

  imageOrientation: ImageOrientation

  premultiplyAlpha: PremultiplyAlpha

  resizeHeight: Число

  resizeQuality: ResizeQuality

  resizeWidth: Число
}


тип ImageBitmapRenderingContextSettings = интерфейс
{
  alpha: ДаНет
}


тип ImageDataSettings = интерфейс
{
  colorSpace: PredefinedColorSpace
}


тип ImageEncodeOptions = интерфейс
{
  quality: Число

  type`: Текст
}


тип ImportMeta = интерфейс
{
  url: Текст
}


тип InputEventInit = интерфейс на основе UIEventInit
{
  data: Текст?

  dataTransfer: DataTransfer?

  inputType: Текст

  isComposing: ДаНет

  targetRanges: Список<StaticRange>
}


тип IntersectionObserverEntryInit = интерфейс
{
  boundingClientRect: DOMRectInit

  intersectionRatio: Число

  intersectionRect: DOMRectInit

  isIntersecting: ДаНет

  rootBounds: DOMRectInit?

  target: Element

  time: DOMHighResTimeStamp
}


тип IntersectionObserverInit = интерфейс
{
  root: Объект? /*(!)Element | Document | пусто*/

  rootMargin: Текст

  threshold: Объект? /*(!)Число | Список<Число>*/
}


тип JsonWebKey = интерфейс
{
  alg: Текст

  crv: Текст

  d: Текст

  dp: Текст

  dq: Текст

  e: Текст

  ext: ДаНет

  k: Текст

  key_ops: Список<Текст>

  kty: Текст

  n: Текст

  oth: Список<RsaOtherPrimesInfo>

  p: Текст

  q: Текст

  qi: Текст

  use: Текст

  x: Текст

  y: Текст
}


тип KeyAlgorithm = интерфейс
{
  name: Текст
}


тип KeyboardEventInit = интерфейс на основе EventModifierInit
{
  code: Текст

  isComposing: ДаНет

  key: Текст

  location: Число

  repeat: ДаНет
}


тип Keyframe = интерфейс
{
  composite: CompositeOperationOrAuto

  easing: Текст

  offset: Число?

  /*(!) [property: string]: string | number | null | undefined*/
}


тип KeyframeAnimationOptions = интерфейс на основе KeyframeEffectOptions
{
  id: Текст

  timeline: AnimationTimeline?
}


тип KeyframeEffectOptions = интерфейс на основе EffectTiming
{
  composite: CompositeOperation

  iterationComposite: IterationCompositeOperation

  pseudoElement: Текст?
}


тип LockInfo = интерфейс
{
  clientId: Текст

  mode: LockMode

  name: Текст
}


тип LockManagerSnapshot = интерфейс
{
  held: Список<LockInfo>

  pending: Список<LockInfo>
}


тип LockOptions = интерфейс
{
  ifAvailable: ДаНет

  mode: LockMode

  signal: AbortSignal

  steal: ДаНет
}


тип MIDIConnectionEventInit = интерфейс на основе EventInit
{
  port: MIDIPort
}


тип MIDIMessageEventInit = интерфейс на основе EventInit
{
  data: Uint8Array
}


тип MIDIOptions = интерфейс
{
  software: ДаНет

  sysex: ДаНет
}


тип MediaCapabilitiesDecodingInfo = интерфейс на основе MediaCapabilitiesInfo
{
  configuration: MediaDecodingConfiguration
}


тип MediaCapabilitiesEncodingInfo = интерфейс на основе MediaCapabilitiesInfo
{
  configuration: MediaEncodingConfiguration
}


тип MediaCapabilitiesInfo = интерфейс
{
  powerEfficient: ДаНет

  smooth: ДаНет

  supported: ДаНет
}


тип MediaConfiguration = интерфейс
{
  audio: AudioConfiguration

  video: VideoConfiguration
}


тип MediaDecodingConfiguration = интерфейс на основе MediaConfiguration
{
  type`: MediaDecodingType
}


тип MediaElementAudioSourceOptions = интерфейс
{
  mediaElement: HTMLMediaElement
}


тип MediaEncodingConfiguration = интерфейс на основе MediaConfiguration
{
  type`: MediaEncodingType
}


тип MediaEncryptedEventInit = интерфейс на основе EventInit
{
  initData: ArrayBuffer?

  initDataType: Текст
}


тип MediaImage = интерфейс
{
  sizes: Текст

  src: Текст

  type`: Текст
}


тип MediaKeyMessageEventInit = интерфейс на основе EventInit
{
  message: ArrayBuffer

  messageType: MediaKeyMessageType
}


тип MediaKeySystemConfiguration = интерфейс
{
  audioCapabilities: Список<MediaKeySystemMediaCapability>

  distinctiveIdentifier: MediaKeysRequirement

  initDataTypes: Список<Текст>

  label: Текст

  persistentState: MediaKeysRequirement

  sessionTypes: Список<Текст>

  videoCapabilities: Список<MediaKeySystemMediaCapability>
}


тип MediaKeySystemMediaCapability = интерфейс
{
  contentType: Текст

  encryptionScheme: Текст?

  robustness: Текст
}


тип MediaMetadataInit = интерфейс
{
  album: Текст

  artist: Текст

  artwork: Список<MediaImage>

  title: Текст
}


тип MediaPositionState = интерфейс
{
  duration: Число

  playbackRate: Число

  position: Число
}


тип MediaQueryListEventInit = интерфейс на основе EventInit
{
  matches: ДаНет

  media: Текст
}


тип MediaRecorderOptions = интерфейс
{
  audioBitsPerSecond: Число

  bitsPerSecond: Число

  mimeType: Текст

  videoBitsPerSecond: Число
}


тип MediaSessionActionDetails = интерфейс
{
  action: MediaSessionAction

  fastSeek: ДаНет

  seekOffset: Число

  seekTime: Число
}


тип MediaStreamAudioSourceOptions = интерфейс
{
  mediaStream: MediaStream
}


тип MediaStreamConstraints = интерфейс
{
  audio: Объект? /*(!)ДаНет | MediaTrackConstraints*/

  peerIdentity: Текст

  preferCurrentTab: ДаНет

  video: Объект? /*(!)ДаНет | MediaTrackConstraints*/
}


тип MediaStreamTrackEventInit = интерфейс на основе EventInit
{
  track: MediaStreamTrack
}


тип MediaTrackCapabilities = интерфейс
{
  aspectRatio: DoubleRange

  autoGainControl: Список<ДаНет>

  channelCount: ULongRange

  deviceId: Текст

  displaySurface: Текст

  echoCancellation: Список<ДаНет>

  facingMode: Список<Текст>

  frameRate: DoubleRange

  groupId: Текст

  height: ULongRange

  noiseSuppression: Список<ДаНет>

  sampleRate: ULongRange

  sampleSize: ULongRange

  width: ULongRange
}


тип MediaTrackConstraintSet = интерфейс
{
  aspectRatio: ConstrainDouble

  autoGainControl: ConstrainBoolean

  channelCount: ConstrainULong

  deviceId: ConstrainDOMString

  displaySurface: ConstrainDOMString

  echoCancellation: ConstrainBoolean

  facingMode: ConstrainDOMString

  frameRate: ConstrainDouble

  groupId: ConstrainDOMString

  height: ConstrainULong

  noiseSuppression: ConstrainBoolean

  sampleRate: ConstrainULong

  sampleSize: ConstrainULong

  width: ConstrainULong
}


тип MediaTrackConstraints = интерфейс на основе MediaTrackConstraintSet
{
  advanced: Список<MediaTrackConstraintSet>
}


тип MediaTrackSettings = интерфейс
{
  aspectRatio: Число

  autoGainControl: ДаНет

  channelCount: Число

  deviceId: Текст

  displaySurface: Текст

  echoCancellation: ДаНет

  facingMode: Текст

  frameRate: Число

  groupId: Текст

  height: Число

  noiseSuppression: ДаНет

  sampleRate: Число

  sampleSize: Число

  width: Число
}


тип MediaTrackSupportedConstraints = интерфейс
{
  aspectRatio: ДаНет

  autoGainControl: ДаНет

  channelCount: ДаНет

  deviceId: ДаНет

  displaySurface: ДаНет

  echoCancellation: ДаНет

  facingMode: ДаНет

  frameRate: ДаНет

  groupId: ДаНет

  height: ДаНет

  noiseSuppression: ДаНет

  sampleRate: ДаНет

  sampleSize: ДаНет

  width: ДаНет
}


тип MessageEventInit<T> = интерфейс на основе EventInit
{
  data: T

  lastEventId: Текст

  origin: Текст

  ports: Список<MessagePort>

  source: MessageEventSource?
}


тип MouseEventInit = интерфейс на основе EventModifierInit
{
  button: Число

  buttons: Число

  clientX: Число

  clientY: Число

  movementX: Число

  movementY: Число

  relatedTarget: EventTarget?

  screenX: Число

  screenY: Число
}


тип MultiCacheQueryOptions = интерфейс на основе CacheQueryOptions
{
  cacheName: Текст
}


тип MutationObserverInit = интерфейс
{
  attributeFilter: Список<Текст>

  attributeOldValue: ДаНет

  attributes: ДаНет

  characterData: ДаНет

  characterDataOldValue: ДаНет

  childList: ДаНет

  subtree: ДаНет
}


тип NavigationPreloadState = интерфейс
{
  enabled: ДаНет

  headerValue: Текст
}


тип NotificationAction = интерфейс
{
  action: Текст

  icon: Текст

  title: Текст
}


тип NotificationOptions = интерфейс
{
  actions: Список<NotificationAction>

  badge: Текст

  body: Текст

  data: /*(!) any */ Объект?

  dir: NotificationDirection

  icon: Текст

  image: Текст

  lang: Текст

  renotify: ДаНет

  requireInteraction: ДаНет

  silent: ДаНет?

  tag: Текст

  timestamp: EpochTimeStamp

  vibrate: VibratePattern
}


тип OfflineAudioCompletionEventInit = интерфейс на основе EventInit
{
  renderedBuffer: AudioBuffer
}


тип OfflineAudioContextOptions = интерфейс
{
  length: Число

  numberOfChannels: Число

  sampleRate: Число
}


тип OptionalEffectTiming = интерфейс
{
  delay: Число

  direction: PlaybackDirection

  duration: Объект? /*(!)Число | Текст*/

  easing: Текст

  endDelay: Число

  fill: FillMode

  iterationStart: Число

  iterations: Число

  playbackRate: Число
}


тип OscillatorOptions = интерфейс на основе AudioNodeOptions
{
  detune: Число

  frequency: Число

  periodicWave: PeriodicWave

  type`: OscillatorType
}


тип PageTransitionEventInit = интерфейс на основе EventInit
{
  persisted: ДаНет
}


тип PannerOptions = интерфейс на основе AudioNodeOptions
{
  coneInnerAngle: Число

  coneOuterAngle: Число

  coneOuterGain: Число

  distanceModel: DistanceModelType

  maxDistance: Число

  orientationX: Число

  orientationY: Число

  orientationZ: Число

  panningModel: PanningModelType

  positionX: Число

  positionY: Число

  positionZ: Число

  refDistance: Число

  rolloffFactor: Число
}


тип PaymentCurrencyAmount = интерфейс
{
  currency: Текст

  value: Текст
}


тип PaymentDetailsBase = интерфейс
{
  displayItems: Список<PaymentItem>

  modifiers: Список<PaymentDetailsModifier>
}


тип PaymentDetailsInit = интерфейс на основе PaymentDetailsBase
{
  id: Текст

  total: PaymentItem
}


тип PaymentDetailsModifier = интерфейс
{
  additionalDisplayItems: Список<PaymentItem>

  data: /*(!) any */ Объект?

  supportedMethods: Текст

  total: PaymentItem
}


тип PaymentDetailsUpdate = интерфейс на основе PaymentDetailsBase
{
  paymentMethodErrors: /*(!) any */ Объект?

  total: PaymentItem
}


тип PaymentItem = интерфейс
{
  amount: PaymentCurrencyAmount

  label: Текст

  pending: ДаНет
}


тип PaymentMethodChangeEventInit = интерфейс на основе PaymentRequestUpdateEventInit
{
  methodDetails: /*(!) any */ Объект?

  methodName: Текст
}


тип PaymentMethodData = интерфейс
{
  data: /*(!) any */ Объект?

  supportedMethods: Текст
}


тип PaymentRequestUpdateEventInit = интерфейс на основе EventInit
{

}


тип PaymentValidationErrors = интерфейс
{
  error`: Текст

  paymentMethod: /*(!) any */ Объект?
}


тип Pbkdf2Params = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier

  iterations: Число

  salt: BufferSource
}


тип PerformanceMarkOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  startTime: DOMHighResTimeStamp
}


тип PerformanceMeasureOptions = интерфейс
{
  detail: /*(!) any */ Объект?

  duration: DOMHighResTimeStamp

  end: Объект? /*(!)Текст | DOMHighResTimeStamp*/

  start: Объект? /*(!)Текст | DOMHighResTimeStamp*/
}


тип PerformanceObserverInit = интерфейс
{
  buffered: ДаНет

  entryTypes: Список<Текст>

  type`: Текст
}


тип PeriodicWaveConstraints = интерфейс
{
  disableNormalization: ДаНет
}


тип PeriodicWaveOptions = интерфейс на основе PeriodicWaveConstraints
{
  imag: Объект? /*(!)Список<Число> | Float32Array*/

  real: Объект? /*(!)Список<Число> | Float32Array*/
}


тип PermissionDescriptor = интерфейс
{
  name: PermissionName
}


тип PictureInPictureEventInit = интерфейс на основе EventInit
{
  pictureInPictureWindow: PictureInPictureWindow
}


тип PlaneLayout = интерфейс
{
  offset: Число

  stride: Число
}


тип PointerEventInit = интерфейс на основе MouseEventInit
{
  coalescedEvents: Список<PointerEvent>

  height: Число

  isPrimary: ДаНет

  pointerId: Число

  pointerType: Текст

  predictedEvents: Список<PointerEvent>

  pressure: Число

  tangentialPressure: Число

  tiltX: Число

  tiltY: Число

  twist: Число

  width: Число
}


тип PopStateEventInit = интерфейс на основе EventInit
{
  state: /*(!) any */ Объект?
}


тип PositionOptions = интерфейс
{
  enableHighAccuracy: ДаНет

  maximumAge: Число

  timeout: Число
}


тип ProgressEventInit = интерфейс на основе EventInit
{
  lengthComputable: ДаНет

  loaded: Число

  total: Число
}


тип PromiseRejectionEventInit = интерфейс на основе EventInit
{
  promise: Promise</*(!) any */ Объект?>

  reason: /*(!) any */ Объект?
}


тип PropertyDefinition = интерфейс
{
  inherits: ДаНет

  initialValue: Текст

  name: Текст

  syntax: Текст
}


тип PropertyIndexedKeyframes = интерфейс
{
  composite: Объект? /*(!)CompositeOperationOrAuto | Список<CompositeOperationOrAuto>*/

  easing: Объект? /*(!)Текст | Список<Текст>*/

  offset: Объект? /*(!)Число | Список<Число?>*/

  /*(!) [property: string]: string | string[] | number | null | (number | null)[] | undefined*/
}


тип PublicKeyCredentialCreationOptions = интерфейс
{
  attestation: AttestationConveyancePreference

  authenticatorSelection: AuthenticatorSelectionCriteria

  challenge: BufferSource

  excludeCredentials: Список<PublicKeyCredentialDescriptor>

  extensions: AuthenticationExtensionsClientInputs

  pubKeyCredParams: Список<PublicKeyCredentialParameters>

  rp: PublicKeyCredentialRpEntity

  timeout: Число

  user: PublicKeyCredentialUserEntity
}


тип PublicKeyCredentialDescriptor = интерфейс
{
  id: BufferSource

  transports: Список<AuthenticatorTransport>

  type`: PublicKeyCredentialType
}


тип PublicKeyCredentialEntity = интерфейс
{
  name: Текст
}


тип PublicKeyCredentialParameters = интерфейс
{
  alg: COSEAlgorithmIdentifier

  type`: PublicKeyCredentialType
}


тип PublicKeyCredentialRequestOptions = интерфейс
{
  allowCredentials: Список<PublicKeyCredentialDescriptor>

  challenge: BufferSource

  extensions: AuthenticationExtensionsClientInputs

  rpId: Текст

  timeout: Число

  userVerification: UserVerificationRequirement
}


тип PublicKeyCredentialRpEntity = интерфейс на основе PublicKeyCredentialEntity
{
  id: Текст
}


тип PublicKeyCredentialUserEntity = интерфейс на основе PublicKeyCredentialEntity
{
  displayName: Текст

  id: BufferSource
}


тип PushSubscriptionJSON = интерфейс
{
  endpoint: Текст

  expirationTime: EpochTimeStamp?

  keys: Record<Текст, Текст>
}


тип PushSubscriptionOptionsInit = интерфейс
{
  applicationServerKey: Объект? /*(!)BufferSource | Текст | пусто*/

  userVisibleOnly: ДаНет
}


тип QueuingStrategy<T> = интерфейс
{
  highWaterMark: Число

  size: QueuingStrategySize<T>
}


тип QueuingStrategyInit = интерфейс
{
  highWaterMark: Число
}


тип RTCAnswerOptions = интерфейс на основе RTCOfferAnswerOptions
{

}


тип RTCCertificateExpiration = интерфейс
{
  expires: Число
}


тип RTCConfiguration = интерфейс
{
  bundlePolicy: RTCBundlePolicy

  certificates: Список<RTCCertificate>

  iceCandidatePoolSize: Число

  iceServers: Список<RTCIceServer>

  iceTransportPolicy: RTCIceTransportPolicy

  rtcpMuxPolicy: RTCRtcpMuxPolicy
}


тип RTCDTMFToneChangeEventInit = интерфейс на основе EventInit
{
  tone: Текст
}


тип RTCDataChannelEventInit = интерфейс на основе EventInit
{
  channel: RTCDataChannel
}


тип RTCDataChannelInit = интерфейс
{
  id: Число

  maxPacketLifeTime: Число

  maxRetransmits: Число

  negotiated: ДаНет

  ordered: ДаНет

  protocol: Текст
}


тип RTCDtlsFingerprint = интерфейс
{
  algorithm: Текст

  value: Текст
}


тип RTCEncodedAudioFrameMetadata = интерфейс
{
  contributingSources: Список<Число>

  synchronizationSource: Число
}


тип RTCEncodedVideoFrameMetadata = интерфейс
{
  dependencies: Список<Число>

  frameId: Число

  height: Число

  spatialIndex: Число

  synchronizationSource: Число

  temporalIndex: Число

  width: Число
}


тип RTCErrorEventInit = интерфейс на основе EventInit
{
  error`: RTCError
}


тип RTCErrorInit = интерфейс
{
  errorDetail: RTCErrorDetailType

  httpRequestStatusCode: Число

  receivedAlert: Число

  sctpCauseCode: Число

  sdpLineNumber: Число

  sentAlert: Число
}


тип RTCIceCandidateInit = интерфейс
{
  candidate: Текст

  sdpMLineIndex: Число?

  sdpMid: Текст?

  usernameFragment: Текст?
}


тип RTCIceCandidatePair = интерфейс
{
  local: RTCIceCandidate

  remote: RTCIceCandidate
}


тип RTCIceCandidatePairStats = интерфейс на основе RTCStats
{
  availableIncomingBitrate: Число

  availableOutgoingBitrate: Число

  bytesReceived: Число

  bytesSent: Число

  currentRoundTripTime: Число

  lastPacketReceivedTimestamp: DOMHighResTimeStamp

  lastPacketSentTimestamp: DOMHighResTimeStamp

  localCandidateId: Текст

  nominated: ДаНет

  remoteCandidateId: Текст

  requestsReceived: Число

  requestsSent: Число

  responsesReceived: Число

  responsesSent: Число

  state: RTCStatsIceCandidatePairState

  totalRoundTripTime: Число

  transportId: Текст
}


тип RTCIceServer = интерфейс
{
  credential: Текст

  urls: Объект? /*(!)Текст | Список<Текст>*/

  username: Текст
}


тип RTCInboundRtpStreamStats = интерфейс на основе RTCReceivedRtpStreamStats
{
  audioLevel: Число

  bytesReceived: Число

  concealedSamples: Число

  concealmentEvents: Число

  decoderImplementation: Текст

  estimatedPlayoutTimestamp: DOMHighResTimeStamp

  fecPacketsDiscarded: Число

  fecPacketsReceived: Число

  firCount: Число

  frameHeight: Число

  frameWidth: Число

  framesDecoded: Число

  framesDropped: Число

  framesPerSecond: Число

  framesReceived: Число

  headerBytesReceived: Число

  insertedSamplesForDeceleration: Число

  jitterBufferDelay: Число

  jitterBufferEmittedCount: Число

  keyFramesDecoded: Число

  kind: Текст

  lastPacketReceivedTimestamp: DOMHighResTimeStamp

  mid: Текст

  nackCount: Число

  packetsDiscarded: Число

  pliCount: Число

  qpSum: Число

  remoteId: Текст

  removedSamplesForAcceleration: Число

  silentConcealedSamples: Число

  totalAudioEnergy: Число

  totalDecodeTime: Число

  totalInterFrameDelay: Число

  totalProcessingDelay: Число

  totalSamplesDuration: Число

  totalSamplesReceived: Число

  totalSquaredInterFrameDelay: Число

  trackIdentifier: Текст
}


тип RTCLocalSessionDescriptionInit = интерфейс
{
  sdp: Текст

  type`: RTCSdpType
}


тип RTCOfferAnswerOptions = интерфейс
{

}


тип RTCOfferOptions = интерфейс на основе RTCOfferAnswerOptions
{
  iceRestart: ДаНет

  offerToReceiveAudio: ДаНет

  offerToReceiveVideo: ДаНет
}


тип RTCOutboundRtpStreamStats = интерфейс на основе RTCSentRtpStreamStats
{
  firCount: Число

  frameHeight: Число

  frameWidth: Число

  framesEncoded: Число

  framesPerSecond: Число

  framesSent: Число

  headerBytesSent: Число

  hugeFramesSent: Число

  keyFramesEncoded: Число

  mediaSourceId: Текст

  nackCount: Число

  pliCount: Число

  qpSum: Число

  qualityLimitationResolutionChanges: Число

  remoteId: Текст

  retransmittedBytesSent: Число

  retransmittedPacketsSent: Число

  rid: Текст

  targetBitrate: Число

  totalEncodeTime: Число

  totalEncodedBytesTarget: Число

  totalPacketSendDelay: Число
}


тип RTCPeerConnectionIceErrorEventInit = интерфейс на основе EventInit
{
  address: Текст?

  errorCode: Число

  errorText: Текст

  port: Число?

  url: Текст
}


тип RTCPeerConnectionIceEventInit = интерфейс на основе EventInit
{
  candidate: RTCIceCandidate?

  url: Текст?
}


тип RTCReceivedRtpStreamStats = интерфейс на основе RTCRtpStreamStats
{
  jitter: Число

  packetsLost: Число

  packetsReceived: Число
}


тип RTCRtcpParameters = интерфейс
{
  cname: Текст

  reducedSize: ДаНет
}


тип RTCRtpCapabilities = интерфейс
{
  codecs: Список<RTCRtpCodecCapability>

  headerExtensions: Список<RTCRtpHeaderExtensionCapability>
}


тип RTCRtpCodec = интерфейс
{
  channels: Число

  clockRate: Число

  mimeType: Текст

  sdpFmtpLine: Текст
}


тип RTCRtpCodecCapability = интерфейс на основе RTCRtpCodec
{

}


тип RTCRtpCodecParameters = интерфейс на основе RTCRtpCodec
{
  payloadType: Число
}


тип RTCRtpCodingParameters = интерфейс
{
  rid: Текст
}


тип RTCRtpContributingSource = интерфейс
{
  audioLevel: Число

  rtpTimestamp: Число

  source: Число

  timestamp: DOMHighResTimeStamp
}


тип RTCRtpEncodingParameters = интерфейс на основе RTCRtpCodingParameters
{
  active: ДаНет

  maxBitrate: Число

  maxFramerate: Число

  networkPriority: RTCPriorityType

  priority: RTCPriorityType

  scaleResolutionDownBy: Число
}


тип RTCRtpHeaderExtensionCapability = интерфейс
{
  uri: Текст
}


тип RTCRtpHeaderExtensionParameters = интерфейс
{
  encrypted: ДаНет

  id: Число

  uri: Текст
}


тип RTCRtpParameters = интерфейс
{
  codecs: Список<RTCRtpCodecParameters>

  headerExtensions: Список<RTCRtpHeaderExtensionParameters>

  rtcp: RTCRtcpParameters
}


тип RTCRtpReceiveParameters = интерфейс на основе RTCRtpParameters
{

}


тип RTCRtpSendParameters = интерфейс на основе RTCRtpParameters
{
  degradationPreference: RTCDegradationPreference

  encodings: Список<RTCRtpEncodingParameters>

  transactionId: Текст
}


тип RTCRtpStreamStats = интерфейс на основе RTCStats
{
  codecId: Текст

  kind: Текст

  ssrc: Число

  transportId: Текст
}


тип RTCRtpSynchronizationSource = интерфейс на основе RTCRtpContributingSource
{

}


тип RTCRtpTransceiverInit = интерфейс
{
  direction: RTCRtpTransceiverDirection

  sendEncodings: Список<RTCRtpEncodingParameters>

  streams: Список<MediaStream>
}


тип RTCSentRtpStreamStats = интерфейс на основе RTCRtpStreamStats
{
  bytesSent: Число

  packetsSent: Число
}


тип RTCSessionDescriptionInit = интерфейс
{
  sdp: Текст

  type`: RTCSdpType
}


тип RTCStats = интерфейс
{
  id: Текст

  timestamp: DOMHighResTimeStamp

  type`: RTCStatsType
}


тип RTCTrackEventInit = интерфейс на основе EventInit
{
  receiver: RTCRtpReceiver

  streams: Список<MediaStream>

  track: MediaStreamTrack

  transceiver: RTCRtpTransceiver
}


тип RTCTransportStats = интерфейс на основе RTCStats
{
  bytesReceived: Число

  bytesSent: Число

  dtlsCipher: Текст

  dtlsState: RTCDtlsTransportState

  localCertificateId: Текст

  remoteCertificateId: Текст

  selectedCandidatePairId: Текст

  srtpCipher: Текст

  tlsVersion: Текст
}


тип ReadableStreamGetReaderOptions = интерфейс
{
  mode: ReadableStreamReaderMode
}


тип ReadableStreamReadDoneResult<T> = интерфейс
{
  done: да

  value: T
}


тип ReadableStreamReadValueResult<T> = интерфейс
{
  done: нет

  value: T
}


тип ReadableWritablePair<R, W> = интерфейс
{
  readable: ReadableStream<R>

  writable: WritableStream<W>
}


тип RegistrationOptions = интерфейс
{
  scope: Текст

  type`: WorkerType

  updateViaCache: ServiceWorkerUpdateViaCache
}


тип ReportingObserverOptions = интерфейс
{
  buffered: ДаНет

  types: Список<Текст>
}


тип RequestInit = интерфейс
{
  body: BodyInit?

  cache: RequestCache

  credentials: RequestCredentials

  headers: HeadersInit

  integrity: Текст

  keepalive: ДаНет

  method: Текст

  mode: RequestMode

  redirect: RequestRedirect

  referrer: Текст

  referrerPolicy: ReferrerPolicy

  signal: AbortSignal?

  window: пусто
}


тип ResizeObserverOptions = интерфейс
{
  box: ResizeObserverBoxOptions
}


тип ResponseInit = интерфейс
{
  headers: HeadersInit

  status: Число

  statusText: Текст
}


тип RsaHashedImportParams = интерфейс на основе Algorithm
{
  hash: HashAlgorithmIdentifier
}


тип RsaHashedKeyAlgorithm = интерфейс на основе RsaKeyAlgorithm
{
  hash: KeyAlgorithm
}


тип RsaHashedKeyGenParams = интерфейс на основе RsaKeyGenParams
{
  hash: HashAlgorithmIdentifier
}


тип RsaKeyAlgorithm = интерфейс на основе KeyAlgorithm
{
  modulusLength: Число

  publicExponent: BigInteger
}


тип RsaKeyGenParams = интерфейс на основе Algorithm
{
  modulusLength: Число

  publicExponent: BigInteger
}


тип RsaOaepParams = интерфейс на основе Algorithm
{
  label: BufferSource
}


тип RsaOtherPrimesInfo = интерфейс
{
  d: Текст

  r: Текст

  t: Текст
}


тип RsaPssParams = интерфейс на основе Algorithm
{
  saltLength: Число
}


тип SVGBoundingBoxOptions = интерфейс
{
  clipped: ДаНет

  fill: ДаНет

  markers: ДаНет

  stroke: ДаНет
}


тип ScrollIntoViewOptions = интерфейс на основе ScrollOptions
{
  block: ScrollLogicalPosition

  inline: ScrollLogicalPosition
}


тип ScrollOptions = интерфейс
{
  behavior: ScrollBehavior
}


тип ScrollToOptions = интерфейс на основе ScrollOptions
{
  left: Число

  top: Число
}


тип SecurityPolicyViolationEventInit = интерфейс на основе EventInit
{
  blockedURI: Текст

  columnNumber: Число

  disposition: SecurityPolicyViolationEventDisposition

  documentURI: Текст

  effectiveDirective: Текст

  lineNumber: Число

  originalPolicy: Текст

  referrer: Текст

  sample: Текст

  sourceFile: Текст

  statusCode: Число

  violatedDirective: Текст
}


тип ShadowRootInit = интерфейс
{
  delegatesFocus: ДаНет

  mode: ShadowRootMode

  slotAssignment: SlotAssignmentMode
}


тип ShareData = интерфейс
{
  files: Список<File>

  text: Текст

  title: Текст

  url: Текст
}


тип SpeechSynthesisErrorEventInit = интерфейс на основе SpeechSynthesisEventInit
{
  error`: SpeechSynthesisErrorCode
}


тип SpeechSynthesisEventInit = интерфейс на основе EventInit
{
  charIndex: Число

  charLength: Число

  elapsedTime: Число

  name: Текст

  utterance: SpeechSynthesisUtterance
}


тип StaticRangeInit = интерфейс
{
  endContainer: Node

  endOffset: Число

  startContainer: Node

  startOffset: Число
}


тип StereoPannerOptions = интерфейс на основе AudioNodeOptions
{
  pan: Число
}


тип StorageEstimate = интерфейс
{
  quota: Число

  usage: Число
}


тип StorageEventInit = интерфейс на основе EventInit
{
  key: Текст?

  newValue: Текст?

  oldValue: Текст?

  storageArea: Storage?

  url: Текст
}


тип StreamPipeOptions = интерфейс
{
  preventAbort: ДаНет

  preventCancel: ДаНет

  preventClose: ДаНет

  signal: AbortSignal
}


тип StructuredSerializeOptions = интерфейс
{
  transfer: Список<Transferable>
}


тип SubmitEventInit = интерфейс на основе EventInit
{
  submitter: HTMLElement?
}


тип TextDecodeOptions = интерфейс
{
  stream: ДаНет
}


тип TextDecoderOptions = интерфейс
{
  fatal: ДаНет

  ignoreBOM: ДаНет
}


тип TextEncoderEncodeIntoResult = интерфейс
{
  read: Число

  written: Число
}


тип ToggleEventInit = интерфейс на основе EventInit
{
  newState: Текст

  oldState: Текст
}


тип TouchEventInit = интерфейс на основе EventModifierInit
{
  changedTouches: Список<Touch>

  targetTouches: Список<Touch>

  touches: Список<Touch>
}


тип TouchInit = интерфейс
{
  altitudeAngle: Число

  azimuthAngle: Число

  clientX: Число

  clientY: Число

  force: Число

  identifier: Число

  pageX: Число

  pageY: Число

  radiusX: Число

  radiusY: Число

  rotationAngle: Число

  screenX: Число

  screenY: Число

  target: EventTarget

  touchType: TouchType
}


тип TrackEventInit = интерфейс на основе EventInit
{
  track: TextTrack?
}


тип Transformer<I, O> = интерфейс
{
  flush: TransformerFlushCallback<O>

  readableType: пусто

  start: TransformerStartCallback<O>

  transform: TransformerTransformCallback<I, O>

  writableType: пусто
}


тип TransitionEventInit = интерфейс на основе EventInit
{
  elapsedTime: Число

  propertyName: Текст

  pseudoElement: Текст
}


тип UIEventInit = интерфейс на основе EventInit
{
  detail: Число

  view: Window?
}


тип ULongRange = интерфейс
{
  max: Число

  min: Число
}


тип UnderlyingByteSource = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableByteStreamController): PromiseLike<Ничего>?

  start: операция(controller: ReadableByteStreamController): /*(!) any */ Объект?

  type`: "bytes"
}


тип UnderlyingDefaultSource<R> = интерфейс
{
  cancel: UnderlyingSourceCancelCallback

  pull: операция(controller: ReadableStreamDefaultController<R>): PromiseLike<Ничего>?

  start: операция(controller: ReadableStreamDefaultController<R>): /*(!) any */ Объект?

  type`: пусто
}


тип UnderlyingSink<W> = интерфейс
{
  abort: UnderlyingSinkAbortCallback

  close: UnderlyingSinkCloseCallback

  start: UnderlyingSinkStartCallback

  type`: пусто

  write: UnderlyingSinkWriteCallback<W>
}


тип UnderlyingSource<R> = интерфейс
{
  autoAllocateChunkSize: Число

  cancel: UnderlyingSourceCancelCallback

  pull: UnderlyingSourcePullCallback<R>

  start: UnderlyingSourceStartCallback<R>

  type`: ReadableStreamType
}


тип ValidityStateFlags = интерфейс
{
  badInput: ДаНет

  customError: ДаНет

  patternMismatch: ДаНет

  rangeOverflow: ДаНет

  rangeUnderflow: ДаНет

  stepMismatch: ДаНет

  tooLong: ДаНет

  tooShort: ДаНет

  typeMismatch: ДаНет

  valueMissing: ДаНет
}


тип VideoColorSpaceInit = интерфейс
{
  fullRange: ДаНет?

  matrix: VideoMatrixCoefficients?

  primaries: VideoColorPrimaries?

  transfer: VideoTransferCharacteristics?
}


тип VideoConfiguration = интерфейс
{
  bitrate: Число

  colorGamut: ColorGamut

  contentType: Текст

  framerate: Число

  hdrMetadataType: HdrMetadataType

  height: Число

  scalabilityMode: Текст

  transferFunction: TransferFunction

  width: Число
}


тип VideoDecoderConfig = интерфейс
{
  codec: Текст

  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  description: BufferSource

  displayAspectHeight: Число

  displayAspectWidth: Число

  hardwareAcceleration: HardwareAcceleration

  optimizeForLatency: ДаНет
}


тип VideoDecoderInit = интерфейс
{
  error`: WebCodecsErrorCallback

  output: VideoFrameOutputCallback
}


тип VideoDecoderSupport = интерфейс
{
  config: VideoDecoderConfig

  supported: ДаНет
}


тип VideoEncoderConfig = интерфейс
{
  alpha: AlphaOption

  avc: AvcEncoderConfig

  bitrate: Число

  bitrateMode: VideoEncoderBitrateMode

  codec: Текст

  displayHeight: Число

  displayWidth: Число

  framerate: Число

  hardwareAcceleration: HardwareAcceleration

  height: Число

  latencyMode: LatencyMode

  scalabilityMode: Текст

  width: Число
}


тип VideoEncoderEncodeOptions = интерфейс
{
  keyFrame: ДаНет
}


тип VideoEncoderInit = интерфейс
{
  error`: WebCodecsErrorCallback

  output: EncodedVideoChunkOutputCallback
}


тип VideoEncoderSupport = интерфейс
{
  config: VideoEncoderConfig

  supported: ДаНет
}


тип VideoFrameBufferInit = интерфейс
{
  codedHeight: Число

  codedWidth: Число

  colorSpace: VideoColorSpaceInit

  displayHeight: Число

  displayWidth: Число

  duration: Число

  format: VideoPixelFormat

  layout: Список<PlaneLayout>

  timestamp: Число

  visibleRect: DOMRectInit
}


тип VideoFrameCallbackMetadata = интерфейс
{
  captureTime: DOMHighResTimeStamp

  expectedDisplayTime: DOMHighResTimeStamp

  height: Число

  mediaTime: Число

  presentationTime: DOMHighResTimeStamp

  presentedFrames: Число

  processingDuration: Число

  receiveTime: DOMHighResTimeStamp

  rtpTimestamp: Число

  width: Число
}


тип VideoFrameCopyToOptions = интерфейс
{
  layout: Список<PlaneLayout>

  rect: DOMRectInit
}


тип VideoFrameInit = интерфейс
{
  alpha: AlphaOption

  displayHeight: Число

  displayWidth: Число

  duration: Число

  timestamp: Число

  visibleRect: DOMRectInit
}


тип WaveShaperOptions = интерфейс на основе AudioNodeOptions
{
  curve: Объект? /*(!)Список<Число> | Float32Array*/

  oversample: OverSampleType
}


тип WebGLContextAttributes = интерфейс
{
  alpha: ДаНет

  antialias: ДаНет

  depth: ДаНет

  desynchronized: ДаНет

  failIfMajorPerformanceCaveat: ДаНет

  powerPreference: WebGLPowerPreference

  premultipliedAlpha: ДаНет

  preserveDrawingBuffer: ДаНет

  stencil: ДаНет
}


тип WebGLContextEventInit = интерфейс на основе EventInit
{
  statusMessage: Текст
}


тип WebTransportCloseInfo = интерфейс
{
  closeCode: Число

  reason: Текст
}


тип WebTransportErrorOptions = интерфейс
{
  source: WebTransportErrorSource

  streamErrorCode: Число?
}


тип WebTransportHash = интерфейс
{
  algorithm: Текст

  value: BufferSource
}


тип WebTransportOptions = интерфейс
{
  allowPooling: ДаНет

  congestionControl: WebTransportCongestionControl

  requireUnreliable: ДаНет

  serverCertificateHashes: Список<WebTransportHash>
}


тип WebTransportSendStreamOptions = интерфейс
{
  sendOrder: Число?
}


тип WheelEventInit = интерфейс на основе MouseEventInit
{
  deltaMode: Число

  deltaX: Число

  deltaY: Число

  deltaZ: Число
}


тип WindowPostMessageOptions = интерфейс на основе StructuredSerializeOptions
{
  targetOrigin: Текст
}


тип WorkerOptions = интерфейс
{
  credentials: RequestCredentials

  name: Текст

  type`: WorkerType
}


тип WorkletOptions = интерфейс
{
  credentials: RequestCredentials
}


тип WriteParams = интерфейс
{
  data: Объект? /*(!)BufferSource | Blob | Текст | пусто*/

  position: Число?

  size: Число?

  type`: WriteCommandType
}


тип NodeFilter = Объект? /*(!)операция(node: Node): Число | объект { операция acceptNode(node: Node): Число }*/

внешнее
/*(!) var */ NodeFilter: объект { защищено  FILTER_ACCEPT: 1; защищено  FILTER_REJECT: 2; защищено  FILTER_SKIP: 3; защищено  SHOW_ALL: 0xFFFFFFFF; защищено  SHOW_ELEMENT: 0x1; защищено  SHOW_ATTRIBUTE: 0x2; защищено  SHOW_TEXT: 0x4; защищено  SHOW_CDATA_SECTION: 0x8; защищено  SHOW_ENTITY_REFERENCE: 0x10; защищено  SHOW_ENTITY: 0x20; защищено  SHOW_PROCESSING_INSTRUCTION: 0x40; защищено  SHOW_COMMENT: 0x80; защищено  SHOW_DOCUMENT: 0x100; защищено  SHOW_DOCUMENT_TYPE: 0x200; защищено  SHOW_DOCUMENT_FRAGMENT: 0x400; защищено  SHOW_NOTATION: 0x800 }


тип XPathNSResolver = Объект? /*(!)операция(prefix: Текст?): Текст? | объект { операция lookupNamespaceURI(prefix: Текст?): Текст? }*/

/**
* The ANGLE_instanced_arrays extension is part of the WebGL API and allows to draw the same object, or groups of similar objects multiple times, if they share the same vertex data, primitive count and type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ANGLE_instanced_arrays)
*/

тип ANGLE_instanced_arrays = интерфейс
{
  операция drawArraysInstancedANGLE(mode: GLenum, first: GLint, count: GLsizei, primcount: GLsizei)

  операция drawElementsInstancedANGLE(mode: GLenum, count: GLsizei, type`: GLenum, offset: GLintptr, primcount: GLsizei)

  операция vertexAttribDivisorANGLE(index: GLuint, divisor: GLuint)

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE
}


тип ARIAMixin = интерфейс
{
  ariaAtomic: Текст?

  ariaAutoComplete: Текст?

  ariaBusy: Текст?

  ariaChecked: Текст?

  ariaColCount: Текст?

  ariaColIndex: Текст?

  ariaColSpan: Текст?

  ariaCurrent: Текст?

  ariaDisabled: Текст?

  ariaExpanded: Текст?

  ariaHasPopup: Текст?

  ariaHidden: Текст?

  ariaInvalid: Текст?

  ariaKeyShortcuts: Текст?

  ariaLabel: Текст?

  ariaLevel: Текст?

  ariaLive: Текст?

  ariaModal: Текст?

  ariaMultiLine: Текст?

  ariaMultiSelectable: Текст?

  ariaOrientation: Текст?

  ariaPlaceholder: Текст?

  ariaPosInSet: Текст?

  ariaPressed: Текст?

  ariaReadOnly: Текст?

  ariaRequired: Текст?

  ariaRoleDescription: Текст?

  ariaRowCount: Текст?

  ariaRowIndex: Текст?

  ariaRowSpan: Текст?

  ariaSelected: Текст?

  ariaSetSize: Текст?

  ariaSort: Текст?

  ariaValueMax: Текст?

  ariaValueMin: Текст?

  ariaValueNow: Текст?

  ariaValueText: Текст?

  role: Текст?
}


/**
* A controller object that allows you to abort one or more DOM requests as and when desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)
*/

тип AbortController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция abort(reason: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ AbortController: объект { prototype: AbortController; при создании(): AbortController }


тип AbortSignalEventMap = интерфейс
{
  "abort": Event
}


/**
* A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)
*/

тип AbortSignal = интерфейс на основе EventTarget
{
  защищено 
  aborted: ДаНет

  onabort: (операция(this: AbortSignal, ev: Event): /*(!) any */ Объект?)?

  защищено 
  reason: /*(!) any */ Объект?

  операция throwIfAborted()

  операция addEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type`: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AbortSignalEventMap */ Объект?>(type`: K, listener: операция(this: AbortSignal, ev: /*(!) AbortSignalEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ AbortSignal: объект { prototype: AbortSignal; при создании(): AbortSignal; операция abort(reason: /*(!) any */ Объект? = пусто): AbortSignal; операция timeout(milliseconds: Число): AbortSignal }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbstractRange) */

тип AbstractRange = интерфейс
{
  защищено 
  collapsed: ДаНет

  защищено 
  endContainer: Node

  защищено 
  endOffset: Число

  защищено 
  startContainer: Node

  защищено 
  startOffset: Число
}


внешнее
/*(!) var */ AbstractRange: объект { prototype: AbstractRange; при создании(): AbstractRange }


тип AbstractWorkerEventMap = интерфейс
{
  "error": ErrorEvent
}


тип AbstractWorker = интерфейс
{
  onerror: (операция(this: AbstractWorker, ev: ErrorEvent): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type`: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type`: K, listener: операция(this: AbstractWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


/**
* A node able to provide real-time frequency and time-domain analysis information. It is an AudioNode that passes the audio stream unchanged from the input to the output, but allows you to take the generated data, process it, and create audio visualizations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnalyserNode)
*/

тип AnalyserNode = интерфейс на основе AudioNode
{
  fftSize: Число

  защищено 
  frequencyBinCount: Число

  maxDecibels: Число

  minDecibels: Число

  smoothingTimeConstant: Число

  операция getByteFrequencyData(array: Uint8Array)

  операция getByteTimeDomainData(array: Uint8Array)

  операция getFloatFrequencyData(array: Float32Array)

  операция getFloatTimeDomainData(array: Float32Array)
}


внешнее
/*(!) var */ AnalyserNode: объект { prototype: AnalyserNode; при создании(context: BaseAudioContext, options: AnalyserOptions? = пусто): AnalyserNode }


тип Animatable = интерфейс
{
  операция animate(keyframes: Объект? /*(!)Список<Keyframe> | PropertyIndexedKeyframes | пусто*/, options: Объект? /*(!)Число | KeyframeAnimationOptions | пусто*/ = пусто): Animation

  операция getAnimations(options: GetAnimationsOptions? = пусто): Список<Animation>
}


тип AnimationEventMap = интерфейс
{
  "cancel": AnimationPlaybackEvent

  "finish": AnimationPlaybackEvent

  "remove": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Animation) */

тип Animation = интерфейс на основе EventTarget
{
  currentTime: CSSNumberish?

  effect: AnimationEffect?

  защищено 
  finished: Promise<Animation>

  id: Текст

  oncancel: (операция(this: Animation, ev: AnimationPlaybackEvent): /*(!) any */ Объект?)?

  onfinish: (операция(this: Animation, ev: AnimationPlaybackEvent): /*(!) any */ Объект?)?

  onremove: (операция(this: Animation, ev: Event): /*(!) any */ Объект?)?

  защищено 
  pending: ДаНет

  защищено 
  playState: AnimationPlayState

  playbackRate: Число

  защищено 
  ready: Promise<Animation>

  защищено 
  replaceState: AnimationReplaceState

  startTime: CSSNumberish?

  timeline: AnimationTimeline?

  операция cancel()

  операция commitStyles()

  операция finish()

  операция pause()

  операция persist()

  операция play()

  операция reverse()

  операция updatePlaybackRate(playbackRate: Число)

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: Animation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: Animation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Animation: объект { prototype: Animation; при создании(effect: AnimationEffect? = пусто, timeline: AnimationTimeline? = пусто): Animation }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationEffect) */

тип AnimationEffect = интерфейс
{
  операция getComputedTiming(): ComputedEffectTiming

  операция getTiming(): EffectTiming

  операция updateTiming(timing: OptionalEffectTiming? = пусто)
}


внешнее
/*(!) var */ AnimationEffect: объект { prototype: AnimationEffect; при создании(): AnimationEffect }


/**
* Events providing information related to animations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationEvent)
*/

тип AnimationEvent = интерфейс на основе Event
{
  защищено 
  animationName: Текст

  защищено 
  elapsedTime: Число

  защищено 
  pseudoElement: Текст
}


внешнее
/*(!) var */ AnimationEvent: объект { prototype: AnimationEvent; при создании(type`: Текст, animationEventInitDict: AnimationEventInit? = пусто): AnimationEvent }


тип AnimationFrameProvider = интерфейс
{
  операция cancelAnimationFrame(handle: Число)

  операция requestAnimationFrame(callback: FrameRequestCallback): Число
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationPlaybackEvent) */

тип AnimationPlaybackEvent = интерфейс на основе Event
{
  защищено 
  currentTime: CSSNumberish?

  защищено 
  timelineTime: CSSNumberish?
}


внешнее
/*(!) var */ AnimationPlaybackEvent: объект { prototype: AnimationPlaybackEvent; при создании(type`: Текст, eventInitDict: AnimationPlaybackEventInit? = пусто): AnimationPlaybackEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AnimationTimeline) */

тип AnimationTimeline = интерфейс
{
  защищено 
  currentTime: CSSNumberish?
}


внешнее
/*(!) var */ AnimationTimeline: объект { prototype: AnimationTimeline; при создании(): AnimationTimeline }


/**
* A DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Attr)
*/

тип Attr = интерфейс на основе Node
{
  защищено 
  ownerDocument: Document
}


внешнее
/*(!) var */ Attr: объект { prototype: Attr; при создании(): Attr }


/**
* A short audio asset residing in memory, created from an audio file using the AudioContext.decodeAudioData() method, or from raw data using AudioContext.createBuffer(). Once put into an AudioBuffer, the audio can then be played by being passed into an AudioBufferSourceNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioBuffer)
*/

тип AudioBuffer = интерфейс
{
  защищено 
  duration: Число

  защищено 
  length: Число

  защищено 
  numberOfChannels: Число

  защищено 
  sampleRate: Число

  операция copyFromChannel(destination: Float32Array, channelNumber: Число, bufferOffset: Число? = пусто)

  операция copyToChannel(source: Float32Array, channelNumber: Число, bufferOffset: Число? = пусто)

  операция getChannelData(channel: Число): Float32Array
}


внешнее
/*(!) var */ AudioBuffer: объект { prototype: AudioBuffer; при создании(options: AudioBufferOptions): AudioBuffer }


/**
* An AudioScheduledSourceNode which represents an audio source consisting of in-memory audio data, stored in an AudioBuffer. It's especially useful for playing back audio which has particularly stringent timing accuracy requirements, such as for sounds that must match a specific rhythm and can be kept in memory rather than being played from disk or the network.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioBufferSourceNode)
*/

тип AudioBufferSourceNode = интерфейс на основе AudioScheduledSourceNode
{
  buffer: AudioBuffer?

  защищено 
  detune: AudioParam

  loop: ДаНет

  loopEnd: Число

  loopStart: Число

  защищено 
  playbackRate: AudioParam

  операция start(when: Число? = пусто, offset: Число? = пусто, duration: Число? = пусто)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioBufferSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioBufferSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ AudioBufferSourceNode: объект { prototype: AudioBufferSourceNode; при создании(context: BaseAudioContext, options: AudioBufferSourceOptions? = пусто): AudioBufferSourceNode }


/**
* An audio-processing graph built from audio modules linked together, each represented by an AudioNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioContext)
*/

тип AudioContext = интерфейс на основе BaseAudioContext
{
  защищено 
  baseLatency: Число

  защищено 
  outputLatency: Число

  операция close(): Promise<Ничего>

  операция createMediaElementSource(mediaElement: HTMLMediaElement): MediaElementAudioSourceNode

  операция createMediaStreamDestination(): MediaStreamAudioDestinationNode

  операция createMediaStreamSource(mediaStream: MediaStream): MediaStreamAudioSourceNode

  операция getOutputTimestamp(): AudioTimestamp

  операция resume(): Promise<Ничего>

  операция suspend(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: AudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: AudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ AudioContext: объект { prototype: AudioContext; при создании(contextOptions: AudioContextOptions? = пусто): AudioContext }


/**
* AudioDestinationNode has no output (as it is the output, no more AudioNode can be linked after it in the audio graph) and one input. The number of channels in the input must be between 0 and the maxChannelCount value or an exception is raised.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioDestinationNode)
*/

тип AudioDestinationNode = интерфейс на основе AudioNode
{
  защищено 
  maxChannelCount: Число
}


внешнее
/*(!) var */ AudioDestinationNode: объект { prototype: AudioDestinationNode; при создании(): AudioDestinationNode }


/**
* The position and orientation of the unique person listening to the audio scene, and is used in audio spatialization. All PannerNodes spatialize in relation to the AudioListener stored in the BaseAudioContext.listener attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioListener)
*/

тип AudioListener = интерфейс
{

}


внешнее
/*(!) var */ AudioListener: объект { prototype: AudioListener; при создании(): AudioListener }


/**
* A generic interface for representing an audio processing module. Examples include:
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioNode)
*/

тип AudioNode = интерфейс на основе EventTarget
{
  channelCount: Число

  channelCountMode: ChannelCountMode

  channelInterpretation: ChannelInterpretation

  защищено 
  context: BaseAudioContext

  защищено 
  numberOfInputs: Число

  защищено 
  numberOfOutputs: Число

  операция connect(destinationNode: AudioNode, output: Число? = пусто, input: Число? = пусто): AudioNode

  операция connect(destinationParam: AudioParam, output: Число? = пусто)

  операция disconnect()

  операция disconnect(output: Число)

  операция disconnect(destinationNode: AudioNode)

  операция disconnect(destinationNode: AudioNode, output: Число)

  операция disconnect(destinationNode: AudioNode, output: Число, input: Число)

  операция disconnect(destinationParam: AudioParam)

  операция disconnect(destinationParam: AudioParam, output: Число)
}


внешнее
/*(!) var */ AudioNode: объект { prototype: AudioNode; при создании(): AudioNode }


/**
* The Web Audio API's AudioParam interface represents an audio-related parameter, usually a parameter of an AudioNode (such as GainNode.gain).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioParam)
*/

тип AudioParam = интерфейс
{
  automationRate: AutomationRate

  защищено 
  defaultValue: Число

  защищено 
  maxValue: Число

  защищено 
  minValue: Число

  value: Число

  операция cancelAndHoldAtTime(cancelTime: Число): AudioParam

  операция cancelScheduledValues(cancelTime: Число): AudioParam

  операция exponentialRampToValueAtTime(value: Число, endTime: Число): AudioParam

  операция linearRampToValueAtTime(value: Число, endTime: Число): AudioParam

  операция setTargetAtTime(target: Число, startTime: Число, timeConstant: Число): AudioParam

  операция setValueAtTime(value: Число, startTime: Число): AudioParam

  операция setValueCurveAtTime(values: Объект? /*(!)Список<Число> | Float32Array*/, startTime: Число, duration: Число): AudioParam
}


внешнее
/*(!) var */ AudioParam: объект { prototype: AudioParam; при создании(): AudioParam }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioParamMap) */

тип AudioParamMap = интерфейс
{
  операция forEach(callbackfn: операция(value: AudioParam, key: Текст, parent: AudioParamMap), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ AudioParamMap: объект { prototype: AudioParamMap; при создании(): AudioParamMap }


тип AudioScheduledSourceNodeEventMap = интерфейс
{
  "ended": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioScheduledSourceNode) */

тип AudioScheduledSourceNode = интерфейс на основе AudioNode
{
  onended: (операция(this: AudioScheduledSourceNode, ev: Event): /*(!) any */ Объект?)?

  операция start(when: Число? = пусто)

  операция stop(when: Число? = пусто)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioScheduledSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioScheduledSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ AudioScheduledSourceNode: объект { prototype: AudioScheduledSourceNode; при создании(): AudioScheduledSourceNode }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioWorklet)
*/

тип AudioWorklet = интерфейс на основе Worklet
{

}


внешнее
/*(!) var */ AudioWorklet: объект { prototype: AudioWorklet; при создании(): AudioWorklet }


тип AudioWorkletNodeEventMap = интерфейс
{
  "processorerror": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AudioWorkletNode)
*/

тип AudioWorkletNode = интерфейс на основе AudioNode
{
  onprocessorerror: (операция(this: AudioWorkletNode, ev: Event): /*(!) any */ Объект?)?

  защищено 
  parameters: AudioParamMap

  защищено 
  port: MessagePort

  операция addEventListener<K = /*(!) keyof AudioWorkletNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioWorkletNode, ev: /*(!) AudioWorkletNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AudioWorkletNodeEventMap */ Объект?>(type`: K, listener: операция(this: AudioWorkletNode, ev: /*(!) AudioWorkletNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ AudioWorkletNode: объект { prototype: AudioWorkletNode; при создании(context: BaseAudioContext, name: Текст, options: AudioWorkletNodeOptions? = пусто): AudioWorkletNode }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorAssertionResponse)
*/

тип AuthenticatorAssertionResponse = интерфейс на основе AuthenticatorResponse
{
  защищено 
  authenticatorData: ArrayBuffer

  защищено 
  signature: ArrayBuffer

  защищено 
  userHandle: ArrayBuffer?
}


внешнее
/*(!) var */ AuthenticatorAssertionResponse: объект { prototype: AuthenticatorAssertionResponse; при создании(): AuthenticatorAssertionResponse }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorAttestationResponse)
*/

тип AuthenticatorAttestationResponse = интерфейс на основе AuthenticatorResponse
{
  защищено 
  attestationObject: ArrayBuffer

  операция getAuthenticatorData(): ArrayBuffer

  операция getPublicKey(): ArrayBuffer?

  операция getPublicKeyAlgorithm(): COSEAlgorithmIdentifier

  операция getTransports(): Список<Текст>
}


внешнее
/*(!) var */ AuthenticatorAttestationResponse: объект { prototype: AuthenticatorAttestationResponse; при создании(): AuthenticatorAttestationResponse }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AuthenticatorResponse)
*/

тип AuthenticatorResponse = интерфейс
{
  защищено 
  clientDataJSON: ArrayBuffer
}


внешнее
/*(!) var */ AuthenticatorResponse: объект { prototype: AuthenticatorResponse; при создании(): AuthenticatorResponse }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BarProp) */

тип BarProp = интерфейс
{
  защищено 
  visible: ДаНет
}


внешнее
/*(!) var */ BarProp: объект { prototype: BarProp; при создании(): BarProp }


тип BaseAudioContextEventMap = интерфейс
{
  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BaseAudioContext) */

тип BaseAudioContext = интерфейс на основе EventTarget
{
  операция addEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: BaseAudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof BaseAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: BaseAudioContext, ev: /*(!) BaseAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ BaseAudioContext: объект { prototype: BaseAudioContext; при создании(): BaseAudioContext }


/**
* The beforeunload event is fired when the window, the document and its resources are about to be unloaded.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/BeforeUnloadEvent)
*/

тип BeforeUnloadEvent = интерфейс на основе Event
{
  returnValue: /*(!) any */ Объект?
}


внешнее
/*(!) var */ BeforeUnloadEvent: объект { prototype: BeforeUnloadEvent; при создании(): BeforeUnloadEvent }


/**
* A simple low-order filter, and is created using the AudioContext.createBiquadFilter() method. It is an AudioNode that can represent different kinds of filters, tone control devices, and graphic equalizers.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/BiquadFilterNode)
*/

тип BiquadFilterNode = интерфейс на основе AudioNode
{
  защищено 
  Q: AudioParam

  защищено 
  detune: AudioParam

  защищено 
  frequency: AudioParam

  защищено 
  gain: AudioParam

  type`: BiquadFilterType

  операция getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array)
}


внешнее
/*(!) var */ BiquadFilterNode: объект { prototype: BiquadFilterNode; при создании(context: BaseAudioContext, options: BiquadFilterOptions? = пусто): BiquadFilterNode }


/**
* A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)
*/

тип Blob = интерфейс
{
  защищено 
  size: Число

  защищено 
  type`: Текст

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция slice(start: Число? = пусто, end: Число? = пусто, contentType: Текст? = пусто): Blob

  операция stream(): ReadableStream<Uint8Array>

  операция text(): Promise<Текст>
}


внешнее
/*(!) var */ Blob: объект { prototype: Blob; при создании(blobParts: Список<BlobPart>? = пусто, options: BlobPropertyBag? = пусто): Blob }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BlobEvent) */

тип BlobEvent = интерфейс на основе Event
{
  защищено 
  data: Blob

  защищено 
  timecode: DOMHighResTimeStamp
}


внешнее
/*(!) var */ BlobEvent: объект { prototype: BlobEvent; при создании(type`: Текст, eventInitDict: BlobEventInit): BlobEvent }


тип Body = интерфейс
{
  защищено 
  body: ReadableStream<Uint8Array>?

  защищено 
  bodyUsed: ДаНет

  операция arrayBuffer(): Promise<ArrayBuffer>

  операция blob(): Promise<Blob>

  операция formData(): Promise<FormData>

  операция json(): Promise</*(!) any */ Объект?>

  операция text(): Promise<Текст>
}


тип BroadcastChannelEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/BroadcastChannel) */

тип BroadcastChannel = интерфейс на основе EventTarget
{
  защищено 
  name: Текст

  onmessage: (операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект?)?

  onmessageerror: (операция(this: BroadcastChannel, ev: MessageEvent): /*(!) any */ Объект?)?

  операция close()

  операция postMessage(message: /*(!) any */ Объект?)

  операция addEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type`: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof BroadcastChannelEventMap */ Объект?>(type`: K, listener: операция(this: BroadcastChannel, ev: /*(!) BroadcastChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ BroadcastChannel: объект { prototype: BroadcastChannel; при создании(name: Текст): BroadcastChannel }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)
*/

тип ByteLengthQueuingStrategy = интерфейс на основе QueuingStrategy<ArrayBufferView>
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize<ArrayBufferView>
}


внешнее
/*(!) var */ ByteLengthQueuingStrategy: объект { prototype: ByteLengthQueuingStrategy; при создании(init: QueuingStrategyInit): ByteLengthQueuingStrategy }


/**
* A CDATA section that can be used within XML to include extended portions of unescaped text. The symbols < and & don’t need escaping as they normally do when inside a CDATA section.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CDATASection)
*/

тип CDATASection = интерфейс на основе Text
{

}


внешнее
/*(!) var */ CDATASection: объект { prototype: CDATASection; при создании(): CDATASection }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSAnimation) */

тип CSSAnimation = интерфейс на основе Animation
{
  защищено 
  animationName: Текст

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: CSSAnimation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: CSSAnimation, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ CSSAnimation: объект { prototype: CSSAnimation; при создании(): CSSAnimation }


/**
* A single condition CSS at-rule, which consists of a condition and a statement block. It is a child of CSSGroupingRule.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSConditionRule)
*/

тип CSSConditionRule = интерфейс на основе CSSGroupingRule
{
  защищено 
  conditionText: Текст
}


внешнее
/*(!) var */ CSSConditionRule: объект { prototype: CSSConditionRule; при создании(): CSSConditionRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSContainerRule) */

тип CSSContainerRule = интерфейс на основе CSSConditionRule
{
  защищено 
  containerName: Текст

  защищено 
  containerQuery: Текст
}


внешнее
/*(!) var */ CSSContainerRule: объект { prototype: CSSContainerRule; при создании(): CSSContainerRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSCounterStyleRule) */

тип CSSCounterStyleRule = интерфейс на основе CSSRule
{
  additiveSymbols: Текст

  fallback: Текст

  name: Текст

  negative: Текст

  pad: Текст

  prefix: Текст

  range: Текст

  speakAs: Текст

  suffix: Текст

  symbols: Текст

  system: Текст
}


внешнее
/*(!) var */ CSSCounterStyleRule: объект { prototype: CSSCounterStyleRule; при создании(): CSSCounterStyleRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontFaceRule) */

тип CSSFontFaceRule = интерфейс на основе CSSRule
{
  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSFontFaceRule: объект { prototype: CSSFontFaceRule; при создании(): CSSFontFaceRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontFeatureValuesRule) */

тип CSSFontFeatureValuesRule = интерфейс на основе CSSRule
{
  fontFamily: Текст
}


внешнее
/*(!) var */ CSSFontFeatureValuesRule: объект { prototype: CSSFontFeatureValuesRule; при создании(): CSSFontFeatureValuesRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSFontPaletteValuesRule) */

тип CSSFontPaletteValuesRule = интерфейс на основе CSSRule
{
  защищено 
  basePalette: Текст

  защищено 
  fontFamily: Текст

  защищено 
  name: Текст

  защищено 
  overrideColors: Текст
}


внешнее
/*(!) var */ CSSFontPaletteValuesRule: объект { prototype: CSSFontPaletteValuesRule; при создании(): CSSFontPaletteValuesRule }


/**
* Any CSS at-rule that contains other rules nested within it.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSGroupingRule)
*/

тип CSSGroupingRule = интерфейс на основе CSSRule
{
  защищено 
  cssRules: CSSRuleList

  операция deleteRule(index: Число)

  операция insertRule(rule: Текст, index: Число? = пусто): Число
}


внешнее
/*(!) var */ CSSGroupingRule: объект { prototype: CSSGroupingRule; при создании(): CSSGroupingRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSImageValue) */

тип CSSImageValue = интерфейс на основе CSSStyleValue
{

}


внешнее
/*(!) var */ CSSImageValue: объект { prototype: CSSImageValue; при создании(): CSSImageValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSImportRule) */

тип CSSImportRule = интерфейс на основе CSSRule
{
  защищено 
  href: Текст

  защищено 
  layerName: Текст?

  защищено 
  media: MediaList

  защищено 
  styleSheet: CSSStyleSheet?
}


внешнее
/*(!) var */ CSSImportRule: объект { prototype: CSSImportRule; при создании(): CSSImportRule }


/**
* An object representing a set of style for a given keyframe. It corresponds to the contains of a single keyframe of a @keyframes at-rule. It implements the CSSRule interface with a type value of 8 (CSSRule.KEYFRAME_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeyframeRule)
*/

тип CSSKeyframeRule = интерфейс на основе CSSRule
{
  keyText: Текст

  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSKeyframeRule: объект { prototype: CSSKeyframeRule; при создании(): CSSKeyframeRule }


/**
* An object representing a complete set of keyframes for a CSS animation. It corresponds to the contains of a whole @keyframes at-rule. It implements the CSSRule interface with a type value of 7 (CSSRule.KEYFRAMES_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeyframesRule)
*/

тип CSSKeyframesRule = интерфейс на основе CSSRule
{
  защищено 
  cssRules: CSSRuleList

  защищено 
  length: Число

  name: Текст

  операция appendRule(rule: Текст)

  операция deleteRule(select: Текст)

  операция findRule(select: Текст): CSSKeyframeRule?

  /*(!) [index: number]: CSSKeyframeRule*/
}


внешнее
/*(!) var */ CSSKeyframesRule: объект { prototype: CSSKeyframesRule; при создании(): CSSKeyframesRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSKeywordValue) */

тип CSSKeywordValue = интерфейс на основе CSSStyleValue
{
  value: Текст
}


внешнее
/*(!) var */ CSSKeywordValue: объект { prototype: CSSKeywordValue; при создании(value: Текст): CSSKeywordValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSLayerBlockRule) */

тип CSSLayerBlockRule = интерфейс на основе CSSGroupingRule
{
  защищено 
  name: Текст
}


внешнее
/*(!) var */ CSSLayerBlockRule: объект { prototype: CSSLayerBlockRule; при создании(): CSSLayerBlockRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSLayerStatementRule) */

тип CSSLayerStatementRule = интерфейс на основе CSSRule
{
  защищено 
  nameList: ReadonlyArray<Текст>
}


внешнее
/*(!) var */ CSSLayerStatementRule: объект { prototype: CSSLayerStatementRule; при создании(): CSSLayerStatementRule }


тип CSSMathClamp = интерфейс на основе CSSMathValue
{
  защищено 
  lower: CSSNumericValue

  защищено 
  upper: CSSNumericValue

  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathClamp: объект { prototype: CSSMathClamp; при создании(lower: CSSNumberish, value: CSSNumberish, upper: CSSNumberish): CSSMathClamp }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathInvert) */

тип CSSMathInvert = интерфейс на основе CSSMathValue
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathInvert: объект { prototype: CSSMathInvert; при создании(arg: CSSNumberish): CSSMathInvert }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMax) */

тип CSSMathMax = интерфейс на основе CSSMathValue
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMax: объект { prototype: CSSMathMax; #js.МассивПараметров при создании(args: Список<CSSNumberish>): CSSMathMax }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathMin) */

тип CSSMathMin = интерфейс на основе CSSMathValue
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathMin: объект { prototype: CSSMathMin; #js.МассивПараметров при создании(args: Список<CSSNumberish>): CSSMathMin }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathNegate) */

тип CSSMathNegate = интерфейс на основе CSSMathValue
{
  защищено 
  value: CSSNumericValue
}


внешнее
/*(!) var */ CSSMathNegate: объект { prototype: CSSMathNegate; при создании(arg: CSSNumberish): CSSMathNegate }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathProduct) */

тип CSSMathProduct = интерфейс на основе CSSMathValue
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathProduct: объект { prototype: CSSMathProduct; #js.МассивПараметров при создании(args: Список<CSSNumberish>): CSSMathProduct }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathSum) */

тип CSSMathSum = интерфейс на основе CSSMathValue
{
  защищено 
  values: CSSNumericArray
}


внешнее
/*(!) var */ CSSMathSum: объект { prototype: CSSMathSum; #js.МассивПараметров при создании(args: Список<CSSNumberish>): CSSMathSum }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMathValue) */

тип CSSMathValue = интерфейс на основе CSSNumericValue
{
  защищено 
  operator: CSSMathOperator
}


внешнее
/*(!) var */ CSSMathValue: объект { prototype: CSSMathValue; при создании(): CSSMathValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMatrixComponent) */

тип CSSMatrixComponent = интерфейс на основе CSSTransformComponent
{
  matrix: DOMMatrix
}


внешнее
/*(!) var */ CSSMatrixComponent: объект { prototype: CSSMatrixComponent; при создании(matrix: DOMMatrixReadOnly, options: CSSMatrixComponentOptions? = пусто): CSSMatrixComponent }


/**
* A single CSS @media rule. It implements the CSSConditionRule interface, and therefore the CSSGroupingRule and the CSSRule interface with a type value of 4 (CSSRule.MEDIA_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSMediaRule)
*/

тип CSSMediaRule = интерфейс на основе CSSConditionRule
{
  защищено 
  media: MediaList
}


внешнее
/*(!) var */ CSSMediaRule: объект { prototype: CSSMediaRule; при создании(): CSSMediaRule }


/**
* An object representing a single CSS @namespace at-rule. It implements the CSSRule interface, with a type value of 10 (CSSRule.NAMESPACE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNamespaceRule)
*/

тип CSSNamespaceRule = интерфейс на основе CSSRule
{
  защищено 
  namespaceURI: Текст

  защищено 
  prefix: Текст
}


внешнее
/*(!) var */ CSSNamespaceRule: объект { prototype: CSSNamespaceRule; при создании(): CSSNamespaceRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericArray) */

тип CSSNumericArray = интерфейс
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSNumericValue, key: Число, parent: CSSNumericArray), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: CSSNumericValue*/
}


внешнее
/*(!) var */ CSSNumericArray: объект { prototype: CSSNumericArray; при создании(): CSSNumericArray }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSNumericValue) */

тип CSSNumericValue = интерфейс на основе CSSStyleValue
{
  #js.МассивПараметров
  операция add(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция div(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция equals(value: Список<CSSNumberish>): ДаНет

  #js.МассивПараметров
  операция max(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция min(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция mul(values: Список<CSSNumberish>): CSSNumericValue

  #js.МассивПараметров
  операция sub(values: Список<CSSNumberish>): CSSNumericValue

  операция to(unit: Текст): CSSUnitValue

  #js.МассивПараметров
  операция toSum(units: Список<Текст>): CSSMathSum

  операция type`(): CSSNumericType
}


внешнее
/*(!) var */ CSSNumericValue: объект { prototype: CSSNumericValue; при создании(): CSSNumericValue; операция parse(cssText: Текст): CSSNumericValue }


/**
* CSSPageRule is an interface representing a single CSS @page rule. It implements the CSSRule interface with a type value of 6 (CSSRule.PAGE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPageRule)
*/

тип CSSPageRule = интерфейс на основе CSSGroupingRule
{
  selectorText: Текст

  защищено 
  style: CSSStyleDeclaration
}


внешнее
/*(!) var */ CSSPageRule: объект { prototype: CSSPageRule; при создании(): CSSPageRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPerspective) */

тип CSSPerspective = интерфейс на основе CSSTransformComponent
{
  length: CSSPerspectiveValue
}


внешнее
/*(!) var */ CSSPerspective: объект { prototype: CSSPerspective; при создании(length: CSSPerspectiveValue): CSSPerspective }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSPropertyRule) */

тип CSSPropertyRule = интерфейс на основе CSSRule
{
  защищено 
  inherits: ДаНет

  защищено 
  initialValue: Текст?

  защищено 
  name: Текст

  защищено 
  syntax: Текст
}


внешнее
/*(!) var */ CSSPropertyRule: объект { prototype: CSSPropertyRule; при создании(): CSSPropertyRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRotate) */

тип CSSRotate = интерфейс на основе CSSTransformComponent
{
  angle: CSSNumericValue

  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSRotate: объект { prototype: CSSRotate; при создании(angle: CSSNumericValue): CSSRotate; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish, angle: CSSNumericValue): CSSRotate }


/**
* A single CSS rule. There are several types of rules, listed in the Type constants section below.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRule)
*/

тип CSSRule = интерфейс
{
  защищено 
  STYLE_RULE: 1

  защищено 
  CHARSET_RULE: 2

  защищено 
  IMPORT_RULE: 3

  защищено 
  MEDIA_RULE: 4

  защищено 
  FONT_FACE_RULE: 5

  защищено 
  PAGE_RULE: 6

  защищено 
  NAMESPACE_RULE: 10

  защищено 
  KEYFRAMES_RULE: 7

  защищено 
  KEYFRAME_RULE: 8

  защищено 
  SUPPORTS_RULE: 12
}


внешнее
/*(!) var */ CSSRule: объект { prototype: CSSRule; при создании(): CSSRule; защищено  STYLE_RULE: 1; защищено  CHARSET_RULE: 2; защищено  IMPORT_RULE: 3; защищено  MEDIA_RULE: 4; защищено  FONT_FACE_RULE: 5; защищено  PAGE_RULE: 6; защищено  NAMESPACE_RULE: 10; защищено  KEYFRAMES_RULE: 7; защищено  KEYFRAME_RULE: 8; защищено  SUPPORTS_RULE: 12 }


/**
* A CSSRuleList is an (indirect-modify only) array-like object containing an ordered collection of CSSRule objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSRuleList)
*/

тип CSSRuleList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): CSSRule?

  /*(!) [index: number]: CSSRule*/
}


внешнее
/*(!) var */ CSSRuleList: объект { prototype: CSSRuleList; при создании(): CSSRuleList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSScale) */

тип CSSScale = интерфейс на основе CSSTransformComponent
{
  x: CSSNumberish

  y: CSSNumberish

  z: CSSNumberish
}


внешнее
/*(!) var */ CSSScale: объект { prototype: CSSScale; при создании(x: CSSNumberish, y: CSSNumberish, z: CSSNumberish? = пусто): CSSScale }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkew) */

тип CSSSkew = интерфейс на основе CSSTransformComponent
{
  ax: CSSNumericValue

  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkew: объект { prototype: CSSSkew; при создании(ax: CSSNumericValue, ay: CSSNumericValue): CSSSkew }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewX) */

тип CSSSkewX = интерфейс на основе CSSTransformComponent
{
  ax: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewX: объект { prototype: CSSSkewX; при создании(ax: CSSNumericValue): CSSSkewX }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSkewY) */

тип CSSSkewY = интерфейс на основе CSSTransformComponent
{
  ay: CSSNumericValue
}


внешнее
/*(!) var */ CSSSkewY: объект { prototype: CSSSkewY; при создании(ay: CSSNumericValue): CSSSkewY }


/**
* An object that is a CSS declaration block, and exposes style information and various style-related methods and properties.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleDeclaration)
*/

тип CSSStyleDeclaration = интерфейс
{
  alignmentBaseline: Текст

  baselineShift: Текст

  clipRule: Текст

  colorInterpolation: Текст

  colorInterpolationFilters: Текст

  dominantBaseline: Текст

  fill: Текст

  fillOpacity: Текст

  fillRule: Текст

  floodColor: Текст

  floodOpacity: Текст

  lightingColor: Текст

  marker: Текст

  markerEnd: Текст

  markerMid: Текст

  markerStart: Текст

  shapeRendering: Текст

  stopColor: Текст

  stopOpacity: Текст

  stroke: Текст

  strokeDasharray: Текст

  strokeDashoffset: Текст

  strokeLinecap: Текст

  strokeLinejoin: Текст

  strokeMiterlimit: Текст

  strokeOpacity: Текст

  strokeWidth: Текст

  textAnchor: Текст

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ CSSStyleDeclaration: объект { prototype: CSSStyleDeclaration; при создании(): CSSStyleDeclaration }


/**
* CSSStyleRule represents a single CSS style rule. It implements the CSSRule interface with a type value of 1 (CSSRule.STYLE_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleRule)
*/

тип CSSStyleRule = интерфейс на основе CSSRule
{
  защищено 
  cssRules: CSSRuleList

  selectorText: Текст

  защищено 
  style: CSSStyleDeclaration

  защищено 
  styleMap: StylePropertyMap

  операция deleteRule(index: Число)

  операция insertRule(rule: Текст, index: Число? = пусто): Число
}


внешнее
/*(!) var */ CSSStyleRule: объект { prototype: CSSStyleRule; при создании(): CSSStyleRule }


/**
* A single CSS style sheet. It inherits properties and methods from its parent, StyleSheet.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleSheet)
*/

тип CSSStyleSheet = интерфейс на основе StyleSheet
{

}


внешнее
/*(!) var */ CSSStyleSheet: объект { prototype: CSSStyleSheet; при создании(options: CSSStyleSheetInit? = пусто): CSSStyleSheet }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSStyleValue) */

тип CSSStyleValue = интерфейс
{
  операция toString(): Текст
}


внешнее
/*(!) var */ CSSStyleValue: объект { prototype: CSSStyleValue; при создании(): CSSStyleValue; операция parse(property: Текст, cssText: Текст): CSSStyleValue; операция parseAll(property: Текст, cssText: Текст): Список<CSSStyleValue> }


/**
* An object representing a single CSS @supports at-rule. It implements the CSSConditionRule interface, and therefore the CSSRule and CSSGroupingRule interfaces with a type value of 12 (CSSRule.SUPPORTS_RULE).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSSupportsRule)
*/

тип CSSSupportsRule = интерфейс на основе CSSConditionRule
{

}


внешнее
/*(!) var */ CSSSupportsRule: объект { prototype: CSSSupportsRule; при создании(): CSSSupportsRule }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformComponent) */

тип CSSTransformComponent = интерфейс
{
  is2D: ДаНет

  операция toMatrix(): DOMMatrix

  операция toString(): Текст
}


внешнее
/*(!) var */ CSSTransformComponent: объект { prototype: CSSTransformComponent; при создании(): CSSTransformComponent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransformValue) */

тип CSSTransformValue = интерфейс на основе CSSStyleValue
{
  защищено 
  is2D: ДаНет

  защищено 
  length: Число

  операция toMatrix(): DOMMatrix

  операция forEach(callbackfn: операция(value: CSSTransformComponent, key: Число, parent: CSSTransformValue), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: CSSTransformComponent*/
}


внешнее
/*(!) var */ CSSTransformValue: объект { prototype: CSSTransformValue; при создании(transforms: Список<CSSTransformComponent>): CSSTransformValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTransition) */

тип CSSTransition = интерфейс на основе Animation
{
  защищено 
  transitionProperty: Текст

  операция addEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: CSSTransition, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AnimationEventMap */ Объект?>(type`: K, listener: операция(this: CSSTransition, ev: /*(!) AnimationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ CSSTransition: объект { prototype: CSSTransition; при создании(): CSSTransition }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSTranslate) */

тип CSSTranslate = интерфейс на основе CSSTransformComponent
{
  x: CSSNumericValue

  y: CSSNumericValue

  z: CSSNumericValue
}


внешнее
/*(!) var */ CSSTranslate: объект { prototype: CSSTranslate; при создании(x: CSSNumericValue, y: CSSNumericValue, z: CSSNumericValue? = пусто): CSSTranslate }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnitValue) */

тип CSSUnitValue = интерфейс на основе CSSNumericValue
{
  защищено 
  unit: Текст

  value: Число
}


внешнее
/*(!) var */ CSSUnitValue: объект { prototype: CSSUnitValue; при создании(value: Число, unit: Текст): CSSUnitValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSUnparsedValue) */

тип CSSUnparsedValue = интерфейс на основе CSSStyleValue
{
  защищено 
  length: Число

  операция forEach(callbackfn: операция(value: CSSUnparsedSegment, key: Число, parent: CSSUnparsedValue), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: CSSUnparsedSegment*/
}


внешнее
/*(!) var */ CSSUnparsedValue: объект { prototype: CSSUnparsedValue; при создании(members: Список<CSSUnparsedSegment>): CSSUnparsedValue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSSVariableReferenceValue) */

тип CSSVariableReferenceValue = интерфейс
{
  защищено 
  fallback: CSSUnparsedValue?

  variable: Текст
}


внешнее
/*(!) var */ CSSVariableReferenceValue: объект { prototype: CSSVariableReferenceValue; при создании(variable: Текст, fallback: CSSUnparsedValue? = пусто): CSSVariableReferenceValue }


/**
* Provides a storage mechanism for Request / Response object pairs that are cached, for example as part of the ServiceWorker life cycle. Note that the Cache interface is exposed to windowed scopes as well as workers. You don't have to use it in conjunction with service workers, even though it is defined in the service worker spec.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Cache)
*/

тип Cache = интерфейс
{
  операция add(request: Объект? /*(!)RequestInfo | URL*/): Promise<Ничего>

  операция addAll(requests: Список<RequestInfo>): Promise<Ничего>

  операция delete(request: Объект? /*(!)RequestInfo | URL*/, options: CacheQueryOptions? = пусто): Promise<ДаНет>

  операция keys(request: Объект? /*(!)RequestInfo | URL | пусто*/ = пусто, options: CacheQueryOptions? = пусто): Promise<ReadonlyArray<Request>>

  операция match(request: Объект? /*(!)RequestInfo | URL*/, options: CacheQueryOptions? = пусто): Promise<Response?>

  операция matchAll(request: Объект? /*(!)RequestInfo | URL | пусто*/ = пусто, options: CacheQueryOptions? = пусто): Promise<ReadonlyArray<Response>>

  операция put(request: Объект? /*(!)RequestInfo | URL*/, response: Response): Promise<Ничего>
}


внешнее
/*(!) var */ Cache: объект { prototype: Cache; при создании(): Cache }


/**
* The storage for Cache objects.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage)
*/

тип CacheStorage = интерфейс
{
  операция delete(cacheName: Текст): Promise<ДаНет>

  операция has(cacheName: Текст): Promise<ДаНет>

  операция keys(): Promise<Список<Текст>>

  операция match(request: Объект? /*(!)RequestInfo | URL*/, options: MultiCacheQueryOptions? = пусто): Promise<Response?>

  операция open(cacheName: Текст): Promise<Cache>
}


внешнее
/*(!) var */ CacheStorage: объект { prototype: CacheStorage; при создании(): CacheStorage }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasCaptureMediaStreamTrack) */

тип CanvasCaptureMediaStreamTrack = интерфейс на основе MediaStreamTrack
{
  защищено 
  canvas: HTMLCanvasElement

  операция requestFrame()

  операция addEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type`: K, listener: операция(this: CanvasCaptureMediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type`: K, listener: операция(this: CanvasCaptureMediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ CanvasCaptureMediaStreamTrack: объект { prototype: CanvasCaptureMediaStreamTrack; при создании(): CanvasCaptureMediaStreamTrack }


тип CanvasCompositing = интерфейс
{
  globalAlpha: Число

  globalCompositeOperation: GlobalCompositeOperation
}


тип CanvasDrawImage = интерфейс
{
  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число)

  операция drawImage(image: CanvasImageSource, dx: Число, dy: Число, dw: Число, dh: Число)

  операция drawImage(image: CanvasImageSource, sx: Число, sy: Число, sw: Число, sh: Число, dx: Число, dy: Число, dw: Число, dh: Число)
}


тип CanvasDrawPath = интерфейс
{
  операция beginPath()

  операция clip(fillRule: CanvasFillRule? = пусто)

  операция clip(path: Path2D, fillRule: CanvasFillRule? = пусто)

  операция fill(fillRule: CanvasFillRule? = пусто)

  операция fill(path: Path2D, fillRule: CanvasFillRule? = пусто)

  операция isPointInPath(x: Число, y: Число, fillRule: CanvasFillRule? = пусто): ДаНет

  операция isPointInPath(path: Path2D, x: Число, y: Число, fillRule: CanvasFillRule? = пусто): ДаНет

  операция isPointInStroke(x: Число, y: Число): ДаНет

  операция isPointInStroke(path: Path2D, x: Число, y: Число): ДаНет

  операция stroke()

  операция stroke(path: Path2D)
}


тип CanvasFillStrokeStyles = интерфейс
{
  fillStyle: Объект? /*(!)Текст | CanvasGradient | CanvasPattern*/

  strokeStyle: Объект? /*(!)Текст | CanvasGradient | CanvasPattern*/

  операция createConicGradient(startAngle: Число, x: Число, y: Число): CanvasGradient

  операция createLinearGradient(x0: Число, y0: Число, x1: Число, y1: Число): CanvasGradient

  операция createPattern(image: CanvasImageSource, repetition: Текст?): CanvasPattern?

  операция createRadialGradient(x0: Число, y0: Число, r0: Число, x1: Число, y1: Число, r1: Число): CanvasGradient
}


тип CanvasFilters = интерфейс
{
  filter: Текст
}


/**
* An opaque object describing a gradient. It is returned by the methods CanvasRenderingContext2D.createLinearGradient() or CanvasRenderingContext2D.createRadialGradient().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasGradient)
*/

тип CanvasGradient = интерфейс
{
  операция addColorStop(offset: Число, color: Текст)
}


внешнее
/*(!) var */ CanvasGradient: объект { prototype: CanvasGradient; при создании(): CanvasGradient }


тип CanvasImageData = интерфейс
{
  операция createImageData(sw: Число, sh: Число, settings: ImageDataSettings? = пусто): ImageData

  операция createImageData(imagedata: ImageData): ImageData

  операция getImageData(sx: Число, sy: Число, sw: Число, sh: Число, settings: ImageDataSettings? = пусто): ImageData

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число)

  операция putImageData(imagedata: ImageData, dx: Число, dy: Число, dirtyX: Число, dirtyY: Число, dirtyWidth: Число, dirtyHeight: Число)
}


тип CanvasImageSmoothing = интерфейс
{
  imageSmoothingEnabled: ДаНет

  imageSmoothingQuality: ImageSmoothingQuality
}


тип CanvasPath = интерфейс
{
  операция arc(x: Число, y: Число, radius: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет? = пусто)

  операция arcTo(x1: Число, y1: Число, x2: Число, y2: Число, radius: Число)

  операция bezierCurveTo(cp1x: Число, cp1y: Число, cp2x: Число, cp2y: Число, x: Число, y: Число)

  операция closePath()

  операция ellipse(x: Число, y: Число, radiusX: Число, radiusY: Число, rotation: Число, startAngle: Число, endAngle: Число, counterclockwise: ДаНет? = пусто)

  операция lineTo(x: Число, y: Число)

  операция moveTo(x: Число, y: Число)

  операция quadraticCurveTo(cpx: Число, cpy: Число, x: Число, y: Число)

  операция rect(x: Число, y: Число, w: Число, h: Число)

  операция roundRect(x: Число, y: Число, w: Число, h: Число, radii: Объект? /*(!)Число | DOMPointInit | Список<Объект? /*(!)Число | DOMPointInit*/> | пусто*/ = пусто)
}


тип CanvasPathDrawingStyles = интерфейс
{
  lineCap: CanvasLineCap

  lineDashOffset: Число

  lineJoin: CanvasLineJoin

  lineWidth: Число

  miterLimit: Число

  операция getLineDash(): Список<Число>

  операция setLineDash(segments: Список<Число>)
}


/**
* An opaque object describing a pattern, based on an image, a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasPattern)
*/

тип CanvasPattern = интерфейс
{
  операция setTransform(transform: DOMMatrix2DInit? = пусто)
}


внешнее
/*(!) var */ CanvasPattern: объект { prototype: CanvasPattern; при создании(): CanvasPattern }


тип CanvasRect = интерфейс
{
  операция clearRect(x: Число, y: Число, w: Число, h: Число)

  операция fillRect(x: Число, y: Число, w: Число, h: Число)

  операция strokeRect(x: Число, y: Число, w: Число, h: Число)
}


/**
* The CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and other objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D)
*/

тип CanvasRenderingContext2D = интерфейс на основе CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform, CanvasUserInterface
{
  защищено 
  canvas: HTMLCanvasElement

  операция getContextAttributes(): CanvasRenderingContext2DSettings
}


внешнее
/*(!) var */ CanvasRenderingContext2D: объект { prototype: CanvasRenderingContext2D; при создании(): CanvasRenderingContext2D }


тип CanvasShadowStyles = интерфейс
{
  shadowBlur: Число

  shadowColor: Текст

  shadowOffsetX: Число

  shadowOffsetY: Число
}


тип CanvasState = интерфейс
{
  операция reset()

  операция restore()

  операция save()
}


тип CanvasText = интерфейс
{
  операция fillText(text: Текст, x: Число, y: Число, maxWidth: Число? = пусто)

  операция measureText(text: Текст): TextMetrics

  операция strokeText(text: Текст, x: Число, y: Число, maxWidth: Число? = пусто)
}


тип CanvasTextDrawingStyles = интерфейс
{
  direction: CanvasDirection

  font: Текст

  fontKerning: CanvasFontKerning

  textAlign: CanvasTextAlign

  textBaseline: CanvasTextBaseline
}


тип CanvasTransform = интерфейс
{
  операция getTransform(): DOMMatrix

  операция resetTransform()

  операция rotate(angle: Число)

  операция scale(x: Число, y: Число)

  операция setTransform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция setTransform(transform: DOMMatrix2DInit? = пусто)

  операция transform(a: Число, b: Число, c: Число, d: Число, e: Число, f: Число)

  операция translate(x: Число, y: Число)
}


тип CanvasUserInterface = интерфейс
{
  операция drawFocusIfNeeded(element: Element)

  операция drawFocusIfNeeded(path: Path2D, element: Element)
}


/**
* The ChannelMergerNode interface, often used in conjunction with its opposite, ChannelSplitterNode, reunites different mono inputs into a single output. Each input is used to fill a channel of the output. This is useful for accessing each channels separately, e.g. for performing channel mixing where gain must be separately controlled on each channel.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ChannelMergerNode)
*/

тип ChannelMergerNode = интерфейс на основе AudioNode
{

}


внешнее
/*(!) var */ ChannelMergerNode: объект { prototype: ChannelMergerNode; при создании(context: BaseAudioContext, options: ChannelMergerOptions? = пусто): ChannelMergerNode }


/**
* The ChannelSplitterNode interface, often used in conjunction with its opposite, ChannelMergerNode, separates the different channels of an audio source into a set of mono outputs. This is useful for accessing each channel separately, e.g. for performing channel mixing where gain must be separately controlled on each channel.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ChannelSplitterNode)
*/

тип ChannelSplitterNode = интерфейс на основе AudioNode
{

}


внешнее
/*(!) var */ ChannelSplitterNode: объект { prototype: ChannelSplitterNode; при создании(context: BaseAudioContext, options: ChannelSplitterOptions? = пусто): ChannelSplitterNode }


/**
* The CharacterData abstract interface represents a Node object that contains characters. This is an abstract interface, meaning there aren't any object of type CharacterData: it is implemented by other interfaces, like Text, Comment, or ProcessingInstruction which aren't abstract.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CharacterData)
*/

тип CharacterData = интерфейс на основе Node, ChildNode, NonDocumentTypeChildNode
{
  data: Текст

  защищено 
  length: Число

  защищено 
  ownerDocument: Document

  операция appendData(data: Текст)

  операция deleteData(offset: Число, count: Число)

  операция insertData(offset: Число, data: Текст)

  операция replaceData(offset: Число, count: Число, data: Текст)

  операция substringData(offset: Число, count: Число): Текст
}


внешнее
/*(!) var */ CharacterData: объект { prototype: CharacterData; при создании(): CharacterData }


тип ChildNode = интерфейс на основе Node
{
  #js.МассивПараметров
  операция after(nodes: Список<Объект? /*(!)Node | Текст*/>)

  #js.МассивПараметров
  операция before(nodes: Список<Объект? /*(!)Node | Текст*/>)

  операция remove()

  #js.МассивПараметров
  операция replaceWith(nodes: Список<Объект? /*(!)Node | Текст*/>)
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Clipboard)
*/

тип Clipboard = интерфейс на основе EventTarget
{
  операция read(): Promise<ClipboardItems>

  операция readText(): Promise<Текст>

  операция write(data: ClipboardItems): Promise<Ничего>

  операция writeText(data: Текст): Promise<Ничего>
}


внешнее
/*(!) var */ Clipboard: объект { prototype: Clipboard; при создании(): Clipboard }


/**
* Events providing information related to modification of the clipboard, that is cut, copy, and paste events.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ClipboardEvent)
*/

тип ClipboardEvent = интерфейс на основе Event
{
  защищено 
  clipboardData: DataTransfer?
}


внешнее
/*(!) var */ ClipboardEvent: объект { prototype: ClipboardEvent; при создании(type`: Текст, eventInitDict: ClipboardEventInit? = пусто): ClipboardEvent }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ClipboardItem)
*/

тип ClipboardItem = интерфейс
{
  защищено 
  types: ReadonlyArray<Текст>

  операция getType(type`: Текст): Promise<Blob>
}


внешнее
/*(!) var */ ClipboardItem: объект { prototype: ClipboardItem; при создании(items: Record<Текст, Объект? /*(!)Текст | Blob | PromiseLike<Объект? /*(!)Текст | Blob*/>*/>, options: ClipboardItemOptions? = пусто): ClipboardItem }


/**
* A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)
*/

тип CloseEvent = интерфейс на основе Event
{
  защищено 
  code: Число

  защищено 
  reason: Текст

  защищено 
  wasClean: ДаНет
}


внешнее
/*(!) var */ CloseEvent: объект { prototype: CloseEvent; при создании(type`: Текст, eventInitDict: CloseEventInit? = пусто): CloseEvent }


/**
* Textual notations within markup; although it is generally not visually shown, such comments are available to be read in the source view.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Comment)
*/

тип Comment = интерфейс на основе CharacterData
{

}


внешнее
/*(!) var */ Comment: объект { prototype: Comment; при создании(data: Текст? = пусто): Comment }


/**
* The DOM CompositionEvent represents events that occur due to the user indirectly entering text.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompositionEvent)
*/

тип CompositionEvent = интерфейс на основе UIEvent
{

}


внешнее
/*(!) var */ CompositionEvent: объект { prototype: CompositionEvent; при создании(type`: Текст, eventInitDict: CompositionEventInit? = пусто): CompositionEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */

тип CompressionStream = интерфейс на основе GenericTransformStream
{

}


внешнее
/*(!) var */ CompressionStream: объект { prototype: CompressionStream; при создании(format: CompressionFormat): CompressionStream }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ConstantSourceNode) */

тип ConstantSourceNode = интерфейс на основе AudioScheduledSourceNode
{
  защищено 
  offset: AudioParam

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: ConstantSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: ConstantSourceNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ConstantSourceNode: объект { prototype: ConstantSourceNode; при создании(context: BaseAudioContext, options: ConstantSourceOptions? = пусто): ConstantSourceNode }


/**
* An AudioNode that performs a Linear Convolution on a given AudioBuffer, often used to achieve a reverb effect. A ConvolverNode always has exactly one input and one output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ConvolverNode)
*/

тип ConvolverNode = интерфейс на основе AudioNode
{
  buffer: AudioBuffer?

  normalize: ДаНет
}


внешнее
/*(!) var */ ConvolverNode: объект { prototype: ConvolverNode; при создании(context: BaseAudioContext, options: ConvolverOptions? = пусто): ConvolverNode }


/**
* This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)
*/

тип CountQueuingStrategy = интерфейс на основе QueuingStrategy
{
  защищено 
  highWaterMark: Число

  защищено 
  size: QueuingStrategySize
}


внешнее
/*(!) var */ CountQueuingStrategy: объект { prototype: CountQueuingStrategy; при создании(init: QueuingStrategyInit): CountQueuingStrategy }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Credential)
*/

тип Credential = интерфейс
{
  защищено 
  id: Текст

  защищено 
  type`: Текст
}


внешнее
/*(!) var */ Credential: объект { prototype: Credential; при создании(): Credential }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CredentialsContainer)
*/

тип CredentialsContainer = интерфейс
{
  операция create(options: CredentialCreationOptions? = пусто): Promise<Credential?>

  операция get(options: CredentialRequestOptions? = пусто): Promise<Credential?>

  операция preventSilentAccess(): Promise<Ничего>

  операция store(credential: Credential): Promise<Credential>
}


внешнее
/*(!) var */ CredentialsContainer: объект { prototype: CredentialsContainer; при создании(): CredentialsContainer }


/**
* Basic cryptography features available in the current context. It allows access to a cryptographically strong random number generator and to cryptographic primitives.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto)
*/

тип Crypto = интерфейс
{
  защищено 
  subtle: SubtleCrypto

  операция getRandomValues<T = ArrayBufferView?>(array: T): T

  операция randomUUID(): /*(!) `${string}-${string}-${string}-${string}-${string}` */ Объект?
}


внешнее
/*(!) var */ Crypto: объект { prototype: Crypto; при создании(): Crypto }


/**
* The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)
*/

тип CryptoKey = интерфейс
{
  защищено 
  algorithm: KeyAlgorithm

  защищено 
  extractable: ДаНет

  защищено 
  type`: KeyType

  защищено 
  usages: Список<KeyUsage>
}


внешнее
/*(!) var */ CryptoKey: объект { prototype: CryptoKey; при создании(): CryptoKey }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry) */

тип CustomElementRegistry = интерфейс
{
  операция define(name: Текст, constructor: CustomElementConstructor, options: ElementDefinitionOptions? = пусто)

  операция get(name: Текст): CustomElementConstructor?

  операция upgrade(root: Node)

  операция whenDefined(name: Текст): Promise<CustomElementConstructor>
}


внешнее
/*(!) var */ CustomElementRegistry: объект { prototype: CustomElementRegistry; при создании(): CustomElementRegistry }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */

тип CustomEvent<T> = интерфейс на основе Event
{

}


внешнее
/*(!) var */ CustomEvent: объект { prototype: CustomEvent; при создании(type`: Текст, eventInitDict: CustomEventInit<T>? = пусто): CustomEvent<T> }


/**
* An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)
*/

тип DOMException = интерфейс на основе Error
{
  защищено 
  INDEX_SIZE_ERR: 1

  защищено 
  DOMSTRING_SIZE_ERR: 2

  защищено 
  HIERARCHY_REQUEST_ERR: 3

  защищено 
  WRONG_DOCUMENT_ERR: 4

  защищено 
  INVALID_CHARACTER_ERR: 5

  защищено 
  NO_DATA_ALLOWED_ERR: 6

  защищено 
  NO_MODIFICATION_ALLOWED_ERR: 7

  защищено 
  NOT_FOUND_ERR: 8

  защищено 
  NOT_SUPPORTED_ERR: 9

  защищено 
  INUSE_ATTRIBUTE_ERR: 10

  защищено 
  INVALID_STATE_ERR: 11

  защищено 
  SYNTAX_ERR: 12

  защищено 
  INVALID_MODIFICATION_ERR: 13

  защищено 
  NAMESPACE_ERR: 14

  защищено 
  INVALID_ACCESS_ERR: 15

  защищено 
  VALIDATION_ERR: 16

  защищено 
  TYPE_MISMATCH_ERR: 17

  защищено 
  SECURITY_ERR: 18

  защищено 
  NETWORK_ERR: 19

  защищено 
  ABORT_ERR: 20

  защищено 
  URL_MISMATCH_ERR: 21

  защищено 
  QUOTA_EXCEEDED_ERR: 22

  защищено 
  TIMEOUT_ERR: 23

  защищено 
  INVALID_NODE_TYPE_ERR: 24

  защищено 
  DATA_CLONE_ERR: 25
}


внешнее
/*(!) var */ DOMException: объект { prototype: DOMException; при создании(message: Текст? = пусто, name: Текст? = пусто): DOMException; защищено  INDEX_SIZE_ERR: 1; защищено  DOMSTRING_SIZE_ERR: 2; защищено  HIERARCHY_REQUEST_ERR: 3; защищено  WRONG_DOCUMENT_ERR: 4; защищено  INVALID_CHARACTER_ERR: 5; защищено  NO_DATA_ALLOWED_ERR: 6; защищено  NO_MODIFICATION_ALLOWED_ERR: 7; защищено  NOT_FOUND_ERR: 8; защищено  NOT_SUPPORTED_ERR: 9; защищено  INUSE_ATTRIBUTE_ERR: 10; защищено  INVALID_STATE_ERR: 11; защищено  SYNTAX_ERR: 12; защищено  INVALID_MODIFICATION_ERR: 13; защищено  NAMESPACE_ERR: 14; защищено  INVALID_ACCESS_ERR: 15; защищено  VALIDATION_ERR: 16; защищено  TYPE_MISMATCH_ERR: 17; защищено  SECURITY_ERR: 18; защищено  NETWORK_ERR: 19; защищено  ABORT_ERR: 20; защищено  URL_MISMATCH_ERR: 21; защищено  QUOTA_EXCEEDED_ERR: 22; защищено  TIMEOUT_ERR: 23; защищено  INVALID_NODE_TYPE_ERR: 24; защищено  DATA_CLONE_ERR: 25 }


/**
* An object providing methods which are not dependent on any particular document. Such an object is returned by the Document.implementation property.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMImplementation)
*/

тип DOMImplementation = интерфейс
{

}


внешнее
/*(!) var */ DOMImplementation: объект { prototype: DOMImplementation; при создании(): DOMImplementation }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrix) */

тип DOMMatrix = интерфейс на основе DOMMatrixReadOnly
{
  a: Число

  b: Число

  c: Число

  d: Число

  e: Число

  f: Число

  m11: Число

  m12: Число

  m13: Число

  m14: Число

  m21: Число

  m22: Число

  m23: Число

  m24: Число

  m31: Число

  m32: Число

  m33: Число

  m34: Число

  m41: Число

  m42: Число

  m43: Число

  m44: Число

  операция invertSelf(): DOMMatrix

  операция multiplySelf(other: DOMMatrixInit? = пусто): DOMMatrix

  операция preMultiplySelf(other: DOMMatrixInit? = пусто): DOMMatrix

  операция rotateAxisAngleSelf(x: Число? = пусто, y: Число? = пусто, z: Число? = пусто, angle: Число? = пусто): DOMMatrix

  операция rotateFromVectorSelf(x: Число? = пусто, y: Число? = пусто): DOMMatrix

  операция rotateSelf(rotX: Число? = пусто, rotY: Число? = пусто, rotZ: Число? = пусто): DOMMatrix

  операция scale3dSelf(scale: Число? = пусто, originX: Число? = пусто, originY: Число? = пусто, originZ: Число? = пусто): DOMMatrix

  операция scaleSelf(scaleX: Число? = пусто, scaleY: Число? = пусто, scaleZ: Число? = пусто, originX: Число? = пусто, originY: Число? = пусто, originZ: Число? = пусто): DOMMatrix

  операция setMatrixValue(transformList: Текст): DOMMatrix

  операция skewXSelf(sx: Число? = пусто): DOMMatrix

  операция skewYSelf(sy: Число? = пусто): DOMMatrix

  операция translateSelf(tx: Число? = пусто, ty: Число? = пусто, tz: Число? = пусто): DOMMatrix
}


внешнее
/*(!) var */ DOMMatrix: объект { prototype: DOMMatrix; при создании(init: Объект? /*(!)Текст | Список<Число> | пусто*/ = пусто): DOMMatrix; операция fromFloat32Array(array32: Float32Array): DOMMatrix; операция fromFloat64Array(array64: Float64Array): DOMMatrix; операция fromMatrix(other: DOMMatrixInit? = пусто): DOMMatrix }


тип SVGMatrix = DOMMatrix

внешнее
/*(!) var */ SVGMatrix: /*(!) typeof DOMMatrix */ Объект?


тип WebKitCSSMatrix = DOMMatrix

внешнее
/*(!) var */ WebKitCSSMatrix: /*(!) typeof DOMMatrix */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMMatrixReadOnly) */

тип DOMMatrixReadOnly = интерфейс
{
  операция toJSON(): /*(!) any */ Объект?

  операция toString(): Текст
}


внешнее
/*(!) var */ DOMMatrixReadOnly: объект { prototype: DOMMatrixReadOnly; при создании(init: Объект? /*(!)Текст | Список<Число> | пусто*/ = пусто): DOMMatrixReadOnly; операция fromFloat32Array(array32: Float32Array): DOMMatrixReadOnly; операция fromFloat64Array(array64: Float64Array): DOMMatrixReadOnly; операция fromMatrix(other: DOMMatrixInit? = пусто): DOMMatrixReadOnly }


/**
* Provides the ability to parse XML or HTML source code from a string into a DOM Document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMParser)
*/

тип DOMParser = интерфейс
{
  операция parseFromString(string: Текст, type`: DOMParserSupportedType): Document
}


внешнее
/*(!) var */ DOMParser: объект { prototype: DOMParser; при создании(): DOMParser }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPoint) */

тип DOMPoint = интерфейс на основе DOMPointReadOnly
{
  w: Число

  x: Число

  y: Число

  z: Число
}


внешнее
/*(!) var */ DOMPoint: объект { prototype: DOMPoint; при создании(x: Число? = пусто, y: Число? = пусто, z: Число? = пусто, w: Число? = пусто): DOMPoint; операция fromPoint(other: DOMPointInit? = пусто): DOMPoint }


тип SVGPoint = DOMPoint

внешнее
/*(!) var */ SVGPoint: /*(!) typeof DOMPoint */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMPointReadOnly) */

тип DOMPointReadOnly = интерфейс
{
  защищено 
  w: Число

  защищено 
  x: Число

  защищено 
  y: Число

  защищено 
  z: Число

  операция matrixTransform(matrix: DOMMatrixInit? = пусто): DOMPoint

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMPointReadOnly: объект { prototype: DOMPointReadOnly; при создании(x: Число? = пусто, y: Число? = пусто, z: Число? = пусто, w: Число? = пусто): DOMPointReadOnly; операция fromPoint(other: DOMPointInit? = пусто): DOMPointReadOnly }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMQuad) */

тип DOMQuad = интерфейс
{
  защищено 
  p1: DOMPoint

  защищено 
  p2: DOMPoint

  защищено 
  p3: DOMPoint

  защищено 
  p4: DOMPoint

  операция getBounds(): DOMRect

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMQuad: объект { prototype: DOMQuad; при создании(p1: DOMPointInit? = пусто, p2: DOMPointInit? = пусто, p3: DOMPointInit? = пусто, p4: DOMPointInit? = пусто): DOMQuad; операция fromQuad(other: DOMQuadInit? = пусто): DOMQuad; операция fromRect(other: DOMRectInit? = пусто): DOMQuad }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */

тип DOMRect = интерфейс на основе DOMRectReadOnly
{
  height: Число

  width: Число

  x: Число

  y: Число
}


внешнее
/*(!) var */ DOMRect: объект { prototype: DOMRect; при создании(x: Число? = пусто, y: Число? = пусто, width: Число? = пусто, height: Число? = пусто): DOMRect; операция fromRect(other: DOMRectInit? = пусто): DOMRect }


тип SVGRect = DOMRect

внешнее
/*(!) var */ SVGRect: /*(!) typeof DOMRect */ Объект?


тип DOMRectList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): DOMRect?

  /*(!) [index: number]: DOMRect*/
}


внешнее
/*(!) var */ DOMRectList: объект { prototype: DOMRectList; при создании(): DOMRectList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */

тип DOMRectReadOnly = интерфейс
{
  защищено 
  bottom: Число

  защищено 
  height: Число

  защищено 
  left: Число

  защищено 
  right: Число

  защищено 
  top: Число

  защищено 
  width: Число

  защищено 
  x: Число

  защищено 
  y: Число

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ DOMRectReadOnly: объект { prototype: DOMRectReadOnly; при создании(x: Число? = пусто, y: Число? = пусто, width: Число? = пусто, height: Число? = пусто): DOMRectReadOnly; операция fromRect(other: DOMRectInit? = пусто): DOMRectReadOnly }


/**
* A type returned by some APIs which contains a list of DOMString (strings).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringList)
*/

тип DOMStringList = интерфейс
{
  защищено 
  length: Число

  операция contains(string: Текст): ДаНет

  операция item(index: Число): Текст?

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ DOMStringList: объект { prototype: DOMStringList; при создании(): DOMStringList }


/**
* Used by the dataset HTML attribute to represent data for custom attributes added to elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMStringMap)
*/

тип DOMStringMap = интерфейс
{
  /*(!) [name: string]: string | undefined*/
}


внешнее
/*(!) var */ DOMStringMap: объект { prototype: DOMStringMap; при создании(): DOMStringMap }


/**
* A set of space-separated tokens. Such a set is returned by Element.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList, HTMLAreaElement.relList, HTMLIframeElement.sandbox, or HTMLOutputElement.htmlFor. It is indexed beginning with 0 as with JavaScript Array objects. DOMTokenList is always case-sensitive.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMTokenList)
*/

тип DOMTokenList = интерфейс
{
  защищено 
  length: Число

  value: Текст

  операция toString(): Текст

  #js.МассивПараметров
  операция add(tokens: Список<Текст>)

  операция contains(token: Текст): ДаНет

  операция item(index: Число): Текст?

  #js.МассивПараметров
  операция remove(tokens: Список<Текст>)

  операция replace(token: Текст, newToken: Текст): ДаНет

  операция supports(token: Текст): ДаНет

  операция toggle(token: Текст, force: ДаНет? = пусто): ДаНет

  операция forEach(callbackfn: операция(value: Текст, key: Число, parent: DOMTokenList), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ DOMTokenList: объект { prototype: DOMTokenList; при создании(): DOMTokenList }


/**
* Used to hold the data that is being dragged during a drag and drop operation. It may hold one or more data items, each of one or more data types. For more information about drag and drop, see HTML Drag and Drop API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransfer)
*/

тип DataTransfer = интерфейс
{
  dropEffect: Объект? /*(!)"none" | "copy" | "link" | "move"*/

  effectAllowed: Объект? /*(!)"none" | "copy" | "copyLink" | "copyMove" | "link" | "linkMove" | "move" | "all" | "uninitialized"*/

  защищено 
  files: FileList

  защищено 
  items: DataTransferItemList

  защищено 
  types: ReadonlyArray<Текст>

  операция clearData(format: Текст? = пусто)

  операция getData(format: Текст): Текст

  операция setData(format: Текст, data: Текст)

  операция setDragImage(image: Element, x: Число, y: Число)
}


внешнее
/*(!) var */ DataTransfer: объект { prototype: DataTransfer; при создании(): DataTransfer }


/**
* One drag data item. During a drag operation, each drag event has a dataTransfer property which contains a list of drag data items. Each item in the list is a DataTransferItem object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransferItem)
*/

тип DataTransferItem = интерфейс
{
  защищено 
  kind: Текст

  защищено 
  type`: Текст

  операция getAsFile(): File?

  операция getAsString(callback: FunctionStringCallback?)

  операция webkitGetAsEntry(): FileSystemEntry?
}


внешнее
/*(!) var */ DataTransferItem: объект { prototype: DataTransferItem; при создании(): DataTransferItem }


/**
* A list of DataTransferItem objects representing items being dragged. During a drag operation, each DragEvent has a dataTransfer property and that property is a DataTransferItemList.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DataTransferItemList)
*/

тип DataTransferItemList = интерфейс
{
  защищено 
  length: Число

  операция add(data: Текст, type`: Текст): DataTransferItem?

  операция add(data: File): DataTransferItem?

  операция clear()

  операция remove(index: Число)

  /*(!) [index: number]: DataTransferItem*/
}


внешнее
/*(!) var */ DataTransferItemList: объект { prototype: DataTransferItemList; при создании(): DataTransferItemList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */

тип DecompressionStream = интерфейс на основе GenericTransformStream
{

}


внешнее
/*(!) var */ DecompressionStream: объект { prototype: DecompressionStream; при создании(format: CompressionFormat): DecompressionStream }


/**
* A delay-line; an AudioNode audio-processing module that causes a delay between the arrival of an input data and its propagation to the output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DelayNode)
*/

тип DelayNode = интерфейс на основе AudioNode
{
  защищено 
  delayTime: AudioParam
}


внешнее
/*(!) var */ DelayNode: объект { prototype: DelayNode; при создании(context: BaseAudioContext, options: DelayOptions? = пусто): DelayNode }


/**
* The DeviceMotionEvent provides web developers with information about the speed of changes for the device's position and orientation.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent)
*/

тип DeviceMotionEvent = интерфейс на основе Event
{
  защищено 
  acceleration: DeviceMotionEventAcceleration?

  защищено 
  accelerationIncludingGravity: DeviceMotionEventAcceleration?

  защищено 
  interval: Число

  защищено 
  rotationRate: DeviceMotionEventRotationRate?
}


внешнее
/*(!) var */ DeviceMotionEvent: объект { prototype: DeviceMotionEvent; при создании(type`: Текст, eventInitDict: DeviceMotionEventInit? = пусто): DeviceMotionEvent }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEventAcceleration)
*/

тип DeviceMotionEventAcceleration = интерфейс
{
  защищено 
  x: Число?

  защищено 
  y: Число?

  защищено 
  z: Число?
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceMotionEventRotationRate)
*/

тип DeviceMotionEventRotationRate = интерфейс
{
  защищено 
  alpha: Число?

  защищено 
  beta: Число?

  защищено 
  gamma: Число?
}


/**
* The DeviceOrientationEvent provides web developers with information from the physical orientation of the device running the web page.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent)
*/

тип DeviceOrientationEvent = интерфейс на основе Event
{
  защищено 
  absolute: ДаНет

  защищено 
  alpha: Число?

  защищено 
  beta: Число?

  защищено 
  gamma: Число?
}


внешнее
/*(!) var */ DeviceOrientationEvent: объект { prototype: DeviceOrientationEvent; при создании(type`: Текст, eventInitDict: DeviceOrientationEventInit? = пусто): DeviceOrientationEvent }


тип DocumentEventMap = интерфейс на основе GlobalEventHandlersEventMap
{
  "DOMContentLoaded": Event

  "fullscreenchange": Event

  "fullscreenerror": Event

  "pointerlockchange": Event

  "pointerlockerror": Event

  "readystatechange": Event

  "visibilitychange": Event
}


/**
* Any web page loaded in the browser and serves as an entry point into the web page's content, which is the DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document)
*/

тип Document = интерфейс на основе Node, DocumentOrShadowRoot, FontFaceSource, GlobalEventHandlers, NonElementParentNode, ParentNode, XPathEvaluatorBase
{
  операция location(href: Объект? /*(!)Текст | Location*/): /*(!) no_type */ Объект?

  защищено 
  ownerDocument: пусто

  операция createElement(tagName: Текст, options: ElementCreationOptions? = пусто): HTMLElement

  операция createElementNS<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: K): /*(!) SVGElementTagNameMap[K] */ Объект?

  операция createElementNS(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: Текст): SVGElement

  операция createElementNS<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: K): /*(!) MathMLElementTagNameMap[K] */ Объект?

  операция createElementNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: Текст): MathMLElement

  операция createElementNS(namespaceURI: Текст?, qualifiedName: Текст, options: ElementCreationOptions? = пусто): Element

  операция createElementNS(namespace: Текст?, qualifiedName: Текст, options: Объект? /*(!)Текст | ElementCreationOptions | пусто*/ = пусто): Element

  операция createEvent(eventInterface: "AnimationPlaybackEvent"): AnimationPlaybackEvent

  операция createEvent(eventInterface: "AudioProcessingEvent"): AudioProcessingEvent

  операция createEvent(eventInterface: "BeforeUnloadEvent"): BeforeUnloadEvent

  операция createEvent(eventInterface: "BlobEvent"): BlobEvent

  операция createEvent(eventInterface: "ClipboardEvent"): ClipboardEvent

  операция createEvent(eventInterface: "CloseEvent"): CloseEvent

  операция createEvent(eventInterface: "CompositionEvent"): CompositionEvent

  операция createEvent(eventInterface: "CustomEvent"): CustomEvent

  операция createEvent(eventInterface: "DeviceMotionEvent"): DeviceMotionEvent

  операция createEvent(eventInterface: "DeviceOrientationEvent"): DeviceOrientationEvent

  операция createEvent(eventInterface: "DragEvent"): DragEvent

  операция createEvent(eventInterface: "ErrorEvent"): ErrorEvent

  операция createEvent(eventInterface: "Event"): Event

  операция createEvent(eventInterface: "Events"): Event

  операция createEvent(eventInterface: "FocusEvent"): FocusEvent

  операция createEvent(eventInterface: "FontFaceSetLoadEvent"): FontFaceSetLoadEvent

  операция createEvent(eventInterface: "FormDataEvent"): FormDataEvent

  операция createEvent(eventInterface: "GamepadEvent"): GamepadEvent

  операция createEvent(eventInterface: "HashChangeEvent"): HashChangeEvent

  операция createEvent(eventInterface: "IDBVersionChangeEvent"): IDBVersionChangeEvent

  операция createEvent(eventInterface: "InputEvent"): InputEvent

  операция createEvent(eventInterface: "KeyboardEvent"): KeyboardEvent

  операция createEvent(eventInterface: "MIDIConnectionEvent"): MIDIConnectionEvent

  операция createEvent(eventInterface: "MIDIMessageEvent"): MIDIMessageEvent

  операция createEvent(eventInterface: "MediaEncryptedEvent"): MediaEncryptedEvent

  операция createEvent(eventInterface: "MediaKeyMessageEvent"): MediaKeyMessageEvent

  операция createEvent(eventInterface: "MediaQueryListEvent"): MediaQueryListEvent

  операция createEvent(eventInterface: "MediaStreamTrackEvent"): MediaStreamTrackEvent

  операция createEvent(eventInterface: "MessageEvent"): MessageEvent

  операция createEvent(eventInterface: "MouseEvent"): MouseEvent

  операция createEvent(eventInterface: "MouseEvents"): MouseEvent

  операция createEvent(eventInterface: "MutationEvent"): MutationEvent

  операция createEvent(eventInterface: "MutationEvents"): MutationEvent

  операция createEvent(eventInterface: "OfflineAudioCompletionEvent"): OfflineAudioCompletionEvent

  операция createEvent(eventInterface: "PageTransitionEvent"): PageTransitionEvent

  операция createEvent(eventInterface: "PaymentMethodChangeEvent"): PaymentMethodChangeEvent

  операция createEvent(eventInterface: "PaymentRequestUpdateEvent"): PaymentRequestUpdateEvent

  операция createEvent(eventInterface: "PictureInPictureEvent"): PictureInPictureEvent

  операция createEvent(eventInterface: "PointerEvent"): PointerEvent

  операция createEvent(eventInterface: "PopStateEvent"): PopStateEvent

  операция createEvent(eventInterface: "ProgressEvent"): ProgressEvent

  операция createEvent(eventInterface: "PromiseRejectionEvent"): PromiseRejectionEvent

  операция createEvent(eventInterface: "RTCDTMFToneChangeEvent"): RTCDTMFToneChangeEvent

  операция createEvent(eventInterface: "RTCDataChannelEvent"): RTCDataChannelEvent

  операция createEvent(eventInterface: "RTCErrorEvent"): RTCErrorEvent

  операция createEvent(eventInterface: "RTCPeerConnectionIceErrorEvent"): RTCPeerConnectionIceErrorEvent

  операция createEvent(eventInterface: "RTCPeerConnectionIceEvent"): RTCPeerConnectionIceEvent

  операция createEvent(eventInterface: "RTCTrackEvent"): RTCTrackEvent

  операция createEvent(eventInterface: "SecurityPolicyViolationEvent"): SecurityPolicyViolationEvent

  операция createEvent(eventInterface: "SpeechSynthesisErrorEvent"): SpeechSynthesisErrorEvent

  операция createEvent(eventInterface: "SpeechSynthesisEvent"): SpeechSynthesisEvent

  операция createEvent(eventInterface: "StorageEvent"): StorageEvent

  операция createEvent(eventInterface: "SubmitEvent"): SubmitEvent

  операция createEvent(eventInterface: "ToggleEvent"): ToggleEvent

  операция createEvent(eventInterface: "TouchEvent"): TouchEvent

  операция createEvent(eventInterface: "TrackEvent"): TrackEvent

  операция createEvent(eventInterface: "TransitionEvent"): TransitionEvent

  операция createEvent(eventInterface: "UIEvent"): UIEvent

  операция createEvent(eventInterface: "UIEvents"): UIEvent

  операция createEvent(eventInterface: "WebGLContextEvent"): WebGLContextEvent

  операция createEvent(eventInterface: "WheelEvent"): WheelEvent

  операция createEvent(eventInterface: Текст): Event

  операция getElementsByTagName<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName(qualifiedName: Текст): HTMLCollectionOf<Element>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: Текст): HTMLCollectionOf<SVGElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: Текст): HTMLCollectionOf<MathMLElement>

  операция getElementsByTagNameNS(namespace: Текст?, localName: Текст): HTMLCollectionOf<Element>

  операция open(url: Объект? /*(!)Текст | URL*/, name: Текст, features: Текст): WindowProxy?

  операция addEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type`: K, listener: операция(this: Document, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type`: K, listener: операция(this: Document, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Document: объект { prototype: Document; при создании(): Document }


/**
* A minimal document object that has no parent. It is used as a lightweight version of Document that stores a segment of a document structure comprised of nodes just like a standard document. The key difference is that because the document fragment isn't part of the active document tree structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentFragment)
*/

тип DocumentFragment = интерфейс на основе Node, NonElementParentNode, ParentNode
{
  защищено 
  ownerDocument: Document

  операция getElementById(elementId: Текст): HTMLElement?
}


внешнее
/*(!) var */ DocumentFragment: объект { prototype: DocumentFragment; при создании(): DocumentFragment }


тип DocumentOrShadowRoot = интерфейс
{
  защищено 
  activeElement: Element?

  adoptedStyleSheets: Список<CSSStyleSheet>

  защищено 
  fullscreenElement: Element?

  защищено 
  pictureInPictureElement: Element?

  защищено 
  pointerLockElement: Element?

  защищено 
  styleSheets: StyleSheetList

  операция elementFromPoint(x: Число, y: Число): Element?

  операция elementsFromPoint(x: Число, y: Число): Список<Element>

  операция getAnimations(): Список<Animation>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentTimeline) */

тип DocumentTimeline = интерфейс на основе AnimationTimeline
{

}


внешнее
/*(!) var */ DocumentTimeline: объект { prototype: DocumentTimeline; при создании(options: DocumentTimelineOptions? = пусто): DocumentTimeline }


/**
* A Node containing a doctype.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DocumentType)
*/

тип DocumentType = интерфейс на основе Node, ChildNode
{
  защищено 
  name: Текст

  защищено 
  ownerDocument: Document

  защищено 
  publicId: Текст

  защищено 
  systemId: Текст
}


внешнее
/*(!) var */ DocumentType: объект { prototype: DocumentType; при создании(): DocumentType }


/**
* A DOM event that represents a drag and drop interaction. The user initiates a drag by placing a pointer device (such as a mouse) on the touch surface and then dragging the pointer to a new location (such as another DOM element). Applications are free to interpret a drag and drop interaction in an application-specific way.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DragEvent)
*/

тип DragEvent = интерфейс на основе MouseEvent
{
  защищено 
  dataTransfer: DataTransfer?
}


внешнее
/*(!) var */ DragEvent: объект { prototype: DragEvent; при создании(type`: Текст, eventInitDict: DragEventInit? = пусто): DragEvent }


/**
* Inherits properties from its parent, AudioNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DynamicsCompressorNode)
*/

тип DynamicsCompressorNode = интерфейс на основе AudioNode
{
  защищено 
  attack: AudioParam

  защищено 
  knee: AudioParam

  защищено 
  ratio: AudioParam

  защищено 
  reduction: Число

  защищено 
  release: AudioParam

  защищено 
  threshold: AudioParam
}


внешнее
/*(!) var */ DynamicsCompressorNode: объект { prototype: DynamicsCompressorNode; при создании(context: BaseAudioContext, options: DynamicsCompressorOptions? = пусто): DynamicsCompressorNode }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_blend_minmax) */

тип EXT_blend_minmax = интерфейс
{
  защищено 
  MIN_EXT: 0x8007

  защищено 
  MAX_EXT: 0x8008
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_float) */

тип EXT_color_buffer_float = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_color_buffer_half_float) */

тип EXT_color_buffer_half_float = интерфейс
{
  защищено 
  RGBA16F_EXT: 0x881A

  защищено 
  RGB16F_EXT: 0x881B

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_float_blend) */

тип EXT_float_blend = интерфейс
{

}


/**
* The EXT_frag_depth extension is part of the WebGL API and enables to set a depth value of a fragment from within the fragment shader.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_frag_depth)
*/

тип EXT_frag_depth = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_sRGB) */

тип EXT_sRGB = интерфейс
{
  защищено 
  SRGB_EXT: 0x8C40

  защищено 
  SRGB_ALPHA_EXT: 0x8C42

  защищено 
  SRGB8_ALPHA8_EXT: 0x8C43

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_shader_texture_lod) */

тип EXT_shader_texture_lod = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_bptc) */

тип EXT_texture_compression_bptc = интерфейс
{
  защищено 
  COMPRESSED_RGBA_BPTC_UNORM_EXT: 0x8E8C

  защищено 
  COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: 0x8E8D

  защищено 
  COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: 0x8E8E

  защищено 
  COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: 0x8E8F
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_compression_rgtc) */

тип EXT_texture_compression_rgtc = интерфейс
{
  защищено 
  COMPRESSED_RED_RGTC1_EXT: 0x8DBB

  защищено 
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8DBC

  защищено 
  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8DBD

  защищено 
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8DBE
}


/**
* The EXT_texture_filter_anisotropic extension is part of the WebGL API and exposes two constants for anisotropic filtering (AF).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_filter_anisotropic)
*/

тип EXT_texture_filter_anisotropic = интерфейс
{
  защищено 
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE

  защищено 
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EXT_texture_norm16) */

тип EXT_texture_norm16 = интерфейс
{
  защищено 
  R16_EXT: 0x822A

  защищено 
  RG16_EXT: 0x822C

  защищено 
  RGB16_EXT: 0x8054

  защищено 
  RGBA16_EXT: 0x805B

  защищено 
  R16_SNORM_EXT: 0x8F98

  защищено 
  RG16_SNORM_EXT: 0x8F99

  защищено 
  RGB16_SNORM_EXT: 0x8F9A

  защищено 
  RGBA16_SNORM_EXT: 0x8F9B
}


тип ElementEventMap = интерфейс
{
  "fullscreenchange": Event

  "fullscreenerror": Event
}


/**
* Element is the most general base class from which all objects in a Document inherit. It only has methods and properties common to all kinds of elements. More specific classes inherit from Element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element)
*/

тип Element = интерфейс на основе Node, ARIAMixin, Animatable, ChildNode, InnerHTML, NonDocumentTypeChildNode, ParentNode, Slottable
{
  защищено 
  ownerDocument: Document

  операция checkVisibility(options: CheckVisibilityOptions? = пусто): ДаНет

  операция closest<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selector: K): /*(!) SVGElementTagNameMap[K] */ Объект?

  операция closest<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selector: K): /*(!) MathMLElementTagNameMap[K] */ Объект?

  операция closest<E = Element>(selectors: Текст): E?

  операция getElementsByTagName<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(qualifiedName: K): HTMLCollectionOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция getElementsByTagName(qualifiedName: Текст): HTMLCollectionOf<Element>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/2000/svg", localName: Текст): HTMLCollectionOf<SVGElement>

  операция getElementsByTagNameNS(namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: Текст): HTMLCollectionOf<MathMLElement>

  операция getElementsByTagNameNS(namespace: Текст?, localName: Текст): HTMLCollectionOf<Element>

  операция scroll(x: Число, y: Число)

  операция scrollBy(x: Число, y: Число)

  операция scrollTo(x: Число, y: Число)

  операция addEventListener<K = /*(!) keyof ElementEventMap */ Объект?>(type`: K, listener: операция(this: Element, ev: /*(!) ElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ElementEventMap */ Объект?>(type`: K, listener: операция(this: Element, ev: /*(!) ElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Element: объект { prototype: Element; при создании(): Element }


тип ElementCSSInlineStyle = интерфейс
{
  защищено 
  attributeStyleMap: StylePropertyMap

  защищено 
  style: CSSStyleDeclaration
}


тип ElementContentEditable = интерфейс
{
  contentEditable: Текст

  enterKeyHint: Текст

  inputMode: Текст

  защищено 
  isContentEditable: ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ElementInternals) */

тип ElementInternals = интерфейс на основе ARIAMixin
{
  защищено 
  form: HTMLFormElement?

  защищено 
  labels: NodeList

  защищено 
  shadowRoot: ShadowRoot?

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setFormValue(value: Объект? /*(!)File | Текст | FormData | пусто*/, state: Объект? /*(!)File | Текст | FormData | пусто | пусто*/ = пусто)

  операция setValidity(flags: ValidityStateFlags? = пусто, message: Текст? = пусто, anchor: HTMLElement? = пусто)
}


внешнее
/*(!) var */ ElementInternals: объект { prototype: ElementInternals; при создании(): ElementInternals }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EncodedVideoChunk) */

тип EncodedVideoChunk = интерфейс
{
  защищено 
  byteLength: Число

  защищено 
  duration: Число?

  защищено 
  timestamp: Число

  защищено 
  type`: EncodedVideoChunkType

  операция copyTo(destination: BufferSource)
}


внешнее
/*(!) var */ EncodedVideoChunk: объект { prototype: EncodedVideoChunk; при создании(init: EncodedVideoChunkInit): EncodedVideoChunk }


/**
* Events providing information related to errors in scripts or in files.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)
*/

тип ErrorEvent = интерфейс на основе Event
{
  защищено 
  colno: Число

  защищено 
  error`: /*(!) any */ Объект?

  защищено 
  filename: Текст

  защищено 
  lineno: Число

  защищено 
  message: Текст
}


внешнее
/*(!) var */ ErrorEvent: объект { prototype: ErrorEvent; при создании(type`: Текст, eventInitDict: ErrorEventInit? = пусто): ErrorEvent }


/**
* An event which takes place in the DOM.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)
*/

тип Event = интерфейс
{
  защищено 
  NONE: 0

  защищено 
  CAPTURING_PHASE: 1

  защищено 
  AT_TARGET: 2

  защищено 
  BUBBLING_PHASE: 3
}


внешнее
/*(!) var */ Event: объект { prototype: Event; при создании(type`: Текст, eventInitDict: EventInit? = пусто): Event; защищено  NONE: 0; защищено  CAPTURING_PHASE: 1; защищено  AT_TARGET: 2; защищено  BUBBLING_PHASE: 3 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventCounts) */

тип EventCounts = интерфейс
{
  операция forEach(callbackfn: операция(value: Число, key: Текст, parent: EventCounts), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ EventCounts: объект { prototype: EventCounts; при создании(): EventCounts }


тип EventListener = интерфейс
{
  /*(!) (evt: Event): void*/
}


тип EventListenerObject = интерфейс
{
  операция handleEvent(object`: Event)
}


тип EventSourceEventMap = интерфейс
{
  "error": Event

  "message": MessageEvent

  "open": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource) */

тип EventSource = интерфейс на основе EventTarget
{
  onerror: (операция(this: EventSource, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: EventSource, ev: MessageEvent): /*(!) any */ Объект?)?

  onopen: (операция(this: EventSource, ev: Event): /*(!) any */ Объект?)?

  защищено 
  readyState: Число

  защищено 
  url: Текст

  защищено 
  withCredentials: ДаНет

  операция close()

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSED: 2

  операция addEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type`: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof EventSourceEventMap */ Объект?>(type`: K, listener: операция(this: EventSource, ev: /*(!) EventSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: операция(this: EventSource, event: MessageEvent): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ EventSource: объект { prototype: EventSource; при создании(url: Объект? /*(!)Текст | URL*/, eventSourceInitDict: EventSourceInit? = пусто): EventSource; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSED: 2 }


/**
* EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)
*/

тип EventTarget = интерфейс
{
  операция addEventListener(type`: Текст, callback: EventListenerOrEventListenerObject?, options: Объект? /*(!)AddEventListenerOptions | ДаНет | пусто*/ = пусто)

  операция dispatchEvent(event: Event): ДаНет

  операция removeEventListener(type`: Текст, callback: EventListenerOrEventListenerObject?, options: Объект? /*(!)EventListenerOptions | ДаНет | пусто*/ = пусто)
}


внешнее
/*(!) var */ EventTarget: объект { prototype: EventTarget; при создании(): EventTarget }


/**
* Provides information about files and allows JavaScript in a web page to access their content.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)
*/

тип File = интерфейс на основе Blob
{
  защищено 
  lastModified: Число

  защищено 
  name: Текст

  защищено 
  webkitRelativePath: Текст
}


внешнее
/*(!) var */ File: объект { prototype: File; при создании(fileBits: Список<BlobPart>, fileName: Текст, options: FilePropertyBag? = пусто): File }


/**
* An object of this type is returned by the files property of the HTML <input> element; this lets you access the list of files selected with the <input type="file"> element. It's also used for a list of files dropped into web content when using the drag and drop API; see the DataTransfer object for details on this usage.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileList)
*/

тип FileList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): File?

  /*(!) [index: number]: File*/
}


внешнее
/*(!) var */ FileList: объект { prototype: FileList; при создании(): FileList }


тип FileReaderEventMap = интерфейс
{
  "abort": ProgressEvent<FileReader>

  "error": ProgressEvent<FileReader>

  "load": ProgressEvent<FileReader>

  "loadend": ProgressEvent<FileReader>

  "loadstart": ProgressEvent<FileReader>

  "progress": ProgressEvent<FileReader>
}


/**
* Lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileReader)
*/

тип FileReader = интерфейс на основе EventTarget
{
  защищено 
  error`: DOMException?

  onabort: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  onerror: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  onload: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  onloadend: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  onloadstart: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  onprogress: (операция(this: FileReader, ev: ProgressEvent<FileReader>): /*(!) any */ Объект?)?

  защищено 
  readyState: Объект? /*(!)/*(!) typeof FileReader.EMPTY */ Объект? | /*(!) typeof FileReader.LOADING */ Объект? | /*(!) typeof FileReader.DONE */ Объект?*/

  защищено 
  result: Объект? /*(!)Текст | ArrayBuffer | пусто*/

  операция abort()

  операция readAsArrayBuffer(blob: Blob)

  операция readAsBinaryString(blob: Blob)

  операция readAsDataURL(blob: Blob)

  операция readAsText(blob: Blob, encoding: Текст? = пусто)

  защищено 
  EMPTY: 0

  защищено 
  LOADING: 1

  защищено 
  DONE: 2

  операция addEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type`: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof FileReaderEventMap */ Объект?>(type`: K, listener: операция(this: FileReader, ev: /*(!) FileReaderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ FileReader: объект { prototype: FileReader; при создании(): FileReader; защищено  EMPTY: 0; защищено  LOADING: 1; защищено  DONE: 2 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystem) */

тип FileSystem = интерфейс
{
  защищено 
  name: Текст

  защищено 
  root: FileSystemDirectoryEntry
}


внешнее
/*(!) var */ FileSystem: объект { prototype: FileSystem; при создании(): FileSystem }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryEntry) */

тип FileSystemDirectoryEntry = интерфейс на основе FileSystemEntry
{
  операция createReader(): FileSystemDirectoryReader

  операция getDirectory(path: Текст? = пусто, options: FileSystemFlags? = пусто, successCallback: FileSystemEntryCallback? = пусто, errorCallback: ErrorCallback? = пусто)

  операция getFile(path: Текст? = пусто, options: FileSystemFlags? = пусто, successCallback: FileSystemEntryCallback? = пусто, errorCallback: ErrorCallback? = пусто)
}


внешнее
/*(!) var */ FileSystemDirectoryEntry: объект { prototype: FileSystemDirectoryEntry; при создании(): FileSystemDirectoryEntry }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryHandle)
*/

тип FileSystemDirectoryHandle = интерфейс на основе FileSystemHandle
{
  защищено 
  kind: "directory"

  операция getDirectoryHandle(name: Текст, options: FileSystemGetDirectoryOptions? = пусто): Promise<FileSystemDirectoryHandle>

  операция getFileHandle(name: Текст, options: FileSystemGetFileOptions? = пусто): Promise<FileSystemFileHandle>

  операция removeEntry(name: Текст, options: FileSystemRemoveOptions? = пусто): Promise<Ничего>

  операция resolve(possibleDescendant: FileSystemHandle): Promise<Список<Текст>?>
}


внешнее
/*(!) var */ FileSystemDirectoryHandle: объект { prototype: FileSystemDirectoryHandle; при создании(): FileSystemDirectoryHandle }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemDirectoryReader) */

тип FileSystemDirectoryReader = интерфейс
{
  операция readEntries(successCallback: FileSystemEntriesCallback, errorCallback: ErrorCallback? = пусто)
}


внешнее
/*(!) var */ FileSystemDirectoryReader: объект { prototype: FileSystemDirectoryReader; при создании(): FileSystemDirectoryReader }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemEntry) */

тип FileSystemEntry = интерфейс
{
  защищено 
  filesystem: FileSystem

  защищено 
  fullPath: Текст

  защищено 
  isDirectory: ДаНет

  защищено 
  isFile: ДаНет

  защищено 
  name: Текст

  операция getParent(successCallback: FileSystemEntryCallback? = пусто, errorCallback: ErrorCallback? = пусто)
}


внешнее
/*(!) var */ FileSystemEntry: объект { prototype: FileSystemEntry; при создании(): FileSystemEntry }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemFileEntry) */

тип FileSystemFileEntry = интерфейс на основе FileSystemEntry
{
  операция file(successCallback: FileCallback, errorCallback: ErrorCallback? = пусто)
}


внешнее
/*(!) var */ FileSystemFileEntry: объект { prototype: FileSystemFileEntry; при создании(): FileSystemFileEntry }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemFileHandle)
*/

тип FileSystemFileHandle = интерфейс на основе FileSystemHandle
{
  защищено 
  kind: "file"

  операция createWritable(options: FileSystemCreateWritableOptions? = пусто): Promise<FileSystemWritableFileStream>

  операция getFile(): Promise<File>
}


внешнее
/*(!) var */ FileSystemFileHandle: объект { prototype: FileSystemFileHandle; при создании(): FileSystemFileHandle }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemHandle)
*/

тип FileSystemHandle = интерфейс
{
  защищено 
  kind: FileSystemHandleKind

  защищено 
  name: Текст

  операция isSameEntry(other: FileSystemHandle): Promise<ДаНет>
}


внешнее
/*(!) var */ FileSystemHandle: объект { prototype: FileSystemHandle; при создании(): FileSystemHandle }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FileSystemWritableFileStream)
*/

тип FileSystemWritableFileStream = интерфейс на основе WritableStream
{
  операция seek(position: Число): Promise<Ничего>

  операция truncate(size: Число): Promise<Ничего>

  операция write(data: FileSystemWriteChunkType): Promise<Ничего>
}


внешнее
/*(!) var */ FileSystemWritableFileStream: объект { prototype: FileSystemWritableFileStream; при создании(): FileSystemWritableFileStream }


/**
* Focus-related events like focus, blur, focusin, or focusout.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FocusEvent)
*/

тип FocusEvent = интерфейс на основе UIEvent
{
  защищено 
  relatedTarget: EventTarget?
}


внешнее
/*(!) var */ FocusEvent: объект { prototype: FocusEvent; при создании(type`: Текст, eventInitDict: FocusEventInit? = пусто): FocusEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFace) */

тип FontFace = интерфейс
{
  ascentOverride: Текст

  descentOverride: Текст

  display: FontDisplay

  family: Текст

  featureSettings: Текст

  lineGapOverride: Текст

  защищено 
  loaded: Promise<FontFace>

  защищено 
  status: FontFaceLoadStatus

  stretch: Текст

  style: Текст

  unicodeRange: Текст

  variant`: Текст

  weight: Текст

  операция load(): Promise<FontFace>
}


внешнее
/*(!) var */ FontFace: объект { prototype: FontFace; при создании(family: Текст, source: Объект? /*(!)Текст | BinaryData*/, descriptors: FontFaceDescriptors? = пусто): FontFace }


тип FontFaceSetEventMap = интерфейс
{
  "loading": Event

  "loadingdone": Event

  "loadingerror": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSet) */

тип FontFaceSet = интерфейс на основе EventTarget
{
  onloading: (операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект?)?

  onloadingdone: (операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект?)?

  onloadingerror: (операция(this: FontFaceSet, ev: Event): /*(!) any */ Объект?)?

  защищено 
  ready: Promise<FontFaceSet>

  защищено 
  status: FontFaceSetLoadStatus

  операция check(font: Текст, text: Текст? = пусто): ДаНет

  операция load(font: Текст, text: Текст? = пусто): Promise<Список<FontFace>>

  операция forEach(callbackfn: операция(value: FontFace, key: FontFace, parent: FontFaceSet), thisArg: /*(!) any */ Объект? = пусто)

  операция addEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type`: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof FontFaceSetEventMap */ Объект?>(type`: K, listener: операция(this: FontFaceSet, ev: /*(!) FontFaceSetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ FontFaceSet: объект { prototype: FontFaceSet; при создании(initialFaces: Список<FontFace>): FontFaceSet }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FontFaceSetLoadEvent) */

тип FontFaceSetLoadEvent = интерфейс на основе Event
{
  защищено 
  fontfaces: ReadonlyArray<FontFace>
}


внешнее
/*(!) var */ FontFaceSetLoadEvent: объект { prototype: FontFaceSetLoadEvent; при создании(type`: Текст, eventInitDict: FontFaceSetLoadEventInit? = пусто): FontFaceSetLoadEvent }


тип FontFaceSource = интерфейс
{
  защищено 
  fonts: FontFaceSet
}


/**
* Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)
*/

тип FormData = интерфейс
{
  операция append(name: Текст, value: Объект? /*(!)Текст | Blob*/)

  операция append(name: Текст, value: Текст)

  операция append(name: Текст, blobValue: Blob, filename: Текст? = пусто)

  операция delete(name: Текст)

  операция get(name: Текст): FormDataEntryValue?

  операция getAll(name: Текст): Список<FormDataEntryValue>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Объект? /*(!)Текст | Blob*/)

  операция set(name: Текст, value: Текст)

  операция set(name: Текст, blobValue: Blob, filename: Текст? = пусто)

  операция forEach(callbackfn: операция(value: FormDataEntryValue, key: Текст, parent: FormData), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ FormData: объект { prototype: FormData; при создании(form: HTMLFormElement? = пусто, submitter: HTMLElement? = пусто): FormData }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormDataEvent) */

тип FormDataEvent = интерфейс на основе Event
{
  защищено 
  formData: FormData
}


внешнее
/*(!) var */ FormDataEvent: объект { prototype: FormDataEvent; при создании(type`: Текст, eventInitDict: FormDataEventInit): FormDataEvent }


/**
* A change in volume. It is an AudioNode audio-processing module that causes a given gain to be applied to the input data before its propagation to the output. A GainNode always has exactly one input and one output, both with the same number of channels.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GainNode)
*/

тип GainNode = интерфейс на основе AudioNode
{
  защищено 
  gain: AudioParam
}


внешнее
/*(!) var */ GainNode: объект { prototype: GainNode; при создании(context: BaseAudioContext, options: GainOptions? = пусто): GainNode }


/**
* This Gamepad API interface defines an individual gamepad or other controller, allowing access to information such as button presses, axis positions, and id.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Gamepad)
*/

тип Gamepad = интерфейс
{
  защищено 
  axes: ReadonlyArray<Число>

  защищено 
  buttons: ReadonlyArray<GamepadButton>

  защищено 
  connected: ДаНет

  защищено 
  hapticActuators: ReadonlyArray<GamepadHapticActuator>

  защищено 
  id: Текст

  защищено 
  index: Число

  защищено 
  mapping: GamepadMappingType

  защищено 
  timestamp: DOMHighResTimeStamp

  защищено 
  vibrationActuator: GamepadHapticActuator?
}


внешнее
/*(!) var */ Gamepad: объект { prototype: Gamepad; при создании(): Gamepad }


/**
* An individual button of a gamepad or other controller, allowing access to the current state of different types of buttons available on the control device.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadButton)
*/

тип GamepadButton = интерфейс
{
  защищено 
  pressed: ДаНет

  защищено 
  touched: ДаНет

  защищено 
  value: Число
}


внешнее
/*(!) var */ GamepadButton: объект { prototype: GamepadButton; при создании(): GamepadButton }


/**
* This Gamepad API interface contains references to gamepads connected to the system, which is what the gamepad events Window.gamepadconnected and Window.gamepaddisconnected are fired in response to.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadEvent)
*/

тип GamepadEvent = интерфейс на основе Event
{
  защищено 
  gamepad: Gamepad
}


внешнее
/*(!) var */ GamepadEvent: объект { prototype: GamepadEvent; при создании(type`: Текст, eventInitDict: GamepadEventInit): GamepadEvent }


/**
* This Gamepad API interface represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GamepadHapticActuator)
*/

тип GamepadHapticActuator = интерфейс
{
  защищено 
  type`: GamepadHapticActuatorType

  операция playEffect(type`: GamepadHapticEffectType, params: GamepadEffectParameters? = пусто): Promise<GamepadHapticsResult>

  операция reset(): Promise<GamepadHapticsResult>
}


внешнее
/*(!) var */ GamepadHapticActuator: объект { prototype: GamepadHapticActuator; при создании(): GamepadHapticActuator }


тип GenericTransformStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


/**
* An object able to programmatically obtain the position of the device. It gives Web content access to the location of the device. This allows a Web site or app to offer customized results based on the user's location.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Geolocation)
*/

тип Geolocation = интерфейс
{
  операция clearWatch(watchId: Число)

  операция getCurrentPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback? = пусто, options: PositionOptions? = пусто)

  операция watchPosition(successCallback: PositionCallback, errorCallback: PositionErrorCallback? = пусто, options: PositionOptions? = пусто): Число
}


внешнее
/*(!) var */ Geolocation: объект { prototype: Geolocation; при создании(): Geolocation }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationCoordinates)
*/

тип GeolocationCoordinates = интерфейс
{
  защищено 
  accuracy: Число

  защищено 
  altitude: Число?

  защищено 
  altitudeAccuracy: Число?

  защищено 
  heading: Число?

  защищено 
  latitude: Число

  защищено 
  longitude: Число

  защищено 
  speed: Число?
}


внешнее
/*(!) var */ GeolocationCoordinates: объект { prototype: GeolocationCoordinates; при создании(): GeolocationCoordinates }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationPosition)
*/

тип GeolocationPosition = интерфейс
{
  защищено 
  coords: GeolocationCoordinates

  защищено 
  timestamp: EpochTimeStamp
}


внешнее
/*(!) var */ GeolocationPosition: объект { prototype: GeolocationPosition; при создании(): GeolocationPosition }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/GeolocationPositionError) */

тип GeolocationPositionError = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  PERMISSION_DENIED: 1

  защищено 
  POSITION_UNAVAILABLE: 2

  защищено 
  TIMEOUT: 3
}


внешнее
/*(!) var */ GeolocationPositionError: объект { prototype: GeolocationPositionError; при создании(): GeolocationPositionError; защищено  PERMISSION_DENIED: 1; защищено  POSITION_UNAVAILABLE: 2; защищено  TIMEOUT: 3 }


тип GlobalEventHandlersEventMap = интерфейс
{
  "abort": UIEvent

  "animationcancel": AnimationEvent

  "animationend": AnimationEvent

  "animationiteration": AnimationEvent

  "animationstart": AnimationEvent

  "auxclick": MouseEvent

  "beforeinput": InputEvent

  "blur": FocusEvent

  "cancel": Event

  "canplay": Event

  "canplaythrough": Event

  "change": Event

  "click": MouseEvent

  "close": Event

  "compositionend": CompositionEvent

  "compositionstart": CompositionEvent

  "compositionupdate": CompositionEvent

  "contextmenu": MouseEvent

  "copy": ClipboardEvent

  "cuechange": Event

  "cut": ClipboardEvent

  "dblclick": MouseEvent

  "drag": DragEvent

  "dragend": DragEvent

  "dragenter": DragEvent

  "dragleave": DragEvent

  "dragover": DragEvent

  "dragstart": DragEvent

  "drop": DragEvent

  "durationchange": Event

  "emptied": Event

  "ended": Event

  "error": ErrorEvent

  "focus": FocusEvent

  "focusin": FocusEvent

  "focusout": FocusEvent

  "formdata": FormDataEvent

  "gotpointercapture": PointerEvent

  "input": Event

  "invalid": Event

  "keydown": KeyboardEvent

  "keypress": KeyboardEvent

  "keyup": KeyboardEvent

  "load": Event

  "loadeddata": Event

  "loadedmetadata": Event

  "loadstart": Event

  "lostpointercapture": PointerEvent

  "mousedown": MouseEvent

  "mouseenter": MouseEvent

  "mouseleave": MouseEvent

  "mousemove": MouseEvent

  "mouseout": MouseEvent

  "mouseover": MouseEvent

  "mouseup": MouseEvent

  "paste": ClipboardEvent

  "pause": Event

  "play": Event

  "playing": Event

  "pointercancel": PointerEvent

  "pointerdown": PointerEvent

  "pointerenter": PointerEvent

  "pointerleave": PointerEvent

  "pointermove": PointerEvent

  "pointerout": PointerEvent

  "pointerover": PointerEvent

  "pointerup": PointerEvent

  "progress": ProgressEvent

  "ratechange": Event

  "reset": Event

  "resize": UIEvent

  "scroll": Event

  "scrollend": Event

  "securitypolicyviolation": SecurityPolicyViolationEvent

  "seeked": Event

  "seeking": Event

  "select": Event

  "selectionchange": Event

  "selectstart": Event

  "slotchange": Event

  "stalled": Event

  "submit": SubmitEvent

  "suspend": Event

  "timeupdate": Event

  "toggle": Event

  "touchcancel": TouchEvent

  "touchend": TouchEvent

  "touchmove": TouchEvent

  "touchstart": TouchEvent

  "transitioncancel": TransitionEvent

  "transitionend": TransitionEvent

  "transitionrun": TransitionEvent

  "transitionstart": TransitionEvent

  "volumechange": Event

  "waiting": Event

  "webkitanimationend": Event

  "webkitanimationiteration": Event

  "webkitanimationstart": Event

  "webkittransitionend": Event

  "wheel": WheelEvent
}


тип GlobalEventHandlers = интерфейс
{
  операция addEventListener<K = /*(!) keyof GlobalEventHandlersEventMap */ Объект?>(type`: K, listener: операция(this: GlobalEventHandlers, ev: /*(!) GlobalEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof GlobalEventHandlersEventMap */ Объект?>(type`: K, listener: операция(this: GlobalEventHandlers, ev: /*(!) GlobalEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAllCollection) */

тип HTMLAllCollection = интерфейс
{
  защищено 
  length: Число

  операция item(nameOrIndex: Текст? = пусто): Объект? /*(!)HTMLCollection | Element | пусто*/

  операция namedItem(name: Текст): Объект? /*(!)HTMLCollection | Element | пусто*/

  /*(!) [index: number]: Element*/
}


внешнее
/*(!) var */ HTMLAllCollection: объект { prototype: HTMLAllCollection; при создании(): HTMLAllCollection }


/**
* Hyperlink elements and provides special properties and methods (beyond those of the regular HTMLElement object interface that they inherit from) for manipulating the layout and presentation of such elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAnchorElement)
*/

тип HTMLAnchorElement = интерфейс на основе HTMLElement, HTMLHyperlinkElementUtils
{
  ping: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAnchorElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAnchorElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLAnchorElement: объект { prototype: HTMLAnchorElement; при создании(): HTMLAnchorElement }


/**
* Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <area> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAreaElement)
*/

тип HTMLAreaElement = интерфейс на основе HTMLElement, HTMLHyperlinkElementUtils
{
  ping: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLAreaElement: объект { prototype: HTMLAreaElement; при создании(): HTMLAreaElement }


/**
* Provides access to the properties of <audio> elements, as well as methods to manipulate them. It derives from the HTMLMediaElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLAudioElement)
*/

тип HTMLAudioElement = интерфейс на основе HTMLMediaElement
{
  операция addEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAudioElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLAudioElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLAudioElement: объект { prototype: HTMLAudioElement; при создании(): HTMLAudioElement }


/**
* A HTML line break element (<br>). It inherits from HTMLElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBRElement)
*/

тип HTMLBRElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLBRElement: объект { prototype: HTMLBRElement; при создании(): HTMLBRElement }


/**
* Contains the base URI for a document. This object inherits all of the properties and methods as described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBaseElement)
*/

тип HTMLBaseElement = интерфейс на основе HTMLElement
{
  href: Текст

  target: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBaseElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBaseElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLBaseElement: объект { prototype: HTMLBaseElement; при создании(): HTMLBaseElement }


тип HTMLBodyElementEventMap = интерфейс на основе HTMLElementEventMap, WindowEventHandlersEventMap
{

}


/**
* Provides special properties (beyond those inherited from the regular HTMLElement interface) for manipulating <body> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLBodyElement)
*/

тип HTMLBodyElement = интерфейс на основе HTMLElement, WindowEventHandlers
{
  операция addEventListener<K = /*(!) keyof HTMLBodyElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBodyElement, ev: /*(!) HTMLBodyElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLBodyElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLBodyElement, ev: /*(!) HTMLBodyElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLBodyElement: объект { prototype: HTMLBodyElement; при создании(): HTMLBodyElement }


/**
* Provides properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <button> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLButtonElement)
*/

тип HTMLButtonElement = интерфейс на основе HTMLElement, PopoverInvokerElement
{
  disabled: ДаНет

  защищено 
  form: HTMLFormElement?

  formAction: Текст

  formEnctype: Текст

  formMethod: Текст

  formNoValidate: ДаНет

  formTarget: Текст

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  name: Текст

  type`: Объект? /*(!)"submit" | "reset" | "button"*/

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error`: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLButtonElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLButtonElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLButtonElement: объект { prototype: HTMLButtonElement; при создании(): HTMLButtonElement }


/**
* Provides properties and methods for manipulating the layout and presentation of <canvas> elements. The HTMLCanvasElement interface also inherits the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLCanvasElement)
*/

тип HTMLCanvasElement = интерфейс на основе HTMLElement
{
  height: Число

  width: Число

  операция captureStream(frameRequestRate: Число? = пусто): MediaStream

  операция getContext(contextId: "2d", options: CanvasRenderingContext2DSettings? = пусто): CanvasRenderingContext2D?

  операция getContext(contextId: "bitmaprenderer", options: ImageBitmapRenderingContextSettings? = пусто): ImageBitmapRenderingContext?

  операция getContext(contextId: "webgl", options: WebGLContextAttributes? = пусто): WebGLRenderingContext?

  операция getContext(contextId: "webgl2", options: WebGLContextAttributes? = пусто): WebGL2RenderingContext?

  операция getContext(contextId: Текст, options: /*(!) any */ Объект? = пусто): RenderingContext?

  операция toBlob(callback: BlobCallback, type`: Текст? = пусто, quality: /*(!) any */ Объект? = пусто)

  операция toDataURL(type`: Текст? = пусто, quality: /*(!) any */ Объект? = пусто): Текст

  операция transferControlToOffscreen(): OffscreenCanvas

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLCanvasElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLCanvasElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLCanvasElement: объект { prototype: HTMLCanvasElement; при создании(): HTMLCanvasElement }


/**
* A generic collection (array-like object similar to arguments) of elements (in document order) and offers methods and properties for selecting from the list.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLCollection)
*/

тип HTMLCollectionBase = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Element?

  /*(!) [index: number]: Element*/
}


тип HTMLCollection = интерфейс на основе HTMLCollectionBase
{
  операция namedItem(name: Текст): Element?
}


внешнее
/*(!) var */ HTMLCollection: объект { prototype: HTMLCollection; при создании(): HTMLCollection }


тип HTMLCollectionOf<T = Element> = интерфейс на основе HTMLCollectionBase
{
  операция item(index: Число): T?

  операция namedItem(name: Текст): T?

  /*(!) [index: number]: T*/
}


/**
* Provides special properties (beyond those of the regular HTMLElement interface it also has available to it by inheritance) for manipulating definition list (<dl>) elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDListElement)
*/

тип HTMLDListElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDListElement: объект { prototype: HTMLDListElement; при создании(): HTMLDListElement }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <data> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDataElement)
*/

тип HTMLDataElement = интерфейс на основе HTMLElement
{
  value: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDataElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDataElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDataElement: объект { prototype: HTMLDataElement; при создании(): HTMLDataElement }


/**
* Provides special properties (beyond the HTMLElement object interface it also has available to it by inheritance) to manipulate <datalist> elements and their content.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDataListElement)
*/

тип HTMLDataListElement = интерфейс на основе HTMLElement
{
  защищено 
  options: HTMLCollectionOf<HTMLOptionElement>

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDataListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDataListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDataListElement: объект { prototype: HTMLDataListElement; при создании(): HTMLDataListElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDetailsElement) */

тип HTMLDetailsElement = интерфейс на основе HTMLElement
{
  open: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDetailsElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDetailsElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDetailsElement: объект { prototype: HTMLDetailsElement; при создании(): HTMLDetailsElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement) */

тип HTMLDialogElement = интерфейс на основе HTMLElement
{
  open: ДаНет

  returnValue: Текст

  операция close(returnValue: Текст? = пусто)

  операция show()

  операция showModal()

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDialogElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDialogElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDialogElement: объект { prototype: HTMLDialogElement; при создании(): HTMLDialogElement }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <div> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDivElement)
*/

тип HTMLDivElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDivElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLDivElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLDivElement: объект { prototype: HTMLDivElement; при создании(): HTMLDivElement }


тип HTMLElementEventMap = интерфейс на основе ElementEventMap, GlobalEventHandlersEventMap
{

}


/**
* Any HTML element. Some elements directly implement this interface, while others implement it via an interface that inherits it.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement)
*/

тип HTMLElement = интерфейс на основе Element, ElementCSSInlineStyle, ElementContentEditable, GlobalEventHandlers, HTMLOrSVGElement
{
  accessKey: Текст

  защищено 
  accessKeyLabel: Текст

  autocapitalize: Текст

  dir: Текст

  draggable: ДаНет

  hidden`: ДаНет

  inert: ДаНет

  innerText: Текст

  lang: Текст

  защищено 
  offsetHeight: Число

  защищено 
  offsetLeft: Число

  защищено 
  offsetParent: Element?

  защищено 
  offsetTop: Число

  защищено 
  offsetWidth: Число

  outerText: Текст

  popover: Текст?

  spellcheck: ДаНет

  title: Текст

  translate: ДаНет

  операция attachInternals(): ElementInternals

  операция click()

  операция hidePopover()

  операция showPopover()

  операция togglePopover(force: ДаНет? = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLElement: объект { prototype: HTMLElement; при создании(): HTMLElement }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <embed> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLEmbedElement)
*/

тип HTMLEmbedElement = интерфейс на основе HTMLElement
{
  type`: Текст

  операция getSVGDocument(): Document?

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLEmbedElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLEmbedElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLEmbedElement: объект { prototype: HTMLEmbedElement; при создании(): HTMLEmbedElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <fieldset> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFieldSetElement)
*/

тип HTMLFieldSetElement = интерфейс на основе HTMLElement
{
  disabled: ДаНет

  защищено 
  elements: HTMLCollection

  защищено 
  form: HTMLFormElement?

  name: Текст

  защищено 
  type`: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error`: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLFieldSetElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLFieldSetElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLFieldSetElement: объект { prototype: HTMLFieldSetElement; при создании(): HTMLFieldSetElement }


/**
* A collection of HTML form control elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormControlsCollection)
*/

тип HTMLFormControlsCollection = интерфейс на основе HTMLCollectionBase
{
  операция namedItem(name: Текст): Объект? /*(!)RadioNodeList | Element | пусто*/
}


внешнее
/*(!) var */ HTMLFormControlsCollection: объект { prototype: HTMLFormControlsCollection; при создании(): HTMLFormControlsCollection }


/**
* A <form> element in the DOM; it allows access to and in some cases modification of aspects of the form, as well as access to its component elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement)
*/

тип HTMLFormElement = интерфейс на основе HTMLElement
{
  acceptCharset: Текст

  action: Текст

  autocomplete: AutoFillBase

  защищено 
  elements: HTMLFormControlsCollection

  encoding: Текст

  enctype: Текст

  защищено 
  length: Число

  method: Текст

  name: Текст

  noValidate: ДаНет

  rel: Текст

  защищено 
  relList: DOMTokenList

  target: Текст

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция requestSubmit(submitter: HTMLElement? = пусто)

  операция reset()

  операция submit()

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLFormElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLFormElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  /*(!) [index: number]: Element*/

  /*(!) [name: string]: any*/
}


внешнее
/*(!) var */ HTMLFormElement: объект { prototype: HTMLFormElement; при создании(): HTMLFormElement }


тип HTMLFrameSetElementEventMap = интерфейс на основе HTMLElementEventMap, WindowEventHandlersEventMap
{

}


/**
* Provides special properties (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating <hr> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHRElement)
*/

тип HTMLHRElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHRElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLHRElement: объект { prototype: HTMLHRElement; при создании(): HTMLHRElement }


/**
* Contains the descriptive information, or metadata, for a document. This object inherits all of the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHeadElement)
*/

тип HTMLHeadElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHeadElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHeadElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLHeadElement: объект { prototype: HTMLHeadElement; при создании(): HTMLHeadElement }


/**
* The different heading elements. It inherits methods and properties from the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHeadingElement)
*/

тип HTMLHeadingElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHeadingElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHeadingElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLHeadingElement: объект { prototype: HTMLHeadingElement; при создании(): HTMLHeadingElement }


/**
* Serves as the root node for a given HTML document. This object inherits the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLHtmlElement)
*/

тип HTMLHtmlElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHtmlElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLHtmlElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLHtmlElement: объект { prototype: HTMLHtmlElement; при создании(): HTMLHtmlElement }


тип HTMLHyperlinkElementUtils = интерфейс
{
  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  password: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  username: Текст
}


/**
* Provides special properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of inline frame elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLIFrameElement)
*/

тип HTMLIFrameElement = интерфейс на основе HTMLElement
{
  allow: Текст

  allowFullscreen: ДаНет

  loading: Текст

  защищено 
  sandbox: DOMTokenList

  операция getSVGDocument(): Document?

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLIFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLIFrameElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLIFrameElement: объект { prototype: HTMLIFrameElement; при создании(): HTMLIFrameElement }


/**
* Provides special properties and methods for manipulating <img> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
*/

тип HTMLImageElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLImageElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLImageElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLImageElement: объект { prototype: HTMLImageElement; при создании(): HTMLImageElement }


/**
* Provides special properties and methods for manipulating the options, layout, and presentation of <input> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement)
*/

тип HTMLInputElement = интерфейс на основе HTMLElement, PopoverInvokerElement
{
  capture: Текст

  dirName: Текст

  disabled: ДаНет

  minLength: Число

  readOnly: ДаНет

  size: Число

  операция setRangeText(replacement: Текст, start: Число, end: Число, selectionMode: SelectionMode? = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLInputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLInputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLInputElement: объект { prototype: HTMLInputElement; при создании(): HTMLInputElement }


/**
* Exposes specific properties and methods (beyond those defined by regular HTMLElement interface it also has available to it by inheritance) for manipulating list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLIElement)
*/

тип HTMLLIElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLIElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLIElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLLIElement: объект { prototype: HTMLLIElement; при создании(): HTMLLIElement }


/**
* Gives access to properties specific to <label> elements. It inherits methods and properties from the base HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLabelElement)
*/

тип HTMLLabelElement = интерфейс на основе HTMLElement
{
  защищено 
  control: HTMLElement?

  защищено 
  form: HTMLFormElement?

  htmlFor: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLabelElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLabelElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLLabelElement: объект { prototype: HTMLLabelElement; при создании(): HTMLLabelElement }


/**
* The HTMLLegendElement is an interface allowing to access properties of the <legend> elements. It inherits properties and methods from the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLegendElement)
*/

тип HTMLLegendElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLegendElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLegendElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLLegendElement: объект { prototype: HTMLLegendElement; при создании(): HTMLLegendElement }


/**
* Reference information for external resources and the relationship of those resources to a document and vice-versa. This object inherits all of the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLLinkElement)
*/

тип HTMLLinkElement = интерфейс на основе HTMLElement, LinkStyle
{
  disabled: ДаНет

  imageSizes: Текст

  imageSrcset: Текст

  integrity: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLinkElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLLinkElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLLinkElement: объект { prototype: HTMLLinkElement; при создании(): HTMLLinkElement }


/**
* Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of map elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMapElement)
*/

тип HTMLMapElement = интерфейс на основе HTMLElement
{
  защищено 
  areas: HTMLCollection

  name: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMapElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMapElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLMapElement: объект { prototype: HTMLMapElement; при создании(): HTMLMapElement }


тип HTMLMediaElementEventMap = интерфейс на основе HTMLElementEventMap
{
  "encrypted": MediaEncryptedEvent

  "waitingforkey": Event
}


/**
* Adds to HTMLElement the properties and methods needed to support basic media-related capabilities that are common to audio and video.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement)
*/

тип HTMLMediaElement = интерфейс на основе HTMLElement
{
  autoplay: ДаНет

  защищено 
  buffered: TimeRanges

  controls: ДаНет

  crossOrigin: Текст?

  защищено 
  currentSrc: Текст

  currentTime: Число

  defaultMuted: ДаНет

  defaultPlaybackRate: Число

  disableRemotePlayback: ДаНет

  защищено 
  duration: Число

  защищено 
  ended: ДаНет

  защищено 
  error`: MediaError?

  loop: ДаНет

  защищено 
  mediaKeys: MediaKeys?

  muted: ДаНет

  защищено 
  networkState: Число

  onencrypted: (операция(this: HTMLMediaElement, ev: MediaEncryptedEvent): /*(!) any */ Объект?)?

  onwaitingforkey: (операция(this: HTMLMediaElement, ev: Event): /*(!) any */ Объект?)?

  защищено 
  paused: ДаНет

  playbackRate: Число

  защищено 
  played: TimeRanges

  preload: Объект? /*(!)"none" | "metadata" | "auto" | ""*/

  preservesPitch: ДаНет

  защищено 
  readyState: Число

  защищено 
  remote: RemotePlayback

  защищено 
  seekable: TimeRanges

  защищено 
  seeking: ДаНет

  src: Текст

  srcObject: MediaProvider?

  защищено 
  textTracks: TextTrackList

  volume: Число

  операция addTextTrack(kind: TextTrackKind, label: Текст? = пусто, language: Текст? = пусто): TextTrack

  операция canPlayType(type`: Текст): CanPlayTypeResult

  операция fastSeek(time: Число)

  операция load()

  операция pause()

  операция play(): Promise<Ничего>

  операция setMediaKeys(mediaKeys: MediaKeys?): Promise<Ничего>

  защищено 
  NETWORK_EMPTY: 0

  защищено 
  NETWORK_IDLE: 1

  защищено 
  NETWORK_LOADING: 2

  защищено 
  NETWORK_NO_SOURCE: 3

  защищено 
  HAVE_NOTHING: 0

  защищено 
  HAVE_METADATA: 1

  защищено 
  HAVE_CURRENT_DATA: 2

  защищено 
  HAVE_FUTURE_DATA: 3

  защищено 
  HAVE_ENOUGH_DATA: 4

  операция addEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMediaElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLMediaElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMediaElement, ev: /*(!) HTMLMediaElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLMediaElement: объект { prototype: HTMLMediaElement; при создании(): HTMLMediaElement; защищено  NETWORK_EMPTY: 0; защищено  NETWORK_IDLE: 1; защищено  NETWORK_LOADING: 2; защищено  NETWORK_NO_SOURCE: 3; защищено  HAVE_NOTHING: 0; защищено  HAVE_METADATA: 1; защищено  HAVE_CURRENT_DATA: 2; защищено  HAVE_FUTURE_DATA: 3; защищено  HAVE_ENOUGH_DATA: 4 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMenuElement) */

тип HTMLMenuElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMenuElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMenuElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLMenuElement: объект { prototype: HTMLMenuElement; при создании(): HTMLMenuElement }


/**
* Contains descriptive metadata about a document. It inherits all of the properties and methods described in the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMetaElement)
*/

тип HTMLMetaElement = интерфейс на основе HTMLElement
{
  media: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMetaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMetaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLMetaElement: объект { prototype: HTMLMetaElement; при создании(): HTMLMetaElement }


/**
* The HTML <meter> elements expose the HTMLMeterElement interface, which provides special properties and methods (beyond the HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <meter> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMeterElement)
*/

тип HTMLMeterElement = интерфейс на основе HTMLElement
{
  high: Число

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  low: Число

  max: Число

  min: Число

  optimum: Число

  value: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMeterElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLMeterElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLMeterElement: объект { prototype: HTMLMeterElement; при создании(): HTMLMeterElement }


/**
* Provides special properties (beyond the regular methods and properties available through the HTMLElement interface they also have available to them by inheritance) for manipulating modification elements, that is <del> and <ins>.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLModElement)
*/

тип HTMLModElement = интерфейс на основе HTMLElement
{
  cite: Текст

  dateTime: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLModElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLModElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLModElement: объект { prototype: HTMLModElement; при создании(): HTMLModElement }


/**
* Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating ordered list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOListElement)
*/

тип HTMLOListElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLOListElement: объект { prototype: HTMLOListElement; при создании(): HTMLOListElement }


/**
* Provides special properties and methods (beyond those on the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <object> element, representing external resources.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLObjectElement)
*/

тип HTMLObjectElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLObjectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLObjectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLObjectElement: объект { prototype: HTMLObjectElement; при создании(): HTMLObjectElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <optgroup> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptGroupElement)
*/

тип HTMLOptGroupElement = интерфейс на основе HTMLElement
{
  disabled: ДаНет

  label: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOptGroupElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOptGroupElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLOptGroupElement: объект { prototype: HTMLOptGroupElement; при создании(): HTMLOptGroupElement }


/**
* <option> elements and inherits all classes and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptionElement)
*/

тип HTMLOptionElement = интерфейс на основе HTMLElement
{
  defaultSelected: ДаНет

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?

  защищено 
  index: Число

  label: Текст

  selected: ДаНет

  text: Текст

  value: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLOptionElement: объект { prototype: HTMLOptionElement; при создании(): HTMLOptionElement }


/**
* HTMLOptionsCollection is an interface representing a collection of HTML option elements (in document order) and offers methods and properties for traversing the list as well as optionally altering its items. This type is returned solely by the "options" property of select.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOptionsCollection)
*/

тип HTMLOptionsCollection = интерфейс на основе HTMLCollectionOf<HTMLOptionElement>
{
  length: Число

  selectedIndex: Число

  операция add(element: Объект? /*(!)HTMLOptionElement | HTMLOptGroupElement*/, before: Объект? /*(!)HTMLElement | Число | пусто | пусто*/ = пусто)

  операция remove(index: Число)
}


внешнее
/*(!) var */ HTMLOptionsCollection: объект { prototype: HTMLOptionsCollection; при создании(): HTMLOptionsCollection }


тип HTMLOrSVGElement = интерфейс
{
  autofocus: ДаНет

  защищено 
  dataset: DOMStringMap

  nonce: Текст

  tabIndex: Число

  операция blur()

  операция focus(options: FocusOptions? = пусто)
}


/**
* Provides properties and methods (beyond those inherited from HTMLElement) for manipulating the layout and presentation of <output> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLOutputElement)
*/

тип HTMLOutputElement = интерфейс на основе HTMLElement
{
  defaultValue: Текст

  защищено 
  form: HTMLFormElement?

  защищено 
  htmlFor: DOMTokenList

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  name: Текст

  защищено 
  type`: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция setCustomValidity(error`: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOutputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLOutputElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLOutputElement: объект { prototype: HTMLOutputElement; при создании(): HTMLOutputElement }


/**
* Provides special properties (beyond those of the regular HTMLElement object interface it inherits) for manipulating <p> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLParagraphElement)
*/

тип HTMLParagraphElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLParagraphElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLParagraphElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLParagraphElement: объект { prototype: HTMLParagraphElement; при создании(): HTMLParagraphElement }


/**
* A <picture> HTML element. It doesn't implement specific properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLPictureElement)
*/

тип HTMLPictureElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLPictureElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLPictureElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLPictureElement: объект { prototype: HTMLPictureElement; при создании(): HTMLPictureElement }


/**
* Exposes specific properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating a block of preformatted text (<pre>).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLPreElement)
*/

тип HTMLPreElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLPreElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLPreElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLPreElement: объект { prototype: HTMLPreElement; при создании(): HTMLPreElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <progress> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLProgressElement)
*/

тип HTMLProgressElement = интерфейс на основе HTMLElement
{
  защищено 
  labels: NodeListOf<HTMLLabelElement>

  max: Число

  защищено 
  position: Число

  value: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLProgressElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLProgressElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLProgressElement: объект { prototype: HTMLProgressElement; при создании(): HTMLProgressElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating quoting elements, like <blockquote> and <q>, but not the <cite> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLQuoteElement)
*/

тип HTMLQuoteElement = интерфейс на основе HTMLElement
{
  cite: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLQuoteElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLQuoteElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLQuoteElement: объект { prototype: HTMLQuoteElement; при создании(): HTMLQuoteElement }


/**
* HTML <script> elements expose the HTMLScriptElement interface, which provides special properties and methods for manipulating the behavior and execution of <script> elements (beyond the inherited HTMLElement interface).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLScriptElement)
*/

тип HTMLScriptElement = интерфейс на основе HTMLElement
{
  async: ДаНет

  crossOrigin: Текст?

  integrity: Текст

  noModule: ДаНет

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLScriptElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLScriptElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLScriptElement: объект { prototype: HTMLScriptElement; при создании(): HTMLScriptElement; операция supports(type`: Текст): ДаНет }


/**
* A <select> HTML Element. These elements also share all of the properties and methods of other HTML elements via the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSelectElement)
*/

тип HTMLSelectElement = интерфейс на основе HTMLElement
{
  autocomplete: AutoFill

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  length: Число

  multiple: ДаНет

  name: Текст

  защищено 
  options: HTMLOptionsCollection

  required: ДаНет

  selectedIndex: Число

  защищено 
  selectedOptions: HTMLCollectionOf<HTMLOptionElement>

  size: Число

  защищено 
  type`: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  операция add(element: Объект? /*(!)HTMLOptionElement | HTMLOptGroupElement*/, before: Объект? /*(!)HTMLElement | Число | пусто | пусто*/ = пусто)

  операция checkValidity(): ДаНет

  операция item(index: Число): HTMLOptionElement?

  операция namedItem(name: Текст): HTMLOptionElement?

  операция remove()

  операция remove(index: Число)

  операция reportValidity(): ДаНет

  операция setCustomValidity(error`: Текст)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSelectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSelectElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  /*(!) [name: number]: HTMLOptionElement | HTMLOptGroupElement*/
}


внешнее
/*(!) var */ HTMLSelectElement: объект { prototype: HTMLSelectElement; при создании(): HTMLSelectElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSlotElement) */

тип HTMLSlotElement = интерфейс на основе HTMLElement
{
  name: Текст

  #js.МассивПараметров
  операция assign(nodes: Список<Объект? /*(!)Element | Text*/>)

  операция assignedElements(options: AssignedNodesOptions? = пусто): Список<Element>

  операция assignedNodes(options: AssignedNodesOptions? = пусто): Список<Node>

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSlotElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSlotElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLSlotElement: объект { prototype: HTMLSlotElement; при создании(): HTMLSlotElement }


/**
* Provides special properties (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating <source> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSourceElement)
*/

тип HTMLSourceElement = интерфейс на основе HTMLElement
{
  height: Число

  media: Текст

  sizes: Текст

  src: Текст

  srcset: Текст

  type`: Текст

  width: Число

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSourceElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSourceElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLSourceElement: объект { prototype: HTMLSourceElement; при создании(): HTMLSourceElement }


/**
* A <span> element and derives from the HTMLElement interface, but without implementing any additional properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSpanElement)
*/

тип HTMLSpanElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSpanElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLSpanElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLSpanElement: объект { prototype: HTMLSpanElement; при создании(): HTMLSpanElement }


/**
* A <style> element. It inherits properties and methods from its parent, HTMLElement, and from LinkStyle.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLStyleElement)
*/

тип HTMLStyleElement = интерфейс на основе HTMLElement, LinkStyle
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLStyleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLStyleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLStyleElement: объект { prototype: HTMLStyleElement; при создании(): HTMLStyleElement }


/**
* Special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating table caption elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableCaptionElement)
*/

тип HTMLTableCaptionElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableCaptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableCaptionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableCaptionElement: объект { prototype: HTMLTableCaptionElement; при создании(): HTMLTableCaptionElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of table cells, either header or data cells, in an HTML document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableCellElement)
*/

тип HTMLTableCellElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableCellElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableCellElement: объект { prototype: HTMLTableCellElement; при создании(): HTMLTableCellElement }


/**
* Provides special properties (beyond the HTMLElement interface it also has available to it inheritance) for manipulating single or grouped table column elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableColElement)
*/

тип HTMLTableColElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableColElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableColElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableColElement: объект { prototype: HTMLTableColElement; при создании(): HTMLTableColElement }


/**
* Provides special properties and methods (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating the layout and presentation of tables in an HTML document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableElement)
*/

тип HTMLTableElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableElement: объект { prototype: HTMLTableElement; при создании(): HTMLTableElement }


/**
* Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of rows in an HTML table.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableRowElement)
*/

тип HTMLTableRowElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableRowElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableRowElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableRowElement: объект { prototype: HTMLTableRowElement; при создании(): HTMLTableRowElement }


/**
* Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of sections, that is headers, footers and bodies, in an HTML table.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTableSectionElement)
*/

тип HTMLTableSectionElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableSectionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTableSectionElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTableSectionElement: объект { prototype: HTMLTableSectionElement; при создании(): HTMLTableSectionElement }


/**
* Enables access to the contents of an HTML <template> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTemplateElement)
*/

тип HTMLTemplateElement = интерфейс на основе HTMLElement
{
  защищено 
  content: DocumentFragment

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTemplateElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTemplateElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTemplateElement: объект { prototype: HTMLTemplateElement; при создании(): HTMLTemplateElement }


/**
* Provides special properties and methods for manipulating the layout and presentation of <textarea> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTextAreaElement)
*/

тип HTMLTextAreaElement = интерфейс на основе HTMLElement
{
  autocomplete: AutoFill

  cols: Число

  defaultValue: Текст

  dirName: Текст

  disabled: ДаНет

  защищено 
  form: HTMLFormElement?

  защищено 
  labels: NodeListOf<HTMLLabelElement>

  maxLength: Число

  minLength: Число

  name: Текст

  placeholder: Текст

  readOnly: ДаНет

  required: ДаНет

  rows: Число

  selectionDirection: Объект? /*(!)"forward" | "backward" | "none"*/

  selectionEnd: Число

  selectionStart: Число

  защищено 
  textLength: Число

  защищено 
  type`: Текст

  защищено 
  validationMessage: Текст

  защищено 
  validity: ValidityState

  value: Текст

  защищено 
  willValidate: ДаНет

  wrap: Текст

  операция checkValidity(): ДаНет

  операция reportValidity(): ДаНет

  операция select()

  операция setCustomValidity(error`: Текст)

  операция setRangeText(replacement: Текст)

  операция setRangeText(replacement: Текст, start: Число, end: Число, selectionMode: SelectionMode? = пусто)

  операция setSelectionRange(start: Число?, end: Число?, direction: Объект? /*(!)"forward" | "backward" | "none" | пусто*/ = пусто)

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTextAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTextAreaElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTextAreaElement: объект { prototype: HTMLTextAreaElement; при создании(): HTMLTextAreaElement }


/**
* Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <time> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTimeElement)
*/

тип HTMLTimeElement = интерфейс на основе HTMLElement
{
  dateTime: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTimeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTimeElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTimeElement: объект { prototype: HTMLTimeElement; при создании(): HTMLTimeElement }


/**
* Contains the title for a document. This element inherits all of the properties and methods of the HTMLElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTitleElement)
*/

тип HTMLTitleElement = интерфейс на основе HTMLElement
{
  text: Текст

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTitleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTitleElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTitleElement: объект { prototype: HTMLTitleElement; при создании(): HTMLTitleElement }


/**
* The HTMLTrackElement
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTrackElement)
*/

тип HTMLTrackElement = интерфейс на основе HTMLElement
{
  default: ДаНет

  kind: Текст

  label: Текст

  защищено 
  readyState: Число

  src: Текст

  srclang: Текст

  защищено 
  track: TextTrack

  защищено 
  NONE: 0

  защищено 
  LOADING: 1

  защищено 
  LOADED: 2

  защищено 
  ERROR: 3

  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTrackElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLTrackElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLTrackElement: объект { prototype: HTMLTrackElement; при создании(): HTMLTrackElement; защищено  NONE: 0; защищено  LOADING: 1; защищено  LOADED: 2; защищено  ERROR: 3 }


/**
* Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating unordered list elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLUListElement)
*/

тип HTMLUListElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLUListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLUListElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLUListElement: объект { prototype: HTMLUListElement; при создании(): HTMLUListElement }


/**
* An invalid HTML element and derives from the HTMLElement interface, but without implementing any additional properties or methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLUnknownElement)
*/

тип HTMLUnknownElement = интерфейс на основе HTMLElement
{
  операция addEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLUnknownElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLUnknownElement, ev: /*(!) HTMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLUnknownElement: объект { prototype: HTMLUnknownElement; при создании(): HTMLUnknownElement }


тип HTMLVideoElementEventMap = интерфейс на основе HTMLMediaElementEventMap
{
  "enterpictureinpicture": Event

  "leavepictureinpicture": Event
}


/**
* Provides special properties and methods for manipulating video objects. It also inherits properties and methods of HTMLMediaElement and HTMLElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
*/

тип HTMLVideoElement = интерфейс на основе HTMLMediaElement
{
  disablePictureInPicture: ДаНет

  height: Число

  onenterpictureinpicture: (операция(this: HTMLVideoElement, ev: Event): /*(!) any */ Объект?)?

  onleavepictureinpicture: (операция(this: HTMLVideoElement, ev: Event): /*(!) any */ Объект?)?

  playsInline: ДаНет

  poster: Текст

  защищено 
  videoHeight: Число

  защищено 
  videoWidth: Число

  width: Число

  операция cancelVideoFrameCallback(handle: Число)

  операция getVideoPlaybackQuality(): VideoPlaybackQuality

  операция requestPictureInPicture(): Promise<PictureInPictureWindow>

  операция requestVideoFrameCallback(callback: VideoFrameRequestCallback): Число

  операция addEventListener<K = /*(!) keyof HTMLVideoElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLVideoElement, ev: /*(!) HTMLVideoElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof HTMLVideoElementEventMap */ Объект?>(type`: K, listener: операция(this: HTMLVideoElement, ev: /*(!) HTMLVideoElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ HTMLVideoElement: объект { prototype: HTMLVideoElement; при создании(): HTMLVideoElement }


/**
* Events that fire when the fragment identifier of the URL has changed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HashChangeEvent)
*/

тип HashChangeEvent = интерфейс на основе Event
{
  защищено 
  newURL: Текст

  защищено 
  oldURL: Текст
}


внешнее
/*(!) var */ HashChangeEvent: объект { prototype: HashChangeEvent; при создании(type`: Текст, eventInitDict: HashChangeEventInit? = пусто): HashChangeEvent }


/**
* This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)
*/

тип Headers = интерфейс
{
  операция append(name: Текст, value: Текст)

  операция delete(name: Текст)

  операция get(name: Текст): Текст?

  операция getSetCookie(): Список<Текст>

  операция has(name: Текст): ДаНет

  операция set(name: Текст, value: Текст)

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: Headers), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ Headers: объект { prototype: Headers; при создании(init: HeadersInit? = пусто): Headers }


/**
* Allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/History)
*/

тип History = интерфейс
{
  защищено 
  length: Число

  scrollRestoration: ScrollRestoration

  защищено 
  state: /*(!) any */ Объект?

  операция back()

  операция forward()

  операция go(delta: Число? = пусто)

  операция pushState(data: /*(!) any */ Объект?, unused: Текст, url: Объект? /*(!)Текст | URL | пусто | пусто*/ = пусто)

  операция replaceState(data: /*(!) any */ Объект?, unused: Текст, url: Объект? /*(!)Текст | URL | пусто | пусто*/ = пусто)
}


внешнее
/*(!) var */ History: объект { prototype: History; при создании(): History }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursor)
*/

тип IDBCursor = интерфейс
{
  защищено 
  direction: IDBCursorDirection

  защищено 
  key: IDBValidKey

  защищено 
  primaryKey: IDBValidKey

  защищено 
  request: IDBRequest

  защищено 
  source: Объект? /*(!)IDBObjectStore | IDBIndex*/

  операция advance(count: Число)

  операция continue(key: IDBValidKey? = пусто)

  операция continuePrimaryKey(key: IDBValidKey, primaryKey: IDBValidKey)

  операция delete(): IDBRequest<пусто>

  операция update(value: /*(!) any */ Объект?): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBCursor: объект { prototype: IDBCursor; при создании(): IDBCursor }


/**
* This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database. It is the same as the IDBCursor, except that it includes the value property.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBCursorWithValue)
*/

тип IDBCursorWithValue = интерфейс на основе IDBCursor
{
  защищено 
  value: /*(!) any */ Объект?
}


внешнее
/*(!) var */ IDBCursorWithValue: объект { prototype: IDBCursorWithValue; при создании(): IDBCursorWithValue }


тип IDBDatabaseEventMap = интерфейс
{
  "abort": Event

  "close": Event

  "error": Event

  "versionchange": IDBVersionChangeEvent
}


/**
* This IndexedDB API interface provides a connection to a database; you can use an IDBDatabase object to open a transaction on your database then create, manipulate, and delete objects (data) in that database. The interface provides the only way to get and manage versions of the database.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBDatabase)
*/

тип IDBDatabase = интерфейс на основе EventTarget
{
  защищено 
  name: Текст

  защищено 
  objectStoreNames: DOMStringList

  onabort: (операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект?)?

  onclose: (операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект?)?

  onerror: (операция(this: IDBDatabase, ev: Event): /*(!) any */ Объект?)?

  onversionchange: (операция(this: IDBDatabase, ev: IDBVersionChangeEvent): /*(!) any */ Объект?)?

  защищено 
  version: Число

  операция close()

  операция createObjectStore(name: Текст, options: IDBObjectStoreParameters? = пусто): IDBObjectStore

  операция deleteObjectStore(name: Текст)

  операция transaction(storeNames: Объект? /*(!)Текст | Список<Текст>*/, mode: IDBTransactionMode? = пусто, options: IDBTransactionOptions? = пусто): IDBTransaction

  операция addEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type`: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof IDBDatabaseEventMap */ Объект?>(type`: K, listener: операция(this: IDBDatabase, ev: /*(!) IDBDatabaseEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ IDBDatabase: объект { prototype: IDBDatabase; при создании(): IDBDatabase }


/**
* In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBFactory)
*/

тип IDBFactory = интерфейс
{
  операция cmp(first: /*(!) any */ Объект?, second: /*(!) any */ Объект?): Число

  операция databases(): Promise<Список<IDBDatabaseInfo>>

  операция deleteDatabase(name: Текст): IDBOpenDBRequest

  операция open(name: Текст, version: Число? = пусто): IDBOpenDBRequest
}


внешнее
/*(!) var */ IDBFactory: объект { prototype: IDBFactory; при создании(): IDBFactory }


/**
* IDBIndex interface of the IndexedDB API provides asynchronous access to an index in a database. An index is a kind of object store for looking up records in another object store, called the referenced object store. You use this interface to retrieve data.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBIndex)
*/

тип IDBIndex = интерфейс
{
  защищено 
  keyPath: Объект? /*(!)Текст | Список<Текст>*/

  защищено 
  multiEntry: ДаНет

  name: Текст

  защищено 
  objectStore: IDBObjectStore

  защищено 
  unique: ДаНет

  операция count(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто*/ = пусто): IDBRequest<Число>

  операция get(query: Объект? /*(!)IDBValidKey | IDBKeyRange*/): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, count: Число? = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, count: Число? = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: Объект? /*(!)IDBValidKey | IDBKeyRange*/): IDBRequest<IDBValidKey?>

  операция openCursor(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, direction: IDBCursorDirection? = пусто): IDBRequest<IDBCursorWithValue?>

  операция openKeyCursor(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, direction: IDBCursorDirection? = пусто): IDBRequest<IDBCursor?>
}


внешнее
/*(!) var */ IDBIndex: объект { prototype: IDBIndex; при создании(): IDBIndex }


/**
* A key range can be a single value or a range with upper and lower bounds or endpoints. If the key range has both upper and lower bounds, then it is bounded; if it has no bounds, it is unbounded. A bounded key range can either be open (the endpoints are excluded) or closed (the endpoints are included). To retrieve all keys within a certain range, you can use the following code constructs:
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBKeyRange)
*/

тип IDBKeyRange = интерфейс
{
  защищено 
  lower: /*(!) any */ Объект?

  защищено 
  lowerOpen: ДаНет

  защищено 
  upper: /*(!) any */ Объект?

  защищено 
  upperOpen: ДаНет

  операция includes(key: /*(!) any */ Объект?): ДаНет
}


внешнее
/*(!) var */ IDBKeyRange: объект { prototype: IDBKeyRange; при создании(): IDBKeyRange; операция bound(lower: /*(!) any */ Объект?, upper: /*(!) any */ Объект?, lowerOpen: ДаНет? = пусто, upperOpen: ДаНет? = пусто): IDBKeyRange; операция lowerBound(lower: /*(!) any */ Объект?, open: ДаНет? = пусто): IDBKeyRange; операция only(value: /*(!) any */ Объект?): IDBKeyRange; операция upperBound(upper: /*(!) any */ Объект?, open: ДаНет? = пусто): IDBKeyRange }


/**
* This example shows a variety of different uses of object stores, from updating the data structure with IDBObjectStore.createIndex inside an onupgradeneeded function, to adding a new item to our object store with IDBObjectStore.add. For a full working example, see our To-do Notifications app (view example live.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBObjectStore)
*/

тип IDBObjectStore = интерфейс
{
  защищено 
  autoIncrement: ДаНет

  защищено 
  indexNames: DOMStringList

  защищено 
  keyPath: Объект? /*(!)Текст | Список<Текст>*/

  name: Текст

  защищено 
  transaction: IDBTransaction

  операция add(value: /*(!) any */ Объект?, key: IDBValidKey? = пусто): IDBRequest<IDBValidKey>

  операция clear(): IDBRequest<пусто>

  операция count(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто*/ = пусто): IDBRequest<Число>

  операция createIndex(name: Текст, keyPath: Объект? /*(!)Текст | Список<Текст>*/, options: IDBIndexParameters? = пусто): IDBIndex

  операция delete(query: Объект? /*(!)IDBValidKey | IDBKeyRange*/): IDBRequest<пусто>

  операция deleteIndex(name: Текст)

  операция get(query: Объект? /*(!)IDBValidKey | IDBKeyRange*/): IDBRequest</*(!) any */ Объект?>

  операция getAll(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, count: Число? = пусто): IDBRequest<Список</*(!) any */ Объект?>>

  операция getAllKeys(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, count: Число? = пусто): IDBRequest<Список<IDBValidKey>>

  операция getKey(query: Объект? /*(!)IDBValidKey | IDBKeyRange*/): IDBRequest<IDBValidKey?>

  операция index(name: Текст): IDBIndex

  операция openCursor(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, direction: IDBCursorDirection? = пусто): IDBRequest<IDBCursorWithValue?>

  операция openKeyCursor(query: Объект? /*(!)IDBValidKey | IDBKeyRange | пусто | пусто*/ = пусто, direction: IDBCursorDirection? = пусто): IDBRequest<IDBCursor?>

  операция put(value: /*(!) any */ Объект?, key: IDBValidKey? = пусто): IDBRequest<IDBValidKey>
}


внешнее
/*(!) var */ IDBObjectStore: объект { prototype: IDBObjectStore; при создании(): IDBObjectStore }


тип IDBOpenDBRequestEventMap = интерфейс на основе IDBRequestEventMap
{
  "blocked": IDBVersionChangeEvent

  "upgradeneeded": IDBVersionChangeEvent
}


/**
* Also inherits methods from its parents IDBRequest and EventTarget.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBOpenDBRequest)
*/

тип IDBOpenDBRequest = интерфейс на основе IDBRequest<IDBDatabase>
{
  onblocked: (операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект?)?

  onupgradeneeded: (операция(this: IDBOpenDBRequest, ev: IDBVersionChangeEvent): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type`: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof IDBOpenDBRequestEventMap */ Объект?>(type`: K, listener: операция(this: IDBOpenDBRequest, ev: /*(!) IDBOpenDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ IDBOpenDBRequest: объект { prototype: IDBOpenDBRequest; при создании(): IDBOpenDBRequest }


тип IDBRequestEventMap = интерфейс
{
  "error": Event

  "success": Event
}


/**
* The request object does not initially contain any information about the result of the operation, but once information becomes available, an event is fired on the request, and the information becomes available through the properties of the IDBRequest instance.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBRequest)
*/

тип IDBRequest<T> = интерфейс на основе EventTarget
{
  защищено 
  error`: DOMException?

  onerror: (операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект?)?

  onsuccess: (операция(this: IDBRequest<T>, ev: Event): /*(!) any */ Объект?)?

  защищено 
  readyState: IDBRequestReadyState

  защищено 
  result: T

  защищено 
  source: Объект? /*(!)IDBObjectStore | IDBIndex | IDBCursor*/

  защищено 
  transaction: IDBTransaction?

  операция addEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type`: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof IDBRequestEventMap */ Объект?>(type`: K, listener: операция(this: IDBRequest<T>, ev: /*(!) IDBRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ IDBRequest: объект { prototype: IDBRequest; при создании(): IDBRequest }


тип IDBTransactionEventMap = интерфейс
{
  "abort": Event

  "complete": Event

  "error": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBTransaction) */

тип IDBTransaction = интерфейс на основе EventTarget
{
  защищено 
  db: IDBDatabase

  защищено 
  durability: IDBTransactionDurability

  защищено 
  error`: DOMException?

  защищено 
  mode: IDBTransactionMode

  защищено 
  objectStoreNames: DOMStringList

  onabort: (операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект?)?

  oncomplete: (операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект?)?

  onerror: (операция(this: IDBTransaction, ev: Event): /*(!) any */ Объект?)?

  операция abort()

  операция commit()

  операция objectStore(name: Текст): IDBObjectStore

  операция addEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type`: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof IDBTransactionEventMap */ Объект?>(type`: K, listener: операция(this: IDBTransaction, ev: /*(!) IDBTransactionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ IDBTransaction: объект { prototype: IDBTransaction; при создании(): IDBTransaction }


/**
* This IndexedDB API interface indicates that the version of the database has changed, as the result of an IDBOpenDBRequest.onupgradeneeded event handler function.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IDBVersionChangeEvent)
*/

тип IDBVersionChangeEvent = интерфейс на основе Event
{
  защищено 
  newVersion: Число?

  защищено 
  oldVersion: Число
}


внешнее
/*(!) var */ IDBVersionChangeEvent: объект { prototype: IDBVersionChangeEvent; при создании(type`: Текст, eventInitDict: IDBVersionChangeEventInit? = пусто): IDBVersionChangeEvent }


/**
* The IIRFilterNode interface of the Web Audio API is a AudioNode processor which implements a general infinite impulse response (IIR)  filter; this type of filter can be used to implement tone control devices and graphic equalizers as well. It lets the parameters of the filter response be specified, so that it can be tuned as needed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IIRFilterNode)
*/

тип IIRFilterNode = интерфейс на основе AudioNode
{
  операция getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array)
}


внешнее
/*(!) var */ IIRFilterNode: объект { prototype: IIRFilterNode; при создании(context: BaseAudioContext, options: IIRFilterOptions): IIRFilterNode }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/IdleDeadline) */

тип IdleDeadline = интерфейс
{
  защищено 
  didTimeout: ДаНет

  операция timeRemaining(): DOMHighResTimeStamp
}


внешнее
/*(!) var */ IdleDeadline: объект { prototype: IdleDeadline; при создании(): IdleDeadline }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmap) */

тип ImageBitmap = интерфейс
{
  защищено 
  height: Число

  защищено 
  width: Число

  операция close()
}


внешнее
/*(!) var */ ImageBitmap: объект { prototype: ImageBitmap; при создании(): ImageBitmap }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageBitmapRenderingContext) */

тип ImageBitmapRenderingContext = интерфейс
{
  защищено 
  canvas: Объект? /*(!)HTMLCanvasElement | OffscreenCanvas*/

  операция transferFromImageBitmap(bitmap: ImageBitmap?)
}


внешнее
/*(!) var */ ImageBitmapRenderingContext: объект { prototype: ImageBitmapRenderingContext; при создании(): ImageBitmapRenderingContext }


/**
* The underlying pixel data of an area of a <canvas> element. It is created using the ImageData() constructor or creator methods on the CanvasRenderingContext2D object associated with a canvas: createImageData() and getImageData(). It can also be used to set a part of the canvas by using putImageData().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ImageData)
*/

тип ImageData = интерфейс
{
  защищено 
  colorSpace: PredefinedColorSpace

  защищено 
  data: Uint8ClampedArray

  защищено 
  height: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ ImageData: объект { prototype: ImageData; при создании(sw: Число, sh: Число, settings: ImageDataSettings? = пусто): ImageData; при создании(data: Uint8ClampedArray, sw: Число, sh: Число? = пусто, settings: ImageDataSettings? = пусто): ImageData }


тип InnerHTML = интерфейс
{
  innerHTML: Текст
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/InputDeviceInfo)
*/

тип InputDeviceInfo = интерфейс на основе MediaDeviceInfo
{
  операция getCapabilities(): MediaTrackCapabilities
}


внешнее
/*(!) var */ InputDeviceInfo: объект { prototype: InputDeviceInfo; при создании(): InputDeviceInfo }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/InputEvent) */

тип InputEvent = интерфейс на основе UIEvent
{
  защищено 
  data: Текст?

  защищено 
  dataTransfer: DataTransfer?

  защищено 
  inputType: Текст

  защищено 
  isComposing: ДаНет

  операция getTargetRanges(): Список<StaticRange>
}


внешнее
/*(!) var */ InputEvent: объект { prototype: InputEvent; при создании(type`: Текст, eventInitDict: InputEventInit? = пусто): InputEvent }


/**
* provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IntersectionObserver)
*/

тип IntersectionObserver = интерфейс
{
  защищено 
  root: Объект? /*(!)Element | Document | пусто*/

  защищено 
  rootMargin: Текст

  защищено 
  thresholds: ReadonlyArray<Число>

  операция disconnect()

  операция observe(target: Element)

  операция takeRecords(): Список<IntersectionObserverEntry>

  операция unobserve(target: Element)
}


внешнее
/*(!) var */ IntersectionObserver: объект { prototype: IntersectionObserver; при создании(callback: IntersectionObserverCallback, options: IntersectionObserverInit? = пусто): IntersectionObserver }


/**
* This Intersection Observer API interface describes the intersection between the target element and its root container at a specific moment of transition.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/IntersectionObserverEntry)
*/

тип IntersectionObserverEntry = интерфейс
{
  защищено 
  boundingClientRect: DOMRectReadOnly

  защищено 
  intersectionRatio: Число

  защищено 
  intersectionRect: DOMRectReadOnly

  защищено 
  isIntersecting: ДаНет

  защищено 
  rootBounds: DOMRectReadOnly?

  защищено 
  target: Element

  защищено 
  time: DOMHighResTimeStamp
}


внешнее
/*(!) var */ IntersectionObserverEntry: объект { prototype: IntersectionObserverEntry; при создании(intersectionObserverEntryInit: IntersectionObserverEntryInit): IntersectionObserverEntry }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/KHR_parallel_shader_compile) */

тип KHR_parallel_shader_compile = интерфейс
{
  защищено 
  COMPLETION_STATUS_KHR: 0x91B1
}


/**
* KeyboardEvent objects describe a user interaction with the keyboard; each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/KeyboardEvent)
*/

тип KeyboardEvent = интерфейс на основе UIEvent
{
  защищено 
  DOM_KEY_LOCATION_STANDARD: 0x00

  защищено 
  DOM_KEY_LOCATION_LEFT: 0x01

  защищено 
  DOM_KEY_LOCATION_RIGHT: 0x02

  защищено 
  DOM_KEY_LOCATION_NUMPAD: 0x03
}


внешнее
/*(!) var */ KeyboardEvent: объект { prototype: KeyboardEvent; при создании(type`: Текст, eventInitDict: KeyboardEventInit? = пусто): KeyboardEvent; защищено  DOM_KEY_LOCATION_STANDARD: 0x00; защищено  DOM_KEY_LOCATION_LEFT: 0x01; защищено  DOM_KEY_LOCATION_RIGHT: 0x02; защищено  DOM_KEY_LOCATION_NUMPAD: 0x03 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/KeyframeEffect) */

тип KeyframeEffect = интерфейс на основе AnimationEffect
{
  composite: CompositeOperation

  iterationComposite: IterationCompositeOperation

  pseudoElement: Текст?

  target: Element?

  операция getKeyframes(): Список<ComputedKeyframe>

  операция setKeyframes(keyframes: Объект? /*(!)Список<Keyframe> | PropertyIndexedKeyframes | пусто*/)
}


внешнее
/*(!) var */ KeyframeEffect: объект { prototype: KeyframeEffect; при создании(target: Element?, keyframes: Объект? /*(!)Список<Keyframe> | PropertyIndexedKeyframes | пусто*/, options: Объект? /*(!)Число | KeyframeEffectOptions | пусто*/ = пусто): KeyframeEffect; при создании(source: KeyframeEffect): KeyframeEffect }


тип LinkStyle = интерфейс
{
  защищено 
  sheet: CSSStyleSheet?
}


/**
* The location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Location)
*/

тип Location = интерфейс
{
  защищено 
  ancestorOrigins: DOMStringList

  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  операция assign(url: Объект? /*(!)Текст | URL*/)

  операция reload()

  операция replace(url: Объект? /*(!)Текст | URL*/)
}


внешнее
/*(!) var */ Location: объект { prototype: Location; при создании(): Location }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Lock)
*/

тип Lock = интерфейс
{
  защищено 
  mode: LockMode

  защищено 
  name: Текст
}


внешнее
/*(!) var */ Lock: объект { prototype: Lock; при создании(): Lock }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/LockManager)
*/

тип LockManager = интерфейс
{
  операция query(): Promise<LockManagerSnapshot>

  операция request(name: Текст, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>

  операция request(name: Текст, options: LockOptions, callback: LockGrantedCallback): Promise</*(!) any */ Объект?>
}


внешнее
/*(!) var */ LockManager: объект { prototype: LockManager; при создании(): LockManager }


тип MIDIAccessEventMap = интерфейс
{
  "statechange": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIAccess)
*/

тип MIDIAccess = интерфейс на основе EventTarget
{
  защищено 
  inputs: MIDIInputMap

  onstatechange: (операция(this: MIDIAccess, ev: Event): /*(!) any */ Объект?)?

  защищено 
  outputs: MIDIOutputMap

  защищено 
  sysexEnabled: ДаНет

  операция addEventListener<K = /*(!) keyof MIDIAccessEventMap */ Объект?>(type`: K, listener: операция(this: MIDIAccess, ev: /*(!) MIDIAccessEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIAccessEventMap */ Объект?>(type`: K, listener: операция(this: MIDIAccess, ev: /*(!) MIDIAccessEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MIDIAccess: объект { prototype: MIDIAccess; при создании(): MIDIAccess }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIConnectionEvent)
*/

тип MIDIConnectionEvent = интерфейс на основе Event
{
  защищено 
  port: MIDIPort
}


внешнее
/*(!) var */ MIDIConnectionEvent: объект { prototype: MIDIConnectionEvent; при создании(type`: Текст, eventInitDict: MIDIConnectionEventInit? = пусто): MIDIConnectionEvent }


тип MIDIInputEventMap = интерфейс на основе MIDIPortEventMap
{
  "midimessage": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIInput)
*/

тип MIDIInput = интерфейс на основе MIDIPort
{
  onmidimessage: (операция(this: MIDIInput, ev: Event): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof MIDIInputEventMap */ Объект?>(type`: K, listener: операция(this: MIDIInput, ev: /*(!) MIDIInputEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIInputEventMap */ Объект?>(type`: K, listener: операция(this: MIDIInput, ev: /*(!) MIDIInputEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MIDIInput: объект { prototype: MIDIInput; при создании(): MIDIInput }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIInputMap)
*/

тип MIDIInputMap = интерфейс
{
  операция forEach(callbackfn: операция(value: MIDIInput, key: Текст, parent: MIDIInputMap), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ MIDIInputMap: объект { prototype: MIDIInputMap; при создании(): MIDIInputMap }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIMessageEvent)
*/

тип MIDIMessageEvent = интерфейс на основе Event
{
  защищено 
  data: Uint8Array
}


внешнее
/*(!) var */ MIDIMessageEvent: объект { prototype: MIDIMessageEvent; при создании(type`: Текст, eventInitDict: MIDIMessageEventInit? = пусто): MIDIMessageEvent }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIOutput)
*/

тип MIDIOutput = интерфейс на основе MIDIPort
{
  операция send(data: Список<Число>, timestamp: DOMHighResTimeStamp? = пусто)

  операция addEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type`: K, listener: операция(this: MIDIOutput, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type`: K, listener: операция(this: MIDIOutput, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MIDIOutput: объект { prototype: MIDIOutput; при создании(): MIDIOutput }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIOutputMap)
*/

тип MIDIOutputMap = интерфейс
{
  операция forEach(callbackfn: операция(value: MIDIOutput, key: Текст, parent: MIDIOutputMap), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ MIDIOutputMap: объект { prototype: MIDIOutputMap; при создании(): MIDIOutputMap }


тип MIDIPortEventMap = интерфейс
{
  "statechange": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MIDIPort)
*/

тип MIDIPort = интерфейс на основе EventTarget
{
  защищено 
  connection: MIDIPortConnectionState

  защищено 
  id: Текст

  защищено 
  manufacturer: Текст?

  защищено 
  name: Текст?

  onstatechange: (операция(this: MIDIPort, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: MIDIPortDeviceState

  защищено 
  type`: MIDIPortType

  защищено 
  version: Текст?

  операция close(): Promise<MIDIPort>

  операция open(): Promise<MIDIPort>

  операция addEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type`: K, listener: операция(this: MIDIPort, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MIDIPortEventMap */ Объект?>(type`: K, listener: операция(this: MIDIPort, ev: /*(!) MIDIPortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MIDIPort: объект { prototype: MIDIPort; при создании(): MIDIPort }


тип MathMLElementEventMap = интерфейс на основе ElementEventMap, GlobalEventHandlersEventMap
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MathMLElement) */

тип MathMLElement = интерфейс на основе Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement
{
  операция addEventListener<K = /*(!) keyof MathMLElementEventMap */ Объект?>(type`: K, listener: операция(this: MathMLElement, ev: /*(!) MathMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MathMLElementEventMap */ Объект?>(type`: K, listener: операция(this: MathMLElement, ev: /*(!) MathMLElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MathMLElement: объект { prototype: MathMLElement; при создании(): MathMLElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaCapabilities) */

тип MediaCapabilities = интерфейс
{
  операция decodingInfo(configuration: MediaDecodingConfiguration): Promise<MediaCapabilitiesDecodingInfo>

  операция encodingInfo(configuration: MediaEncodingConfiguration): Promise<MediaCapabilitiesEncodingInfo>
}


внешнее
/*(!) var */ MediaCapabilities: объект { prototype: MediaCapabilities; при создании(): MediaCapabilities }


/**
* The MediaDevicesInfo interface contains information that describes a single media input or output device.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaDeviceInfo)
*/

тип MediaDeviceInfo = интерфейс
{
  защищено 
  deviceId: Текст

  защищено 
  groupId: Текст

  защищено 
  kind: MediaDeviceKind

  защищено 
  label: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ MediaDeviceInfo: объект { prototype: MediaDeviceInfo; при создании(): MediaDeviceInfo }


тип MediaDevicesEventMap = интерфейс
{
  "devicechange": Event
}


/**
* Provides access to connected media input devices like cameras and microphones, as well as screen sharing. In essence, it lets you obtain access to any hardware source of media data.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaDevices)
*/

тип MediaDevices = интерфейс на основе EventTarget
{
  ondevicechange: (операция(this: MediaDevices, ev: Event): /*(!) any */ Объект?)?

  операция enumerateDevices(): Promise<Список<MediaDeviceInfo>>

  операция getDisplayMedia(options: DisplayMediaStreamOptions? = пусто): Promise<MediaStream>

  операция getSupportedConstraints(): MediaTrackSupportedConstraints

  операция getUserMedia(constraints: MediaStreamConstraints? = пусто): Promise<MediaStream>

  операция addEventListener<K = /*(!) keyof MediaDevicesEventMap */ Объект?>(type`: K, listener: операция(this: MediaDevices, ev: /*(!) MediaDevicesEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaDevicesEventMap */ Объект?>(type`: K, listener: операция(this: MediaDevices, ev: /*(!) MediaDevicesEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaDevices: объект { prototype: MediaDevices; при создании(): MediaDevices }


/**
* A MediaElementSourceNode has no inputs and exactly one output, and is created using the AudioContext.createMediaElementSource method. The amount of channels in the output equals the number of channels of the audio referenced by the HTMLMediaElement used in the creation of the node, or is 1 if the HTMLMediaElement has no audio.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaElementAudioSourceNode)
*/

тип MediaElementAudioSourceNode = интерфейс на основе AudioNode
{
  защищено 
  mediaElement: HTMLMediaElement
}


внешнее
/*(!) var */ MediaElementAudioSourceNode: объект { prototype: MediaElementAudioSourceNode; при создании(context: AudioContext, options: MediaElementAudioSourceOptions): MediaElementAudioSourceNode }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaEncryptedEvent) */

тип MediaEncryptedEvent = интерфейс на основе Event
{
  защищено 
  initData: ArrayBuffer?

  защищено 
  initDataType: Текст
}


внешнее
/*(!) var */ MediaEncryptedEvent: объект { prototype: MediaEncryptedEvent; при создании(type`: Текст, eventInitDict: MediaEncryptedEventInit? = пусто): MediaEncryptedEvent }


/**
* An error which occurred while handling media in an HTML media element based on HTMLMediaElement, such as <audio> or <video>.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaError)
*/

тип MediaError = интерфейс
{
  защищено 
  code: Число

  защищено 
  message: Текст

  защищено 
  MEDIA_ERR_ABORTED: 1

  защищено 
  MEDIA_ERR_NETWORK: 2

  защищено 
  MEDIA_ERR_DECODE: 3

  защищено 
  MEDIA_ERR_SRC_NOT_SUPPORTED: 4
}


внешнее
/*(!) var */ MediaError: объект { prototype: MediaError; при создании(): MediaError; защищено  MEDIA_ERR_ABORTED: 1; защищено  MEDIA_ERR_NETWORK: 2; защищено  MEDIA_ERR_DECODE: 3; защищено  MEDIA_ERR_SRC_NOT_SUPPORTED: 4 }


/**
* This EncryptedMediaExtensions API interface contains the content and related data when the content decryption module generates a message for the session.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeyMessageEvent)
*/

тип MediaKeyMessageEvent = интерфейс на основе Event
{
  защищено 
  message: ArrayBuffer

  защищено 
  messageType: MediaKeyMessageType
}


внешнее
/*(!) var */ MediaKeyMessageEvent: объект { prototype: MediaKeyMessageEvent; при создании(type`: Текст, eventInitDict: MediaKeyMessageEventInit): MediaKeyMessageEvent }


тип MediaKeySessionEventMap = интерфейс
{
  "keystatuseschange": Event

  "message": MediaKeyMessageEvent
}


/**
* This EncryptedMediaExtensions API interface represents a context for message exchange with a content decryption module (CDM).
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeySession)
*/

тип MediaKeySession = интерфейс на основе EventTarget
{
  защищено 
  closed: Promise<MediaKeySessionClosedReason>

  защищено 
  expiration: Число

  защищено 
  keyStatuses: MediaKeyStatusMap

  onkeystatuseschange: (операция(this: MediaKeySession, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: MediaKeySession, ev: MediaKeyMessageEvent): /*(!) any */ Объект?)?

  защищено 
  sessionId: Текст

  операция close(): Promise<Ничего>

  операция generateRequest(initDataType: Текст, initData: BufferSource): Promise<Ничего>

  операция load(sessionId: Текст): Promise<ДаНет>

  операция remove(): Promise<Ничего>

  операция update(response: BufferSource): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof MediaKeySessionEventMap */ Объект?>(type`: K, listener: операция(this: MediaKeySession, ev: /*(!) MediaKeySessionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaKeySessionEventMap */ Объект?>(type`: K, listener: операция(this: MediaKeySession, ev: /*(!) MediaKeySessionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaKeySession: объект { prototype: MediaKeySession; при создании(): MediaKeySession }


/**
* This EncryptedMediaExtensions API interface is a read-only map of media key statuses by key IDs.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeyStatusMap)
*/

тип MediaKeyStatusMap = интерфейс
{
  защищено 
  size: Число

  операция get(keyId: BufferSource): MediaKeyStatus?

  операция has(keyId: BufferSource): ДаНет

  операция forEach(callbackfn: операция(value: MediaKeyStatus, key: BufferSource, parent: MediaKeyStatusMap), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ MediaKeyStatusMap: объект { prototype: MediaKeyStatusMap; при создании(): MediaKeyStatusMap }


/**
* This EncryptedMediaExtensions API interface provides access to a Key System for decryption and/or a content protection provider. You can request an instance of this object using the Navigator.requestMediaKeySystemAccess method.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeySystemAccess)
*/

тип MediaKeySystemAccess = интерфейс
{
  защищено 
  keySystem: Текст

  операция createMediaKeys(): Promise<MediaKeys>

  операция getConfiguration(): MediaKeySystemConfiguration
}


внешнее
/*(!) var */ MediaKeySystemAccess: объект { prototype: MediaKeySystemAccess; при создании(): MediaKeySystemAccess }


/**
* This EncryptedMediaExtensions API interface the represents a set of keys that an associated HTMLMediaElement can use for decryption of media data during playback.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaKeys)
*/

тип MediaKeys = интерфейс
{
  операция createSession(sessionType: MediaKeySessionType? = пусто): MediaKeySession

  операция setServerCertificate(serverCertificate: BufferSource): Promise<ДаНет>
}


внешнее
/*(!) var */ MediaKeys: объект { prototype: MediaKeys; при создании(): MediaKeys }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaList) */

тип MediaList = интерфейс
{
  защищено 
  length: Число

  mediaText: Текст

  операция toString(): Текст

  операция appendMedium(medium: Текст)

  операция deleteMedium(medium: Текст)

  операция item(index: Число): Текст?

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ MediaList: объект { prototype: MediaList; при создании(): MediaList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaMetadata) */

тип MediaMetadata = интерфейс
{
  album: Текст

  artist: Текст

  artwork: ReadonlyArray<MediaImage>

  title: Текст
}


внешнее
/*(!) var */ MediaMetadata: объект { prototype: MediaMetadata; при создании(init: MediaMetadataInit? = пусто): MediaMetadata }


тип MediaQueryListEventMap = интерфейс
{
  "change": MediaQueryListEvent
}


/**
* Stores information on a media query applied to a document, and handles sending notifications to listeners when the media query state change (i.e. when the media query test starts or stops evaluating to true).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaQueryList)
*/

тип MediaQueryList = интерфейс на основе EventTarget
{
  операция addEventListener<K = /*(!) keyof MediaQueryListEventMap */ Объект?>(type`: K, listener: операция(this: MediaQueryList, ev: /*(!) MediaQueryListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaQueryListEventMap */ Объект?>(type`: K, listener: операция(this: MediaQueryList, ev: /*(!) MediaQueryListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaQueryList: объект { prototype: MediaQueryList; при создании(): MediaQueryList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaQueryListEvent) */

тип MediaQueryListEvent = интерфейс на основе Event
{
  защищено 
  matches: ДаНет

  защищено 
  media: Текст
}


внешнее
/*(!) var */ MediaQueryListEvent: объект { prototype: MediaQueryListEvent; при создании(type`: Текст, eventInitDict: MediaQueryListEventInit? = пусто): MediaQueryListEvent }


тип MediaRecorderEventMap = интерфейс
{
  "dataavailable": BlobEvent

  "error": Event

  "pause": Event

  "resume": Event

  "start": Event

  "stop": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaRecorder) */

тип MediaRecorder = интерфейс на основе EventTarget
{
  защищено 
  audioBitsPerSecond: Число

  защищено 
  mimeType: Текст

  ondataavailable: (операция(this: MediaRecorder, ev: BlobEvent): /*(!) any */ Объект?)?

  onerror: (операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект?)?

  onpause: (операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект?)?

  onresume: (операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект?)?

  onstart: (операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект?)?

  onstop: (операция(this: MediaRecorder, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: RecordingState

  защищено 
  stream: MediaStream

  защищено 
  videoBitsPerSecond: Число

  операция pause()

  операция requestData()

  операция resume()

  операция start(timeslice: Число? = пусто)

  операция stop()

  операция addEventListener<K = /*(!) keyof MediaRecorderEventMap */ Объект?>(type`: K, listener: операция(this: MediaRecorder, ev: /*(!) MediaRecorderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaRecorderEventMap */ Объект?>(type`: K, listener: операция(this: MediaRecorder, ev: /*(!) MediaRecorderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaRecorder: объект { prototype: MediaRecorder; при создании(stream: MediaStream, options: MediaRecorderOptions? = пусто): MediaRecorder; операция isTypeSupported(type`: Текст): ДаНет }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaSession) */

тип MediaSession = интерфейс
{
  metadata: MediaMetadata?

  playbackState: MediaSessionPlaybackState

  операция setActionHandler(action: MediaSessionAction, handler: MediaSessionActionHandler?)

  операция setPositionState(state: MediaPositionState? = пусто)
}


внешнее
/*(!) var */ MediaSession: объект { prototype: MediaSession; при создании(): MediaSession }


тип MediaSourceEventMap = интерфейс
{
  "sourceclose": Event

  "sourceended": Event

  "sourceopen": Event
}


/**
* This Media Source Extensions API interface represents a source of media data for an HTMLMediaElement object. A MediaSource object can be attached to a HTMLMediaElement to be played in the user agent.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaSource)
*/

тип MediaSource = интерфейс на основе EventTarget
{
  защищено 
  activeSourceBuffers: SourceBufferList

  duration: Число

  onsourceclose: (операция(this: MediaSource, ev: Event): /*(!) any */ Объект?)?

  onsourceended: (операция(this: MediaSource, ev: Event): /*(!) any */ Объект?)?

  onsourceopen: (операция(this: MediaSource, ev: Event): /*(!) any */ Объект?)?

  защищено 
  readyState: ReadyState

  защищено 
  sourceBuffers: SourceBufferList

  операция addSourceBuffer(type`: Текст): SourceBuffer

  операция clearLiveSeekableRange()

  операция endOfStream(error`: EndOfStreamError? = пусто)

  операция removeSourceBuffer(sourceBuffer: SourceBuffer)

  операция setLiveSeekableRange(start: Число, end: Число)

  операция addEventListener<K = /*(!) keyof MediaSourceEventMap */ Объект?>(type`: K, listener: операция(this: MediaSource, ev: /*(!) MediaSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaSourceEventMap */ Объект?>(type`: K, listener: операция(this: MediaSource, ev: /*(!) MediaSourceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaSource: объект { prototype: MediaSource; при создании(): MediaSource; операция isTypeSupported(type`: Текст): ДаНет }


тип MediaStreamEventMap = интерфейс
{
  "addtrack": MediaStreamTrackEvent

  "removetrack": MediaStreamTrackEvent
}


/**
* A stream of media content. A stream consists of several tracks such as video or audio tracks. Each track is specified as an instance of MediaStreamTrack.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStream)
*/

тип MediaStream = интерфейс на основе EventTarget
{
  защищено 
  active: ДаНет

  защищено 
  id: Текст

  onaddtrack: (операция(this: MediaStream, ev: MediaStreamTrackEvent): /*(!) any */ Объект?)?

  onremovetrack: (операция(this: MediaStream, ev: MediaStreamTrackEvent): /*(!) any */ Объект?)?

  операция addTrack(track: MediaStreamTrack)

  операция clone(): MediaStream

  операция getAudioTracks(): Список<MediaStreamTrack>

  операция getTrackById(trackId: Текст): MediaStreamTrack?

  операция getTracks(): Список<MediaStreamTrack>

  операция getVideoTracks(): Список<MediaStreamTrack>

  операция removeTrack(track: MediaStreamTrack)

  операция addEventListener<K = /*(!) keyof MediaStreamEventMap */ Объект?>(type`: K, listener: операция(this: MediaStream, ev: /*(!) MediaStreamEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamEventMap */ Объект?>(type`: K, listener: операция(this: MediaStream, ev: /*(!) MediaStreamEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaStream: объект { prototype: MediaStream; при создании(): MediaStream; при создании(stream: MediaStream): MediaStream; при создании(tracks: Список<MediaStreamTrack>): MediaStream }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamAudioDestinationNode) */

тип MediaStreamAudioDestinationNode = интерфейс на основе AudioNode
{
  защищено 
  stream: MediaStream
}


внешнее
/*(!) var */ MediaStreamAudioDestinationNode: объект { prototype: MediaStreamAudioDestinationNode; при создании(context: AudioContext, options: AudioNodeOptions? = пусто): MediaStreamAudioDestinationNode }


/**
* A type of AudioNode which operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamAudioSourceNode)
*/

тип MediaStreamAudioSourceNode = интерфейс на основе AudioNode
{
  защищено 
  mediaStream: MediaStream
}


внешнее
/*(!) var */ MediaStreamAudioSourceNode: объект { prototype: MediaStreamAudioSourceNode; при создании(context: AudioContext, options: MediaStreamAudioSourceOptions): MediaStreamAudioSourceNode }


тип MediaStreamTrackEventMap = интерфейс
{
  "ended": Event

  "mute": Event

  "unmute": Event
}


/**
* A single media track within a stream; typically, these are audio or video tracks, but other track types may exist as well.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamTrack)
*/

тип MediaStreamTrack = интерфейс на основе EventTarget
{
  contentHint: Текст

  enabled: ДаНет

  защищено 
  id: Текст

  защищено 
  kind: Текст

  защищено 
  label: Текст

  защищено 
  muted: ДаНет

  onended: (операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект?)?

  onmute: (операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект?)?

  onunmute: (операция(this: MediaStreamTrack, ev: Event): /*(!) any */ Объект?)?

  защищено 
  readyState: MediaStreamTrackState

  операция applyConstraints(constraints: MediaTrackConstraints? = пусто): Promise<Ничего>

  операция clone(): MediaStreamTrack

  операция getCapabilities(): MediaTrackCapabilities

  операция getConstraints(): MediaTrackConstraints

  операция getSettings(): MediaTrackSettings

  операция stop()

  операция addEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type`: K, listener: операция(this: MediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MediaStreamTrackEventMap */ Объект?>(type`: K, listener: операция(this: MediaStreamTrack, ev: /*(!) MediaStreamTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MediaStreamTrack: объект { prototype: MediaStreamTrack; при создании(): MediaStreamTrack }


/**
* Events which indicate that a MediaStream has had tracks added to or removed from the stream through calls to Media Stream API methods. These events are sent to the stream when these changes occur.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MediaStreamTrackEvent)
*/

тип MediaStreamTrackEvent = интерфейс на основе Event
{
  защищено 
  track: MediaStreamTrack
}


внешнее
/*(!) var */ MediaStreamTrackEvent: объект { prototype: MediaStreamTrackEvent; при создании(type`: Текст, eventInitDict: MediaStreamTrackEventInit): MediaStreamTrackEvent }


/**
* This Channel Messaging API interface allows us to create a new message channel and send data through it via its two MessagePort properties.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel)
*/

тип MessageChannel = интерфейс
{
  защищено 
  port1: MessagePort

  защищено 
  port2: MessagePort
}


внешнее
/*(!) var */ MessageChannel: объект { prototype: MessageChannel; при создании(): MessageChannel }


/**
* A message received by a target object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)
*/

тип MessageEvent<T> = интерфейс на основе Event
{

}


внешнее
/*(!) var */ MessageEvent: объект { prototype: MessageEvent; при создании(type`: Текст, eventInitDict: MessageEventInit<T>? = пусто): MessageEvent<T> }


тип MessagePortEventMap = интерфейс
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Channel Messaging API interface represents one of the two ports of a MessageChannel, allowing messages to be sent from one port and listening out for them arriving at the other.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort)
*/

тип MessagePort = интерфейс на основе EventTarget
{
  onmessage: (операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект?)?

  onmessageerror: (операция(this: MessagePort, ev: MessageEvent): /*(!) any */ Объект?)?

  операция close()

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions? = пусто)

  операция start()

  операция addEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type`: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof MessagePortEventMap */ Объект?>(type`: K, listener: операция(this: MessagePort, ev: /*(!) MessagePortEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ MessagePort: объект { prototype: MessagePort; при создании(): MessagePort }


/**
* Events that occur due to the user interacting with a pointing device (such as a mouse). Common events using this interface include click, dblclick, mouseup, mousedown.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MouseEvent)
*/

тип MouseEvent = интерфейс на основе UIEvent
{

}


внешнее
/*(!) var */ MouseEvent: объект { prototype: MouseEvent; при создании(type`: Текст, eventInitDict: MouseEventInit? = пусто): MouseEvent }


/**
* Provides the ability to watch for changes being made to the DOM tree. It is designed as a replacement for the older Mutation Events feature which was part of the DOM3 Events specification.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MutationObserver)
*/

тип MutationObserver = интерфейс
{
  операция disconnect()

  операция observe(target: Node, options: MutationObserverInit? = пусто)

  операция takeRecords(): Список<MutationRecord>
}


внешнее
/*(!) var */ MutationObserver: объект { prototype: MutationObserver; при создании(callback: MutationCallback): MutationObserver }


/**
* A MutationRecord represents an individual DOM mutation. It is the object that is passed to MutationObserver's callback.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/MutationRecord)
*/

тип MutationRecord = интерфейс
{
  защищено 
  addedNodes: NodeList

  защищено 
  attributeName: Текст?

  защищено 
  attributeNamespace: Текст?

  защищено 
  nextSibling: Node?

  защищено 
  oldValue: Текст?

  защищено 
  previousSibling: Node?

  защищено 
  removedNodes: NodeList

  защищено 
  target: Node

  защищено 
  type`: MutationRecordType
}


внешнее
/*(!) var */ MutationRecord: объект { prototype: MutationRecord; при создании(): MutationRecord }


/**
* A collection of Attr objects. Objects inside a NamedNodeMap are not in any particular order, unlike NodeList, although they may be accessed by an index as in an array.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NamedNodeMap)
*/

тип NamedNodeMap = интерфейс
{
  защищено 
  length: Число

  операция getNamedItem(qualifiedName: Текст): Attr?

  операция getNamedItemNS(namespace: Текст?, localName: Текст): Attr?

  операция item(index: Число): Attr?

  операция removeNamedItem(qualifiedName: Текст): Attr

  операция removeNamedItemNS(namespace: Текст?, localName: Текст): Attr

  операция setNamedItem(attr: Attr): Attr?

  операция setNamedItemNS(attr: Attr): Attr?

  /*(!) [index: number]: Attr*/
}


внешнее
/*(!) var */ NamedNodeMap: объект { prototype: NamedNodeMap; при создании(): NamedNodeMap }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NavigationPreloadManager)
*/

тип NavigationPreloadManager = интерфейс
{
  операция disable(): Promise<Ничего>

  операция enable(): Promise<Ничего>

  операция getState(): Promise<NavigationPreloadState>

  операция setHeaderValue(value: Текст): Promise<Ничего>
}


внешнее
/*(!) var */ NavigationPreloadManager: объект { prototype: NavigationPreloadManager; при создании(): NavigationPreloadManager }


/**
* The state and the identity of the user agent. It allows scripts to query it and to register themselves to carry on some activities.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Navigator)
*/

тип Navigator = интерфейс на основе NavigatorAutomationInformation, NavigatorBadge, NavigatorConcurrentHardware, NavigatorContentUtils, NavigatorCookies, NavigatorID, NavigatorLanguage, NavigatorLocks, NavigatorOnLine, NavigatorPlugins, NavigatorStorage
{
  защищено 
  clipboard: Clipboard

  защищено 
  credentials: CredentialsContainer

  защищено 
  doNotTrack: Текст?

  защищено 
  geolocation: Geolocation

  защищено 
  maxTouchPoints: Число

  защищено 
  mediaCapabilities: MediaCapabilities

  защищено 
  mediaDevices: MediaDevices

  защищено 
  mediaSession: MediaSession

  защищено 
  permissions: Permissions

  защищено 
  serviceWorker: ServiceWorkerContainer

  защищено 
  userActivation: UserActivation

  защищено 
  wakeLock: WakeLock

  операция canShare(data: ShareData? = пусто): ДаНет

  операция getGamepads(): Список<Gamepad?>

  операция requestMIDIAccess(options: MIDIOptions? = пусто): Promise<MIDIAccess>

  операция requestMediaKeySystemAccess(keySystem: Текст, supportedConfigurations: Список<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>

  операция sendBeacon(url: Объект? /*(!)Текст | URL*/, data: BodyInit? = пусто): ДаНет

  операция share(data: ShareData? = пусто): Promise<Ничего>

  операция vibrate(pattern: VibratePattern): ДаНет
}


внешнее
/*(!) var */ Navigator: объект { prototype: Navigator; при создании(): Navigator }


тип NavigatorAutomationInformation = интерфейс
{
  защищено 
  webdriver: ДаНет
}


/** Available only in secure contexts. */

тип NavigatorBadge = интерфейс
{
  операция clearAppBadge(): Promise<Ничего>

  операция setAppBadge(contents: Число? = пусто): Promise<Ничего>
}


тип NavigatorConcurrentHardware = интерфейс
{
  защищено 
  hardwareConcurrency: Число
}


тип NavigatorContentUtils = интерфейс
{
  операция registerProtocolHandler(scheme: Текст, url: Объект? /*(!)Текст | URL*/)
}


тип NavigatorCookies = интерфейс
{
  защищено 
  cookieEnabled: ДаНет
}


тип NavigatorID = интерфейс
{

}


тип NavigatorLanguage = интерфейс
{
  защищено 
  language: Текст

  защищено 
  languages: ReadonlyArray<Текст>
}


/** Available only in secure contexts. */

тип NavigatorLocks = интерфейс
{
  защищено 
  locks: LockManager
}


тип NavigatorOnLine = интерфейс
{
  защищено 
  onLine: ДаНет
}


тип NavigatorPlugins = интерфейс
{

}


/** Available only in secure contexts. */

тип NavigatorStorage = интерфейс
{
  защищено 
  storage: StorageManager
}


/**
* Node is an interface from which a number of DOM API object types inherit. It allows those types to be treated similarly; for example, inheriting the same set of methods, or being tested in the same way.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node)
*/

тип Node = интерфейс на основе EventTarget
{
  защищено 
  baseURI: Текст

  защищено 
  childNodes: NodeListOf<ChildNode>

  защищено 
  firstChild: ChildNode?

  защищено 
  isConnected: ДаНет

  защищено 
  lastChild: ChildNode?

  защищено 
  nextSibling: ChildNode?

  защищено 
  nodeName: Текст

  защищено 
  nodeType: Число

  nodeValue: Текст?

  защищено 
  ownerDocument: Document?

  защищено 
  parentElement: HTMLElement?

  защищено 
  parentNode: ParentNode?

  защищено 
  previousSibling: ChildNode?

  textContent: Текст?

  операция appendChild<T = Node>(node: T): T

  операция cloneNode(deep: ДаНет? = пусто): Node

  операция compareDocumentPosition(other: Node): Число

  операция contains(other: Node?): ДаНет

  операция getRootNode(options: GetRootNodeOptions? = пусто): Node

  операция hasChildNodes(): ДаНет

  операция insertBefore<T = Node>(node: T, child: Node?): T

  операция isDefaultNamespace(namespace: Текст?): ДаНет

  операция isEqualNode(otherNode: Node?): ДаНет

  операция isSameNode(otherNode: Node?): ДаНет

  операция lookupNamespaceURI(prefix: Текст?): Текст?

  операция lookupPrefix(namespace: Текст?): Текст?

  операция normalize()

  операция removeChild<T = Node>(child: T): T

  операция replaceChild<T = Node>(node: Node, child: T): T

  защищено 
  ELEMENT_NODE: 1

  защищено 
  ATTRIBUTE_NODE: 2

  защищено 
  TEXT_NODE: 3

  защищено 
  CDATA_SECTION_NODE: 4

  защищено 
  ENTITY_REFERENCE_NODE: 5

  защищено 
  ENTITY_NODE: 6

  защищено 
  PROCESSING_INSTRUCTION_NODE: 7

  защищено 
  COMMENT_NODE: 8

  защищено 
  DOCUMENT_NODE: 9

  защищено 
  DOCUMENT_TYPE_NODE: 10

  защищено 
  DOCUMENT_FRAGMENT_NODE: 11

  защищено 
  NOTATION_NODE: 12

  защищено 
  DOCUMENT_POSITION_DISCONNECTED: 0x01

  защищено 
  DOCUMENT_POSITION_PRECEDING: 0x02

  защищено 
  DOCUMENT_POSITION_FOLLOWING: 0x04

  защищено 
  DOCUMENT_POSITION_CONTAINS: 0x08

  защищено 
  DOCUMENT_POSITION_CONTAINED_BY: 0x10

  защищено 
  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
}


внешнее
/*(!) var */ Node: объект { prototype: Node; при создании(): Node; защищено  ELEMENT_NODE: 1; защищено  ATTRIBUTE_NODE: 2; защищено  TEXT_NODE: 3; защищено  CDATA_SECTION_NODE: 4; защищено  ENTITY_REFERENCE_NODE: 5; защищено  ENTITY_NODE: 6; защищено  PROCESSING_INSTRUCTION_NODE: 7; защищено  COMMENT_NODE: 8; защищено  DOCUMENT_NODE: 9; защищено  DOCUMENT_TYPE_NODE: 10; защищено  DOCUMENT_FRAGMENT_NODE: 11; защищено  NOTATION_NODE: 12; защищено  DOCUMENT_POSITION_DISCONNECTED: 0x01; защищено  DOCUMENT_POSITION_PRECEDING: 0x02; защищено  DOCUMENT_POSITION_FOLLOWING: 0x04; защищено  DOCUMENT_POSITION_CONTAINS: 0x08; защищено  DOCUMENT_POSITION_CONTAINED_BY: 0x10; защищено  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20 }


/**
* An iterator over the members of a list of the nodes in a subtree of the DOM. The nodes will be returned in document order.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeIterator)
*/

тип NodeIterator = интерфейс
{

}


внешнее
/*(!) var */ NodeIterator: объект { prototype: NodeIterator; при создании(): NodeIterator }


/**
* NodeList objects are collections of nodes, usually returned by properties such as Node.childNodes and methods such as document.querySelectorAll().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/NodeList)
*/

тип NodeList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Node?

  операция forEach(callbackfn: операция(value: Node, key: Число, parent: NodeList), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: Node*/
}


внешнее
/*(!) var */ NodeList: объект { prototype: NodeList; при создании(): NodeList }


тип NodeListOf<TNode = Node> = интерфейс на основе NodeList
{
  операция item(index: Число): TNode

  операция forEach(callbackfn: операция(value: TNode, key: Число, parent: NodeListOf<TNode>), thisArg: /*(!) any */ Объект? = пусто)

  /*(!) [index: number]: TNode*/
}


тип NonDocumentTypeChildNode = интерфейс
{
  защищено 
  nextElementSibling: Element?

  защищено 
  previousElementSibling: Element?
}


тип NonElementParentNode = интерфейс
{
  операция getElementById(elementId: Текст): Element?
}


тип NotificationEventMap = интерфейс
{
  "click": Event

  "close": Event

  "error": Event

  "show": Event
}


/**
* This Notifications API interface is used to configure and display desktop notifications to the user.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Notification)
*/

тип Notification = интерфейс на основе EventTarget
{
  защищено 
  body: Текст

  защищено 
  data: /*(!) any */ Объект?

  защищено 
  dir: NotificationDirection

  защищено 
  icon: Текст

  защищено 
  lang: Текст

  onclick: (операция(this: Notification, ev: Event): /*(!) any */ Объект?)?

  onclose: (операция(this: Notification, ev: Event): /*(!) any */ Объект?)?

  onerror: (операция(this: Notification, ev: Event): /*(!) any */ Объект?)?

  onshow: (операция(this: Notification, ev: Event): /*(!) any */ Объект?)?

  защищено 
  silent: ДаНет?

  защищено 
  tag: Текст

  защищено 
  title: Текст

  операция close()

  операция addEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type`: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof NotificationEventMap */ Объект?>(type`: K, listener: операция(this: Notification, ev: /*(!) NotificationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Notification: объект { prototype: Notification; при создании(title: Текст, options: NotificationOptions? = пусто): Notification; защищено  permission: NotificationPermission; операция requestPermission(deprecatedCallback: NotificationPermissionCallback? = пусто): Promise<NotificationPermission> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_draw_buffers_indexed) */

тип OES_draw_buffers_indexed = интерфейс
{
  операция blendEquationSeparateiOES(buf: GLuint, modeRGB: GLenum, modeAlpha: GLenum)

  операция blendEquationiOES(buf: GLuint, mode: GLenum)

  операция blendFuncSeparateiOES(buf: GLuint, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция blendFunciOES(buf: GLuint, src: GLenum, dst: GLenum)

  операция colorMaskiOES(buf: GLuint, r: GLboolean, g: GLboolean, b: GLboolean, a: GLboolean)

  операция disableiOES(target: GLenum, index: GLuint)

  операция enableiOES(target: GLenum, index: GLuint)
}


/**
* The OES_element_index_uint extension is part of the WebGL API and adds support for gl.UNSIGNED_INT types to WebGLRenderingContext.drawElements().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_element_index_uint)
*/

тип OES_element_index_uint = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_fbo_render_mipmap) */

тип OES_fbo_render_mipmap = интерфейс
{

}


/**
* The OES_standard_derivatives extension is part of the WebGL API and adds the GLSL derivative functions dFdx, dFdy, and fwidth.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_standard_derivatives)
*/

тип OES_standard_derivatives = интерфейс
{
  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B
}


/**
* The OES_texture_float extension is part of the WebGL API and exposes floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float)
*/

тип OES_texture_float = интерфейс
{

}


/**
* The OES_texture_float_linear extension is part of the WebGL API and allows linear filtering with floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_float_linear)
*/

тип OES_texture_float_linear = интерфейс
{

}


/**
* The OES_texture_half_float extension is part of the WebGL API and adds texture formats with 16- (aka half float) and 32-bit floating-point components.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float)
*/

тип OES_texture_half_float = интерфейс
{
  защищено 
  HALF_FLOAT_OES: 0x8D61
}


/**
* The OES_texture_half_float_linear extension is part of the WebGL API and allows linear filtering with half floating-point pixel types for textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_texture_half_float_linear)
*/

тип OES_texture_half_float_linear = интерфейс
{

}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OES_vertex_array_object) */

тип OES_vertex_array_object = интерфейс
{
  операция bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?)

  операция createVertexArrayOES(): WebGLVertexArrayObjectOES?

  операция deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?)

  операция isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES?): GLboolean

  защищено 
  VERTEX_ARRAY_BINDING_OES: 0x85B5
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OVR_multiview2) */

тип OVR_multiview2 = интерфейс
{
  операция framebufferTextureMultiviewOVR(target: GLenum, attachment: GLenum, texture: WebGLTexture?, level: GLint, baseViewIndex: GLint, numViews: GLsizei)

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR: 0x9630

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: 0x9632

  защищено 
  MAX_VIEWS_OVR: 0x9631

  защищено 
  FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: 0x9633
}


/**
* The Web Audio API OfflineAudioCompletionEvent interface represents events that occur when the processing of an OfflineAudioContext is terminated. The complete event implements this interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OfflineAudioCompletionEvent)
*/

тип OfflineAudioCompletionEvent = интерфейс на основе Event
{
  защищено 
  renderedBuffer: AudioBuffer
}


внешнее
/*(!) var */ OfflineAudioCompletionEvent: объект { prototype: OfflineAudioCompletionEvent; при создании(type`: Текст, eventInitDict: OfflineAudioCompletionEventInit): OfflineAudioCompletionEvent }


тип OfflineAudioContextEventMap = интерфейс на основе BaseAudioContextEventMap
{
  "complete": OfflineAudioCompletionEvent
}


/**
* An AudioContext interface representing an audio-processing graph built from linked together AudioNodes. In contrast with a standard AudioContext, an OfflineAudioContext doesn't render the audio to the device hardware; instead, it generates it, as fast as it can, and outputs the result to an AudioBuffer.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OfflineAudioContext)
*/

тип OfflineAudioContext = интерфейс на основе BaseAudioContext
{
  защищено 
  length: Число

  oncomplete: (операция(this: OfflineAudioContext, ev: OfflineAudioCompletionEvent): /*(!) any */ Объект?)?

  операция resume(): Promise<Ничего>

  операция startRendering(): Promise<AudioBuffer>

  операция suspend(suspendTime: Число): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof OfflineAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: OfflineAudioContext, ev: /*(!) OfflineAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof OfflineAudioContextEventMap */ Объект?>(type`: K, listener: операция(this: OfflineAudioContext, ev: /*(!) OfflineAudioContextEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ OfflineAudioContext: объект { prototype: OfflineAudioContext; при создании(contextOptions: OfflineAudioContextOptions): OfflineAudioContext; при создании(numberOfChannels: Число, length: Число, sampleRate: Число): OfflineAudioContext }


тип OffscreenCanvasEventMap = интерфейс
{
  "contextlost": Event

  "contextrestored": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvas) */

тип OffscreenCanvas = интерфейс на основе EventTarget
{
  height: Число

  oncontextlost: (операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект?)?

  oncontextrestored: (операция(this: OffscreenCanvas, ev: Event): /*(!) any */ Объект?)?

  width: Число

  операция convertToBlob(options: ImageEncodeOptions? = пусто): Promise<Blob>

  операция getContext(contextId: "2d", options: /*(!) any */ Объект? = пусто): OffscreenCanvasRenderingContext2D?

  операция getContext(contextId: "bitmaprenderer", options: /*(!) any */ Объект? = пусто): ImageBitmapRenderingContext?

  операция getContext(contextId: "webgl", options: /*(!) any */ Объект? = пусто): WebGLRenderingContext?

  операция getContext(contextId: "webgl2", options: /*(!) any */ Объект? = пусто): WebGL2RenderingContext?

  операция getContext(contextId: OffscreenRenderingContextId, options: /*(!) any */ Объект? = пусто): OffscreenRenderingContext?

  операция transferToImageBitmap(): ImageBitmap

  операция addEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type`: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof OffscreenCanvasEventMap */ Объект?>(type`: K, listener: операция(this: OffscreenCanvas, ev: /*(!) OffscreenCanvasEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ OffscreenCanvas: объект { prototype: OffscreenCanvas; при создании(width: Число, height: Число): OffscreenCanvas }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OffscreenCanvasRenderingContext2D) */

тип OffscreenCanvasRenderingContext2D = интерфейс на основе CanvasCompositing, CanvasDrawImage, CanvasDrawPath, CanvasFillStrokeStyles, CanvasFilters, CanvasImageData, CanvasImageSmoothing, CanvasPath, CanvasPathDrawingStyles, CanvasRect, CanvasShadowStyles, CanvasState, CanvasText, CanvasTextDrawingStyles, CanvasTransform
{
  защищено 
  canvas: OffscreenCanvas

  операция commit()
}


внешнее
/*(!) var */ OffscreenCanvasRenderingContext2D: объект { prototype: OffscreenCanvasRenderingContext2D; при создании(): OffscreenCanvasRenderingContext2D }


/**
* The OscillatorNode interface represents a periodic waveform, such as a sine wave. It is an AudioScheduledSourceNode audio-processing module that causes a specified frequency of a given wave to be created—in effect, a constant tone.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/OscillatorNode)
*/

тип OscillatorNode = интерфейс на основе AudioScheduledSourceNode
{
  защищено 
  detune: AudioParam

  защищено 
  frequency: AudioParam

  type`: OscillatorType

  операция setPeriodicWave(periodicWave: PeriodicWave)

  операция addEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: OscillatorNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AudioScheduledSourceNodeEventMap */ Объект?>(type`: K, listener: операция(this: OscillatorNode, ev: /*(!) AudioScheduledSourceNodeEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ OscillatorNode: объект { prototype: OscillatorNode; при создании(context: BaseAudioContext, options: OscillatorOptions? = пусто): OscillatorNode }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/OverconstrainedError) */

тип OverconstrainedError = интерфейс на основе Error
{
  защищено 
  constraint: Текст
}


внешнее
/*(!) var */ OverconstrainedError: объект { prototype: OverconstrainedError; при создании(constraint: Текст, message: Текст? = пусто): OverconstrainedError }


/**
* The PageTransitionEvent is fired when a document is being loaded or unloaded.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PageTransitionEvent)
*/

тип PageTransitionEvent = интерфейс на основе Event
{
  защищено 
  persisted: ДаНет
}


внешнее
/*(!) var */ PageTransitionEvent: объект { prototype: PageTransitionEvent; при создании(type`: Текст, eventInitDict: PageTransitionEventInit? = пусто): PageTransitionEvent }


/**
* A PannerNode always has exactly one input and one output: the input can be mono or stereo but the output is always stereo (2 channels); you can't have panning effects without at least two audio channels!
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PannerNode)
*/

тип PannerNode = интерфейс на основе AudioNode
{

}


внешнее
/*(!) var */ PannerNode: объект { prototype: PannerNode; при создании(context: BaseAudioContext, options: PannerOptions? = пусто): PannerNode }


тип ParentNode = интерфейс на основе Node
{
  операция querySelector<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selectors: K): /*(!) SVGElementTagNameMap[K] */ Объект?

  операция querySelector<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selectors: K): /*(!) MathMLElementTagNameMap[K] */ Объект?

  операция querySelector<E = Element>(selectors: Текст): E?

  операция querySelectorAll<K = /*(!) keyof SVGElementTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) SVGElementTagNameMap[K] */ Объект?>

  операция querySelectorAll<K = /*(!) keyof MathMLElementTagNameMap */ Объект?>(selectors: K): NodeListOf</*(!) MathMLElementTagNameMap[K] */ Объект?>

  операция querySelectorAll<E = Element>(selectors: Текст): NodeListOf<E>
}


/**
* This Canvas 2D API interface is used to declare a path that can then be used on a CanvasRenderingContext2D object. The path methods of the CanvasRenderingContext2D interface are also present on this interface, which gives you the convenience of being able to retain and replay your path whenever desired.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Path2D)
*/

тип Path2D = интерфейс на основе CanvasPath
{
  операция addPath(path: Path2D, transform: DOMMatrix2DInit? = пусто)
}


внешнее
/*(!) var */ Path2D: объект { prototype: Path2D; при создании(path: Объект? /*(!)Path2D | Текст | пусто*/ = пусто): Path2D }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentMethodChangeEvent)
*/

тип PaymentMethodChangeEvent = интерфейс на основе PaymentRequestUpdateEvent
{
  защищено 
  methodDetails: /*(!) any */ Объект?

  защищено 
  methodName: Текст
}


внешнее
/*(!) var */ PaymentMethodChangeEvent: объект { prototype: PaymentMethodChangeEvent; при создании(type`: Текст, eventInitDict: PaymentMethodChangeEventInit? = пусто): PaymentMethodChangeEvent }


тип PaymentRequestEventMap = интерфейс
{
  "paymentmethodchange": Event
}


/**
* This Payment Request API interface is the primary access point into the API, and lets web content and apps accept payments from the end user.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentRequest)
*/

тип PaymentRequest = интерфейс на основе EventTarget
{
  защищено 
  id: Текст

  onpaymentmethodchange: (операция(this: PaymentRequest, ev: Event): /*(!) any */ Объект?)?

  операция abort(): Promise<Ничего>

  операция canMakePayment(): Promise<ДаНет>

  операция show(detailsPromise: Объект? /*(!)PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate> | пусто*/ = пусто): Promise<PaymentResponse>

  операция addEventListener<K = /*(!) keyof PaymentRequestEventMap */ Объект?>(type`: K, listener: операция(this: PaymentRequest, ev: /*(!) PaymentRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof PaymentRequestEventMap */ Объект?>(type`: K, listener: операция(this: PaymentRequest, ev: /*(!) PaymentRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ PaymentRequest: объект { prototype: PaymentRequest; при создании(methodData: Список<PaymentMethodData>, details: PaymentDetailsInit): PaymentRequest }


/**
* This Payment Request API interface enables a web page to update the details of a PaymentRequest in response to a user action.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentRequestUpdateEvent)
*/

тип PaymentRequestUpdateEvent = интерфейс на основе Event
{
  операция updateWith(detailsPromise: Объект? /*(!)PaymentDetailsUpdate | PromiseLike<PaymentDetailsUpdate>*/)
}


внешнее
/*(!) var */ PaymentRequestUpdateEvent: объект { prototype: PaymentRequestUpdateEvent; при создании(type`: Текст, eventInitDict: PaymentRequestUpdateEventInit? = пусто): PaymentRequestUpdateEvent }


/**
* This Payment Request API interface is returned after a user selects a payment method and approves a payment request.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PaymentResponse)
*/

тип PaymentResponse = интерфейс на основе EventTarget
{
  защищено 
  details: /*(!) any */ Объект?

  защищено 
  methodName: Текст

  защищено 
  requestId: Текст

  операция complete(result: PaymentComplete? = пусто): Promise<Ничего>

  операция retry(errorFields: PaymentValidationErrors? = пусто): Promise<Ничего>

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PaymentResponse: объект { prototype: PaymentResponse; при создании(): PaymentResponse }


тип PerformanceEventMap = интерфейс
{
  "resourcetimingbufferfull": Event
}


/**
* Provides access to performance-related information for the current page. It's part of the High Resolution Time API, but is enhanced by the Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Performance)
*/

тип Performance = интерфейс на основе EventTarget
{
  операция addEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type`: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof PerformanceEventMap */ Объект?>(type`: K, listener: операция(this: Performance, ev: /*(!) PerformanceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Performance: объект { prototype: Performance; при создании(): Performance }


/**
* Encapsulates a single performance metric that is part of the performance timeline. A performance entry can be directly created by making a performance mark or measure (for example by calling the mark() method) at an explicit point in an application. Performance entries are also created in indirect ways such as loading a resource (such as an image).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEntry)
*/

тип PerformanceEntry = интерфейс
{
  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  entryType: Текст

  защищено 
  name: Текст

  защищено 
  startTime: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceEntry: объект { prototype: PerformanceEntry; при создании(): PerformanceEntry }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceEventTiming) */

тип PerformanceEventTiming = интерфейс на основе PerformanceEntry
{
  защищено 
  cancelable: ДаНет

  защищено 
  processingEnd: DOMHighResTimeStamp

  защищено 
  processingStart: DOMHighResTimeStamp

  защищено 
  target: Node?

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceEventTiming: объект { prototype: PerformanceEventTiming; при создании(): PerformanceEventTiming }


/**
* PerformanceMark is an abstract interface for PerformanceEntry objects with an entryType of "mark". Entries of this type are created by calling performance.mark() to add a named DOMHighResTimeStamp (the mark) to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMark)
*/

тип PerformanceMark = интерфейс на основе PerformanceEntry
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMark: объект { prototype: PerformanceMark; при создании(markName: Текст, markOptions: PerformanceMarkOptions? = пусто): PerformanceMark }


/**
* PerformanceMeasure is an abstract interface for PerformanceEntry objects with an entryType of "measure". Entries of this type are created by calling performance.measure() to add a named DOMHighResTimeStamp (the measure) between two marks to the browser's performance timeline.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceMeasure)
*/

тип PerformanceMeasure = интерфейс на основе PerformanceEntry
{
  защищено 
  detail: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceMeasure: объект { prototype: PerformanceMeasure; при создании(): PerformanceMeasure }


/**
* Provides methods and properties to store and retrieve metrics regarding the browser's document navigation events. For example, this interface can be used to determine how much time it takes to load or unload a document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming)
*/

тип PerformanceNavigationTiming = интерфейс на основе PerformanceResourceTiming
{
  защищено 
  domComplete: DOMHighResTimeStamp

  защищено 
  domContentLoadedEventEnd: DOMHighResTimeStamp

  защищено 
  domContentLoadedEventStart: DOMHighResTimeStamp

  защищено 
  domInteractive: DOMHighResTimeStamp

  защищено 
  loadEventEnd: DOMHighResTimeStamp

  защищено 
  loadEventStart: DOMHighResTimeStamp

  защищено 
  redirectCount: Число

  защищено 
  type`: NavigationTimingType

  защищено 
  unloadEventEnd: DOMHighResTimeStamp

  защищено 
  unloadEventStart: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceNavigationTiming: объект { prototype: PerformanceNavigationTiming; при создании(): PerformanceNavigationTiming }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) */

тип PerformanceObserver = интерфейс
{
  операция disconnect()

  операция observe(options: PerformanceObserverInit? = пусто)

  операция takeRecords(): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserver: объект { prototype: PerformanceObserver; при создании(callback: PerformanceObserverCallback): PerformanceObserver; защищено  supportedEntryTypes: ReadonlyArray<Текст> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceObserverEntryList) */

тип PerformanceObserverEntryList = интерфейс
{
  операция getEntries(): PerformanceEntryList

  операция getEntriesByName(name: Текст, type`: Текст? = пусто): PerformanceEntryList

  операция getEntriesByType(type`: Текст): PerformanceEntryList
}


внешнее
/*(!) var */ PerformanceObserverEntryList: объект { prototype: PerformanceObserverEntryList; при создании(): PerformanceObserverEntryList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformancePaintTiming) */

тип PerformancePaintTiming = интерфейс на основе PerformanceEntry
{

}


внешнее
/*(!) var */ PerformancePaintTiming: объект { prototype: PerformancePaintTiming; при создании(): PerformancePaintTiming }


/**
* Enables retrieval and analysis of detailed network timing data regarding the loading of an application's resources. An application can use the timing metrics to determine, for example, the length of time it takes to fetch a specific resource, such as an XMLHttpRequest, <SVG>, image, or script.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming)
*/

тип PerformanceResourceTiming = интерфейс на основе PerformanceEntry
{
  защищено 
  connectEnd: DOMHighResTimeStamp

  защищено 
  connectStart: DOMHighResTimeStamp

  защищено 
  decodedBodySize: Число

  защищено 
  domainLookupEnd: DOMHighResTimeStamp

  защищено 
  domainLookupStart: DOMHighResTimeStamp

  защищено 
  encodedBodySize: Число

  защищено 
  fetchStart: DOMHighResTimeStamp

  защищено 
  initiatorType: Текст

  защищено 
  nextHopProtocol: Текст

  защищено 
  redirectEnd: DOMHighResTimeStamp

  защищено 
  redirectStart: DOMHighResTimeStamp

  защищено 
  requestStart: DOMHighResTimeStamp

  защищено 
  responseEnd: DOMHighResTimeStamp

  защищено 
  responseStart: DOMHighResTimeStamp

  защищено 
  secureConnectionStart: DOMHighResTimeStamp

  защищено 
  serverTiming: ReadonlyArray<PerformanceServerTiming>

  защищено 
  transferSize: Число

  защищено 
  workerStart: DOMHighResTimeStamp

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceResourceTiming: объект { prototype: PerformanceResourceTiming; при создании(): PerformanceResourceTiming }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PerformanceServerTiming) */

тип PerformanceServerTiming = интерфейс
{
  защищено 
  description: Текст

  защищено 
  duration: DOMHighResTimeStamp

  защищено 
  name: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ PerformanceServerTiming: объект { prototype: PerformanceServerTiming; при создании(): PerformanceServerTiming }


/**
* PeriodicWave has no inputs or outputs; it is used to define custom oscillators when calling OscillatorNode.setPeriodicWave(). The PeriodicWave itself is created/returned by AudioContext.createPeriodicWave().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PeriodicWave)
*/

тип PeriodicWave = интерфейс
{

}


внешнее
/*(!) var */ PeriodicWave: объект { prototype: PeriodicWave; при создании(context: BaseAudioContext, options: PeriodicWaveOptions? = пусто): PeriodicWave }


тип PermissionStatusEventMap = интерфейс
{
  "change": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PermissionStatus) */

тип PermissionStatus = интерфейс на основе EventTarget
{
  защищено 
  name: Текст

  onchange: (операция(this: PermissionStatus, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: PermissionState

  операция addEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type`: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof PermissionStatusEventMap */ Объект?>(type`: K, listener: операция(this: PermissionStatus, ev: /*(!) PermissionStatusEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ PermissionStatus: объект { prototype: PermissionStatus; при создании(): PermissionStatus }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Permissions) */

тип Permissions = интерфейс
{
  операция query(permissionDesc: PermissionDescriptor): Promise<PermissionStatus>
}


внешнее
/*(!) var */ Permissions: объект { prototype: Permissions; при создании(): Permissions }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PictureInPictureEvent) */

тип PictureInPictureEvent = интерфейс на основе Event
{
  защищено 
  pictureInPictureWindow: PictureInPictureWindow
}


внешнее
/*(!) var */ PictureInPictureEvent: объект { prototype: PictureInPictureEvent; при создании(type`: Текст, eventInitDict: PictureInPictureEventInit): PictureInPictureEvent }


тип PictureInPictureWindowEventMap = интерфейс
{
  "resize": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PictureInPictureWindow) */

тип PictureInPictureWindow = интерфейс на основе EventTarget
{
  защищено 
  height: Число

  onresize: (операция(this: PictureInPictureWindow, ev: Event): /*(!) any */ Объект?)?

  защищено 
  width: Число

  операция addEventListener<K = /*(!) keyof PictureInPictureWindowEventMap */ Объект?>(type`: K, listener: операция(this: PictureInPictureWindow, ev: /*(!) PictureInPictureWindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof PictureInPictureWindowEventMap */ Объект?>(type`: K, listener: операция(this: PictureInPictureWindow, ev: /*(!) PictureInPictureWindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ PictureInPictureWindow: объект { prototype: PictureInPictureWindow; при создании(): PictureInPictureWindow }


/**
* The state of a DOM event produced by a pointer such as the geometry of the contact point, the device type that generated the event, the amount of pressure that was applied on the contact surface, etc.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PointerEvent)
*/

тип PointerEvent = интерфейс на основе MouseEvent
{
  защищено 
  height: Число

  защищено 
  isPrimary: ДаНет

  защищено 
  pointerId: Число

  защищено 
  pointerType: Текст

  защищено 
  pressure: Число

  защищено 
  tangentialPressure: Число

  защищено 
  tiltX: Число

  защищено 
  tiltY: Число

  защищено 
  twist: Число

  защищено 
  width: Число

  операция getCoalescedEvents(): Список<PointerEvent>

  операция getPredictedEvents(): Список<PointerEvent>
}


внешнее
/*(!) var */ PointerEvent: объект { prototype: PointerEvent; при создании(type`: Текст, eventInitDict: PointerEventInit? = пусто): PointerEvent }


/**
* PopStateEvent is an event handler for the popstate event on the window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PopStateEvent)
*/

тип PopStateEvent = интерфейс на основе Event
{
  защищено 
  state: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PopStateEvent: объект { prototype: PopStateEvent; при создании(type`: Текст, eventInitDict: PopStateEventInit? = пусто): PopStateEvent }


тип PopoverInvokerElement = интерфейс
{
  popoverTargetAction: Текст

  popoverTargetElement: Element?
}


/**
* A processing instruction embeds application-specific instructions in XML which can be ignored by other applications that don't recognize them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProcessingInstruction)
*/

тип ProcessingInstruction = интерфейс на основе CharacterData, LinkStyle
{
  защищено 
  ownerDocument: Document

  защищено 
  target: Текст
}


внешнее
/*(!) var */ ProcessingInstruction: объект { prototype: ProcessingInstruction; при создании(): ProcessingInstruction }


/**
* Events measuring progress of an underlying process, like an HTTP request (for an XMLHttpRequest, or the loading of the underlying resource of an <img>, <audio>, <video>, <style> or <link>).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ProgressEvent)
*/

тип ProgressEvent<T = EventTarget> = интерфейс на основе Event
{
  защищено 
  lengthComputable: ДаНет

  защищено 
  loaded: Число

  защищено 
  target: T?

  защищено 
  total: Число
}


внешнее
/*(!) var */ ProgressEvent: объект { prototype: ProgressEvent; при создании(type`: Текст, eventInitDict: ProgressEventInit? = пусто): ProgressEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */

тип PromiseRejectionEvent = интерфейс на основе Event
{
  защищено 
  promise: Promise</*(!) any */ Объект?>

  защищено 
  reason: /*(!) any */ Объект?
}


внешнее
/*(!) var */ PromiseRejectionEvent: объект { prototype: PromiseRejectionEvent; при создании(type`: Текст, eventInitDict: PromiseRejectionEventInit): PromiseRejectionEvent }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PublicKeyCredential)
*/

тип PublicKeyCredential = интерфейс на основе Credential
{
  защищено 
  authenticatorAttachment: Текст?

  защищено 
  rawId: ArrayBuffer

  защищено 
  response: AuthenticatorResponse

  операция getClientExtensionResults(): AuthenticationExtensionsClientOutputs
}


внешнее
/*(!) var */ PublicKeyCredential: объект { prototype: PublicKeyCredential; при создании(): PublicKeyCredential; операция isConditionalMediationAvailable(): Promise<ДаНет>; операция isUserVerifyingPlatformAuthenticatorAvailable(): Promise<ДаНет> }


/**
* This Push API interface provides a way to receive notifications from third-party servers as well as request URLs for push notifications.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushManager)
*/

тип PushManager = интерфейс
{
  операция getSubscription(): Promise<PushSubscription?>

  операция permissionState(options: PushSubscriptionOptionsInit? = пусто): Promise<PermissionState>

  операция subscribe(options: PushSubscriptionOptionsInit? = пусто): Promise<PushSubscription>
}


внешнее
/*(!) var */ PushManager: объект { prototype: PushManager; при создании(): PushManager; защищено  supportedContentEncodings: ReadonlyArray<Текст> }


/**
* This Push API interface provides a subcription's URL endpoint and allows unsubscription from a push service.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscription)
*/

тип PushSubscription = интерфейс
{
  защищено 
  endpoint: Текст

  защищено 
  expirationTime: EpochTimeStamp?

  защищено 
  options: PushSubscriptionOptions

  операция getKey(name: PushEncryptionKeyName): ArrayBuffer?

  операция toJSON(): PushSubscriptionJSON

  операция unsubscribe(): Promise<ДаНет>
}


внешнее
/*(!) var */ PushSubscription: объект { prototype: PushSubscription; при создании(): PushSubscription }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PushSubscriptionOptions)
*/

тип PushSubscriptionOptions = интерфейс
{
  защищено 
  applicationServerKey: ArrayBuffer?

  защищено 
  userVisibleOnly: ДаНет
}


внешнее
/*(!) var */ PushSubscriptionOptions: объект { prototype: PushSubscriptionOptions; при создании(): PushSubscriptionOptions }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCCertificate) */

тип RTCCertificate = интерфейс
{
  защищено 
  expires: EpochTimeStamp

  операция getFingerprints(): Список<RTCDtlsFingerprint>
}


внешнее
/*(!) var */ RTCCertificate: объект { prototype: RTCCertificate; при создании(): RTCCertificate }


тип RTCDTMFSenderEventMap = интерфейс
{
  "tonechange": RTCDTMFToneChangeEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDTMFSender) */

тип RTCDTMFSender = интерфейс на основе EventTarget
{
  защищено 
  canInsertDTMF: ДаНет

  ontonechange: (операция(this: RTCDTMFSender, ev: RTCDTMFToneChangeEvent): /*(!) any */ Объект?)?

  защищено 
  toneBuffer: Текст

  операция insertDTMF(tones: Текст, duration: Число? = пусто, interToneGap: Число? = пусто)

  операция addEventListener<K = /*(!) keyof RTCDTMFSenderEventMap */ Объект?>(type`: K, listener: операция(this: RTCDTMFSender, ev: /*(!) RTCDTMFSenderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDTMFSenderEventMap */ Объект?>(type`: K, listener: операция(this: RTCDTMFSender, ev: /*(!) RTCDTMFSenderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCDTMFSender: объект { prototype: RTCDTMFSender; при создании(): RTCDTMFSender }


/**
* Events sent to indicate that DTMF tones have started or finished playing. This interface is used by the tonechange event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDTMFToneChangeEvent)
*/

тип RTCDTMFToneChangeEvent = интерфейс на основе Event
{
  защищено 
  tone: Текст
}


внешнее
/*(!) var */ RTCDTMFToneChangeEvent: объект { prototype: RTCDTMFToneChangeEvent; при создании(type`: Текст, eventInitDict: RTCDTMFToneChangeEventInit? = пусто): RTCDTMFToneChangeEvent }


тип RTCDataChannelEventMap = интерфейс
{
  "bufferedamountlow": Event

  "close": Event

  "closing": Event

  "error": Event

  "message": MessageEvent

  "open": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDataChannel) */

тип RTCDataChannel = интерфейс на основе EventTarget
{
  binaryType: BinaryType

  защищено 
  bufferedAmount: Число

  bufferedAmountLowThreshold: Число

  защищено 
  id: Число?

  защищено 
  label: Текст

  защищено 
  maxPacketLifeTime: Число?

  защищено 
  maxRetransmits: Число?

  защищено 
  negotiated: ДаНет

  onbufferedamountlow: (операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект?)?

  onclose: (операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект?)?

  onclosing: (операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект?)?

  onerror: (операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: RTCDataChannel, ev: MessageEvent): /*(!) any */ Объект?)?

  onopen: (операция(this: RTCDataChannel, ev: Event): /*(!) any */ Объект?)?

  защищено 
  ordered: ДаНет

  защищено 
  protocol: Текст

  защищено 
  readyState: RTCDataChannelState

  операция close()

  операция send(data: Текст)

  операция send(data: Blob)

  операция send(data: ArrayBuffer)

  операция send(data: ArrayBufferView)

  операция addEventListener<K = /*(!) keyof RTCDataChannelEventMap */ Объект?>(type`: K, listener: операция(this: RTCDataChannel, ev: /*(!) RTCDataChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDataChannelEventMap */ Объект?>(type`: K, listener: операция(this: RTCDataChannel, ev: /*(!) RTCDataChannelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCDataChannel: объект { prototype: RTCDataChannel; при создании(): RTCDataChannel }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDataChannelEvent) */

тип RTCDataChannelEvent = интерфейс на основе Event
{
  защищено 
  channel: RTCDataChannel
}


внешнее
/*(!) var */ RTCDataChannelEvent: объект { prototype: RTCDataChannelEvent; при создании(type`: Текст, eventInitDict: RTCDataChannelEventInit): RTCDataChannelEvent }


тип RTCDtlsTransportEventMap = интерфейс
{
  "error": Event

  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCDtlsTransport) */

тип RTCDtlsTransport = интерфейс на основе EventTarget
{
  защищено 
  iceTransport: RTCIceTransport

  onerror: (операция(this: RTCDtlsTransport, ev: Event): /*(!) any */ Объект?)?

  onstatechange: (операция(this: RTCDtlsTransport, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: RTCDtlsTransportState

  операция getRemoteCertificates(): Список<ArrayBuffer>

  операция addEventListener<K = /*(!) keyof RTCDtlsTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCDtlsTransport, ev: /*(!) RTCDtlsTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCDtlsTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCDtlsTransport, ev: /*(!) RTCDtlsTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCDtlsTransport: объект { prototype: RTCDtlsTransport; при создании(): RTCDtlsTransport }


тип RTCEncodedAudioFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  операция getMetadata(): RTCEncodedAudioFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedAudioFrame: объект { prototype: RTCEncodedAudioFrame; при создании(): RTCEncodedAudioFrame }


тип RTCEncodedVideoFrame = интерфейс
{
  data: ArrayBuffer

  защищено 
  timestamp: Число

  защищено 
  type`: RTCEncodedVideoFrameType

  операция getMetadata(): RTCEncodedVideoFrameMetadata
}


внешнее
/*(!) var */ RTCEncodedVideoFrame: объект { prototype: RTCEncodedVideoFrame; при создании(): RTCEncodedVideoFrame }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCError) */

тип RTCError = интерфейс на основе DOMException
{
  защищено 
  errorDetail: RTCErrorDetailType

  защищено 
  receivedAlert: Число?

  защищено 
  sctpCauseCode: Число?

  защищено 
  sdpLineNumber: Число?

  защищено 
  sentAlert: Число?
}


внешнее
/*(!) var */ RTCError: объект { prototype: RTCError; при создании(init: RTCErrorInit, message: Текст? = пусто): RTCError }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCErrorEvent) */

тип RTCErrorEvent = интерфейс на основе Event
{
  защищено 
  error`: RTCError
}


внешнее
/*(!) var */ RTCErrorEvent: объект { prototype: RTCErrorEvent; при создании(type`: Текст, eventInitDict: RTCErrorEventInit): RTCErrorEvent }


/**
* The RTCIceCandidate interface—part of the WebRTC API—represents a candidate Internet Connectivity Establishment (ICE) configuration which may be used to establish an RTCPeerConnection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCIceCandidate)
*/

тип RTCIceCandidate = интерфейс
{
  защищено 
  address: Текст?

  защищено 
  candidate: Текст

  защищено 
  component: RTCIceComponent?

  защищено 
  foundation: Текст?

  защищено 
  port: Число?

  защищено 
  priority: Число?

  защищено 
  protocol: RTCIceProtocol?

  защищено 
  relatedAddress: Текст?

  защищено 
  relatedPort: Число?

  защищено 
  sdpMLineIndex: Число?

  защищено 
  sdpMid: Текст?

  защищено 
  tcpType: RTCIceTcpCandidateType?

  защищено 
  type`: RTCIceCandidateType?

  защищено 
  usernameFragment: Текст?

  операция toJSON(): RTCIceCandidateInit
}


внешнее
/*(!) var */ RTCIceCandidate: объект { prototype: RTCIceCandidate; при создании(candidateInitDict: RTCIceCandidateInit? = пусто): RTCIceCandidate }


тип RTCIceTransportEventMap = интерфейс
{
  "gatheringstatechange": Event

  "selectedcandidatepairchange": Event

  "statechange": Event
}


/**
* Provides access to information about the ICE transport layer over which the data is being sent and received.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCIceTransport)
*/

тип RTCIceTransport = интерфейс на основе EventTarget
{
  защищено 
  gatheringState: RTCIceGathererState

  ongatheringstatechange: (операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект?)?

  onselectedcandidatepairchange: (операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект?)?

  onstatechange: (операция(this: RTCIceTransport, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: RTCIceTransportState

  операция getSelectedCandidatePair(): RTCIceCandidatePair?

  операция addEventListener<K = /*(!) keyof RTCIceTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCIceTransport, ev: /*(!) RTCIceTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCIceTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCIceTransport, ev: /*(!) RTCIceTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCIceTransport: объект { prototype: RTCIceTransport; при создании(): RTCIceTransport }


тип RTCPeerConnectionEventMap = интерфейс
{
  "connectionstatechange": Event

  "datachannel": RTCDataChannelEvent

  "icecandidate": RTCPeerConnectionIceEvent

  "icecandidateerror": Event

  "iceconnectionstatechange": Event

  "icegatheringstatechange": Event

  "negotiationneeded": Event

  "signalingstatechange": Event

  "track": RTCTrackEvent
}


/**
* A WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnection)
*/

тип RTCPeerConnection = интерфейс на основе EventTarget
{
  операция addEventListener<K = /*(!) keyof RTCPeerConnectionEventMap */ Объект?>(type`: K, listener: операция(this: RTCPeerConnection, ev: /*(!) RTCPeerConnectionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCPeerConnectionEventMap */ Объект?>(type`: K, listener: операция(this: RTCPeerConnection, ev: /*(!) RTCPeerConnectionEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCPeerConnection: объект { prototype: RTCPeerConnection; при создании(configuration: RTCConfiguration? = пусто): RTCPeerConnection; операция generateCertificate(keygenAlgorithm: AlgorithmIdentifier): Promise<RTCCertificate> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnectionIceErrorEvent) */

тип RTCPeerConnectionIceErrorEvent = интерфейс на основе Event
{
  защищено 
  address: Текст?

  защищено 
  errorCode: Число

  защищено 
  errorText: Текст

  защищено 
  port: Число?

  защищено 
  url: Текст
}


внешнее
/*(!) var */ RTCPeerConnectionIceErrorEvent: объект { prototype: RTCPeerConnectionIceErrorEvent; при создании(type`: Текст, eventInitDict: RTCPeerConnectionIceErrorEventInit): RTCPeerConnectionIceErrorEvent }


/**
* Events that occurs in relation to ICE candidates with the target, usually an RTCPeerConnection. Only one event is of this type: icecandidate.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCPeerConnectionIceEvent)
*/

тип RTCPeerConnectionIceEvent = интерфейс на основе Event
{
  защищено 
  candidate: RTCIceCandidate?
}


внешнее
/*(!) var */ RTCPeerConnectionIceEvent: объект { prototype: RTCPeerConnectionIceEvent; при создании(type`: Текст, eventInitDict: RTCPeerConnectionIceEventInit? = пусто): RTCPeerConnectionIceEvent }


/**
* This WebRTC API interface manages the reception and decoding of data for a MediaStreamTrack on an RTCPeerConnection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpReceiver)
*/

тип RTCRtpReceiver = интерфейс
{
  защищено 
  track: MediaStreamTrack

  защищено 
  transport: RTCDtlsTransport?

  операция getContributingSources(): Список<RTCRtpContributingSource>

  операция getParameters(): RTCRtpReceiveParameters

  операция getStats(): Promise<RTCStatsReport>

  операция getSynchronizationSources(): Список<RTCRtpSynchronizationSource>
}


внешнее
/*(!) var */ RTCRtpReceiver: объект { prototype: RTCRtpReceiver; при создании(): RTCRtpReceiver; операция getCapabilities(kind: Текст): RTCRtpCapabilities? }


/**
* Provides the ability to control and obtain details about how a particular MediaStreamTrack is encoded and sent to a remote peer.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpSender)
*/

тип RTCRtpSender = интерфейс
{
  защищено 
  dtmf: RTCDTMFSender?

  защищено 
  track: MediaStreamTrack?

  защищено 
  transport: RTCDtlsTransport?

  операция getParameters(): RTCRtpSendParameters

  операция getStats(): Promise<RTCStatsReport>

  операция replaceTrack(withTrack: MediaStreamTrack?): Promise<Ничего>

  операция setParameters(parameters: RTCRtpSendParameters): Promise<Ничего>

  #js.МассивПараметров
  операция setStreams(streams: Список<MediaStream>)
}


внешнее
/*(!) var */ RTCRtpSender: объект { prototype: RTCRtpSender; при создании(): RTCRtpSender; операция getCapabilities(kind: Текст): RTCRtpCapabilities? }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCRtpTransceiver) */

тип RTCRtpTransceiver = интерфейс
{
  защищено 
  currentDirection: RTCRtpTransceiverDirection?

  direction: RTCRtpTransceiverDirection

  защищено 
  mid: Текст?

  защищено 
  receiver: RTCRtpReceiver

  защищено 
  sender: RTCRtpSender

  операция setCodecPreferences(codecs: Список<RTCRtpCodecCapability>)

  операция stop()
}


внешнее
/*(!) var */ RTCRtpTransceiver: объект { prototype: RTCRtpTransceiver; при создании(): RTCRtpTransceiver }


тип RTCSctpTransportEventMap = интерфейс
{
  "statechange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCSctpTransport) */

тип RTCSctpTransport = интерфейс на основе EventTarget
{
  защищено 
  maxChannels: Число?

  защищено 
  maxMessageSize: Число

  onstatechange: (операция(this: RTCSctpTransport, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: RTCSctpTransportState

  защищено 
  transport: RTCDtlsTransport

  операция addEventListener<K = /*(!) keyof RTCSctpTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCSctpTransport, ev: /*(!) RTCSctpTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RTCSctpTransportEventMap */ Объект?>(type`: K, listener: операция(this: RTCSctpTransport, ev: /*(!) RTCSctpTransportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RTCSctpTransport: объект { prototype: RTCSctpTransport; при создании(): RTCSctpTransport }


/**
* One end of a connection—or potential connection—and how it's configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCSessionDescription)
*/

тип RTCSessionDescription = интерфейс
{
  защищено 
  sdp: Текст

  защищено 
  type`: RTCSdpType

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ RTCSessionDescription: объект { prototype: RTCSessionDescription; при создании(descriptionInitDict: RTCSessionDescriptionInit): RTCSessionDescription }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCStatsReport) */

тип RTCStatsReport = интерфейс
{
  операция forEach(callbackfn: операция(value: /*(!) any */ Объект?, key: Текст, parent: RTCStatsReport), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ RTCStatsReport: объект { prototype: RTCStatsReport; при создании(): RTCStatsReport }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RTCTrackEvent) */

тип RTCTrackEvent = интерфейс на основе Event
{
  защищено 
  receiver: RTCRtpReceiver

  защищено 
  streams: ReadonlyArray<MediaStream>

  защищено 
  track: MediaStreamTrack

  защищено 
  transceiver: RTCRtpTransceiver
}


внешнее
/*(!) var */ RTCTrackEvent: объект { prototype: RTCTrackEvent; при создании(type`: Текст, eventInitDict: RTCTrackEventInit): RTCTrackEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RadioNodeList) */

тип RadioNodeList = интерфейс на основе NodeList
{
  value: Текст
}


внешнее
/*(!) var */ RadioNodeList: объект { prototype: RadioNodeList; при создании(): RadioNodeList }


/**
* A fragment of a document that can contain nodes and parts of text nodes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Range)
*/

тип Range = интерфейс на основе AbstractRange
{
  защищено 
  commonAncestorContainer: Node

  операция cloneContents(): DocumentFragment

  операция cloneRange(): Range

  операция collapse(toStart: ДаНет? = пусто)

  операция compareBoundaryPoints(how: Число, sourceRange: Range): Число

  операция comparePoint(node: Node, offset: Число): Число

  операция createContextualFragment(fragment: Текст): DocumentFragment

  операция deleteContents()

  операция detach()

  операция extractContents(): DocumentFragment

  операция getBoundingClientRect(): DOMRect

  операция getClientRects(): DOMRectList

  операция insertNode(node: Node)

  операция intersectsNode(node: Node): ДаНет

  операция isPointInRange(node: Node, offset: Число): ДаНет

  операция selectNode(node: Node)

  операция selectNodeContents(node: Node)

  операция setEnd(node: Node, offset: Число)

  операция setEndAfter(node: Node)

  операция setEndBefore(node: Node)

  операция setStart(node: Node, offset: Число)

  операция setStartAfter(node: Node)

  операция setStartBefore(node: Node)

  операция surroundContents(newParent: Node)

  операция toString(): Текст

  защищено 
  START_TO_START: 0

  защищено 
  START_TO_END: 1

  защищено 
  END_TO_END: 2

  защищено 
  END_TO_START: 3
}


внешнее
/*(!) var */ Range: объект { prototype: Range; при создании(): Range; защищено  START_TO_START: 0; защищено  START_TO_END: 1; защищено  END_TO_END: 2; защищено  END_TO_START: 3 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */

тип ReadableByteStreamController = интерфейс
{
  защищено 
  byobRequest: ReadableStreamBYOBRequest?

  защищено 
  desiredSize: Число?

  операция close()

  операция enqueue(chunk: ArrayBufferView)

  операция error`(e: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ ReadableByteStreamController: объект { prototype: ReadableByteStreamController; при создании(): ReadableByteStreamController }


/**
* This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)
*/

тип ReadableStream<R> = интерфейс
{
  защищено 
  locked: ДаНет

  операция cancel(reason: /*(!) any */ Объект? = пусто): Promise<Ничего>

  операция getReader(options: объект { mode: "byob" }): ReadableStreamBYOBReader

  операция getReader(): ReadableStreamDefaultReader<R>

  операция getReader(options: ReadableStreamGetReaderOptions? = пусто): ReadableStreamReader<R>

  операция pipeThrough<T>(transform: ReadableWritablePair<T, R>, options: StreamPipeOptions? = пусто): ReadableStream<T>

  операция pipeTo(destination: WritableStream<R>, options: StreamPipeOptions? = пусто): Promise<Ничего>

  операция tee(): объект { _0: ReadableStream<R>, _1: ReadableStream<R> }
}


внешнее
/*(!) var */ ReadableStream: объект { prototype: ReadableStream; при создании(underlyingSource: UnderlyingByteSource, strategy: объект { highWaterMark: Число }? = пусто): ReadableStream<Uint8Array>; при создании(underlyingSource: UnderlyingDefaultSource<R>, strategy: QueuingStrategy<R>? = пусто): ReadableStream<R>; при создании(underlyingSource: UnderlyingSource<R>? = пусто, strategy: QueuingStrategy<R>? = пусто): ReadableStream<R> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */

тип ReadableStreamBYOBReader = интерфейс на основе ReadableStreamGenericReader
{
  операция read<T = ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamBYOBReader: объект { prototype: ReadableStreamBYOBReader; при создании(stream: ReadableStream): ReadableStreamBYOBReader }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */

тип ReadableStreamBYOBRequest = интерфейс
{
  защищено 
  view: ArrayBufferView?

  операция respond(bytesWritten: Число)

  операция respondWithNewView(view: ArrayBufferView)
}


внешнее
/*(!) var */ ReadableStreamBYOBRequest: объект { prototype: ReadableStreamBYOBRequest; при создании(): ReadableStreamBYOBRequest }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */

тип ReadableStreamDefaultController<R> = интерфейс
{
  защищено 
  desiredSize: Число?

  операция close()

  операция enqueue(chunk: R? = пусто)

  операция error`(e: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ ReadableStreamDefaultController: объект { prototype: ReadableStreamDefaultController; при создании(): ReadableStreamDefaultController }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */

тип ReadableStreamDefaultReader<R> = интерфейс на основе ReadableStreamGenericReader
{
  операция read(): Promise<ReadableStreamReadResult<R>>

  операция releaseLock()
}


внешнее
/*(!) var */ ReadableStreamDefaultReader: объект { prototype: ReadableStreamDefaultReader; при создании(stream: ReadableStream<R>): ReadableStreamDefaultReader<R> }


тип ReadableStreamGenericReader = интерфейс
{
  защищено 
  closed: Promise<пусто>

  операция cancel(reason: /*(!) any */ Объект? = пусто): Promise<Ничего>
}


тип RemotePlaybackEventMap = интерфейс
{
  "connect": Event

  "connecting": Event

  "disconnect": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/RemotePlayback) */

тип RemotePlayback = интерфейс на основе EventTarget
{
  onconnect: (операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект?)?

  onconnecting: (операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект?)?

  ondisconnect: (операция(this: RemotePlayback, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: RemotePlaybackState

  операция cancelWatchAvailability(id: Число? = пусто): Promise<Ничего>

  операция prompt(): Promise<Ничего>

  операция watchAvailability(callback: RemotePlaybackAvailabilityCallback): Promise<Число>

  операция addEventListener<K = /*(!) keyof RemotePlaybackEventMap */ Объект?>(type`: K, listener: операция(this: RemotePlayback, ev: /*(!) RemotePlaybackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof RemotePlaybackEventMap */ Объект?>(type`: K, listener: операция(this: RemotePlayback, ev: /*(!) RemotePlaybackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ RemotePlayback: объект { prototype: RemotePlayback; при создании(): RemotePlayback }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Report) */

тип Report = интерфейс
{
  защищено 
  body: ReportBody?

  защищено 
  type`: Текст

  защищено 
  url: Текст

  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ Report: объект { prototype: Report; при создании(): Report }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportBody) */

тип ReportBody = интерфейс
{
  операция toJSON(): /*(!) any */ Объект?
}


внешнее
/*(!) var */ ReportBody: объект { prototype: ReportBody; при создании(): ReportBody }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReportingObserver) */

тип ReportingObserver = интерфейс
{
  операция disconnect()

  операция observe()

  операция takeRecords(): ReportList
}


внешнее
/*(!) var */ ReportingObserver: объект { prototype: ReportingObserver; при создании(callback: ReportingObserverCallback, options: ReportingObserverOptions? = пусто): ReportingObserver }


/**
* This Fetch API interface represents a resource request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)
*/

тип Request = интерфейс на основе Body
{
  защищено 
  cache: RequestCache

  защищено 
  credentials: RequestCredentials

  защищено 
  destination: RequestDestination

  защищено 
  headers: Headers

  защищено 
  integrity: Текст

  защищено 
  keepalive: ДаНет

  защищено 
  method: Текст

  защищено 
  mode: RequestMode

  защищено 
  redirect: RequestRedirect

  защищено 
  referrer: Текст

  защищено 
  referrerPolicy: ReferrerPolicy

  защищено 
  signal: AbortSignal

  защищено 
  url: Текст

  операция clone(): Request
}


внешнее
/*(!) var */ Request: объект { prototype: Request; при создании(input: Объект? /*(!)RequestInfo | URL*/, init: RequestInit? = пусто): Request }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserver) */

тип ResizeObserver = интерфейс
{
  операция disconnect()

  операция observe(target: Element, options: ResizeObserverOptions? = пусто)

  операция unobserve(target: Element)
}


внешнее
/*(!) var */ ResizeObserver: объект { prototype: ResizeObserver; при создании(callback: ResizeObserverCallback): ResizeObserver }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserverEntry) */

тип ResizeObserverEntry = интерфейс
{
  защищено 
  borderBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  contentBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  contentRect: DOMRectReadOnly

  защищено 
  devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>

  защищено 
  target: Element
}


внешнее
/*(!) var */ ResizeObserverEntry: объект { prototype: ResizeObserverEntry; при создании(): ResizeObserverEntry }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ResizeObserverSize) */

тип ResizeObserverSize = интерфейс
{
  защищено 
  blockSize: Число

  защищено 
  inlineSize: Число
}


внешнее
/*(!) var */ ResizeObserverSize: объект { prototype: ResizeObserverSize; при создании(): ResizeObserverSize }


/**
* This Fetch API interface represents the response to a request.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)
*/

тип Response = интерфейс на основе Body
{
  защищено 
  headers: Headers

  защищено 
  ok: ДаНет

  защищено 
  redirected: ДаНет

  защищено 
  status: Число

  защищено 
  statusText: Текст

  защищено 
  type`: ResponseType

  защищено 
  url: Текст

  операция clone(): Response
}


внешнее
/*(!) var */ Response: объект { prototype: Response; при создании(body: BodyInit? = пусто, init: ResponseInit? = пусто): Response; операция error`(): Response; операция json(data: /*(!) any */ Объект?, init: ResponseInit? = пусто): Response; операция redirect(url: Объект? /*(!)Текст | URL*/, status: Число? = пусто): Response }


/**
* Provides access to the properties of <a> element, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAElement)
*/

тип SVGAElement = интерфейс на основе SVGGraphicsElement, SVGURIReference
{
  rel: Текст

  защищено 
  relList: DOMTokenList

  защищено 
  target: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGAElement: объект { prototype: SVGAElement; при создании(): SVGAElement }


/**
* Used to represent a value that can be an <angle> or <number> value. An SVGAngle reflected through the animVal attribute is always read only.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAngle)
*/

тип SVGAngle = интерфейс
{
  защищено 
  unitType: Число

  value: Число

  valueAsString: Текст

  valueInSpecifiedUnits: Число

  операция convertToSpecifiedUnits(unitType: Число)

  операция newValueSpecifiedUnits(unitType: Число, valueInSpecifiedUnits: Число)

  защищено 
  SVG_ANGLETYPE_UNKNOWN: 0

  защищено 
  SVG_ANGLETYPE_UNSPECIFIED: 1

  защищено 
  SVG_ANGLETYPE_DEG: 2

  защищено 
  SVG_ANGLETYPE_RAD: 3

  защищено 
  SVG_ANGLETYPE_GRAD: 4
}


внешнее
/*(!) var */ SVGAngle: объект { prototype: SVGAngle; при создании(): SVGAngle; защищено  SVG_ANGLETYPE_UNKNOWN: 0; защищено  SVG_ANGLETYPE_UNSPECIFIED: 1; защищено  SVG_ANGLETYPE_DEG: 2; защищено  SVG_ANGLETYPE_RAD: 3; защищено  SVG_ANGLETYPE_GRAD: 4 }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateElement) */

тип SVGAnimateElement = интерфейс на основе SVGAnimationElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGAnimateElement: объект { prototype: SVGAnimateElement; при создании(): SVGAnimateElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateMotionElement) */

тип SVGAnimateMotionElement = интерфейс на основе SVGAnimationElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateMotionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateMotionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGAnimateMotionElement: объект { prototype: SVGAnimateMotionElement; при создании(): SVGAnimateMotionElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimateTransformElement) */

тип SVGAnimateTransformElement = интерфейс на основе SVGAnimationElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateTransformElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimateTransformElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGAnimateTransformElement: объект { prototype: SVGAnimateTransformElement; при создании(): SVGAnimateTransformElement }


/**
* Used for attributes of basic type <angle> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedAngle)
*/

тип SVGAnimatedAngle = интерфейс
{
  защищено 
  animVal: SVGAngle

  защищено 
  baseVal: SVGAngle
}


внешнее
/*(!) var */ SVGAnimatedAngle: объект { prototype: SVGAnimatedAngle; при создании(): SVGAnimatedAngle }


/**
* Used for attributes of type boolean which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedBoolean)
*/

тип SVGAnimatedBoolean = интерфейс
{
  защищено 
  animVal: ДаНет

  baseVal: ДаНет
}


внешнее
/*(!) var */ SVGAnimatedBoolean: объект { prototype: SVGAnimatedBoolean; при создании(): SVGAnimatedBoolean }


/**
* Used for attributes whose value must be a constant from a particular enumeration and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedEnumeration)
*/

тип SVGAnimatedEnumeration = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedEnumeration: объект { prototype: SVGAnimatedEnumeration; при создании(): SVGAnimatedEnumeration }


/**
* Used for attributes of basic type <integer> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedInteger)
*/

тип SVGAnimatedInteger = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedInteger: объект { prototype: SVGAnimatedInteger; при создании(): SVGAnimatedInteger }


/**
* Used for attributes of basic type <length> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedLength)
*/

тип SVGAnimatedLength = интерфейс
{
  защищено 
  animVal: SVGLength

  защищено 
  baseVal: SVGLength
}


внешнее
/*(!) var */ SVGAnimatedLength: объект { prototype: SVGAnimatedLength; при создании(): SVGAnimatedLength }


/**
* Used for attributes of type SVGLengthList which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedLengthList)
*/

тип SVGAnimatedLengthList = интерфейс
{
  защищено 
  animVal: SVGLengthList

  защищено 
  baseVal: SVGLengthList
}


внешнее
/*(!) var */ SVGAnimatedLengthList: объект { prototype: SVGAnimatedLengthList; при создании(): SVGAnimatedLengthList }


/**
* Used for attributes of basic type <Number> which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedNumber)
*/

тип SVGAnimatedNumber = интерфейс
{
  защищено 
  animVal: Число

  baseVal: Число
}


внешнее
/*(!) var */ SVGAnimatedNumber: объект { prototype: SVGAnimatedNumber; при создании(): SVGAnimatedNumber }


/**
* The SVGAnimatedNumber interface is used for attributes which take a list of numbers and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedNumberList)
*/

тип SVGAnimatedNumberList = интерфейс
{
  защищено 
  animVal: SVGNumberList

  защищено 
  baseVal: SVGNumberList
}


внешнее
/*(!) var */ SVGAnimatedNumberList: объект { prototype: SVGAnimatedNumberList; при создании(): SVGAnimatedNumberList }


тип SVGAnimatedPoints = интерфейс
{
  защищено 
  animatedPoints: SVGPointList

  защищено 
  points: SVGPointList
}


/**
* Used for attributes of type SVGPreserveAspectRatio which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedPreserveAspectRatio)
*/

тип SVGAnimatedPreserveAspectRatio = интерфейс
{
  защищено 
  animVal: SVGPreserveAspectRatio

  защищено 
  baseVal: SVGPreserveAspectRatio
}


внешнее
/*(!) var */ SVGAnimatedPreserveAspectRatio: объект { prototype: SVGAnimatedPreserveAspectRatio; при создании(): SVGAnimatedPreserveAspectRatio }


/**
* Used for attributes of basic SVGRect which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedRect)
*/

тип SVGAnimatedRect = интерфейс
{
  защищено 
  animVal: DOMRectReadOnly

  защищено 
  baseVal: DOMRect
}


внешнее
/*(!) var */ SVGAnimatedRect: объект { prototype: SVGAnimatedRect; при создании(): SVGAnimatedRect }


/**
* The SVGAnimatedString interface represents string attributes which can be animated from each SVG declaration. You need to create SVG attribute before doing anything else, everything should be declared inside this.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedString)
*/

тип SVGAnimatedString = интерфейс
{
  защищено 
  animVal: Текст

  baseVal: Текст
}


внешнее
/*(!) var */ SVGAnimatedString: объект { prototype: SVGAnimatedString; при создании(): SVGAnimatedString }


/**
* Used for attributes which take a list of numbers and which can be animated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimatedTransformList)
*/

тип SVGAnimatedTransformList = интерфейс
{
  защищено 
  animVal: SVGTransformList

  защищено 
  baseVal: SVGTransformList
}


внешнее
/*(!) var */ SVGAnimatedTransformList: объект { prototype: SVGAnimatedTransformList; при создании(): SVGAnimatedTransformList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGAnimationElement) */

тип SVGAnimationElement = интерфейс на основе SVGElement, SVGTests
{
  защищено 
  targetElement: SVGElement?

  операция beginElement()

  операция beginElementAt(offset: Число)

  операция endElement()

  операция endElementAt(offset: Число)

  операция getCurrentTime(): Число

  операция getSimpleDuration(): Число

  операция getStartTime(): Число

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimationElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGAnimationElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGAnimationElement: объект { prototype: SVGAnimationElement; при создании(): SVGAnimationElement }


/**
* An interface for the <circle> element. The circle element is defined by the cx and cy attributes that denote the coordinates of the centre of the circle.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGCircleElement)
*/

тип SVGCircleElement = интерфейс на основе SVGGeometryElement
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  r: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGCircleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGCircleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGCircleElement: объект { prototype: SVGCircleElement; при создании(): SVGCircleElement }


/**
* Provides access to the properties of <clipPath> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGClipPathElement)
*/

тип SVGClipPathElement = интерфейс на основе SVGElement
{
  защищено 
  clipPathUnits: SVGAnimatedEnumeration

  защищено 
  transform: SVGAnimatedTransformList

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGClipPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGClipPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGClipPathElement: объект { prototype: SVGClipPathElement; при создании(): SVGClipPathElement }


/**
* A base interface used by the component transfer function interfaces.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGComponentTransferFunctionElement)
*/

тип SVGComponentTransferFunctionElement = интерфейс на основе SVGElement
{
  защищено 
  amplitude: SVGAnimatedNumber

  защищено 
  exponent: SVGAnimatedNumber

  защищено 
  intercept: SVGAnimatedNumber

  защищено 
  offset: SVGAnimatedNumber

  защищено 
  slope: SVGAnimatedNumber

  защищено 
  tableValues: SVGAnimatedNumberList

  защищено 
  type`: SVGAnimatedEnumeration

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4

  защищено 
  SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGComponentTransferFunctionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGComponentTransferFunctionElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGComponentTransferFunctionElement: объект { prototype: SVGComponentTransferFunctionElement; при создании(): SVGComponentTransferFunctionElement; защищено  SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 0; защищено  SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 1; защищено  SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 2; защищено  SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 3; защищено  SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 4; защищено  SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 5 }


/**
* Corresponds to the <defs> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGDefsElement)
*/

тип SVGDefsElement = интерфейс на основе SVGGraphicsElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGDefsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGDefsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGDefsElement: объект { prototype: SVGDefsElement; при создании(): SVGDefsElement }


/**
* Corresponds to the <desc> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGDescElement)
*/

тип SVGDescElement = интерфейс на основе SVGElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGDescElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGDescElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGDescElement: объект { prototype: SVGDescElement; при создании(): SVGDescElement }


тип SVGElementEventMap = интерфейс на основе ElementEventMap, GlobalEventHandlersEventMap
{

}


/**
* All of the SVG DOM interfaces that correspond directly to elements in the SVG language derive from the SVGElement interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGElement)
*/

тип SVGElement = интерфейс на основе Element, ElementCSSInlineStyle, GlobalEventHandlers, HTMLOrSVGElement
{
  защищено 
  ownerSVGElement: SVGSVGElement?

  защищено 
  viewportElement: SVGElement?

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGElement: объект { prototype: SVGElement; при создании(): SVGElement }


/**
* Provides access to the properties of <ellipse> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGEllipseElement)
*/

тип SVGEllipseElement = интерфейс на основе SVGGeometryElement
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  rx: SVGAnimatedLength

  защищено 
  ry: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGEllipseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGEllipseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGEllipseElement: объект { prototype: SVGEllipseElement; при создании(): SVGEllipseElement }


/**
* Corresponds to the <feBlend> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEBlendElement)
*/

тип SVGFEBlendElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  mode: SVGAnimatedEnumeration

  защищено 
  SVG_FEBLEND_MODE_UNKNOWN: 0

  защищено 
  SVG_FEBLEND_MODE_NORMAL: 1

  защищено 
  SVG_FEBLEND_MODE_MULTIPLY: 2

  защищено 
  SVG_FEBLEND_MODE_SCREEN: 3

  защищено 
  SVG_FEBLEND_MODE_DARKEN: 4

  защищено 
  SVG_FEBLEND_MODE_LIGHTEN: 5

  защищено 
  SVG_FEBLEND_MODE_OVERLAY: 6

  защищено 
  SVG_FEBLEND_MODE_COLOR_DODGE: 7

  защищено 
  SVG_FEBLEND_MODE_COLOR_BURN: 8

  защищено 
  SVG_FEBLEND_MODE_HARD_LIGHT: 9

  защищено 
  SVG_FEBLEND_MODE_SOFT_LIGHT: 10

  защищено 
  SVG_FEBLEND_MODE_DIFFERENCE: 11

  защищено 
  SVG_FEBLEND_MODE_EXCLUSION: 12

  защищено 
  SVG_FEBLEND_MODE_HUE: 13

  защищено 
  SVG_FEBLEND_MODE_SATURATION: 14

  защищено 
  SVG_FEBLEND_MODE_COLOR: 15

  защищено 
  SVG_FEBLEND_MODE_LUMINOSITY: 16

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEBlendElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEBlendElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEBlendElement: объект { prototype: SVGFEBlendElement; при создании(): SVGFEBlendElement; защищено  SVG_FEBLEND_MODE_UNKNOWN: 0; защищено  SVG_FEBLEND_MODE_NORMAL: 1; защищено  SVG_FEBLEND_MODE_MULTIPLY: 2; защищено  SVG_FEBLEND_MODE_SCREEN: 3; защищено  SVG_FEBLEND_MODE_DARKEN: 4; защищено  SVG_FEBLEND_MODE_LIGHTEN: 5; защищено  SVG_FEBLEND_MODE_OVERLAY: 6; защищено  SVG_FEBLEND_MODE_COLOR_DODGE: 7; защищено  SVG_FEBLEND_MODE_COLOR_BURN: 8; защищено  SVG_FEBLEND_MODE_HARD_LIGHT: 9; защищено  SVG_FEBLEND_MODE_SOFT_LIGHT: 10; защищено  SVG_FEBLEND_MODE_DIFFERENCE: 11; защищено  SVG_FEBLEND_MODE_EXCLUSION: 12; защищено  SVG_FEBLEND_MODE_HUE: 13; защищено  SVG_FEBLEND_MODE_SATURATION: 14; защищено  SVG_FEBLEND_MODE_COLOR: 15; защищено  SVG_FEBLEND_MODE_LUMINOSITY: 16 }


/**
* Corresponds to the <feColorMatrix> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEColorMatrixElement)
*/

тип SVGFEColorMatrixElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  type`: SVGAnimatedEnumeration

  защищено 
  values: SVGAnimatedNumberList

  защищено 
  SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0

  защищено 
  SVG_FECOLORMATRIX_TYPE_MATRIX: 1

  защищено 
  SVG_FECOLORMATRIX_TYPE_SATURATE: 2

  защищено 
  SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3

  защищено 
  SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEColorMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEColorMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEColorMatrixElement: объект { prototype: SVGFEColorMatrixElement; при создании(): SVGFEColorMatrixElement; защищено  SVG_FECOLORMATRIX_TYPE_UNKNOWN: 0; защищено  SVG_FECOLORMATRIX_TYPE_MATRIX: 1; защищено  SVG_FECOLORMATRIX_TYPE_SATURATE: 2; защищено  SVG_FECOLORMATRIX_TYPE_HUEROTATE: 3; защищено  SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 4 }


/**
* Corresponds to the <feComponentTransfer> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEComponentTransferElement)
*/

тип SVGFEComponentTransferElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEComponentTransferElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEComponentTransferElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEComponentTransferElement: объект { prototype: SVGFEComponentTransferElement; при создании(): SVGFEComponentTransferElement }


/**
* Corresponds to the <feComposite> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFECompositeElement)
*/

тип SVGFECompositeElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  k1: SVGAnimatedNumber

  защищено 
  k2: SVGAnimatedNumber

  защищено 
  k3: SVGAnimatedNumber

  защищено 
  k4: SVGAnimatedNumber

  защищено 
  operator: SVGAnimatedEnumeration

  защищено 
  SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0

  защищено 
  SVG_FECOMPOSITE_OPERATOR_OVER: 1

  защищено 
  SVG_FECOMPOSITE_OPERATOR_IN: 2

  защищено 
  SVG_FECOMPOSITE_OPERATOR_OUT: 3

  защищено 
  SVG_FECOMPOSITE_OPERATOR_ATOP: 4

  защищено 
  SVG_FECOMPOSITE_OPERATOR_XOR: 5

  защищено 
  SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFECompositeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFECompositeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFECompositeElement: объект { prototype: SVGFECompositeElement; при создании(): SVGFECompositeElement; защищено  SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 0; защищено  SVG_FECOMPOSITE_OPERATOR_OVER: 1; защищено  SVG_FECOMPOSITE_OPERATOR_IN: 2; защищено  SVG_FECOMPOSITE_OPERATOR_OUT: 3; защищено  SVG_FECOMPOSITE_OPERATOR_ATOP: 4; защищено  SVG_FECOMPOSITE_OPERATOR_XOR: 5; защищено  SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 6 }


/**
* Corresponds to the <feConvolveMatrix> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEConvolveMatrixElement)
*/

тип SVGFEConvolveMatrixElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  bias: SVGAnimatedNumber

  защищено 
  divisor: SVGAnimatedNumber

  защищено 
  edgeMode: SVGAnimatedEnumeration

  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelMatrix: SVGAnimatedNumberList

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  orderX: SVGAnimatedInteger

  защищено 
  orderY: SVGAnimatedInteger

  защищено 
  preserveAlpha: SVGAnimatedBoolean

  защищено 
  targetX: SVGAnimatedInteger

  защищено 
  targetY: SVGAnimatedInteger

  защищено 
  SVG_EDGEMODE_UNKNOWN: 0

  защищено 
  SVG_EDGEMODE_DUPLICATE: 1

  защищено 
  SVG_EDGEMODE_WRAP: 2

  защищено 
  SVG_EDGEMODE_NONE: 3

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEConvolveMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEConvolveMatrixElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEConvolveMatrixElement: объект { prototype: SVGFEConvolveMatrixElement; при создании(): SVGFEConvolveMatrixElement; защищено  SVG_EDGEMODE_UNKNOWN: 0; защищено  SVG_EDGEMODE_DUPLICATE: 1; защищено  SVG_EDGEMODE_WRAP: 2; защищено  SVG_EDGEMODE_NONE: 3 }


/**
* Corresponds to the <feDiffuseLighting> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDiffuseLightingElement)
*/

тип SVGFEDiffuseLightingElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  diffuseConstant: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  surfaceScale: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDiffuseLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDiffuseLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEDiffuseLightingElement: объект { prototype: SVGFEDiffuseLightingElement; при создании(): SVGFEDiffuseLightingElement }


/**
* Corresponds to the <feDisplacementMap> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDisplacementMapElement)
*/

тип SVGFEDisplacementMapElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  in2: SVGAnimatedString

  защищено 
  scale: SVGAnimatedNumber

  защищено 
  xChannelSelector: SVGAnimatedEnumeration

  защищено 
  yChannelSelector: SVGAnimatedEnumeration

  защищено 
  SVG_CHANNEL_UNKNOWN: 0

  защищено 
  SVG_CHANNEL_R: 1

  защищено 
  SVG_CHANNEL_G: 2

  защищено 
  SVG_CHANNEL_B: 3

  защищено 
  SVG_CHANNEL_A: 4

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDisplacementMapElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDisplacementMapElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEDisplacementMapElement: объект { prototype: SVGFEDisplacementMapElement; при создании(): SVGFEDisplacementMapElement; защищено  SVG_CHANNEL_UNKNOWN: 0; защищено  SVG_CHANNEL_R: 1; защищено  SVG_CHANNEL_G: 2; защищено  SVG_CHANNEL_B: 3; защищено  SVG_CHANNEL_A: 4 }


/**
* Corresponds to the <feDistantLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDistantLightElement)
*/

тип SVGFEDistantLightElement = интерфейс на основе SVGElement
{
  защищено 
  azimuth: SVGAnimatedNumber

  защищено 
  elevation: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDistantLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDistantLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEDistantLightElement: объект { prototype: SVGFEDistantLightElement; при создании(): SVGFEDistantLightElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEDropShadowElement) */

тип SVGFEDropShadowElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  dx: SVGAnimatedNumber

  защищено 
  dy: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  защищено 
  stdDeviationX: SVGAnimatedNumber

  защищено 
  stdDeviationY: SVGAnimatedNumber

  операция setStdDeviation(stdDeviationX: Число, stdDeviationY: Число)

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDropShadowElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEDropShadowElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEDropShadowElement: объект { prototype: SVGFEDropShadowElement; при создании(): SVGFEDropShadowElement }


/**
* Corresponds to the <feFlood> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFloodElement)
*/

тип SVGFEFloodElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFloodElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFloodElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEFloodElement: объект { prototype: SVGFEFloodElement; при создании(): SVGFEFloodElement }


/**
* Corresponds to the <feFuncA> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncAElement)
*/

тип SVGFEFuncAElement = интерфейс на основе SVGComponentTransferFunctionElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncAElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEFuncAElement: объект { prototype: SVGFEFuncAElement; при создании(): SVGFEFuncAElement }


/**
* Corresponds to the <feFuncB> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncBElement)
*/

тип SVGFEFuncBElement = интерфейс на основе SVGComponentTransferFunctionElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncBElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncBElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEFuncBElement: объект { prototype: SVGFEFuncBElement; при создании(): SVGFEFuncBElement }


/**
* Corresponds to the <feFuncG> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncGElement)
*/

тип SVGFEFuncGElement = интерфейс на основе SVGComponentTransferFunctionElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEFuncGElement: объект { prototype: SVGFEFuncGElement; при создании(): SVGFEFuncGElement }


/**
* Corresponds to the <feFuncR> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEFuncRElement)
*/

тип SVGFEFuncRElement = интерфейс на основе SVGComponentTransferFunctionElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncRElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEFuncRElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEFuncRElement: объект { prototype: SVGFEFuncRElement; при создании(): SVGFEFuncRElement }


/**
* Corresponds to the <feGaussianBlur> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEGaussianBlurElement)
*/

тип SVGFEGaussianBlurElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  stdDeviationX: SVGAnimatedNumber

  защищено 
  stdDeviationY: SVGAnimatedNumber

  операция setStdDeviation(stdDeviationX: Число, stdDeviationY: Число)

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEGaussianBlurElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEGaussianBlurElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEGaussianBlurElement: объект { prototype: SVGFEGaussianBlurElement; при создании(): SVGFEGaussianBlurElement }


/**
* Corresponds to the <feImage> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEImageElement)
*/

тип SVGFEImageElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes, SVGURIReference
{
  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEImageElement: объект { prototype: SVGFEImageElement; при создании(): SVGFEImageElement }


/**
* Corresponds to the <feMerge> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMergeElement)
*/

тип SVGFEMergeElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMergeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMergeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEMergeElement: объект { prototype: SVGFEMergeElement; при создании(): SVGFEMergeElement }


/**
* Corresponds to the <feMergeNode> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMergeNodeElement)
*/

тип SVGFEMergeNodeElement = интерфейс на основе SVGElement
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMergeNodeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMergeNodeElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEMergeNodeElement: объект { prototype: SVGFEMergeNodeElement; при создании(): SVGFEMergeNodeElement }


/**
* Corresponds to the <feMorphology> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEMorphologyElement)
*/

тип SVGFEMorphologyElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  operator: SVGAnimatedEnumeration

  защищено 
  radiusX: SVGAnimatedNumber

  защищено 
  radiusY: SVGAnimatedNumber

  защищено 
  SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0

  защищено 
  SVG_MORPHOLOGY_OPERATOR_ERODE: 1

  защищено 
  SVG_MORPHOLOGY_OPERATOR_DILATE: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMorphologyElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEMorphologyElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEMorphologyElement: объект { prototype: SVGFEMorphologyElement; при создании(): SVGFEMorphologyElement; защищено  SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 0; защищено  SVG_MORPHOLOGY_OPERATOR_ERODE: 1; защищено  SVG_MORPHOLOGY_OPERATOR_DILATE: 2 }


/**
* Corresponds to the <feOffset> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEOffsetElement)
*/

тип SVGFEOffsetElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  dx: SVGAnimatedNumber

  защищено 
  dy: SVGAnimatedNumber

  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEOffsetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEOffsetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEOffsetElement: объект { prototype: SVGFEOffsetElement; при создании(): SVGFEOffsetElement }


/**
* Corresponds to the <fePointLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFEPointLightElement)
*/

тип SVGFEPointLightElement = интерфейс на основе SVGElement
{
  защищено 
  x: SVGAnimatedNumber

  защищено 
  y: SVGAnimatedNumber

  защищено 
  z: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEPointLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFEPointLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFEPointLightElement: объект { prototype: SVGFEPointLightElement; при создании(): SVGFEPointLightElement }


/**
* Corresponds to the <feSpecularLighting> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFESpecularLightingElement)
*/

тип SVGFESpecularLightingElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  защищено 
  kernelUnitLengthX: SVGAnimatedNumber

  защищено 
  kernelUnitLengthY: SVGAnimatedNumber

  защищено 
  specularConstant: SVGAnimatedNumber

  защищено 
  specularExponent: SVGAnimatedNumber

  защищено 
  surfaceScale: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFESpecularLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFESpecularLightingElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFESpecularLightingElement: объект { prototype: SVGFESpecularLightingElement; при создании(): SVGFESpecularLightingElement }


/**
* Corresponds to the <feSpotLight> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFESpotLightElement)
*/

тип SVGFESpotLightElement = интерфейс на основе SVGElement
{
  защищено 
  limitingConeAngle: SVGAnimatedNumber

  защищено 
  pointsAtX: SVGAnimatedNumber

  защищено 
  pointsAtY: SVGAnimatedNumber

  защищено 
  pointsAtZ: SVGAnimatedNumber

  защищено 
  specularExponent: SVGAnimatedNumber

  защищено 
  x: SVGAnimatedNumber

  защищено 
  y: SVGAnimatedNumber

  защищено 
  z: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFESpotLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFESpotLightElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFESpotLightElement: объект { prototype: SVGFESpotLightElement; при создании(): SVGFESpotLightElement }


/**
* Corresponds to the <feTile> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFETileElement)
*/

тип SVGFETileElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  in1: SVGAnimatedString

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFETileElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFETileElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFETileElement: объект { prototype: SVGFETileElement; при создании(): SVGFETileElement }


/**
* Corresponds to the <feTurbulence> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFETurbulenceElement)
*/

тип SVGFETurbulenceElement = интерфейс на основе SVGElement, SVGFilterPrimitiveStandardAttributes
{
  защищено 
  baseFrequencyX: SVGAnimatedNumber

  защищено 
  baseFrequencyY: SVGAnimatedNumber

  защищено 
  numOctaves: SVGAnimatedInteger

  защищено 
  seed: SVGAnimatedNumber

  защищено 
  stitchTiles: SVGAnimatedEnumeration

  защищено 
  type`: SVGAnimatedEnumeration

  защищено 
  SVG_TURBULENCE_TYPE_UNKNOWN: 0

  защищено 
  SVG_TURBULENCE_TYPE_FRACTALNOISE: 1

  защищено 
  SVG_TURBULENCE_TYPE_TURBULENCE: 2

  защищено 
  SVG_STITCHTYPE_UNKNOWN: 0

  защищено 
  SVG_STITCHTYPE_STITCH: 1

  защищено 
  SVG_STITCHTYPE_NOSTITCH: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFETurbulenceElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFETurbulenceElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFETurbulenceElement: объект { prototype: SVGFETurbulenceElement; при создании(): SVGFETurbulenceElement; защищено  SVG_TURBULENCE_TYPE_UNKNOWN: 0; защищено  SVG_TURBULENCE_TYPE_FRACTALNOISE: 1; защищено  SVG_TURBULENCE_TYPE_TURBULENCE: 2; защищено  SVG_STITCHTYPE_UNKNOWN: 0; защищено  SVG_STITCHTYPE_STITCH: 1; защищено  SVG_STITCHTYPE_NOSTITCH: 2 }


/**
* Provides access to the properties of <filter> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGFilterElement)
*/

тип SVGFilterElement = интерфейс на основе SVGElement, SVGURIReference
{
  защищено 
  filterUnits: SVGAnimatedEnumeration

  защищено 
  height: SVGAnimatedLength

  защищено 
  primitiveUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFilterElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGFilterElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGFilterElement: объект { prototype: SVGFilterElement; при создании(): SVGFilterElement }


тип SVGFilterPrimitiveStandardAttributes = интерфейс
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  result: SVGAnimatedString

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength
}


тип SVGFitToViewBox = интерфейс
{
  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  защищено 
  viewBox: SVGAnimatedRect
}


/**
* Provides access to the properties of <foreignObject> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGForeignObjectElement)
*/

тип SVGForeignObjectElement = интерфейс на основе SVGGraphicsElement
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGForeignObjectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGForeignObjectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGForeignObjectElement: объект { prototype: SVGForeignObjectElement; при создании(): SVGForeignObjectElement }


/**
* Corresponds to the <g> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGElement)
*/

тип SVGGElement = интерфейс на основе SVGGraphicsElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGGElement: объект { prototype: SVGGElement; при создании(): SVGGElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGeometryElement) */

тип SVGGeometryElement = интерфейс на основе SVGGraphicsElement
{
  защищено 
  pathLength: SVGAnimatedNumber

  операция getPointAtLength(distance: Число): DOMPoint

  операция getTotalLength(): Число

  операция isPointInFill(point: DOMPointInit? = пусто): ДаНет

  операция isPointInStroke(point: DOMPointInit? = пусто): ДаНет

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGeometryElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGeometryElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGGeometryElement: объект { prototype: SVGGeometryElement; при создании(): SVGGeometryElement }


/**
* The SVGGradient interface is a base interface used by SVGLinearGradientElement and SVGRadialGradientElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGradientElement)
*/

тип SVGGradientElement = интерфейс на основе SVGElement, SVGURIReference
{
  защищено 
  gradientTransform: SVGAnimatedTransformList

  защищено 
  gradientUnits: SVGAnimatedEnumeration

  защищено 
  spreadMethod: SVGAnimatedEnumeration

  защищено 
  SVG_SPREADMETHOD_UNKNOWN: 0

  защищено 
  SVG_SPREADMETHOD_PAD: 1

  защищено 
  SVG_SPREADMETHOD_REFLECT: 2

  защищено 
  SVG_SPREADMETHOD_REPEAT: 3

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGGradientElement: объект { prototype: SVGGradientElement; при создании(): SVGGradientElement; защищено  SVG_SPREADMETHOD_UNKNOWN: 0; защищено  SVG_SPREADMETHOD_PAD: 1; защищено  SVG_SPREADMETHOD_REFLECT: 2; защищено  SVG_SPREADMETHOD_REPEAT: 3 }


/**
* SVG elements whose primary purpose is to directly render graphics into a group.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGGraphicsElement)
*/

тип SVGGraphicsElement = интерфейс на основе SVGElement, SVGTests
{
  защищено 
  transform: SVGAnimatedTransformList

  операция getBBox(options: SVGBoundingBoxOptions? = пусто): DOMRect

  операция getCTM(): DOMMatrix?

  операция getScreenCTM(): DOMMatrix?

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGraphicsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGGraphicsElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGGraphicsElement: объект { prototype: SVGGraphicsElement; при создании(): SVGGraphicsElement }


/**
* Corresponds to the <image> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGImageElement)
*/

тип SVGImageElement = интерфейс на основе SVGGraphicsElement, SVGURIReference
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  preserveAspectRatio: SVGAnimatedPreserveAspectRatio

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGImageElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGImageElement: объект { prototype: SVGImageElement; при создании(): SVGImageElement }


/**
* Correspond to the <length> basic data type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLength)
*/

тип SVGLength = интерфейс
{
  защищено 
  unitType: Число

  value: Число

  valueAsString: Текст

  valueInSpecifiedUnits: Число

  операция convertToSpecifiedUnits(unitType: Число)

  операция newValueSpecifiedUnits(unitType: Число, valueInSpecifiedUnits: Число)

  защищено 
  SVG_LENGTHTYPE_UNKNOWN: 0

  защищено 
  SVG_LENGTHTYPE_NUMBER: 1

  защищено 
  SVG_LENGTHTYPE_PERCENTAGE: 2

  защищено 
  SVG_LENGTHTYPE_EMS: 3

  защищено 
  SVG_LENGTHTYPE_EXS: 4

  защищено 
  SVG_LENGTHTYPE_PX: 5

  защищено 
  SVG_LENGTHTYPE_CM: 6

  защищено 
  SVG_LENGTHTYPE_MM: 7

  защищено 
  SVG_LENGTHTYPE_IN: 8

  защищено 
  SVG_LENGTHTYPE_PT: 9

  защищено 
  SVG_LENGTHTYPE_PC: 10
}


внешнее
/*(!) var */ SVGLength: объект { prototype: SVGLength; при создании(): SVGLength; защищено  SVG_LENGTHTYPE_UNKNOWN: 0; защищено  SVG_LENGTHTYPE_NUMBER: 1; защищено  SVG_LENGTHTYPE_PERCENTAGE: 2; защищено  SVG_LENGTHTYPE_EMS: 3; защищено  SVG_LENGTHTYPE_EXS: 4; защищено  SVG_LENGTHTYPE_PX: 5; защищено  SVG_LENGTHTYPE_CM: 6; защищено  SVG_LENGTHTYPE_MM: 7; защищено  SVG_LENGTHTYPE_IN: 8; защищено  SVG_LENGTHTYPE_PT: 9; защищено  SVG_LENGTHTYPE_PC: 10 }


/**
* The SVGLengthList defines a list of SVGLength objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLengthList)
*/

тип SVGLengthList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGLength): SVGLength

  операция clear()

  операция getItem(index: Число): SVGLength

  операция initialize(newItem: SVGLength): SVGLength

  операция insertItemBefore(newItem: SVGLength, index: Число): SVGLength

  операция removeItem(index: Число): SVGLength

  операция replaceItem(newItem: SVGLength, index: Число): SVGLength

  /*(!) [index: number]: SVGLength*/
}


внешнее
/*(!) var */ SVGLengthList: объект { prototype: SVGLengthList; при создании(): SVGLengthList }


/**
* Provides access to the properties of <line> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLineElement)
*/

тип SVGLineElement = интерфейс на основе SVGGeometryElement
{
  защищено 
  x1: SVGAnimatedLength

  защищено 
  x2: SVGAnimatedLength

  защищено 
  y1: SVGAnimatedLength

  защищено 
  y2: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGLineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGLineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGLineElement: объект { prototype: SVGLineElement; при создании(): SVGLineElement }


/**
* Corresponds to the <linearGradient> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGLinearGradientElement)
*/

тип SVGLinearGradientElement = интерфейс на основе SVGGradientElement
{
  защищено 
  x1: SVGAnimatedLength

  защищено 
  x2: SVGAnimatedLength

  защищено 
  y1: SVGAnimatedLength

  защищено 
  y2: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGLinearGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGLinearGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGLinearGradientElement: объект { prototype: SVGLinearGradientElement; при создании(): SVGLinearGradientElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMPathElement) */

тип SVGMPathElement = интерфейс на основе SVGElement, SVGURIReference
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGMPathElement: объект { prototype: SVGMPathElement; при создании(): SVGMPathElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMarkerElement) */

тип SVGMarkerElement = интерфейс на основе SVGElement, SVGFitToViewBox
{
  защищено 
  markerHeight: SVGAnimatedLength

  защищено 
  markerUnits: SVGAnimatedEnumeration

  защищено 
  markerWidth: SVGAnimatedLength

  защищено 
  orientAngle: SVGAnimatedAngle

  защищено 
  orientType: SVGAnimatedEnumeration

  защищено 
  refX: SVGAnimatedLength

  защищено 
  refY: SVGAnimatedLength

  операция setOrientToAngle(angle: SVGAngle)

  операция setOrientToAuto()

  защищено 
  SVG_MARKERUNITS_UNKNOWN: 0

  защищено 
  SVG_MARKERUNITS_USERSPACEONUSE: 1

  защищено 
  SVG_MARKERUNITS_STROKEWIDTH: 2

  защищено 
  SVG_MARKER_ORIENT_UNKNOWN: 0

  защищено 
  SVG_MARKER_ORIENT_AUTO: 1

  защищено 
  SVG_MARKER_ORIENT_ANGLE: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMarkerElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMarkerElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGMarkerElement: объект { prototype: SVGMarkerElement; при создании(): SVGMarkerElement; защищено  SVG_MARKERUNITS_UNKNOWN: 0; защищено  SVG_MARKERUNITS_USERSPACEONUSE: 1; защищено  SVG_MARKERUNITS_STROKEWIDTH: 2; защищено  SVG_MARKER_ORIENT_UNKNOWN: 0; защищено  SVG_MARKER_ORIENT_AUTO: 1; защищено  SVG_MARKER_ORIENT_ANGLE: 2 }


/**
* Provides access to the properties of <mask> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMaskElement)
*/

тип SVGMaskElement = интерфейс на основе SVGElement
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  maskContentUnits: SVGAnimatedEnumeration

  защищено 
  maskUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMaskElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMaskElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGMaskElement: объект { prototype: SVGMaskElement; при создании(): SVGMaskElement }


/**
* Corresponds to the <metadata> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGMetadataElement)
*/

тип SVGMetadataElement = интерфейс на основе SVGElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMetadataElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGMetadataElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGMetadataElement: объект { prototype: SVGMetadataElement; при создании(): SVGMetadataElement }


/**
* Corresponds to the <number> basic data type.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGNumber)
*/

тип SVGNumber = интерфейс
{
  value: Число
}


внешнее
/*(!) var */ SVGNumber: объект { prototype: SVGNumber; при создании(): SVGNumber }


/**
* The SVGNumberList defines a list of SVGNumber objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGNumberList)
*/

тип SVGNumberList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGNumber): SVGNumber

  операция clear()

  операция getItem(index: Число): SVGNumber

  операция initialize(newItem: SVGNumber): SVGNumber

  операция insertItemBefore(newItem: SVGNumber, index: Число): SVGNumber

  операция removeItem(index: Число): SVGNumber

  операция replaceItem(newItem: SVGNumber, index: Число): SVGNumber

  /*(!) [index: number]: SVGNumber*/
}


внешнее
/*(!) var */ SVGNumberList: объект { prototype: SVGNumberList; при создании(): SVGNumberList }


/**
* Corresponds to the <path> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPathElement)
*/

тип SVGPathElement = интерфейс на основе SVGGeometryElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGPathElement: объект { prototype: SVGPathElement; при создании(): SVGPathElement }


/**
* Corresponds to the <pattern> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPatternElement)
*/

тип SVGPatternElement = интерфейс на основе SVGElement, SVGFitToViewBox, SVGURIReference
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  patternContentUnits: SVGAnimatedEnumeration

  защищено 
  patternTransform: SVGAnimatedTransformList

  защищено 
  patternUnits: SVGAnimatedEnumeration

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPatternElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPatternElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGPatternElement: объект { prototype: SVGPatternElement; при создании(): SVGPatternElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPointList) */

тип SVGPointList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: DOMPoint): DOMPoint

  операция clear()

  операция getItem(index: Число): DOMPoint

  операция initialize(newItem: DOMPoint): DOMPoint

  операция insertItemBefore(newItem: DOMPoint, index: Число): DOMPoint

  операция removeItem(index: Число): DOMPoint

  операция replaceItem(newItem: DOMPoint, index: Число): DOMPoint

  /*(!) [index: number]: DOMPoint*/
}


внешнее
/*(!) var */ SVGPointList: объект { prototype: SVGPointList; при создании(): SVGPointList }


/**
* Provides access to the properties of <polygon> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPolygonElement)
*/

тип SVGPolygonElement = интерфейс на основе SVGGeometryElement, SVGAnimatedPoints
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPolygonElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPolygonElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGPolygonElement: объект { prototype: SVGPolygonElement; при создании(): SVGPolygonElement }


/**
* Provides access to the properties of <polyline> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPolylineElement)
*/

тип SVGPolylineElement = интерфейс на основе SVGGeometryElement, SVGAnimatedPoints
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPolylineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGPolylineElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGPolylineElement: объект { prototype: SVGPolylineElement; при создании(): SVGPolylineElement }


/**
* Corresponds to the preserveAspectRatio attribute, which is available for some of SVG's elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGPreserveAspectRatio)
*/

тип SVGPreserveAspectRatio = интерфейс
{
  align: Число

  meetOrSlice: Число

  защищено 
  SVG_PRESERVEASPECTRATIO_UNKNOWN: 0

  защищено 
  SVG_PRESERVEASPECTRATIO_NONE: 1

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMIN: 2

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMID: 5

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMID: 6

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMID: 7

  защищено 
  SVG_PRESERVEASPECTRATIO_XMINYMAX: 8

  защищено 
  SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9

  защищено 
  SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10

  защищено 
  SVG_MEETORSLICE_UNKNOWN: 0

  защищено 
  SVG_MEETORSLICE_MEET: 1

  защищено 
  SVG_MEETORSLICE_SLICE: 2
}


внешнее
/*(!) var */ SVGPreserveAspectRatio: объект { prototype: SVGPreserveAspectRatio; при создании(): SVGPreserveAspectRatio; защищено  SVG_PRESERVEASPECTRATIO_UNKNOWN: 0; защищено  SVG_PRESERVEASPECTRATIO_NONE: 1; защищено  SVG_PRESERVEASPECTRATIO_XMINYMIN: 2; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMIN: 3; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMIN: 4; защищено  SVG_PRESERVEASPECTRATIO_XMINYMID: 5; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMID: 6; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMID: 7; защищено  SVG_PRESERVEASPECTRATIO_XMINYMAX: 8; защищено  SVG_PRESERVEASPECTRATIO_XMIDYMAX: 9; защищено  SVG_PRESERVEASPECTRATIO_XMAXYMAX: 10; защищено  SVG_MEETORSLICE_UNKNOWN: 0; защищено  SVG_MEETORSLICE_MEET: 1; защищено  SVG_MEETORSLICE_SLICE: 2 }


/**
* Corresponds to the <RadialGradient> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGRadialGradientElement)
*/

тип SVGRadialGradientElement = интерфейс на основе SVGGradientElement
{
  защищено 
  cx: SVGAnimatedLength

  защищено 
  cy: SVGAnimatedLength

  защищено 
  fr: SVGAnimatedLength

  защищено 
  fx: SVGAnimatedLength

  защищено 
  fy: SVGAnimatedLength

  защищено 
  r: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGRadialGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGRadialGradientElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGRadialGradientElement: объект { prototype: SVGRadialGradientElement; при создании(): SVGRadialGradientElement }


/**
* Provides access to the properties of <rect> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGRectElement)
*/

тип SVGRectElement = интерфейс на основе SVGGeometryElement
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  rx: SVGAnimatedLength

  защищено 
  ry: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGRectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGRectElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGRectElement: объект { prototype: SVGRectElement; при создании(): SVGRectElement }


тип SVGSVGElementEventMap = интерфейс на основе SVGElementEventMap, WindowEventHandlersEventMap
{

}


/**
* Provides access to the properties of <svg> elements, as well as methods to manipulate them. This interface contains also various miscellaneous commonly-used utility methods, such as matrix operations and the ability to control the time of redraw on visual rendering devices.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSVGElement)
*/

тип SVGSVGElement = интерфейс на основе SVGGraphicsElement, SVGFitToViewBox, WindowEventHandlers
{
  currentScale: Число

  защищено 
  currentTranslate: DOMPointReadOnly

  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция animationsPaused(): ДаНет

  операция checkEnclosure(element: SVGElement, rect: DOMRectReadOnly): ДаНет

  операция checkIntersection(element: SVGElement, rect: DOMRectReadOnly): ДаНет

  операция createSVGAngle(): SVGAngle

  операция createSVGLength(): SVGLength

  операция createSVGMatrix(): DOMMatrix

  операция createSVGNumber(): SVGNumber

  операция createSVGPoint(): DOMPoint

  операция createSVGRect(): DOMRect

  операция createSVGTransform(): SVGTransform

  операция createSVGTransformFromMatrix(matrix: DOMMatrix2DInit? = пусто): SVGTransform

  операция deselectAll()

  операция getCurrentTime(): Число

  операция getElementById(elementId: Текст): Element

  операция getEnclosureList(rect: DOMRectReadOnly, referenceElement: SVGElement?): NodeListOf<Объект? /*(!)SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement*/>

  операция getIntersectionList(rect: DOMRectReadOnly, referenceElement: SVGElement?): NodeListOf<Объект? /*(!)SVGCircleElement | SVGEllipseElement | SVGImageElement | SVGLineElement | SVGPathElement | SVGPolygonElement | SVGPolylineElement | SVGRectElement | SVGTextElement | SVGUseElement*/>

  операция pauseAnimations()

  операция setCurrentTime(seconds: Число)

  операция unpauseAnimations()

  операция addEventListener<K = /*(!) keyof SVGSVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSVGElement, ev: /*(!) SVGSVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGSVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSVGElement, ev: /*(!) SVGSVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGSVGElement: объект { prototype: SVGSVGElement; при создании(): SVGSVGElement }


/**
* Corresponds to the SVG <script> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGScriptElement)
*/

тип SVGScriptElement = интерфейс на основе SVGElement, SVGURIReference
{
  type`: Текст

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGScriptElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGScriptElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGScriptElement: объект { prototype: SVGScriptElement; при создании(): SVGScriptElement }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSetElement) */

тип SVGSetElement = интерфейс на основе SVGAnimationElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSetElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGSetElement: объект { prototype: SVGSetElement; при создании(): SVGSetElement }


/**
* Corresponds to the <stop> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStopElement)
*/

тип SVGStopElement = интерфейс на основе SVGElement
{
  защищено 
  offset: SVGAnimatedNumber

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGStopElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGStopElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGStopElement: объект { prototype: SVGStopElement; при создании(): SVGStopElement }


/**
* The SVGStringList defines a list of DOMString objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStringList)
*/

тип SVGStringList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: Текст): Текст

  операция clear()

  операция getItem(index: Число): Текст

  операция initialize(newItem: Текст): Текст

  операция insertItemBefore(newItem: Текст, index: Число): Текст

  операция removeItem(index: Число): Текст

  операция replaceItem(newItem: Текст, index: Число): Текст

  /*(!) [index: number]: string*/
}


внешнее
/*(!) var */ SVGStringList: объект { prototype: SVGStringList; при создании(): SVGStringList }


/**
* Corresponds to the SVG <style> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGStyleElement)
*/

тип SVGStyleElement = интерфейс на основе SVGElement, LinkStyle
{
  disabled: ДаНет

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGStyleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGStyleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGStyleElement: объект { prototype: SVGStyleElement; при создании(): SVGStyleElement }


/**
* Corresponds to the <switch> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSwitchElement)
*/

тип SVGSwitchElement = интерфейс на основе SVGGraphicsElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSwitchElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSwitchElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGSwitchElement: объект { prototype: SVGSwitchElement; при создании(): SVGSwitchElement }


/**
* Corresponds to the <symbol> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGSymbolElement)
*/

тип SVGSymbolElement = интерфейс на основе SVGElement, SVGFitToViewBox
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSymbolElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGSymbolElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGSymbolElement: объект { prototype: SVGSymbolElement; при создании(): SVGSymbolElement }


/**
* A <tspan> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTSpanElement)
*/

тип SVGTSpanElement = интерфейс на основе SVGTextPositioningElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTSpanElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTSpanElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTSpanElement: объект { prototype: SVGTSpanElement; при создании(): SVGTSpanElement }


тип SVGTests = интерфейс
{
  защищено 
  requiredExtensions: SVGStringList

  защищено 
  systemLanguage: SVGStringList
}


/**
* Implemented by elements that support rendering child text content. It is inherited by various text-related interfaces, such as SVGTextElement, SVGTSpanElement, SVGTRefElement, SVGAltGlyphElement and SVGTextPathElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextContentElement)
*/

тип SVGTextContentElement = интерфейс на основе SVGGraphicsElement
{
  защищено 
  lengthAdjust: SVGAnimatedEnumeration

  защищено 
  textLength: SVGAnimatedLength

  операция getCharNumAtPosition(point: DOMPointInit? = пусто): Число

  операция getComputedTextLength(): Число

  операция getEndPositionOfChar(charnum: Число): DOMPoint

  операция getExtentOfChar(charnum: Число): DOMRect

  операция getNumberOfChars(): Число

  операция getRotationOfChar(charnum: Число): Число

  операция getStartPositionOfChar(charnum: Число): DOMPoint

  операция getSubStringLength(charnum: Число, nchars: Число): Число

  защищено 
  LENGTHADJUST_UNKNOWN: 0

  защищено 
  LENGTHADJUST_SPACING: 1

  защищено 
  LENGTHADJUST_SPACINGANDGLYPHS: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextContentElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextContentElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTextContentElement: объект { prototype: SVGTextContentElement; при создании(): SVGTextContentElement; защищено  LENGTHADJUST_UNKNOWN: 0; защищено  LENGTHADJUST_SPACING: 1; защищено  LENGTHADJUST_SPACINGANDGLYPHS: 2 }


/**
* Corresponds to the <text> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextElement)
*/

тип SVGTextElement = интерфейс на основе SVGTextPositioningElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTextElement: объект { prototype: SVGTextElement; при создании(): SVGTextElement }


/**
* Corresponds to the <textPath> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextPathElement)
*/

тип SVGTextPathElement = интерфейс на основе SVGTextContentElement, SVGURIReference
{
  защищено 
  method: SVGAnimatedEnumeration

  защищено 
  spacing: SVGAnimatedEnumeration

  защищено 
  startOffset: SVGAnimatedLength

  защищено 
  TEXTPATH_METHODTYPE_UNKNOWN: 0

  защищено 
  TEXTPATH_METHODTYPE_ALIGN: 1

  защищено 
  TEXTPATH_METHODTYPE_STRETCH: 2

  защищено 
  TEXTPATH_SPACINGTYPE_UNKNOWN: 0

  защищено 
  TEXTPATH_SPACINGTYPE_AUTO: 1

  защищено 
  TEXTPATH_SPACINGTYPE_EXACT: 2

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextPathElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTextPathElement: объект { prototype: SVGTextPathElement; при создании(): SVGTextPathElement; защищено  TEXTPATH_METHODTYPE_UNKNOWN: 0; защищено  TEXTPATH_METHODTYPE_ALIGN: 1; защищено  TEXTPATH_METHODTYPE_STRETCH: 2; защищено  TEXTPATH_SPACINGTYPE_UNKNOWN: 0; защищено  TEXTPATH_SPACINGTYPE_AUTO: 1; защищено  TEXTPATH_SPACINGTYPE_EXACT: 2 }


/**
* Implemented by elements that support attributes that position individual text glyphs. It is inherited by SVGTextElement, SVGTSpanElement, SVGTRefElement and SVGAltGlyphElement.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTextPositioningElement)
*/

тип SVGTextPositioningElement = интерфейс на основе SVGTextContentElement
{
  защищено 
  dx: SVGAnimatedLengthList

  защищено 
  dy: SVGAnimatedLengthList

  защищено 
  rotate: SVGAnimatedNumberList

  защищено 
  x: SVGAnimatedLengthList

  защищено 
  y: SVGAnimatedLengthList

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextPositioningElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTextPositioningElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTextPositioningElement: объект { prototype: SVGTextPositioningElement; при создании(): SVGTextPositioningElement }


/**
* Corresponds to the <title> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTitleElement)
*/

тип SVGTitleElement = интерфейс на основе SVGElement
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTitleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGTitleElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGTitleElement: объект { prototype: SVGTitleElement; при создании(): SVGTitleElement }


/**
* SVGTransform is the interface for one of the component transformations within an SVGTransformList; thus, an SVGTransform object corresponds to a single component (e.g., scale(…) or matrix(…)) within a transform attribute.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTransform)
*/

тип SVGTransform = интерфейс
{
  защищено 
  angle: Число

  защищено 
  matrix: DOMMatrix

  защищено 
  type`: Число

  операция setMatrix(matrix: DOMMatrix2DInit? = пусто)

  операция setRotate(angle: Число, cx: Число, cy: Число)

  операция setScale(sx: Число, sy: Число)

  операция setSkewX(angle: Число)

  операция setSkewY(angle: Число)

  операция setTranslate(tx: Число, ty: Число)

  защищено 
  SVG_TRANSFORM_UNKNOWN: 0

  защищено 
  SVG_TRANSFORM_MATRIX: 1

  защищено 
  SVG_TRANSFORM_TRANSLATE: 2

  защищено 
  SVG_TRANSFORM_SCALE: 3

  защищено 
  SVG_TRANSFORM_ROTATE: 4

  защищено 
  SVG_TRANSFORM_SKEWX: 5

  защищено 
  SVG_TRANSFORM_SKEWY: 6
}


внешнее
/*(!) var */ SVGTransform: объект { prototype: SVGTransform; при создании(): SVGTransform; защищено  SVG_TRANSFORM_UNKNOWN: 0; защищено  SVG_TRANSFORM_MATRIX: 1; защищено  SVG_TRANSFORM_TRANSLATE: 2; защищено  SVG_TRANSFORM_SCALE: 3; защищено  SVG_TRANSFORM_ROTATE: 4; защищено  SVG_TRANSFORM_SKEWX: 5; защищено  SVG_TRANSFORM_SKEWY: 6 }


/**
* The SVGTransformList defines a list of SVGTransform objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGTransformList)
*/

тип SVGTransformList = интерфейс
{
  защищено 
  length: Число

  защищено 
  numberOfItems: Число

  операция appendItem(newItem: SVGTransform): SVGTransform

  операция clear()

  операция consolidate(): SVGTransform?

  операция createSVGTransformFromMatrix(matrix: DOMMatrix2DInit? = пусто): SVGTransform

  операция getItem(index: Число): SVGTransform

  операция initialize(newItem: SVGTransform): SVGTransform

  операция insertItemBefore(newItem: SVGTransform, index: Число): SVGTransform

  операция removeItem(index: Число): SVGTransform

  операция replaceItem(newItem: SVGTransform, index: Число): SVGTransform

  /*(!) [index: number]: SVGTransform*/
}


внешнее
/*(!) var */ SVGTransformList: объект { prototype: SVGTransformList; при создании(): SVGTransformList }


тип SVGURIReference = интерфейс
{
  защищено 
  href: SVGAnimatedString
}


/**
* A commonly used set of constants used for reflecting gradientUnits, patternContentUnits and other similar attributes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGUnitTypes)
*/

тип SVGUnitTypes = интерфейс
{
  защищено 
  SVG_UNIT_TYPE_UNKNOWN: 0

  защищено 
  SVG_UNIT_TYPE_USERSPACEONUSE: 1

  защищено 
  SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2
}


внешнее
/*(!) var */ SVGUnitTypes: объект { prototype: SVGUnitTypes; при создании(): SVGUnitTypes; защищено  SVG_UNIT_TYPE_UNKNOWN: 0; защищено  SVG_UNIT_TYPE_USERSPACEONUSE: 1; защищено  SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 2 }


/**
* Corresponds to the <use> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGUseElement)
*/

тип SVGUseElement = интерфейс на основе SVGGraphicsElement, SVGURIReference
{
  защищено 
  height: SVGAnimatedLength

  защищено 
  width: SVGAnimatedLength

  защищено 
  x: SVGAnimatedLength

  защищено 
  y: SVGAnimatedLength

  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGUseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGUseElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGUseElement: объект { prototype: SVGUseElement; при создании(): SVGUseElement }


/**
* Provides access to the properties of <view> elements, as well as methods to manipulate them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGViewElement)
*/

тип SVGViewElement = интерфейс на основе SVGElement, SVGFitToViewBox
{
  операция addEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGViewElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SVGElementEventMap */ Объект?>(type`: K, listener: операция(this: SVGViewElement, ev: /*(!) SVGElementEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SVGViewElement: объект { prototype: SVGViewElement; при создании(): SVGViewElement }


/**
* A screen, usually the one on which the current window is being rendered, and is obtained using window.screen.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Screen)
*/

тип Screen = интерфейс
{
  защищено 
  availHeight: Число

  защищено 
  availWidth: Число

  защищено 
  colorDepth: Число

  защищено 
  height: Число

  защищено 
  orientation: ScreenOrientation

  защищено 
  pixelDepth: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ Screen: объект { prototype: Screen; при создании(): Screen }


тип ScreenOrientationEventMap = интерфейс
{
  "change": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ScreenOrientation) */

тип ScreenOrientation = интерфейс на основе EventTarget
{
  защищено 
  angle: Число

  onchange: (операция(this: ScreenOrientation, ev: Event): /*(!) any */ Объект?)?

  защищено 
  type`: OrientationType

  операция unlock()

  операция addEventListener<K = /*(!) keyof ScreenOrientationEventMap */ Объект?>(type`: K, listener: операция(this: ScreenOrientation, ev: /*(!) ScreenOrientationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ScreenOrientationEventMap */ Объект?>(type`: K, listener: операция(this: ScreenOrientation, ev: /*(!) ScreenOrientationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ScreenOrientation: объект { prototype: ScreenOrientation; при создании(): ScreenOrientation }


тип ScriptProcessorNodeEventMap = интерфейс
{
  "audioprocess": AudioProcessingEvent
}


/**
* Inherits from Event, and represents the event object of an event sent on a document or worker when its content security policy is violated.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SecurityPolicyViolationEvent)
*/

тип SecurityPolicyViolationEvent = интерфейс на основе Event
{
  защищено 
  blockedURI: Текст

  защищено 
  columnNumber: Число

  защищено 
  disposition: SecurityPolicyViolationEventDisposition

  защищено 
  documentURI: Текст

  защищено 
  effectiveDirective: Текст

  защищено 
  lineNumber: Число

  защищено 
  originalPolicy: Текст

  защищено 
  referrer: Текст

  защищено 
  sample: Текст

  защищено 
  sourceFile: Текст

  защищено 
  statusCode: Число

  защищено 
  violatedDirective: Текст
}


внешнее
/*(!) var */ SecurityPolicyViolationEvent: объект { prototype: SecurityPolicyViolationEvent; при создании(type`: Текст, eventInitDict: SecurityPolicyViolationEventInit? = пусто): SecurityPolicyViolationEvent }


/**
* A Selection object represents the range of text selected by the user or the current position of the caret. To obtain a Selection object for examination or modification, call Window.getSelection().
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Selection)
*/

тип Selection = интерфейс
{
  защищено 
  anchorNode: Node?

  защищено 
  anchorOffset: Число

  защищено 
  focusNode: Node?

  защищено 
  focusOffset: Число

  защищено 
  isCollapsed: ДаНет

  защищено 
  rangeCount: Число

  защищено 
  type`: Текст

  операция addRange(range: Range)

  операция collapse(node: Node?, offset: Число? = пусто)

  операция collapseToEnd()

  операция collapseToStart()

  операция containsNode(node: Node, allowPartialContainment: ДаНет? = пусто): ДаНет

  операция deleteFromDocument()

  операция empty`()

  операция extend(node: Node, offset: Число? = пусто)

  операция getRangeAt(index: Число): Range

  операция modify(alter: Текст? = пусто, direction: Текст? = пусто, granularity: Текст? = пусто)

  операция removeAllRanges()

  операция removeRange(range: Range)

  операция selectAllChildren(node: Node)

  операция setBaseAndExtent(anchorNode: Node, anchorOffset: Число, focusNode: Node, focusOffset: Число)

  операция setPosition(node: Node?, offset: Число? = пусто)

  операция toString(): Текст
}


внешнее
/*(!) var */ Selection: объект { prototype: Selection; при создании(): Selection }


тип ServiceWorkerEventMap = интерфейс на основе AbstractWorkerEventMap
{
  "statechange": Event
}


/**
* This ServiceWorker API interface provides a reference to a service worker. Multiple browsing contexts (e.g. pages, workers, etc.) can be associated with the same service worker, each through a unique ServiceWorker object.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorker)
*/

тип ServiceWorker = интерфейс на основе EventTarget, AbstractWorker
{
  onstatechange: (операция(this: ServiceWorker, ev: Event): /*(!) any */ Объект?)?

  защищено 
  scriptURL: Текст

  защищено 
  state: ServiceWorkerState

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions? = пусто)

  операция addEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorker, ev: /*(!) ServiceWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ServiceWorker: объект { prototype: ServiceWorker; при создании(): ServiceWorker }


тип ServiceWorkerContainerEventMap = интерфейс
{
  "controllerchange": Event

  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* The ServiceWorkerContainer interface of the ServiceWorker API provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister and update service workers, and access the state of service workers and their registrations.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerContainer)
*/

тип ServiceWorkerContainer = интерфейс на основе EventTarget
{
  защищено 
  controller: ServiceWorker?

  oncontrollerchange: (операция(this: ServiceWorkerContainer, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект?)?

  onmessageerror: (операция(this: ServiceWorkerContainer, ev: MessageEvent): /*(!) any */ Объект?)?

  защищено 
  ready: Promise<ServiceWorkerRegistration>

  операция getRegistration(clientURL: Объект? /*(!)Текст | URL | пусто*/ = пусто): Promise<ServiceWorkerRegistration?>

  операция getRegistrations(): Promise<ReadonlyArray<ServiceWorkerRegistration>>

  операция register(scriptURL: Объект? /*(!)Текст | URL*/, options: RegistrationOptions? = пусто): Promise<ServiceWorkerRegistration>

  операция startMessages()

  операция addEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerContainerEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorkerContainer, ev: /*(!) ServiceWorkerContainerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ServiceWorkerContainer: объект { prototype: ServiceWorkerContainer; при создании(): ServiceWorkerContainer }


тип ServiceWorkerRegistrationEventMap = интерфейс
{
  "updatefound": Event
}


/**
* This ServiceWorker API interface represents the service worker registration. You register a service worker to control one or more pages that share the same origin.
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration)
*/

тип ServiceWorkerRegistration = интерфейс на основе EventTarget
{
  защищено 
  active: ServiceWorker?

  защищено 
  installing: ServiceWorker?

  защищено 
  navigationPreload: NavigationPreloadManager

  onupdatefound: (операция(this: ServiceWorkerRegistration, ev: Event): /*(!) any */ Объект?)?

  защищено 
  pushManager: PushManager

  защищено 
  scope: Текст

  защищено 
  updateViaCache: ServiceWorkerUpdateViaCache

  защищено 
  waiting: ServiceWorker?

  операция getNotifications(filter: GetNotificationOptions? = пусто): Promise<Список<Notification>>

  операция showNotification(title: Текст, options: NotificationOptions? = пусто): Promise<Ничего>

  операция unregister(): Promise<ДаНет>

  операция update(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ServiceWorkerRegistrationEventMap */ Объект?>(type`: K, listener: операция(this: ServiceWorkerRegistration, ev: /*(!) ServiceWorkerRegistrationEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ServiceWorkerRegistration: объект { prototype: ServiceWorkerRegistration; при создании(): ServiceWorkerRegistration }


тип ShadowRootEventMap = интерфейс
{
  "slotchange": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ShadowRoot) */

тип ShadowRoot = интерфейс на основе DocumentFragment, DocumentOrShadowRoot, InnerHTML
{
  защищено 
  delegatesFocus: ДаНет

  защищено 
  host: Element

  защищено 
  mode: ShadowRootMode

  onslotchange: (операция(this: ShadowRoot, ev: Event): /*(!) any */ Объект?)?

  защищено 
  slotAssignment: SlotAssignmentMode

  операция addEventListener<K = /*(!) keyof ShadowRootEventMap */ Объект?>(type`: K, listener: операция(this: ShadowRoot, ev: /*(!) ShadowRootEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof ShadowRootEventMap */ Объект?>(type`: K, listener: операция(this: ShadowRoot, ev: /*(!) ShadowRootEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ ShadowRoot: объект { prototype: ShadowRoot; при создании(): ShadowRoot }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SharedWorker) */

тип SharedWorker = интерфейс на основе EventTarget, AbstractWorker
{
  защищено 
  port: MessagePort

  операция addEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type`: K, listener: операция(this: SharedWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof AbstractWorkerEventMap */ Объект?>(type`: K, listener: операция(this: SharedWorker, ev: /*(!) AbstractWorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SharedWorker: объект { prototype: SharedWorker; при создании(scriptURL: Объект? /*(!)Текст | URL*/, options: Объект? /*(!)Текст | WorkerOptions | пусто*/ = пусто): SharedWorker }


тип Slottable = интерфейс
{
  защищено 
  assignedSlot: HTMLSlotElement?
}


тип SourceBufferEventMap = интерфейс
{
  "abort": Event

  "error": Event

  "update": Event

  "updateend": Event

  "updatestart": Event
}


/**
* A chunk of media to be passed into an HTMLMediaElement and played, via a MediaSource object. This can be made up of one or several media segments.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SourceBuffer)
*/

тип SourceBuffer = интерфейс на основе EventTarget
{
  appendWindowEnd: Число

  appendWindowStart: Число

  защищено 
  buffered: TimeRanges

  mode: AppendMode

  onabort: (операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект?)?

  onerror: (операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект?)?

  onupdate: (операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект?)?

  onupdateend: (операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект?)?

  onupdatestart: (операция(this: SourceBuffer, ev: Event): /*(!) any */ Объект?)?

  timestampOffset: Число

  защищено 
  updating: ДаНет

  операция abort()

  операция appendBuffer(data: BufferSource)

  операция changeType(type`: Текст)

  операция remove(start: Число, end: Число)

  операция addEventListener<K = /*(!) keyof SourceBufferEventMap */ Объект?>(type`: K, listener: операция(this: SourceBuffer, ev: /*(!) SourceBufferEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SourceBufferEventMap */ Объект?>(type`: K, listener: операция(this: SourceBuffer, ev: /*(!) SourceBufferEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SourceBuffer: объект { prototype: SourceBuffer; при создании(): SourceBuffer }


тип SourceBufferListEventMap = интерфейс
{
  "addsourcebuffer": Event

  "removesourcebuffer": Event
}


/**
* A simple container list for multiple SourceBuffer objects.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SourceBufferList)
*/

тип SourceBufferList = интерфейс на основе EventTarget
{
  защищено 
  length: Число

  onaddsourcebuffer: (операция(this: SourceBufferList, ev: Event): /*(!) any */ Объект?)?

  onremovesourcebuffer: (операция(this: SourceBufferList, ev: Event): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof SourceBufferListEventMap */ Объект?>(type`: K, listener: операция(this: SourceBufferList, ev: /*(!) SourceBufferListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SourceBufferListEventMap */ Объект?>(type`: K, listener: операция(this: SourceBufferList, ev: /*(!) SourceBufferListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  /*(!) [index: number]: SourceBuffer*/
}


внешнее
/*(!) var */ SourceBufferList: объект { prototype: SourceBufferList; при создании(): SourceBufferList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionAlternative) */

тип SpeechRecognitionAlternative = интерфейс
{
  защищено 
  confidence: Число

  защищено 
  transcript: Текст
}


внешнее
/*(!) var */ SpeechRecognitionAlternative: объект { prototype: SpeechRecognitionAlternative; при создании(): SpeechRecognitionAlternative }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionResult) */

тип SpeechRecognitionResult = интерфейс
{
  защищено 
  isFinal: ДаНет

  защищено 
  length: Число

  операция item(index: Число): SpeechRecognitionAlternative

  /*(!) [index: number]: SpeechRecognitionAlternative*/
}


внешнее
/*(!) var */ SpeechRecognitionResult: объект { prototype: SpeechRecognitionResult; при создании(): SpeechRecognitionResult }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechRecognitionResultList) */

тип SpeechRecognitionResultList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): SpeechRecognitionResult

  /*(!) [index: number]: SpeechRecognitionResult*/
}


внешнее
/*(!) var */ SpeechRecognitionResultList: объект { prototype: SpeechRecognitionResultList; при создании(): SpeechRecognitionResultList }


тип SpeechSynthesisEventMap = интерфейс
{
  "voiceschanged": Event
}


/**
* This Web Speech API interface is the controller interface for the speech service; this can be used to retrieve information about the synthesis voices available on the device, start and pause speech, and other commands besides.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesis)
*/

тип SpeechSynthesis = интерфейс на основе EventTarget
{
  onvoiceschanged: (операция(this: SpeechSynthesis, ev: Event): /*(!) any */ Объект?)?

  защищено 
  paused: ДаНет

  защищено 
  pending: ДаНет

  защищено 
  speaking: ДаНет

  операция cancel()

  операция getVoices(): Список<SpeechSynthesisVoice>

  операция pause()

  операция resume()

  операция speak(utterance: SpeechSynthesisUtterance)

  операция addEventListener<K = /*(!) keyof SpeechSynthesisEventMap */ Объект?>(type`: K, listener: операция(this: SpeechSynthesis, ev: /*(!) SpeechSynthesisEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SpeechSynthesisEventMap */ Объект?>(type`: K, listener: операция(this: SpeechSynthesis, ev: /*(!) SpeechSynthesisEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SpeechSynthesis: объект { prototype: SpeechSynthesis; при создании(): SpeechSynthesis }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisErrorEvent) */

тип SpeechSynthesisErrorEvent = интерфейс на основе SpeechSynthesisEvent
{
  защищено 
  error`: SpeechSynthesisErrorCode
}


внешнее
/*(!) var */ SpeechSynthesisErrorEvent: объект { prototype: SpeechSynthesisErrorEvent; при создании(type`: Текст, eventInitDict: SpeechSynthesisErrorEventInit): SpeechSynthesisErrorEvent }


/**
* This Web Speech API interface contains information about the current state of SpeechSynthesisUtterance objects that have been processed in the speech service.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisEvent)
*/

тип SpeechSynthesisEvent = интерфейс на основе Event
{
  защищено 
  charIndex: Число

  защищено 
  charLength: Число

  защищено 
  elapsedTime: Число

  защищено 
  name: Текст

  защищено 
  utterance: SpeechSynthesisUtterance
}


внешнее
/*(!) var */ SpeechSynthesisEvent: объект { prototype: SpeechSynthesisEvent; при создании(type`: Текст, eventInitDict: SpeechSynthesisEventInit): SpeechSynthesisEvent }


тип SpeechSynthesisUtteranceEventMap = интерфейс
{
  "boundary": SpeechSynthesisEvent

  "end": SpeechSynthesisEvent

  "error": SpeechSynthesisErrorEvent

  "mark": SpeechSynthesisEvent

  "pause": SpeechSynthesisEvent

  "resume": SpeechSynthesisEvent

  "start": SpeechSynthesisEvent
}


/**
* This Web Speech API interface represents a speech request. It contains the content the speech service should read and information about how to read it (e.g. language, pitch and volume.)
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisUtterance)
*/

тип SpeechSynthesisUtterance = интерфейс на основе EventTarget
{
  lang: Текст

  onboundary: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  onend: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  onerror: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisErrorEvent): /*(!) any */ Объект?)?

  onmark: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  onpause: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  onresume: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  onstart: (операция(this: SpeechSynthesisUtterance, ev: SpeechSynthesisEvent): /*(!) any */ Объект?)?

  pitch: Число

  rate: Число

  text: Текст

  voice: SpeechSynthesisVoice?

  volume: Число

  операция addEventListener<K = /*(!) keyof SpeechSynthesisUtteranceEventMap */ Объект?>(type`: K, listener: операция(this: SpeechSynthesisUtterance, ev: /*(!) SpeechSynthesisUtteranceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof SpeechSynthesisUtteranceEventMap */ Объект?>(type`: K, listener: операция(this: SpeechSynthesisUtterance, ev: /*(!) SpeechSynthesisUtteranceEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ SpeechSynthesisUtterance: объект { prototype: SpeechSynthesisUtterance; при создании(text: Текст? = пусто): SpeechSynthesisUtterance }


/**
* This Web Speech API interface represents a voice that the system supports. Every SpeechSynthesisVoice has its own relative speech service including information about language, name and URI.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SpeechSynthesisVoice)
*/

тип SpeechSynthesisVoice = интерфейс
{
  защищено 
  default: ДаНет

  защищено 
  lang: Текст

  защищено 
  localService: ДаНет

  защищено 
  name: Текст

  защищено 
  voiceURI: Текст
}


внешнее
/*(!) var */ SpeechSynthesisVoice: объект { prototype: SpeechSynthesisVoice; при создании(): SpeechSynthesisVoice }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StaticRange) */

тип StaticRange = интерфейс на основе AbstractRange
{

}


внешнее
/*(!) var */ StaticRange: объект { prototype: StaticRange; при создании(init: StaticRangeInit): StaticRange }


/**
* The pan property takes a unitless value between -1 (full left pan) and 1 (full right pan). This interface was introduced as a much simpler way to apply a simple panning effect than having to use a full PannerNode.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StereoPannerNode)
*/

тип StereoPannerNode = интерфейс на основе AudioNode
{
  защищено 
  pan: AudioParam
}


внешнее
/*(!) var */ StereoPannerNode: объект { prototype: StereoPannerNode; при создании(context: BaseAudioContext, options: StereoPannerOptions? = пусто): StereoPannerNode }


/**
* This Web Storage API interface provides access to a particular domain's session or local storage. It allows, for example, the addition, modification, or deletion of stored data items.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Storage)
*/

тип Storage = интерфейс
{
  защищено 
  length: Число

  операция clear()

  операция getItem(key: Текст): Текст?

  операция key(index: Число): Текст?

  операция removeItem(key: Текст)

  операция setItem(key: Текст, value: Текст)

  /*(!) [name: string]: any*/
}


внешнее
/*(!) var */ Storage: объект { prototype: Storage; при создании(): Storage }


/**
* A StorageEvent is sent to a window when a storage area it has access to is changed within the context of another document.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StorageEvent)
*/

тип StorageEvent = интерфейс на основе Event
{

}


внешнее
/*(!) var */ StorageEvent: объект { prototype: StorageEvent; при создании(type`: Текст, eventInitDict: StorageEventInit? = пусто): StorageEvent }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StorageManager)
*/

тип StorageManager = интерфейс
{
  операция estimate(): Promise<StorageEstimate>

  операция getDirectory(): Promise<FileSystemDirectoryHandle>

  операция persist(): Promise<ДаНет>

  операция persisted(): Promise<ДаНет>
}


внешнее
/*(!) var */ StorageManager: объект { prototype: StorageManager; при создании(): StorageManager }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StylePropertyMap) */

тип StylePropertyMap = интерфейс на основе StylePropertyMapReadOnly
{
  #js.МассивПараметров
  операция append(property: Текст, values: Список<Объект? /*(!)CSSStyleValue | Текст*/>)

  операция clear()

  операция delete(property: Текст)

  #js.МассивПараметров
  операция set(property: Текст, values: Список<Объект? /*(!)CSSStyleValue | Текст*/>)
}


внешнее
/*(!) var */ StylePropertyMap: объект { prototype: StylePropertyMap; при создании(): StylePropertyMap }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/StylePropertyMapReadOnly) */

тип StylePropertyMapReadOnly = интерфейс
{
  защищено 
  size: Число

  операция get(property: Текст): CSSStyleValue?

  операция getAll(property: Текст): Список<CSSStyleValue>

  операция has(property: Текст): ДаНет

  операция forEach(callbackfn: операция(value: Список<CSSStyleValue>, key: Текст, parent: StylePropertyMapReadOnly), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ StylePropertyMapReadOnly: объект { prototype: StylePropertyMapReadOnly; при создании(): StylePropertyMapReadOnly }


/**
* A single style sheet. CSS style sheets will further implement the more specialized CSSStyleSheet interface.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StyleSheet)
*/

тип StyleSheet = интерфейс
{
  disabled: ДаНет

  защищено 
  href: Текст?

  защищено 
  media: MediaList

  защищено 
  ownerNode: Объект? /*(!)Element | ProcessingInstruction | пусто*/

  защищено 
  parentStyleSheet: CSSStyleSheet?

  защищено 
  title: Текст?

  защищено 
  type`: Текст
}


внешнее
/*(!) var */ StyleSheet: объект { prototype: StyleSheet; при создании(): StyleSheet }


/**
* A list of StyleSheet.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/StyleSheetList)
*/

тип StyleSheetList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): CSSStyleSheet?

  /*(!) [index: number]: CSSStyleSheet*/
}


внешнее
/*(!) var */ StyleSheetList: объект { prototype: StyleSheetList; при создании(): StyleSheetList }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubmitEvent) */

тип SubmitEvent = интерфейс на основе Event
{
  защищено 
  submitter: HTMLElement?
}


внешнее
/*(!) var */ SubmitEvent: объект { prototype: SubmitEvent; при создании(type`: Текст, eventInitDict: SubmitEventInit? = пусто): SubmitEvent }


/**
* This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)
*/

тип SubtleCrypto = интерфейс
{
  операция decrypt(algorithm: Объект? /*(!)AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams*/, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция deriveBits(algorithm: Объект? /*(!)AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params*/, baseKey: CryptoKey, length: Число): Promise<ArrayBuffer>

  операция deriveKey(algorithm: Объект? /*(!)AlgorithmIdentifier | EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params*/, baseKey: CryptoKey, derivedKeyType: Объект? /*(!)AlgorithmIdentifier | AesDerivedKeyParams | HmacImportParams | HkdfParams | Pbkdf2Params*/, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>

  операция encrypt(algorithm: Объект? /*(!)AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams*/, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>

  операция exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>

  операция exportKey(format: KeyFormat, key: CryptoKey): Promise<Объект? /*(!)ArrayBuffer | JsonWebKey*/>

  операция generateKey(algorithm: "Ed25519", extractable: ДаНет, keyUsages: ReadonlyArray<Объект? /*(!)"sign" | "verify"*/>): Promise<CryptoKeyPair>

  операция generateKey(algorithm: Объект? /*(!)RsaHashedKeyGenParams | EcKeyGenParams*/, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKeyPair>

  операция generateKey(algorithm: Объект? /*(!)AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params*/, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция generateKey(algorithm: AlgorithmIdentifier, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<Объект? /*(!)CryptoKeyPair | CryptoKey*/>

  операция importKey(format: "jwk", keyData: JsonWebKey, algorithm: Объект? /*(!)AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm*/, extractable: ДаНет, keyUsages: ReadonlyArray<KeyUsage>): Promise<CryptoKey>

  операция importKey(format: Exclude<KeyFormat, "jwk">, keyData: BufferSource, algorithm: Объект? /*(!)AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm*/, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция sign(algorithm: Объект? /*(!)AlgorithmIdentifier | RsaPssParams | EcdsaParams*/, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer>

  операция unwrapKey(format: KeyFormat, wrappedKey: BufferSource, unwrappingKey: CryptoKey, unwrapAlgorithm: Объект? /*(!)AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams*/, unwrappedKeyAlgorithm: Объект? /*(!)AlgorithmIdentifier | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | AesKeyAlgorithm*/, extractable: ДаНет, keyUsages: Список<KeyUsage>): Promise<CryptoKey>

  операция verify(algorithm: Объект? /*(!)AlgorithmIdentifier | RsaPssParams | EcdsaParams*/, key: CryptoKey, signature: BufferSource, data: BufferSource): Promise<ДаНет>

  операция wrapKey(format: KeyFormat, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: Объект? /*(!)AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams*/): Promise<ArrayBuffer>
}


внешнее
/*(!) var */ SubtleCrypto: объект { prototype: SubtleCrypto; при создании(): SubtleCrypto }


/**
* The textual content of Element or Attr. If an element has no markup within its content, it has a single child implementing Text that contains the element's text. However, if the element contains markup, it is parsed into information items and Text nodes that form its children.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Text)
*/

тип Text = интерфейс на основе CharacterData, Slottable
{
  защищено 
  wholeText: Текст

  операция splitText(offset: Число): Text
}


внешнее
/*(!) var */ Text: объект { prototype: Text; при создании(data: Текст? = пусто): Text }


/**
* A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)
*/

тип TextDecoder = интерфейс на основе TextDecoderCommon
{
  операция decode(input: AllowSharedBufferSource? = пусто, options: TextDecodeOptions? = пусто): Текст
}


внешнее
/*(!) var */ TextDecoder: объект { prototype: TextDecoder; при создании(label: Текст? = пусто, options: TextDecoderOptions? = пусто): TextDecoder }


тип TextDecoderCommon = интерфейс
{
  защищено 
  encoding: Текст

  защищено 
  fatal: ДаНет

  защищено 
  ignoreBOM: ДаНет
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */

тип TextDecoderStream = интерфейс на основе GenericTransformStream, TextDecoderCommon
{
  защищено 
  readable: ReadableStream<Текст>

  защищено 
  writable: WritableStream<BufferSource>
}


внешнее
/*(!) var */ TextDecoderStream: объект { prototype: TextDecoderStream; при создании(label: Текст? = пусто, options: TextDecoderOptions? = пусто): TextDecoderStream }


/**
* TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)
*/

тип TextEncoder = интерфейс на основе TextEncoderCommon
{
  операция encode(input: Текст? = пусто): Uint8Array

  операция encodeInto(source: Текст, destination: Uint8Array): TextEncoderEncodeIntoResult
}


внешнее
/*(!) var */ TextEncoder: объект { prototype: TextEncoder; при создании(): TextEncoder }


тип TextEncoderCommon = интерфейс
{
  защищено 
  encoding: Текст
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */

тип TextEncoderStream = интерфейс на основе GenericTransformStream, TextEncoderCommon
{
  защищено 
  readable: ReadableStream<Uint8Array>

  защищено 
  writable: WritableStream<Текст>
}


внешнее
/*(!) var */ TextEncoderStream: объект { prototype: TextEncoderStream; при создании(): TextEncoderStream }


/**
* The dimensions of a piece of text in the canvas, as created by the CanvasRenderingContext2D.measureText() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextMetrics)
*/

тип TextMetrics = интерфейс
{
  защищено 
  actualBoundingBoxAscent: Число

  защищено 
  actualBoundingBoxDescent: Число

  защищено 
  actualBoundingBoxLeft: Число

  защищено 
  actualBoundingBoxRight: Число

  защищено 
  fontBoundingBoxAscent: Число

  защищено 
  fontBoundingBoxDescent: Число

  защищено 
  width: Число
}


внешнее
/*(!) var */ TextMetrics: объект { prototype: TextMetrics; при создании(): TextMetrics }


тип TextTrackEventMap = интерфейс
{
  "cuechange": Event
}


/**
* This interface also inherits properties from EventTarget.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrack)
*/

тип TextTrack = интерфейс на основе EventTarget
{
  защищено 
  activeCues: TextTrackCueList?

  защищено 
  cues: TextTrackCueList?

  защищено 
  id: Текст

  защищено 
  inBandMetadataTrackDispatchType: Текст

  защищено 
  kind: TextTrackKind

  защищено 
  label: Текст

  защищено 
  language: Текст

  mode: TextTrackMode

  oncuechange: (операция(this: TextTrack, ev: Event): /*(!) any */ Объект?)?

  операция addCue(cue: TextTrackCue)

  операция removeCue(cue: TextTrackCue)

  операция addEventListener<K = /*(!) keyof TextTrackEventMap */ Объект?>(type`: K, listener: операция(this: TextTrack, ev: /*(!) TextTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackEventMap */ Объект?>(type`: K, listener: операция(this: TextTrack, ev: /*(!) TextTrackEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ TextTrack: объект { prototype: TextTrack; при создании(): TextTrack }


тип TextTrackCueEventMap = интерфейс
{
  "enter": Event

  "exit": Event
}


/**
* TextTrackCues represent a string of text that will be displayed for some duration of time on a TextTrack. This includes the start and end times that the cue will be displayed. A TextTrackCue cannot be used directly, instead one of the derived types (e.g. VTTCue) must be used.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackCue)
*/

тип TextTrackCue = интерфейс на основе EventTarget
{
  endTime: Число

  id: Текст

  onenter: (операция(this: TextTrackCue, ev: Event): /*(!) any */ Объект?)?

  onexit: (операция(this: TextTrackCue, ev: Event): /*(!) any */ Объект?)?

  pauseOnExit: ДаНет

  startTime: Число

  защищено 
  track: TextTrack?

  операция addEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type`: K, listener: операция(this: TextTrackCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type`: K, listener: операция(this: TextTrackCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ TextTrackCue: объект { prototype: TextTrackCue; при создании(): TextTrackCue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackCueList) */

тип TextTrackCueList = интерфейс
{
  защищено 
  length: Число

  операция getCueById(id: Текст): TextTrackCue?

  /*(!) [index: number]: TextTrackCue*/
}


внешнее
/*(!) var */ TextTrackCueList: объект { prototype: TextTrackCueList; при создании(): TextTrackCueList }


тип TextTrackListEventMap = интерфейс
{
  "addtrack": TrackEvent

  "change": Event

  "removetrack": TrackEvent
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextTrackList) */

тип TextTrackList = интерфейс на основе EventTarget
{
  защищено 
  length: Число

  onaddtrack: (операция(this: TextTrackList, ev: TrackEvent): /*(!) any */ Объект?)?

  onchange: (операция(this: TextTrackList, ev: Event): /*(!) any */ Объект?)?

  onremovetrack: (операция(this: TextTrackList, ev: TrackEvent): /*(!) any */ Объект?)?

  операция getTrackById(id: Текст): TextTrack?

  операция addEventListener<K = /*(!) keyof TextTrackListEventMap */ Объект?>(type`: K, listener: операция(this: TextTrackList, ev: /*(!) TextTrackListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackListEventMap */ Объект?>(type`: K, listener: операция(this: TextTrackList, ev: /*(!) TextTrackListEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  /*(!) [index: number]: TextTrack*/
}


внешнее
/*(!) var */ TextTrackList: объект { prototype: TextTrackList; при создании(): TextTrackList }


/**
* Used to represent a set of time ranges, primarily for the purpose of tracking which portions of media have been buffered when loading it for use by the <audio> and <video> elements.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TimeRanges)
*/

тип TimeRanges = интерфейс
{
  защищено 
  length: Число

  операция end(index: Число): Число

  операция start(index: Число): Число
}


внешнее
/*(!) var */ TimeRanges: объект { prototype: TimeRanges; при создании(): TimeRanges }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/ToggleEvent) */

тип ToggleEvent = интерфейс на основе Event
{
  защищено 
  newState: Текст

  защищено 
  oldState: Текст
}


внешнее
/*(!) var */ ToggleEvent: объект { prototype: ToggleEvent; при создании(type`: Текст, eventInitDict: ToggleEventInit? = пусто): ToggleEvent }


/**
* A single contact point on a touch-sensitive device. The contact point is commonly a finger or stylus and the device may be a touchscreen or trackpad.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Touch)
*/

тип Touch = интерфейс
{
  защищено 
  clientX: Число

  защищено 
  clientY: Число

  защищено 
  force: Число

  защищено 
  identifier: Число

  защищено 
  pageX: Число

  защищено 
  pageY: Число

  защищено 
  radiusX: Число

  защищено 
  radiusY: Число

  защищено 
  rotationAngle: Число

  защищено 
  screenX: Число

  защищено 
  screenY: Число

  защищено 
  target: EventTarget
}


внешнее
/*(!) var */ Touch: объект { prototype: Touch; при создании(touchInitDict: TouchInit): Touch }


/**
* An event sent when the state of contacts with a touch-sensitive surface changes. This surface can be a touch screen or trackpad, for example. The event can describe one or more points of contact with the screen and includes support for detecting movement, addition and removal of contact points, and so forth.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TouchEvent)
*/

тип TouchEvent = интерфейс на основе UIEvent
{
  защищено 
  altKey: ДаНет

  защищено 
  changedTouches: TouchList

  защищено 
  ctrlKey: ДаНет

  защищено 
  metaKey: ДаНет

  защищено 
  shiftKey: ДаНет

  защищено 
  targetTouches: TouchList

  защищено 
  touches: TouchList
}


внешнее
/*(!) var */ TouchEvent: объект { prototype: TouchEvent; при создании(type`: Текст, eventInitDict: TouchEventInit? = пусто): TouchEvent }


/**
* A list of contact points on a touch surface. For example, if the user has three fingers on the touch surface (such as a screen or trackpad), the corresponding TouchList object would have one Touch object for each finger, for a total of three entries.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TouchList)
*/

тип TouchList = интерфейс
{
  защищено 
  length: Число

  операция item(index: Число): Touch?

  /*(!) [index: number]: Touch*/
}


внешнее
/*(!) var */ TouchList: объект { prototype: TouchList; при создании(): TouchList }


/**
* The TrackEvent interface, part of the HTML DOM specification, is used for events which represent changes to the set of available tracks on an HTML media element; these events are addtrack and removetrack.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TrackEvent)
*/

тип TrackEvent = интерфейс на основе Event
{
  защищено 
  track: TextTrack?
}


внешнее
/*(!) var */ TrackEvent: объект { prototype: TrackEvent; при создании(type`: Текст, eventInitDict: TrackEventInit? = пусто): TrackEvent }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */

тип TransformStream<I, O> = интерфейс
{
  защищено 
  readable: ReadableStream<O>

  защищено 
  writable: WritableStream<I>
}


внешнее
/*(!) var */ TransformStream: объект { prototype: TransformStream; при создании(transformer: Transformer<I, O>? = пусто, writableStrategy: QueuingStrategy<I>? = пусто, readableStrategy: QueuingStrategy<O>? = пусто): TransformStream<I, O> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */

тип TransformStreamDefaultController<O> = интерфейс
{
  защищено 
  desiredSize: Число?

  операция enqueue(chunk: O? = пусто)

  операция error`(reason: /*(!) any */ Объект? = пусто)

  операция terminate()
}


внешнее
/*(!) var */ TransformStreamDefaultController: объект { prototype: TransformStreamDefaultController; при создании(): TransformStreamDefaultController }


/**
* Events providing information related to transitions.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransitionEvent)
*/

тип TransitionEvent = интерфейс на основе Event
{
  защищено 
  elapsedTime: Число

  защищено 
  propertyName: Текст

  защищено 
  pseudoElement: Текст
}


внешнее
/*(!) var */ TransitionEvent: объект { prototype: TransitionEvent; при создании(type`: Текст, transitionEventInitDict: TransitionEventInit? = пусто): TransitionEvent }


/**
* The nodes of a document subtree and a position within them.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TreeWalker)
*/

тип TreeWalker = интерфейс
{
  currentNode: Node

  защищено 
  filter: NodeFilter?

  защищено 
  root: Node

  защищено 
  whatToShow: Число

  операция firstChild(): Node?

  операция lastChild(): Node?

  операция nextNode(): Node?

  операция nextSibling(): Node?

  операция parentNode(): Node?

  операция previousNode(): Node?

  операция previousSibling(): Node?
}


внешнее
/*(!) var */ TreeWalker: объект { prototype: TreeWalker; при создании(): TreeWalker }


/**
* Simple user interface events.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/UIEvent)
*/

тип UIEvent = интерфейс на основе Event
{

}


внешнее
/*(!) var */ UIEvent: объект { prototype: UIEvent; при создании(type`: Текст, eventInitDict: UIEventInit? = пусто): UIEvent }


/**
* The URL interface represents an object providing static methods used for creating object URLs.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)
*/

тип URL = интерфейс
{
  hash: Текст

  host: Текст

  hostname: Текст

  href: Текст

  операция toString(): Текст

  защищено 
  origin: Текст

  password: Текст

  pathname: Текст

  port: Текст

  protocol: Текст

  search: Текст

  защищено 
  searchParams: URLSearchParams

  username: Текст

  операция toJSON(): Текст
}


внешнее
/*(!) var */ URL: объект { prototype: URL; при создании(url: Объект? /*(!)Текст | URL*/, base: Объект? /*(!)Текст | URL | пусто*/ = пусто): URL; операция canParse(url: Объект? /*(!)Текст | URL*/, base: Текст? = пусто): ДаНет; операция createObjectURL(obj: Объект? /*(!)Blob | MediaSource*/): Текст; операция revokeObjectURL(url: Текст) }


тип webkitURL = URL

внешнее
/*(!) var */ webkitURL: /*(!) typeof URL */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */

тип URLSearchParams = интерфейс
{
  защищено 
  size: Число

  операция append(name: Текст, value: Текст)

  операция delete(name: Текст, value: Текст? = пусто)

  операция get(name: Текст): Текст?

  операция getAll(name: Текст): Список<Текст>

  операция has(name: Текст, value: Текст? = пусто): ДаНет

  операция set(name: Текст, value: Текст)

  операция sort()

  операция toString(): Текст

  операция forEach(callbackfn: операция(value: Текст, key: Текст, parent: URLSearchParams), thisArg: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ URLSearchParams: объект { prototype: URLSearchParams; при создании(init: Объект? /*(!)Список<Список<Текст>> | Record<Текст, Текст> | Текст | URLSearchParams | пусто*/ = пусто): URLSearchParams }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/UserActivation) */

тип UserActivation = интерфейс
{
  защищено 
  hasBeenActive: ДаНет

  защищено 
  isActive: ДаНет
}


внешнее
/*(!) var */ UserActivation: объект { prototype: UserActivation; при создании(): UserActivation }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VTTCue) */

тип VTTCue = интерфейс на основе TextTrackCue
{
  align: AlignSetting

  line: LineAndPositionSetting

  lineAlign: LineAlignSetting

  position: LineAndPositionSetting

  positionAlign: PositionAlignSetting

  region: VTTRegion?

  size: Число

  snapToLines: ДаНет

  text: Текст

  vertical: DirectionSetting

  операция getCueAsHTML(): DocumentFragment

  операция addEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type`: K, listener: операция(this: VTTCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof TextTrackCueEventMap */ Объект?>(type`: K, listener: операция(this: VTTCue, ev: /*(!) TextTrackCueEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ VTTCue: объект { prototype: VTTCue; при создании(startTime: Число, endTime: Число, text: Текст): VTTCue }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VTTRegion) */

тип VTTRegion = интерфейс
{
  id: Текст

  lines: Число

  regionAnchorX: Число

  regionAnchorY: Число

  scroll: ScrollSetting

  viewportAnchorX: Число

  viewportAnchorY: Число

  width: Число
}


внешнее
/*(!) var */ VTTRegion: объект { prototype: VTTRegion; при создании(): VTTRegion }


/**
* The validity states that an element can be in, with respect to constraint validation. Together, they help explain why an element's value fails to validate, if it's not valid.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ValidityState)
*/

тип ValidityState = интерфейс
{
  защищено 
  badInput: ДаНет

  защищено 
  customError: ДаНет

  защищено 
  patternMismatch: ДаНет

  защищено 
  rangeOverflow: ДаНет

  защищено 
  rangeUnderflow: ДаНет

  защищено 
  stepMismatch: ДаНет

  защищено 
  tooLong: ДаНет

  защищено 
  tooShort: ДаНет

  защищено 
  typeMismatch: ДаНет

  защищено 
  valid: ДаНет

  защищено 
  valueMissing: ДаНет
}


внешнее
/*(!) var */ ValidityState: объект { prototype: ValidityState; при создании(): ValidityState }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoColorSpace) */

тип VideoColorSpace = интерфейс
{
  защищено 
  fullRange: ДаНет?

  защищено 
  matrix: VideoMatrixCoefficients?

  защищено 
  primaries: VideoColorPrimaries?

  защищено 
  transfer: VideoTransferCharacteristics?

  операция toJSON(): VideoColorSpaceInit
}


внешнее
/*(!) var */ VideoColorSpace: объект { prototype: VideoColorSpace; при создании(init: VideoColorSpaceInit? = пусто): VideoColorSpace }


тип VideoDecoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoDecoder)
*/

тип VideoDecoder = интерфейс на основе EventTarget
{
  защищено 
  decodeQueueSize: Число

  ondequeue: (операция(this: VideoDecoder, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoDecoderConfig)

  операция decode(chunk: EncodedVideoChunk)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type`: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof VideoDecoderEventMap */ Объект?>(type`: K, listener: операция(this: VideoDecoder, ev: /*(!) VideoDecoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ VideoDecoder: объект { prototype: VideoDecoder; при создании(init: VideoDecoderInit): VideoDecoder; операция isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport> }


тип VideoEncoderEventMap = интерфейс
{
  "dequeue": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoEncoder)
*/

тип VideoEncoder = интерфейс на основе EventTarget
{
  защищено 
  encodeQueueSize: Число

  ondequeue: (операция(this: VideoEncoder, ev: Event): /*(!) any */ Объект?)?

  защищено 
  state: CodecState

  операция close()

  операция configure(config: VideoEncoderConfig)

  операция encode(frame: VideoFrame, options: VideoEncoderEncodeOptions? = пусто)

  операция flush(): Promise<Ничего>

  операция reset()

  операция addEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type`: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof VideoEncoderEventMap */ Объект?>(type`: K, listener: операция(this: VideoEncoder, ev: /*(!) VideoEncoderEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ VideoEncoder: объект { prototype: VideoEncoder; при создании(init: VideoEncoderInit): VideoEncoder; операция isConfigSupported(config: VideoEncoderConfig): Promise<VideoEncoderSupport> }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoFrame) */

тип VideoFrame = интерфейс
{
  защищено 
  codedHeight: Число

  защищено 
  codedRect: DOMRectReadOnly?

  защищено 
  codedWidth: Число

  защищено 
  colorSpace: VideoColorSpace

  защищено 
  displayHeight: Число

  защищено 
  displayWidth: Число

  защищено 
  duration: Число?

  защищено 
  format: VideoPixelFormat?

  защищено 
  timestamp: Число

  защищено 
  visibleRect: DOMRectReadOnly?

  операция allocationSize(options: VideoFrameCopyToOptions? = пусто): Число

  операция clone(): VideoFrame

  операция close()

  операция copyTo(destination: BufferSource, options: VideoFrameCopyToOptions? = пусто): Promise<Список<PlaneLayout>>
}


внешнее
/*(!) var */ VideoFrame: объект { prototype: VideoFrame; при создании(image: CanvasImageSource, init: VideoFrameInit? = пусто): VideoFrame; при создании(data: BufferSource, init: VideoFrameBufferInit): VideoFrame }


/**
* Returned by the HTMLVideoElement.getVideoPlaybackQuality() method and contains metrics that can be used to determine the playback quality of a video.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/VideoPlaybackQuality)
*/

тип VideoPlaybackQuality = интерфейс
{

}


внешнее
/*(!) var */ VideoPlaybackQuality: объект { prototype: VideoPlaybackQuality; при создании(): VideoPlaybackQuality }


тип VisualViewportEventMap = интерфейс
{
  "resize": Event

  "scroll": Event
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/VisualViewport) */

тип VisualViewport = интерфейс на основе EventTarget
{
  защищено 
  height: Число

  защищено 
  offsetLeft: Число

  защищено 
  offsetTop: Число

  onresize: (операция(this: VisualViewport, ev: Event): /*(!) any */ Объект?)?

  onscroll: (операция(this: VisualViewport, ev: Event): /*(!) any */ Объект?)?

  защищено 
  pageLeft: Число

  защищено 
  pageTop: Число

  защищено 
  scale: Число

  защищено 
  width: Число

  операция addEventListener<K = /*(!) keyof VisualViewportEventMap */ Объект?>(type`: K, listener: операция(this: VisualViewport, ev: /*(!) VisualViewportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof VisualViewportEventMap */ Объект?>(type`: K, listener: операция(this: VisualViewport, ev: /*(!) VisualViewportEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ VisualViewport: объект { prototype: VisualViewport; при создании(): VisualViewport }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_color_buffer_float) */

тип WEBGL_color_buffer_float = интерфейс
{
  защищено 
  RGBA32F_EXT: 0x8814

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211

  защищено 
  UNSIGNED_NORMALIZED_EXT: 0x8C17
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_astc) */

тип WEBGL_compressed_texture_astc = интерфейс
{
  операция getSupportedProfiles(): Список<Текст>

  защищено 
  COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93B0

  защищено 
  COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93B1

  защищено 
  COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93B2

  защищено 
  COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93B3

  защищено 
  COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93B4

  защищено 
  COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93B5

  защищено 
  COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93B6

  защищено 
  COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93B7

  защищено 
  COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93B8

  защищено 
  COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93B9

  защищено 
  COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93BA

  защищено 
  COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93BB

  защищено 
  COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93BC

  защищено 
  COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93BD

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93D0

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93D1

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93D2

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93D3

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93D4

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93D5

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93D6

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93D7

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93D8

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93D9

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93DA

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93DB

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93DC

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93DD
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc) */

тип WEBGL_compressed_texture_etc = интерфейс
{
  защищено 
  COMPRESSED_R11_EAC: 0x9270

  защищено 
  COMPRESSED_SIGNED_R11_EAC: 0x9271

  защищено 
  COMPRESSED_RG11_EAC: 0x9272

  защищено 
  COMPRESSED_SIGNED_RG11_EAC: 0x9273

  защищено 
  COMPRESSED_RGB8_ETC2: 0x9274

  защищено 
  COMPRESSED_SRGB8_ETC2: 0x9275

  защищено 
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9276

  защищено 
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9277

  защищено 
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278

  защищено 
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9279
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_etc1) */

тип WEBGL_compressed_texture_etc1 = интерфейс
{
  защищено 
  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_pvrtc) */

тип WEBGL_compressed_texture_pvrtc = интерфейс
{
  защищено 
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00

  защищено 
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01

  защищено 
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02

  защищено 
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03
}


/**
* The WEBGL_compressed_texture_s3tc extension is part of the WebGL API and exposes four S3TC compressed texture formats.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc)
*/

тип WEBGL_compressed_texture_s3tc = интерфейс
{
  защищено 
  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0

  защищено 
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1

  защищено 
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2

  защищено 
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_compressed_texture_s3tc_srgb) */

тип WEBGL_compressed_texture_s3tc_srgb = интерфейс
{
  защищено 
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8C4C

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8C4D

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8C4E

  защищено 
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8C4F
}


/**
* The WEBGL_debug_renderer_info extension is part of the WebGL API and exposes two constants with information about the graphics driver for debugging purposes.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_renderer_info)
*/

тип WEBGL_debug_renderer_info = интерфейс
{
  защищено 
  UNMASKED_VENDOR_WEBGL: 0x9245

  защищено 
  UNMASKED_RENDERER_WEBGL: 0x9246
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_debug_shaders) */

тип WEBGL_debug_shaders = интерфейс
{
  операция getTranslatedShaderSource(shader: WebGLShader): Текст
}


/**
* The WEBGL_depth_texture extension is part of the WebGL API and defines 2D depth and depth-stencil textures.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_depth_texture)
*/

тип WEBGL_depth_texture = интерфейс
{
  защищено 
  UNSIGNED_INT_24_8_WEBGL: 0x84FA
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_draw_buffers) */

тип WEBGL_draw_buffers = интерфейс
{
  операция drawBuffersWEBGL(buffers: Список<GLenum>)

  защищено 
  COLOR_ATTACHMENT0_WEBGL: 0x8CE0

  защищено 
  COLOR_ATTACHMENT1_WEBGL: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2_WEBGL: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3_WEBGL: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4_WEBGL: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5_WEBGL: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6_WEBGL: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7_WEBGL: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8_WEBGL: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9_WEBGL: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10_WEBGL: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11_WEBGL: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12_WEBGL: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13_WEBGL: 0x8CED

  защищено 
  COLOR_ATTACHMENT14_WEBGL: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15_WEBGL: 0x8CEF

  защищено 
  DRAW_BUFFER0_WEBGL: 0x8825

  защищено 
  DRAW_BUFFER1_WEBGL: 0x8826

  защищено 
  DRAW_BUFFER2_WEBGL: 0x8827

  защищено 
  DRAW_BUFFER3_WEBGL: 0x8828

  защищено 
  DRAW_BUFFER4_WEBGL: 0x8829

  защищено 
  DRAW_BUFFER5_WEBGL: 0x882A

  защищено 
  DRAW_BUFFER6_WEBGL: 0x882B

  защищено 
  DRAW_BUFFER7_WEBGL: 0x882C

  защищено 
  DRAW_BUFFER8_WEBGL: 0x882D

  защищено 
  DRAW_BUFFER9_WEBGL: 0x882E

  защищено 
  DRAW_BUFFER10_WEBGL: 0x882F

  защищено 
  DRAW_BUFFER11_WEBGL: 0x8830

  защищено 
  DRAW_BUFFER12_WEBGL: 0x8831

  защищено 
  DRAW_BUFFER13_WEBGL: 0x8832

  защищено 
  DRAW_BUFFER14_WEBGL: 0x8833

  защищено 
  DRAW_BUFFER15_WEBGL: 0x8834

  защищено 
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF

  защищено 
  MAX_DRAW_BUFFERS_WEBGL: 0x8824
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_lose_context) */

тип WEBGL_lose_context = интерфейс
{
  операция loseContext()

  операция restoreContext()
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WEBGL_multi_draw) */

тип WEBGL_multi_draw = интерфейс
{
  операция multiDrawArraysInstancedWEBGL(mode: GLenum, firstsList: Объект? /*(!)Int32Array | Список<GLint>*/, firstsOffset: GLuint, countsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, countsOffset: GLuint, instanceCountsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawArraysWEBGL(mode: GLenum, firstsList: Объект? /*(!)Int32Array | Список<GLint>*/, firstsOffset: GLuint, countsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, countsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsInstancedWEBGL(mode: GLenum, countsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, countsOffset: GLuint, type`: GLenum, offsetsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, offsetsOffset: GLuint, instanceCountsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, instanceCountsOffset: GLuint, drawcount: GLsizei)

  операция multiDrawElementsWEBGL(mode: GLenum, countsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, countsOffset: GLuint, type`: GLenum, offsetsList: Объект? /*(!)Int32Array | Список<GLsizei>*/, offsetsOffset: GLuint, drawcount: GLsizei)
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WakeLock)
*/

тип WakeLock = интерфейс
{
  операция request(type`: WakeLockType? = пусто): Promise<WakeLockSentinel>
}


внешнее
/*(!) var */ WakeLock: объект { prototype: WakeLock; при создании(): WakeLock }


тип WakeLockSentinelEventMap = интерфейс
{
  "release": Event
}


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WakeLockSentinel)
*/

тип WakeLockSentinel = интерфейс на основе EventTarget
{
  onrelease: (операция(this: WakeLockSentinel, ev: Event): /*(!) any */ Объект?)?

  защищено 
  released: ДаНет

  защищено 
  type`: WakeLockType

  операция release(): Promise<Ничего>

  операция addEventListener<K = /*(!) keyof WakeLockSentinelEventMap */ Объект?>(type`: K, listener: операция(this: WakeLockSentinel, ev: /*(!) WakeLockSentinelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof WakeLockSentinelEventMap */ Объект?>(type`: K, listener: операция(this: WakeLockSentinel, ev: /*(!) WakeLockSentinelEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ WakeLockSentinel: объект { prototype: WakeLockSentinel; при создании(): WakeLockSentinel }


/**
* A WaveShaperNode always has exactly one input and one output.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WaveShaperNode)
*/

тип WaveShaperNode = интерфейс на основе AudioNode
{
  curve: Float32Array?

  oversample: OverSampleType
}


внешнее
/*(!) var */ WaveShaperNode: объект { prototype: WaveShaperNode; при создании(context: BaseAudioContext, options: WaveShaperOptions? = пусто): WaveShaperNode }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGL2RenderingContext) */

тип WebGL2RenderingContext = интерфейс на основе WebGL2RenderingContextBase, WebGL2RenderingContextOverloads, WebGLRenderingContextBase
{

}


внешнее
/*(!) var */ WebGL2RenderingContext: объект { prototype: WebGL2RenderingContext; при создании(): WebGL2RenderingContext; защищено  READ_BUFFER: 0x0C02; защищено  UNPACK_ROW_LENGTH: 0x0CF2; защищено  UNPACK_SKIP_ROWS: 0x0CF3; защищено  UNPACK_SKIP_PIXELS: 0x0CF4; защищено  PACK_ROW_LENGTH: 0x0D02; защищено  PACK_SKIP_ROWS: 0x0D03; защищено  PACK_SKIP_PIXELS: 0x0D04; защищено  COLOR: 0x1800; защищено  DEPTH: 0x1801; защищено  STENCIL: 0x1802; защищено  RED: 0x1903; защищено  RGB8: 0x8051; защищено  RGBA8: 0x8058; защищено  RGB10_A2: 0x8059; защищено  TEXTURE_BINDING_3D: 0x806A; защищено  UNPACK_SKIP_IMAGES: 0x806D; защищено  UNPACK_IMAGE_HEIGHT: 0x806E; защищено  TEXTURE_3D: 0x806F; защищено  TEXTURE_WRAP_R: 0x8072; защищено  MAX_3D_TEXTURE_SIZE: 0x8073; защищено  UNSIGNED_INT_2_10_10_10_REV: 0x8368; защищено  MAX_ELEMENTS_VERTICES: 0x80E8; защищено  MAX_ELEMENTS_INDICES: 0x80E9; защищено  TEXTURE_MIN_LOD: 0x813A; защищено  TEXTURE_MAX_LOD: 0x813B; защищено  TEXTURE_BASE_LEVEL: 0x813C; защищено  TEXTURE_MAX_LEVEL: 0x813D; защищено  MIN: 0x8007; защищено  MAX: 0x8008; защищено  DEPTH_COMPONENT24: 0x81A6; защищено  MAX_TEXTURE_LOD_BIAS: 0x84FD; защищено  TEXTURE_COMPARE_MODE: 0x884C; защищено  TEXTURE_COMPARE_FUNC: 0x884D; защищено  CURRENT_QUERY: 0x8865; защищено  QUERY_RESULT: 0x8866; защищено  QUERY_RESULT_AVAILABLE: 0x8867; защищено  STREAM_READ: 0x88E1; защищено  STREAM_COPY: 0x88E2; защищено  STATIC_READ: 0x88E5; защищено  STATIC_COPY: 0x88E6; защищено  DYNAMIC_READ: 0x88E9; защищено  DYNAMIC_COPY: 0x88EA; защищено  MAX_DRAW_BUFFERS: 0x8824; защищено  DRAW_BUFFER0: 0x8825; защищено  DRAW_BUFFER1: 0x8826; защищено  DRAW_BUFFER2: 0x8827; защищено  DRAW_BUFFER3: 0x8828; защищено  DRAW_BUFFER4: 0x8829; защищено  DRAW_BUFFER5: 0x882A; защищено  DRAW_BUFFER6: 0x882B; защищено  DRAW_BUFFER7: 0x882C; защищено  DRAW_BUFFER8: 0x882D; защищено  DRAW_BUFFER9: 0x882E; защищено  DRAW_BUFFER10: 0x882F; защищено  DRAW_BUFFER11: 0x8830; защищено  DRAW_BUFFER12: 0x8831; защищено  DRAW_BUFFER13: 0x8832; защищено  DRAW_BUFFER14: 0x8833; защищено  DRAW_BUFFER15: 0x8834; защищено  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49; защищено  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A; защищено  SAMPLER_3D: 0x8B5F; защищено  SAMPLER_2D_SHADOW: 0x8B62; защищено  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B; защищено  PIXEL_PACK_BUFFER: 0x88EB; защищено  PIXEL_UNPACK_BUFFER: 0x88EC; защищено  PIXEL_PACK_BUFFER_BINDING: 0x88ED; защищено  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF; защищено  FLOAT_MAT2x3: 0x8B65; защищено  FLOAT_MAT2x4: 0x8B66; защищено  FLOAT_MAT3x2: 0x8B67; защищено  FLOAT_MAT3x4: 0x8B68; защищено  FLOAT_MAT4x2: 0x8B69; защищено  FLOAT_MAT4x3: 0x8B6A; защищено  SRGB: 0x8C40; защищено  SRGB8: 0x8C41; защищено  SRGB8_ALPHA8: 0x8C43; защищено  COMPARE_REF_TO_TEXTURE: 0x884E; защищено  RGBA32F: 0x8814; защищено  RGB32F: 0x8815; защищено  RGBA16F: 0x881A; защищено  RGB16F: 0x881B; защищено  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD; защищено  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF; защищено  MIN_PROGRAM_TEXEL_OFFSET: 0x8904; защищено  MAX_PROGRAM_TEXEL_OFFSET: 0x8905; защищено  MAX_VARYING_COMPONENTS: 0x8B4B; защищено  TEXTURE_2D_ARRAY: 0x8C1A; защищено  TEXTURE_BINDING_2D_ARRAY: 0x8C1D; защищено  R11F_G11F_B10F: 0x8C3A; защищено  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B; защищено  RGB9_E5: 0x8C3D; защищено  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E; защищено  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80; защищено  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83; защищено  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84; защищено  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85; защищено  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88; защищено  RASTERIZER_DISCARD: 0x8C89; защищено  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A; защищено  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B; защищено  INTERLEAVED_ATTRIBS: 0x8C8C; защищено  SEPARATE_ATTRIBS: 0x8C8D; защищено  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E; защищено  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F; защищено  RGBA32UI: 0x8D70; защищено  RGB32UI: 0x8D71; защищено  RGBA16UI: 0x8D76; защищено  RGB16UI: 0x8D77; защищено  RGBA8UI: 0x8D7C; защищено  RGB8UI: 0x8D7D; защищено  RGBA32I: 0x8D82; защищено  RGB32I: 0x8D83; защищено  RGBA16I: 0x8D88; защищено  RGB16I: 0x8D89; защищено  RGBA8I: 0x8D8E; защищено  RGB8I: 0x8D8F; защищено  RED_INTEGER: 0x8D94; защищено  RGB_INTEGER: 0x8D98; защищено  RGBA_INTEGER: 0x8D99; защищено  SAMPLER_2D_ARRAY: 0x8DC1; защищено  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4; защищено  SAMPLER_CUBE_SHADOW: 0x8DC5; защищено  UNSIGNED_INT_VEC2: 0x8DC6; защищено  UNSIGNED_INT_VEC3: 0x8DC7; защищено  UNSIGNED_INT_VEC4: 0x8DC8; защищено  INT_SAMPLER_2D: 0x8DCA; защищено  INT_SAMPLER_3D: 0x8DCB; защищено  INT_SAMPLER_CUBE: 0x8DCC; защищено  INT_SAMPLER_2D_ARRAY: 0x8DCF; защищено  UNSIGNED_INT_SAMPLER_2D: 0x8DD2; защищено  UNSIGNED_INT_SAMPLER_3D: 0x8DD3; защищено  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4; защищено  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7; защищено  DEPTH_COMPONENT32F: 0x8CAC; защищено  DEPTH32F_STENCIL8: 0x8CAD; защищено  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD; защищено  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210; защищено  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211; защищено  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212; защищено  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213; защищено  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214; защищено  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215; защищено  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216; защищено  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217; защищено  FRAMEBUFFER_DEFAULT: 0x8218; защищено  UNSIGNED_INT_24_8: 0x84FA; защищено  DEPTH24_STENCIL8: 0x88F0; защищено  UNSIGNED_NORMALIZED: 0x8C17; защищено  DRAW_FRAMEBUFFER_BINDING: 0x8CA6; защищено  READ_FRAMEBUFFER: 0x8CA8; защищено  DRAW_FRAMEBUFFER: 0x8CA9; защищено  READ_FRAMEBUFFER_BINDING: 0x8CAA; защищено  RENDERBUFFER_SAMPLES: 0x8CAB; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4; защищено  MAX_COLOR_ATTACHMENTS: 0x8CDF; защищено  COLOR_ATTACHMENT1: 0x8CE1; защищено  COLOR_ATTACHMENT2: 0x8CE2; защищено  COLOR_ATTACHMENT3: 0x8CE3; защищено  COLOR_ATTACHMENT4: 0x8CE4; защищено  COLOR_ATTACHMENT5: 0x8CE5; защищено  COLOR_ATTACHMENT6: 0x8CE6; защищено  COLOR_ATTACHMENT7: 0x8CE7; защищено  COLOR_ATTACHMENT8: 0x8CE8; защищено  COLOR_ATTACHMENT9: 0x8CE9; защищено  COLOR_ATTACHMENT10: 0x8CEA; защищено  COLOR_ATTACHMENT11: 0x8CEB; защищено  COLOR_ATTACHMENT12: 0x8CEC; защищено  COLOR_ATTACHMENT13: 0x8CED; защищено  COLOR_ATTACHMENT14: 0x8CEE; защищено  COLOR_ATTACHMENT15: 0x8CEF; защищено  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56; защищено  MAX_SAMPLES: 0x8D57; защищено  HALF_FLOAT: 0x140B; защищено  RG: 0x8227; защищено  RG_INTEGER: 0x8228; защищено  R8: 0x8229; защищено  RG8: 0x822B; защищено  R16F: 0x822D; защищено  R32F: 0x822E; защищено  RG16F: 0x822F; защищено  RG32F: 0x8230; защищено  R8I: 0x8231; защищено  R8UI: 0x8232; защищено  R16I: 0x8233; защищено  R16UI: 0x8234; защищено  R32I: 0x8235; защищено  R32UI: 0x8236; защищено  RG8I: 0x8237; защищено  RG8UI: 0x8238; защищено  RG16I: 0x8239; защищено  RG16UI: 0x823A; защищено  RG32I: 0x823B; защищено  RG32UI: 0x823C; защищено  VERTEX_ARRAY_BINDING: 0x85B5; защищено  R8_SNORM: 0x8F94; защищено  RG8_SNORM: 0x8F95; защищено  RGB8_SNORM: 0x8F96; защищено  RGBA8_SNORM: 0x8F97; защищено  SIGNED_NORMALIZED: 0x8F9C; защищено  COPY_READ_BUFFER: 0x8F36; защищено  COPY_WRITE_BUFFER: 0x8F37; защищено  COPY_READ_BUFFER_BINDING: 0x8F36; защищено  COPY_WRITE_BUFFER_BINDING: 0x8F37; защищено  UNIFORM_BUFFER: 0x8A11; защищено  UNIFORM_BUFFER_BINDING: 0x8A28; защищено  UNIFORM_BUFFER_START: 0x8A29; защищено  UNIFORM_BUFFER_SIZE: 0x8A2A; защищено  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B; защищено  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D; защищено  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E; защищено  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F; защищено  MAX_UNIFORM_BLOCK_SIZE: 0x8A30; защищено  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31; защищено  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33; защищено  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34; защищено  ACTIVE_UNIFORM_BLOCKS: 0x8A36; защищено  UNIFORM_TYPE: 0x8A37; защищено  UNIFORM_SIZE: 0x8A38; защищено  UNIFORM_BLOCK_INDEX: 0x8A3A; защищено  UNIFORM_OFFSET: 0x8A3B; защищено  UNIFORM_ARRAY_STRIDE: 0x8A3C; защищено  UNIFORM_MATRIX_STRIDE: 0x8A3D; защищено  UNIFORM_IS_ROW_MAJOR: 0x8A3E; защищено  UNIFORM_BLOCK_BINDING: 0x8A3F; защищено  UNIFORM_BLOCK_DATA_SIZE: 0x8A40; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42; защищено  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43; защищено  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44; защищено  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46; защищено  INVALID_INDEX: 0xFFFFFFFF; защищено  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122; защищено  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125; защищено  MAX_SERVER_WAIT_TIMEOUT: 0x9111; защищено  OBJECT_TYPE: 0x9112; защищено  SYNC_CONDITION: 0x9113; защищено  SYNC_STATUS: 0x9114; защищено  SYNC_FLAGS: 0x9115; защищено  SYNC_FENCE: 0x9116; защищено  SYNC_GPU_COMMANDS_COMPLETE: 0x9117; защищено  UNSIGNALED: 0x9118; защищено  SIGNALED: 0x9119; защищено  ALREADY_SIGNALED: 0x911A; защищено  TIMEOUT_EXPIRED: 0x911B; защищено  CONDITION_SATISFIED: 0x911C; защищено  WAIT_FAILED: 0x911D; защищено  SYNC_FLUSH_COMMANDS_BIT: 0x00000001; защищено  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE; защищено  ANY_SAMPLES_PASSED: 0x8C2F; защищено  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A; защищено  SAMPLER_BINDING: 0x8919; защищено  RGB10_A2UI: 0x906F; защищено  INT_2_10_10_10_REV: 0x8D9F; защищено  TRANSFORM_FEEDBACK: 0x8E22; защищено  TRANSFORM_FEEDBACK_PAUSED: 0x8E23; защищено  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24; защищено  TRANSFORM_FEEDBACK_BINDING: 0x8E25; защищено  TEXTURE_IMMUTABLE_FORMAT: 0x912F; защищено  MAX_ELEMENT_INDEX: 0x8D6B; защищено  TEXTURE_IMMUTABLE_LEVELS: 0x82DF; защищено  TIMEOUT_IGNORED: -1; защищено  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGL2RenderingContextBase = интерфейс
{
  операция beginQuery(target: GLenum, query: WebGLQuery)

  операция beginTransformFeedback(primitiveMode: GLenum)

  операция bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer?)

  операция bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer?, offset: GLintptr, size: GLsizeiptr)

  операция bindSampler(unit: GLuint, sampler: WebGLSampler?)

  операция bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback?)

  операция bindVertexArray(array: WebGLVertexArrayObject?)

  операция blitFramebuffer(srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum)

  операция clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint)

  операция clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint? = пусто)

  операция clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint? = пусто)

  операция clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint? = пусто)

  операция clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint? = пусто, srcLengthOverride: GLuint? = пусто)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint? = пусто, srcLengthOverride: GLuint? = пусто)

  операция copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr, writeOffset: GLintptr, size: GLsizeiptr)

  операция copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createQuery(): WebGLQuery?

  операция createSampler(): WebGLSampler?

  операция createTransformFeedback(): WebGLTransformFeedback?

  операция createVertexArray(): WebGLVertexArrayObject?

  операция deleteQuery(query: WebGLQuery?)

  операция deleteSampler(sampler: WebGLSampler?)

  операция deleteSync(sync: WebGLSync?)

  операция deleteTransformFeedback(tf: WebGLTransformFeedback?)

  операция deleteVertexArray(vertexArray: WebGLVertexArrayObject?)

  операция drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei)

  операция drawBuffers(buffers: Список<GLenum>)

  операция drawElementsInstanced(mode: GLenum, count: GLsizei, type`: GLenum, offset: GLintptr, instanceCount: GLsizei)

  операция drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, type`: GLenum, offset: GLintptr)

  операция endQuery(target: GLenum)

  операция endTransformFeedback()

  операция fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync?

  операция framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture?, level: GLint, layer: GLint)

  операция getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): Текст?

  операция getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getActiveUniforms(program: WebGLProgram, uniformIndices: Список<GLuint>, pname: GLenum): /*(!) any */ Объект?

  операция getBufferSubData(target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView, dstOffset: GLuint? = пусто, length: GLuint? = пусто)

  операция getFragDataLocation(program: WebGLProgram, name: Текст): GLint

  операция getIndexedParameter(target: GLenum, index: GLuint): /*(!) any */ Объект?

  операция getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getQuery(target: GLenum, pname: GLenum): WebGLQuery?

  операция getQueryParameter(query: WebGLQuery, pname: GLenum): /*(!) any */ Объект?

  операция getSamplerParameter(sampler: WebGLSampler, pname: GLenum): /*(!) any */ Объект?

  операция getSyncParameter(sync: WebGLSync, pname: GLenum): /*(!) any */ Объект?

  операция getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo?

  операция getUniformBlockIndex(program: WebGLProgram, uniformBlockName: Текст): GLuint

  операция getUniformIndices(program: WebGLProgram, uniformNames: Список<Текст>): Список<GLuint>?

  операция invalidateFramebuffer(target: GLenum, attachments: Список<GLenum>)

  операция invalidateSubFramebuffer(target: GLenum, attachments: Список<GLenum>, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция isQuery(query: WebGLQuery?): GLboolean

  операция isSampler(sampler: WebGLSampler?): GLboolean

  операция isSync(sync: WebGLSync?): GLboolean

  операция isTransformFeedback(tf: WebGLTransformFeedback?): GLboolean

  операция isVertexArray(vertexArray: WebGLVertexArrayObject?): GLboolean

  операция pauseTransformFeedback()

  операция readBuffer(src: GLenum)

  операция renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция resumeTransformFeedback()

  операция samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat)

  операция samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type`: GLenum, pboOffset: GLintptr)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type`: GLenum, srcData: ArrayBufferView?)

  операция texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, border: GLint, format: GLenum, type`: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei, depth: GLsizei)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type`: GLenum, pboOffset: GLintptr)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, type`: GLenum, srcData: ArrayBufferView?, srcOffset: GLuint? = пусто)

  операция transformFeedbackVaryings(program: WebGLProgram, varyings: Список<Текст>, bufferMode: GLenum)

  операция uniform1ui(location: WebGLUniformLocation?, v0: GLuint)

  операция uniform1uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform2ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint)

  операция uniform2uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform3ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint, v2: GLuint)

  операция uniform3uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform4ui(location: WebGLUniformLocation?, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint)

  операция uniform4uiv(location: WebGLUniformLocation?, data: Uint32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint)

  операция uniformMatrix2x3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix2x4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix3x2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix3x4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix4x2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix4x3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция vertexAttribDivisor(index: GLuint, divisor: GLuint)

  операция vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint)

  операция vertexAttribI4iv(index: GLuint, values: Int32List)

  операция vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint)

  операция vertexAttribI4uiv(index: GLuint, values: Uint32List)

  операция vertexAttribIPointer(index: GLuint, size: GLint, type`: GLenum, stride: GLsizei, offset: GLintptr)

  операция waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64)

  защищено 
  READ_BUFFER: 0x0C02

  защищено 
  UNPACK_ROW_LENGTH: 0x0CF2

  защищено 
  UNPACK_SKIP_ROWS: 0x0CF3

  защищено 
  UNPACK_SKIP_PIXELS: 0x0CF4

  защищено 
  PACK_ROW_LENGTH: 0x0D02

  защищено 
  PACK_SKIP_ROWS: 0x0D03

  защищено 
  PACK_SKIP_PIXELS: 0x0D04

  защищено 
  COLOR: 0x1800

  защищено 
  DEPTH: 0x1801

  защищено 
  STENCIL: 0x1802

  защищено 
  RED: 0x1903

  защищено 
  RGB8: 0x8051

  защищено 
  RGBA8: 0x8058

  защищено 
  RGB10_A2: 0x8059

  защищено 
  TEXTURE_BINDING_3D: 0x806A

  защищено 
  UNPACK_SKIP_IMAGES: 0x806D

  защищено 
  UNPACK_IMAGE_HEIGHT: 0x806E

  защищено 
  TEXTURE_3D: 0x806F

  защищено 
  TEXTURE_WRAP_R: 0x8072

  защищено 
  MAX_3D_TEXTURE_SIZE: 0x8073

  защищено 
  UNSIGNED_INT_2_10_10_10_REV: 0x8368

  защищено 
  MAX_ELEMENTS_VERTICES: 0x80E8

  защищено 
  MAX_ELEMENTS_INDICES: 0x80E9

  защищено 
  TEXTURE_MIN_LOD: 0x813A

  защищено 
  TEXTURE_MAX_LOD: 0x813B

  защищено 
  TEXTURE_BASE_LEVEL: 0x813C

  защищено 
  TEXTURE_MAX_LEVEL: 0x813D

  защищено 
  MIN: 0x8007

  защищено 
  MAX: 0x8008

  защищено 
  DEPTH_COMPONENT24: 0x81A6

  защищено 
  MAX_TEXTURE_LOD_BIAS: 0x84FD

  защищено 
  TEXTURE_COMPARE_MODE: 0x884C

  защищено 
  TEXTURE_COMPARE_FUNC: 0x884D

  защищено 
  CURRENT_QUERY: 0x8865

  защищено 
  QUERY_RESULT: 0x8866

  защищено 
  QUERY_RESULT_AVAILABLE: 0x8867

  защищено 
  STREAM_READ: 0x88E1

  защищено 
  STREAM_COPY: 0x88E2

  защищено 
  STATIC_READ: 0x88E5

  защищено 
  STATIC_COPY: 0x88E6

  защищено 
  DYNAMIC_READ: 0x88E9

  защищено 
  DYNAMIC_COPY: 0x88EA

  защищено 
  MAX_DRAW_BUFFERS: 0x8824

  защищено 
  DRAW_BUFFER0: 0x8825

  защищено 
  DRAW_BUFFER1: 0x8826

  защищено 
  DRAW_BUFFER2: 0x8827

  защищено 
  DRAW_BUFFER3: 0x8828

  защищено 
  DRAW_BUFFER4: 0x8829

  защищено 
  DRAW_BUFFER5: 0x882A

  защищено 
  DRAW_BUFFER6: 0x882B

  защищено 
  DRAW_BUFFER7: 0x882C

  защищено 
  DRAW_BUFFER8: 0x882D

  защищено 
  DRAW_BUFFER9: 0x882E

  защищено 
  DRAW_BUFFER10: 0x882F

  защищено 
  DRAW_BUFFER11: 0x8830

  защищено 
  DRAW_BUFFER12: 0x8831

  защищено 
  DRAW_BUFFER13: 0x8832

  защищено 
  DRAW_BUFFER14: 0x8833

  защищено 
  DRAW_BUFFER15: 0x8834

  защищено 
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49

  защищено 
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A

  защищено 
  SAMPLER_3D: 0x8B5F

  защищено 
  SAMPLER_2D_SHADOW: 0x8B62

  защищено 
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B

  защищено 
  PIXEL_PACK_BUFFER: 0x88EB

  защищено 
  PIXEL_UNPACK_BUFFER: 0x88EC

  защищено 
  PIXEL_PACK_BUFFER_BINDING: 0x88ED

  защищено 
  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF

  защищено 
  FLOAT_MAT2x3: 0x8B65

  защищено 
  FLOAT_MAT2x4: 0x8B66

  защищено 
  FLOAT_MAT3x2: 0x8B67

  защищено 
  FLOAT_MAT3x4: 0x8B68

  защищено 
  FLOAT_MAT4x2: 0x8B69

  защищено 
  FLOAT_MAT4x3: 0x8B6A

  защищено 
  SRGB: 0x8C40

  защищено 
  SRGB8: 0x8C41

  защищено 
  SRGB8_ALPHA8: 0x8C43

  защищено 
  COMPARE_REF_TO_TEXTURE: 0x884E

  защищено 
  RGBA32F: 0x8814

  защищено 
  RGB32F: 0x8815

  защищено 
  RGBA16F: 0x881A

  защищено 
  RGB16F: 0x881B

  защищено 
  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD

  защищено 
  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF

  защищено 
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904

  защищено 
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905

  защищено 
  MAX_VARYING_COMPONENTS: 0x8B4B

  защищено 
  TEXTURE_2D_ARRAY: 0x8C1A

  защищено 
  TEXTURE_BINDING_2D_ARRAY: 0x8C1D

  защищено 
  R11F_G11F_B10F: 0x8C3A

  защищено 
  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B

  защищено 
  RGB9_E5: 0x8C3D

  защищено 
  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80

  защищено 
  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85

  защищено 
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88

  защищено 
  RASTERIZER_DISCARD: 0x8C89

  защищено 
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A

  защищено 
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B

  защищено 
  INTERLEAVED_ATTRIBS: 0x8C8C

  защищено 
  SEPARATE_ATTRIBS: 0x8C8D

  защищено 
  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E

  защищено 
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F

  защищено 
  RGBA32UI: 0x8D70

  защищено 
  RGB32UI: 0x8D71

  защищено 
  RGBA16UI: 0x8D76

  защищено 
  RGB16UI: 0x8D77

  защищено 
  RGBA8UI: 0x8D7C

  защищено 
  RGB8UI: 0x8D7D

  защищено 
  RGBA32I: 0x8D82

  защищено 
  RGB32I: 0x8D83

  защищено 
  RGBA16I: 0x8D88

  защищено 
  RGB16I: 0x8D89

  защищено 
  RGBA8I: 0x8D8E

  защищено 
  RGB8I: 0x8D8F

  защищено 
  RED_INTEGER: 0x8D94

  защищено 
  RGB_INTEGER: 0x8D98

  защищено 
  RGBA_INTEGER: 0x8D99

  защищено 
  SAMPLER_2D_ARRAY: 0x8DC1

  защищено 
  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4

  защищено 
  SAMPLER_CUBE_SHADOW: 0x8DC5

  защищено 
  UNSIGNED_INT_VEC2: 0x8DC6

  защищено 
  UNSIGNED_INT_VEC3: 0x8DC7

  защищено 
  UNSIGNED_INT_VEC4: 0x8DC8

  защищено 
  INT_SAMPLER_2D: 0x8DCA

  защищено 
  INT_SAMPLER_3D: 0x8DCB

  защищено 
  INT_SAMPLER_CUBE: 0x8DCC

  защищено 
  INT_SAMPLER_2D_ARRAY: 0x8DCF

  защищено 
  UNSIGNED_INT_SAMPLER_2D: 0x8DD2

  защищено 
  UNSIGNED_INT_SAMPLER_3D: 0x8DD3

  защищено 
  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4

  защищено 
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7

  защищено 
  DEPTH_COMPONENT32F: 0x8CAC

  защищено 
  DEPTH32F_STENCIL8: 0x8CAD

  защищено 
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD

  защищено 
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210

  защищено 
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211

  защищено 
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212

  защищено 
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213

  защищено 
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214

  защищено 
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215

  защищено 
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216

  защищено 
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217

  защищено 
  FRAMEBUFFER_DEFAULT: 0x8218

  защищено 
  UNSIGNED_INT_24_8: 0x84FA

  защищено 
  DEPTH24_STENCIL8: 0x88F0

  защищено 
  UNSIGNED_NORMALIZED: 0x8C17

  защищено 
  DRAW_FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  READ_FRAMEBUFFER: 0x8CA8

  защищено 
  DRAW_FRAMEBUFFER: 0x8CA9

  защищено 
  READ_FRAMEBUFFER_BINDING: 0x8CAA

  защищено 
  RENDERBUFFER_SAMPLES: 0x8CAB

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4

  защищено 
  MAX_COLOR_ATTACHMENTS: 0x8CDF

  защищено 
  COLOR_ATTACHMENT1: 0x8CE1

  защищено 
  COLOR_ATTACHMENT2: 0x8CE2

  защищено 
  COLOR_ATTACHMENT3: 0x8CE3

  защищено 
  COLOR_ATTACHMENT4: 0x8CE4

  защищено 
  COLOR_ATTACHMENT5: 0x8CE5

  защищено 
  COLOR_ATTACHMENT6: 0x8CE6

  защищено 
  COLOR_ATTACHMENT7: 0x8CE7

  защищено 
  COLOR_ATTACHMENT8: 0x8CE8

  защищено 
  COLOR_ATTACHMENT9: 0x8CE9

  защищено 
  COLOR_ATTACHMENT10: 0x8CEA

  защищено 
  COLOR_ATTACHMENT11: 0x8CEB

  защищено 
  COLOR_ATTACHMENT12: 0x8CEC

  защищено 
  COLOR_ATTACHMENT13: 0x8CED

  защищено 
  COLOR_ATTACHMENT14: 0x8CEE

  защищено 
  COLOR_ATTACHMENT15: 0x8CEF

  защищено 
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56

  защищено 
  MAX_SAMPLES: 0x8D57

  защищено 
  HALF_FLOAT: 0x140B

  защищено 
  RG: 0x8227

  защищено 
  RG_INTEGER: 0x8228

  защищено 
  R8: 0x8229

  защищено 
  RG8: 0x822B

  защищено 
  R16F: 0x822D

  защищено 
  R32F: 0x822E

  защищено 
  RG16F: 0x822F

  защищено 
  RG32F: 0x8230

  защищено 
  R8I: 0x8231

  защищено 
  R8UI: 0x8232

  защищено 
  R16I: 0x8233

  защищено 
  R16UI: 0x8234

  защищено 
  R32I: 0x8235

  защищено 
  R32UI: 0x8236

  защищено 
  RG8I: 0x8237

  защищено 
  RG8UI: 0x8238

  защищено 
  RG16I: 0x8239

  защищено 
  RG16UI: 0x823A

  защищено 
  RG32I: 0x823B

  защищено 
  RG32UI: 0x823C

  защищено 
  VERTEX_ARRAY_BINDING: 0x85B5

  защищено 
  R8_SNORM: 0x8F94

  защищено 
  RG8_SNORM: 0x8F95

  защищено 
  RGB8_SNORM: 0x8F96

  защищено 
  RGBA8_SNORM: 0x8F97

  защищено 
  SIGNED_NORMALIZED: 0x8F9C

  защищено 
  COPY_READ_BUFFER: 0x8F36

  защищено 
  COPY_WRITE_BUFFER: 0x8F37

  защищено 
  COPY_READ_BUFFER_BINDING: 0x8F36

  защищено 
  COPY_WRITE_BUFFER_BINDING: 0x8F37

  защищено 
  UNIFORM_BUFFER: 0x8A11

  защищено 
  UNIFORM_BUFFER_BINDING: 0x8A28

  защищено 
  UNIFORM_BUFFER_START: 0x8A29

  защищено 
  UNIFORM_BUFFER_SIZE: 0x8A2A

  защищено 
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B

  защищено 
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D

  защищено 
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E

  защищено 
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F

  защищено 
  MAX_UNIFORM_BLOCK_SIZE: 0x8A30

  защищено 
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31

  защищено 
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33

  защищено 
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34

  защищено 
  ACTIVE_UNIFORM_BLOCKS: 0x8A36

  защищено 
  UNIFORM_TYPE: 0x8A37

  защищено 
  UNIFORM_SIZE: 0x8A38

  защищено 
  UNIFORM_BLOCK_INDEX: 0x8A3A

  защищено 
  UNIFORM_OFFSET: 0x8A3B

  защищено 
  UNIFORM_ARRAY_STRIDE: 0x8A3C

  защищено 
  UNIFORM_MATRIX_STRIDE: 0x8A3D

  защищено 
  UNIFORM_IS_ROW_MAJOR: 0x8A3E

  защищено 
  UNIFORM_BLOCK_BINDING: 0x8A3F

  защищено 
  UNIFORM_BLOCK_DATA_SIZE: 0x8A40

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42

  защищено 
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44

  защищено 
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46

  защищено 
  INVALID_INDEX: 0xFFFFFFFF

  защищено 
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122

  защищено 
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125

  защищено 
  MAX_SERVER_WAIT_TIMEOUT: 0x9111

  защищено 
  OBJECT_TYPE: 0x9112

  защищено 
  SYNC_CONDITION: 0x9113

  защищено 
  SYNC_STATUS: 0x9114

  защищено 
  SYNC_FLAGS: 0x9115

  защищено 
  SYNC_FENCE: 0x9116

  защищено 
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117

  защищено 
  UNSIGNALED: 0x9118

  защищено 
  SIGNALED: 0x9119

  защищено 
  ALREADY_SIGNALED: 0x911A

  защищено 
  TIMEOUT_EXPIRED: 0x911B

  защищено 
  CONDITION_SATISFIED: 0x911C

  защищено 
  WAIT_FAILED: 0x911D

  защищено 
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001

  защищено 
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE

  защищено 
  ANY_SAMPLES_PASSED: 0x8C2F

  защищено 
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A

  защищено 
  SAMPLER_BINDING: 0x8919

  защищено 
  RGB10_A2UI: 0x906F

  защищено 
  INT_2_10_10_10_REV: 0x8D9F

  защищено 
  TRANSFORM_FEEDBACK: 0x8E22

  защищено 
  TRANSFORM_FEEDBACK_PAUSED: 0x8E23

  защищено 
  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24

  защищено 
  TRANSFORM_FEEDBACK_BINDING: 0x8E25

  защищено 
  TEXTURE_IMMUTABLE_FORMAT: 0x912F

  защищено 
  MAX_ELEMENT_INDEX: 0x8D6B

  защищено 
  TEXTURE_IMMUTABLE_LEVELS: 0x82DF

  защищено 
  TIMEOUT_IGNORED: -1

  защищено 
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247
}


тип WebGL2RenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, srcData: BufferSource?, usage: GLenum)

  операция bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length: GLuint? = пусто)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: BufferSource)

  операция bufferSubData(target: GLenum, dstByteOffset: GLintptr, srcData: ArrayBufferView, srcOffset: GLuint, length: GLuint? = пусто)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, srcData: ArrayBufferView, srcOffset: GLuint? = пусто, srcLengthOverride: GLuint? = пусто)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, imageSize: GLsizei, offset: GLintptr)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, srcData: ArrayBufferView, srcOffset: GLuint? = пусто, srcLengthOverride: GLuint? = пусто)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, dstData: ArrayBufferView?)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, offset: GLintptr)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, dstData: ArrayBufferView, dstOffset: GLuint)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type`: GLenum, pixels: ArrayBufferView?)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type`: GLenum, pboOffset: GLintptr)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type`: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, pixels: ArrayBufferView?)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, pboOffset: GLintptr)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, srcData: ArrayBufferView, srcOffset: GLuint)

  операция uniform1fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform1iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform2fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform2iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform3fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform3iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform4fv(location: WebGLUniformLocation?, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniform4iv(location: WebGLUniformLocation?, data: Int32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix2fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix3fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)

  операция uniformMatrix4fv(location: WebGLUniformLocation?, transpose: GLboolean, data: Float32List, srcOffset: GLuint? = пусто, srcLength: GLuint? = пусто)
}


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getActiveAttrib() and WebGLRenderingContext.getActiveUniform() methods.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLActiveInfo)
*/

тип WebGLActiveInfo = интерфейс
{
  защищено 
  name: Текст

  защищено 
  size: GLint

  защищено 
  type`: GLenum
}


внешнее
/*(!) var */ WebGLActiveInfo: объект { prototype: WebGLActiveInfo; при создании(): WebGLActiveInfo }


/**
* Part of the WebGL API and represents an opaque buffer object storing data such as vertices or colors.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLBuffer)
*/

тип WebGLBuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLBuffer: объект { prototype: WebGLBuffer; при создании(): WebGLBuffer }


/**
* The WebContextEvent interface is part of the WebGL API and is an interface for an event that is generated in response to a status change to the WebGL rendering context.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLContextEvent)
*/

тип WebGLContextEvent = интерфейс на основе Event
{
  защищено 
  statusMessage: Текст
}


внешнее
/*(!) var */ WebGLContextEvent: объект { prototype: WebGLContextEvent; при создании(type`: Текст, eventInit: WebGLContextEventInit? = пусто): WebGLContextEvent }


/**
* Part of the WebGL API and represents a collection of buffers that serve as a rendering destination.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLFramebuffer)
*/

тип WebGLFramebuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLFramebuffer: объект { prototype: WebGLFramebuffer; при создании(): WebGLFramebuffer }


/**
* The WebGLProgram is part of the WebGL API and is a combination of two compiled WebGLShaders consisting of a vertex shader and a fragment shader (both written in GLSL).
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLProgram)
*/

тип WebGLProgram = интерфейс
{

}


внешнее
/*(!) var */ WebGLProgram: объект { prototype: WebGLProgram; при создании(): WebGLProgram }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLQuery) */

тип WebGLQuery = интерфейс
{

}


внешнее
/*(!) var */ WebGLQuery: объект { prototype: WebGLQuery; при создании(): WebGLQuery }


/**
* Part of the WebGL API and represents a buffer that can contain an image, or can be source or target of an rendering operation.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderbuffer)
*/

тип WebGLRenderbuffer = интерфейс
{

}


внешнее
/*(!) var */ WebGLRenderbuffer: объект { prototype: WebGLRenderbuffer; при создании(): WebGLRenderbuffer }


/**
* Provides an interface to the OpenGL ES 2.0 graphics rendering context for the drawing surface of an HTML <canvas> element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLRenderingContext)
*/

тип WebGLRenderingContext = интерфейс на основе WebGLRenderingContextBase, WebGLRenderingContextOverloads
{

}


внешнее
/*(!) var */ WebGLRenderingContext: объект { prototype: WebGLRenderingContext; при создании(): WebGLRenderingContext; защищено  DEPTH_BUFFER_BIT: 0x00000100; защищено  STENCIL_BUFFER_BIT: 0x00000400; защищено  COLOR_BUFFER_BIT: 0x00004000; защищено  POINTS: 0x0000; защищено  LINES: 0x0001; защищено  LINE_LOOP: 0x0002; защищено  LINE_STRIP: 0x0003; защищено  TRIANGLES: 0x0004; защищено  TRIANGLE_STRIP: 0x0005; защищено  TRIANGLE_FAN: 0x0006; защищено  ZERO: 0; защищено  ONE: 1; защищено  SRC_COLOR: 0x0300; защищено  ONE_MINUS_SRC_COLOR: 0x0301; защищено  SRC_ALPHA: 0x0302; защищено  ONE_MINUS_SRC_ALPHA: 0x0303; защищено  DST_ALPHA: 0x0304; защищено  ONE_MINUS_DST_ALPHA: 0x0305; защищено  DST_COLOR: 0x0306; защищено  ONE_MINUS_DST_COLOR: 0x0307; защищено  SRC_ALPHA_SATURATE: 0x0308; защищено  FUNC_ADD: 0x8006; защищено  BLEND_EQUATION: 0x8009; защищено  BLEND_EQUATION_RGB: 0x8009; защищено  BLEND_EQUATION_ALPHA: 0x883D; защищено  FUNC_SUBTRACT: 0x800A; защищено  FUNC_REVERSE_SUBTRACT: 0x800B; защищено  BLEND_DST_RGB: 0x80C8; защищено  BLEND_SRC_RGB: 0x80C9; защищено  BLEND_DST_ALPHA: 0x80CA; защищено  BLEND_SRC_ALPHA: 0x80CB; защищено  CONSTANT_COLOR: 0x8001; защищено  ONE_MINUS_CONSTANT_COLOR: 0x8002; защищено  CONSTANT_ALPHA: 0x8003; защищено  ONE_MINUS_CONSTANT_ALPHA: 0x8004; защищено  BLEND_COLOR: 0x8005; защищено  ARRAY_BUFFER: 0x8892; защищено  ELEMENT_ARRAY_BUFFER: 0x8893; защищено  ARRAY_BUFFER_BINDING: 0x8894; защищено  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895; защищено  STREAM_DRAW: 0x88E0; защищено  STATIC_DRAW: 0x88E4; защищено  DYNAMIC_DRAW: 0x88E8; защищено  BUFFER_SIZE: 0x8764; защищено  BUFFER_USAGE: 0x8765; защищено  CURRENT_VERTEX_ATTRIB: 0x8626; защищено  FRONT: 0x0404; защищено  BACK: 0x0405; защищено  FRONT_AND_BACK: 0x0408; защищено  CULL_FACE: 0x0B44; защищено  BLEND: 0x0BE2; защищено  DITHER: 0x0BD0; защищено  STENCIL_TEST: 0x0B90; защищено  DEPTH_TEST: 0x0B71; защищено  SCISSOR_TEST: 0x0C11; защищено  POLYGON_OFFSET_FILL: 0x8037; защищено  SAMPLE_ALPHA_TO_COVERAGE: 0x809E; защищено  SAMPLE_COVERAGE: 0x80A0; защищено  NO_ERROR: 0; защищено  INVALID_ENUM: 0x0500; защищено  INVALID_VALUE: 0x0501; защищено  INVALID_OPERATION: 0x0502; защищено  OUT_OF_MEMORY: 0x0505; защищено  CW: 0x0900; защищено  CCW: 0x0901; защищено  LINE_WIDTH: 0x0B21; защищено  ALIASED_POINT_SIZE_RANGE: 0x846D; защищено  ALIASED_LINE_WIDTH_RANGE: 0x846E; защищено  CULL_FACE_MODE: 0x0B45; защищено  FRONT_FACE: 0x0B46; защищено  DEPTH_RANGE: 0x0B70; защищено  DEPTH_WRITEMASK: 0x0B72; защищено  DEPTH_CLEAR_VALUE: 0x0B73; защищено  DEPTH_FUNC: 0x0B74; защищено  STENCIL_CLEAR_VALUE: 0x0B91; защищено  STENCIL_FUNC: 0x0B92; защищено  STENCIL_FAIL: 0x0B94; защищено  STENCIL_PASS_DEPTH_FAIL: 0x0B95; защищено  STENCIL_PASS_DEPTH_PASS: 0x0B96; защищено  STENCIL_REF: 0x0B97; защищено  STENCIL_VALUE_MASK: 0x0B93; защищено  STENCIL_WRITEMASK: 0x0B98; защищено  STENCIL_BACK_FUNC: 0x8800; защищено  STENCIL_BACK_FAIL: 0x8801; защищено  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802; защищено  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803; защищено  STENCIL_BACK_REF: 0x8CA3; защищено  STENCIL_BACK_VALUE_MASK: 0x8CA4; защищено  STENCIL_BACK_WRITEMASK: 0x8CA5; защищено  VIEWPORT: 0x0BA2; защищено  SCISSOR_BOX: 0x0C10; защищено  COLOR_CLEAR_VALUE: 0x0C22; защищено  COLOR_WRITEMASK: 0x0C23; защищено  UNPACK_ALIGNMENT: 0x0CF5; защищено  PACK_ALIGNMENT: 0x0D05; защищено  MAX_TEXTURE_SIZE: 0x0D33; защищено  MAX_VIEWPORT_DIMS: 0x0D3A; защищено  SUBPIXEL_BITS: 0x0D50; защищено  RED_BITS: 0x0D52; защищено  GREEN_BITS: 0x0D53; защищено  BLUE_BITS: 0x0D54; защищено  ALPHA_BITS: 0x0D55; защищено  DEPTH_BITS: 0x0D56; защищено  STENCIL_BITS: 0x0D57; защищено  POLYGON_OFFSET_UNITS: 0x2A00; защищено  POLYGON_OFFSET_FACTOR: 0x8038; защищено  TEXTURE_BINDING_2D: 0x8069; защищено  SAMPLE_BUFFERS: 0x80A8; защищено  SAMPLES: 0x80A9; защищено  SAMPLE_COVERAGE_VALUE: 0x80AA; защищено  SAMPLE_COVERAGE_INVERT: 0x80AB; защищено  COMPRESSED_TEXTURE_FORMATS: 0x86A3; защищено  DONT_CARE: 0x1100; защищено  FASTEST: 0x1101; защищено  NICEST: 0x1102; защищено  GENERATE_MIPMAP_HINT: 0x8192; защищено  BYTE: 0x1400; защищено  UNSIGNED_BYTE: 0x1401; защищено  SHORT: 0x1402; защищено  UNSIGNED_SHORT: 0x1403; защищено  INT: 0x1404; защищено  UNSIGNED_INT: 0x1405; защищено  FLOAT: 0x1406; защищено  DEPTH_COMPONENT: 0x1902; защищено  ALPHA: 0x1906; защищено  RGB: 0x1907; защищено  RGBA: 0x1908; защищено  LUMINANCE: 0x1909; защищено  LUMINANCE_ALPHA: 0x190A; защищено  UNSIGNED_SHORT_4_4_4_4: 0x8033; защищено  UNSIGNED_SHORT_5_5_5_1: 0x8034; защищено  UNSIGNED_SHORT_5_6_5: 0x8363; защищено  FRAGMENT_SHADER: 0x8B30; защищено  VERTEX_SHADER: 0x8B31; защищено  MAX_VERTEX_ATTRIBS: 0x8869; защищено  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB; защищено  MAX_VARYING_VECTORS: 0x8DFC; защищено  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D; защищено  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C; защищено  MAX_TEXTURE_IMAGE_UNITS: 0x8872; защищено  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD; защищено  SHADER_TYPE: 0x8B4F; защищено  DELETE_STATUS: 0x8B80; защищено  LINK_STATUS: 0x8B82; защищено  VALIDATE_STATUS: 0x8B83; защищено  ATTACHED_SHADERS: 0x8B85; защищено  ACTIVE_UNIFORMS: 0x8B86; защищено  ACTIVE_ATTRIBUTES: 0x8B89; защищено  SHADING_LANGUAGE_VERSION: 0x8B8C; защищено  CURRENT_PROGRAM: 0x8B8D; защищено  NEVER: 0x0200; защищено  LESS: 0x0201; защищено  EQUAL: 0x0202; защищено  LEQUAL: 0x0203; защищено  GREATER: 0x0204; защищено  NOTEQUAL: 0x0205; защищено  GEQUAL: 0x0206; защищено  ALWAYS: 0x0207; защищено  KEEP: 0x1E00; защищено  REPLACE: 0x1E01; защищено  INCR: 0x1E02; защищено  DECR: 0x1E03; защищено  INVERT: 0x150A; защищено  INCR_WRAP: 0x8507; защищено  DECR_WRAP: 0x8508; защищено  VENDOR: 0x1F00; защищено  RENDERER: 0x1F01; защищено  VERSION: 0x1F02; защищено  NEAREST: 0x2600; защищено  LINEAR: 0x2601; защищено  NEAREST_MIPMAP_NEAREST: 0x2700; защищено  LINEAR_MIPMAP_NEAREST: 0x2701; защищено  NEAREST_MIPMAP_LINEAR: 0x2702; защищено  LINEAR_MIPMAP_LINEAR: 0x2703; защищено  TEXTURE_MAG_FILTER: 0x2800; защищено  TEXTURE_MIN_FILTER: 0x2801; защищено  TEXTURE_WRAP_S: 0x2802; защищено  TEXTURE_WRAP_T: 0x2803; защищено  TEXTURE_2D: 0x0DE1; защищено  TEXTURE: 0x1702; защищено  TEXTURE_CUBE_MAP: 0x8513; защищено  TEXTURE_BINDING_CUBE_MAP: 0x8514; защищено  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515; защищено  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516; защищено  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518; защищено  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519; защищено  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A; защищено  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C; защищено  TEXTURE0: 0x84C0; защищено  TEXTURE1: 0x84C1; защищено  TEXTURE2: 0x84C2; защищено  TEXTURE3: 0x84C3; защищено  TEXTURE4: 0x84C4; защищено  TEXTURE5: 0x84C5; защищено  TEXTURE6: 0x84C6; защищено  TEXTURE7: 0x84C7; защищено  TEXTURE8: 0x84C8; защищено  TEXTURE9: 0x84C9; защищено  TEXTURE10: 0x84CA; защищено  TEXTURE11: 0x84CB; защищено  TEXTURE12: 0x84CC; защищено  TEXTURE13: 0x84CD; защищено  TEXTURE14: 0x84CE; защищено  TEXTURE15: 0x84CF; защищено  TEXTURE16: 0x84D0; защищено  TEXTURE17: 0x84D1; защищено  TEXTURE18: 0x84D2; защищено  TEXTURE19: 0x84D3; защищено  TEXTURE20: 0x84D4; защищено  TEXTURE21: 0x84D5; защищено  TEXTURE22: 0x84D6; защищено  TEXTURE23: 0x84D7; защищено  TEXTURE24: 0x84D8; защищено  TEXTURE25: 0x84D9; защищено  TEXTURE26: 0x84DA; защищено  TEXTURE27: 0x84DB; защищено  TEXTURE28: 0x84DC; защищено  TEXTURE29: 0x84DD; защищено  TEXTURE30: 0x84DE; защищено  TEXTURE31: 0x84DF; защищено  ACTIVE_TEXTURE: 0x84E0; защищено  REPEAT: 0x2901; защищено  CLAMP_TO_EDGE: 0x812F; защищено  MIRRORED_REPEAT: 0x8370; защищено  FLOAT_VEC2: 0x8B50; защищено  FLOAT_VEC3: 0x8B51; защищено  FLOAT_VEC4: 0x8B52; защищено  INT_VEC2: 0x8B53; защищено  INT_VEC3: 0x8B54; защищено  INT_VEC4: 0x8B55; защищено  BOOL: 0x8B56; защищено  BOOL_VEC2: 0x8B57; защищено  BOOL_VEC3: 0x8B58; защищено  BOOL_VEC4: 0x8B59; защищено  FLOAT_MAT2: 0x8B5A; защищено  FLOAT_MAT3: 0x8B5B; защищено  FLOAT_MAT4: 0x8B5C; защищено  SAMPLER_2D: 0x8B5E; защищено  SAMPLER_CUBE: 0x8B60; защищено  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622; защищено  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623; защищено  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624; защищено  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625; защищено  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A; защищено  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645; защищено  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F; защищено  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A; защищено  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B; защищено  COMPILE_STATUS: 0x8B81; защищено  LOW_FLOAT: 0x8DF0; защищено  MEDIUM_FLOAT: 0x8DF1; защищено  HIGH_FLOAT: 0x8DF2; защищено  LOW_INT: 0x8DF3; защищено  MEDIUM_INT: 0x8DF4; защищено  HIGH_INT: 0x8DF5; защищено  FRAMEBUFFER: 0x8D40; защищено  RENDERBUFFER: 0x8D41; защищено  RGBA4: 0x8056; защищено  RGB5_A1: 0x8057; защищено  RGB565: 0x8D62; защищено  DEPTH_COMPONENT16: 0x81A5; защищено  STENCIL_INDEX8: 0x8D48; защищено  DEPTH_STENCIL: 0x84F9; защищено  RENDERBUFFER_WIDTH: 0x8D42; защищено  RENDERBUFFER_HEIGHT: 0x8D43; защищено  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44; защищено  RENDERBUFFER_RED_SIZE: 0x8D50; защищено  RENDERBUFFER_GREEN_SIZE: 0x8D51; защищено  RENDERBUFFER_BLUE_SIZE: 0x8D52; защищено  RENDERBUFFER_ALPHA_SIZE: 0x8D53; защищено  RENDERBUFFER_DEPTH_SIZE: 0x8D54; защищено  RENDERBUFFER_STENCIL_SIZE: 0x8D55; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0; защищено  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2; защищено  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3; защищено  COLOR_ATTACHMENT0: 0x8CE0; защищено  DEPTH_ATTACHMENT: 0x8D00; защищено  STENCIL_ATTACHMENT: 0x8D20; защищено  DEPTH_STENCIL_ATTACHMENT: 0x821A; защищено  NONE: 0; защищено  FRAMEBUFFER_COMPLETE: 0x8CD5; защищено  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6; защищено  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7; защищено  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9; защищено  FRAMEBUFFER_UNSUPPORTED: 0x8CDD; защищено  FRAMEBUFFER_BINDING: 0x8CA6; защищено  RENDERBUFFER_BINDING: 0x8CA7; защищено  MAX_RENDERBUFFER_SIZE: 0x84E8; защищено  INVALID_FRAMEBUFFER_OPERATION: 0x0506; защищено  UNPACK_FLIP_Y_WEBGL: 0x9240; защищено  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241; защищено  CONTEXT_LOST_WEBGL: 0x9242; защищено  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243; защищено  BROWSER_DEFAULT_WEBGL: 0x9244 }


тип WebGLRenderingContextBase = интерфейс
{
  защищено 
  canvas: Объект? /*(!)HTMLCanvasElement | OffscreenCanvas*/

  drawingBufferColorSpace: PredefinedColorSpace

  защищено 
  drawingBufferHeight: GLsizei

  защищено 
  drawingBufferWidth: GLsizei

  операция activeTexture(texture: GLenum)

  операция attachShader(program: WebGLProgram, shader: WebGLShader)

  операция bindAttribLocation(program: WebGLProgram, index: GLuint, name: Текст)

  операция bindBuffer(target: GLenum, buffer: WebGLBuffer?)

  операция bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer?)

  операция bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer?)

  операция bindTexture(target: GLenum, texture: WebGLTexture?)

  операция blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция blendEquation(mode: GLenum)

  операция blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum)

  операция blendFunc(sfactor: GLenum, dfactor: GLenum)

  операция blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum)

  операция checkFramebufferStatus(target: GLenum): GLenum

  операция clear(mask: GLbitfield)

  операция clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf)

  операция clearDepth(depth: GLclampf)

  операция clearStencil(s: GLint)

  операция colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean)

  операция compileShader(shader: WebGLShader)

  операция copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint)

  операция copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция createBuffer(): WebGLBuffer?

  операция createFramebuffer(): WebGLFramebuffer?

  операция createProgram(): WebGLProgram?

  операция createRenderbuffer(): WebGLRenderbuffer?

  операция createShader(type`: GLenum): WebGLShader?

  операция createTexture(): WebGLTexture?

  операция cullFace(mode: GLenum)

  операция deleteBuffer(buffer: WebGLBuffer?)

  операция deleteFramebuffer(framebuffer: WebGLFramebuffer?)

  операция deleteProgram(program: WebGLProgram?)

  операция deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?)

  операция deleteShader(shader: WebGLShader?)

  операция deleteTexture(texture: WebGLTexture?)

  операция depthFunc(func: GLenum)

  операция depthMask(flag: GLboolean)

  операция depthRange(zNear: GLclampf, zFar: GLclampf)

  операция detachShader(program: WebGLProgram, shader: WebGLShader)

  операция disable(cap: GLenum)

  операция disableVertexAttribArray(index: GLuint)

  операция drawArrays(mode: GLenum, first: GLint, count: GLsizei)

  операция drawElements(mode: GLenum, count: GLsizei, type`: GLenum, offset: GLintptr)

  операция enable(cap: GLenum)

  операция enableVertexAttribArray(index: GLuint)

  операция finish()

  операция flush()

  операция framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer?)

  операция framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture?, level: GLint)

  операция frontFace(mode: GLenum)

  операция generateMipmap(target: GLenum)

  операция getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo?

  операция getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo?

  операция getAttachedShaders(program: WebGLProgram): Список<WebGLShader>?

  операция getAttribLocation(program: WebGLProgram, name: Текст): GLint

  операция getBufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getContextAttributes(): WebGLContextAttributes?

  операция getError(): GLenum

  операция getExtension(extensionName: "ANGLE_instanced_arrays"): ANGLE_instanced_arrays?

  операция getExtension(extensionName: "EXT_blend_minmax"): EXT_blend_minmax?

  операция getExtension(extensionName: "EXT_color_buffer_float"): EXT_color_buffer_float?

  операция getExtension(extensionName: "EXT_color_buffer_half_float"): EXT_color_buffer_half_float?

  операция getExtension(extensionName: "EXT_float_blend"): EXT_float_blend?

  операция getExtension(extensionName: "EXT_frag_depth"): EXT_frag_depth?

  операция getExtension(extensionName: "EXT_sRGB"): EXT_sRGB?

  операция getExtension(extensionName: "EXT_shader_texture_lod"): EXT_shader_texture_lod?

  операция getExtension(extensionName: "EXT_texture_compression_bptc"): EXT_texture_compression_bptc?

  операция getExtension(extensionName: "EXT_texture_compression_rgtc"): EXT_texture_compression_rgtc?

  операция getExtension(extensionName: "EXT_texture_filter_anisotropic"): EXT_texture_filter_anisotropic?

  операция getExtension(extensionName: "KHR_parallel_shader_compile"): KHR_parallel_shader_compile?

  операция getExtension(extensionName: "OES_element_index_uint"): OES_element_index_uint?

  операция getExtension(extensionName: "OES_fbo_render_mipmap"): OES_fbo_render_mipmap?

  операция getExtension(extensionName: "OES_standard_derivatives"): OES_standard_derivatives?

  операция getExtension(extensionName: "OES_texture_float"): OES_texture_float?

  операция getExtension(extensionName: "OES_texture_float_linear"): OES_texture_float_linear?

  операция getExtension(extensionName: "OES_texture_half_float"): OES_texture_half_float?

  операция getExtension(extensionName: "OES_texture_half_float_linear"): OES_texture_half_float_linear?

  операция getExtension(extensionName: "OES_vertex_array_object"): OES_vertex_array_object?

  операция getExtension(extensionName: "OVR_multiview2"): OVR_multiview2?

  операция getExtension(extensionName: "WEBGL_color_buffer_float"): WEBGL_color_buffer_float?

  операция getExtension(extensionName: "WEBGL_compressed_texture_astc"): WEBGL_compressed_texture_astc?

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc"): WEBGL_compressed_texture_etc?

  операция getExtension(extensionName: "WEBGL_compressed_texture_etc1"): WEBGL_compressed_texture_etc1?

  операция getExtension(extensionName: "WEBGL_compressed_texture_pvrtc"): WEBGL_compressed_texture_pvrtc?

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc"): WEBGL_compressed_texture_s3tc?

  операция getExtension(extensionName: "WEBGL_compressed_texture_s3tc_srgb"): WEBGL_compressed_texture_s3tc_srgb?

  операция getExtension(extensionName: "WEBGL_debug_renderer_info"): WEBGL_debug_renderer_info?

  операция getExtension(extensionName: "WEBGL_debug_shaders"): WEBGL_debug_shaders?

  операция getExtension(extensionName: "WEBGL_depth_texture"): WEBGL_depth_texture?

  операция getExtension(extensionName: "WEBGL_draw_buffers"): WEBGL_draw_buffers?

  операция getExtension(extensionName: "WEBGL_lose_context"): WEBGL_lose_context?

  операция getExtension(extensionName: "WEBGL_multi_draw"): WEBGL_multi_draw?

  операция getExtension(name: Текст): /*(!) any */ Объект?

  операция getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getParameter(pname: GLenum): /*(!) any */ Объект?

  операция getProgramInfoLog(program: WebGLProgram): Текст?

  операция getProgramParameter(program: WebGLProgram, pname: GLenum): /*(!) any */ Объект?

  операция getRenderbufferParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getShaderInfoLog(shader: WebGLShader): Текст?

  операция getShaderParameter(shader: WebGLShader, pname: GLenum): /*(!) any */ Объект?

  операция getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat?

  операция getShaderSource(shader: WebGLShader): Текст?

  операция getSupportedExtensions(): Список<Текст>?

  операция getTexParameter(target: GLenum, pname: GLenum): /*(!) any */ Объект?

  операция getUniform(program: WebGLProgram, location: WebGLUniformLocation): /*(!) any */ Объект?

  операция getUniformLocation(program: WebGLProgram, name: Текст): WebGLUniformLocation?

  операция getVertexAttrib(index: GLuint, pname: GLenum): /*(!) any */ Объект?

  операция getVertexAttribOffset(index: GLuint, pname: GLenum): GLintptr

  операция hint(target: GLenum, mode: GLenum)

  операция isBuffer(buffer: WebGLBuffer?): GLboolean

  операция isContextLost(): ДаНет

  операция isEnabled(cap: GLenum): GLboolean

  операция isFramebuffer(framebuffer: WebGLFramebuffer?): GLboolean

  операция isProgram(program: WebGLProgram?): GLboolean

  операция isRenderbuffer(renderbuffer: WebGLRenderbuffer?): GLboolean

  операция isShader(shader: WebGLShader?): GLboolean

  операция isTexture(texture: WebGLTexture?): GLboolean

  операция lineWidth(width: GLfloat)

  операция linkProgram(program: WebGLProgram)

  операция pixelStorei(pname: GLenum, param: Объект? /*(!)GLint | GLboolean*/)

  операция polygonOffset(factor: GLfloat, units: GLfloat)

  операция renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei)

  операция sampleCoverage(value: GLclampf, invert: GLboolean)

  операция scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  операция shaderSource(shader: WebGLShader, source: Текст)

  операция stencilFunc(func: GLenum, ref`: GLint, mask: GLuint)

  операция stencilFuncSeparate(face: GLenum, func: GLenum, ref`: GLint, mask: GLuint)

  операция stencilMask(mask: GLuint)

  операция stencilMaskSeparate(face: GLenum, mask: GLuint)

  операция stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum)

  операция texParameterf(target: GLenum, pname: GLenum, param: GLfloat)

  операция texParameteri(target: GLenum, pname: GLenum, param: GLint)

  операция uniform1f(location: WebGLUniformLocation?, x: GLfloat)

  операция uniform1i(location: WebGLUniformLocation?, x: GLint)

  операция uniform2f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat)

  операция uniform2i(location: WebGLUniformLocation?, x: GLint, y: GLint)

  операция uniform3f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat)

  операция uniform3i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint)

  операция uniform4f(location: WebGLUniformLocation?, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция uniform4i(location: WebGLUniformLocation?, x: GLint, y: GLint, z: GLint, w: GLint)

  операция useProgram(program: WebGLProgram?)

  операция validateProgram(program: WebGLProgram)

  операция vertexAttrib1f(index: GLuint, x: GLfloat)

  операция vertexAttrib1fv(index: GLuint, values: Float32List)

  операция vertexAttrib2f(index: GLuint, x: GLfloat, y: GLfloat)

  операция vertexAttrib2fv(index: GLuint, values: Float32List)

  операция vertexAttrib3f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat)

  операция vertexAttrib3fv(index: GLuint, values: Float32List)

  операция vertexAttrib4f(index: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat)

  операция vertexAttrib4fv(index: GLuint, values: Float32List)

  операция vertexAttribPointer(index: GLuint, size: GLint, type`: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr)

  операция viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei)

  защищено 
  DEPTH_BUFFER_BIT: 0x00000100

  защищено 
  STENCIL_BUFFER_BIT: 0x00000400

  защищено 
  COLOR_BUFFER_BIT: 0x00004000

  защищено 
  POINTS: 0x0000

  защищено 
  LINES: 0x0001

  защищено 
  LINE_LOOP: 0x0002

  защищено 
  LINE_STRIP: 0x0003

  защищено 
  TRIANGLES: 0x0004

  защищено 
  TRIANGLE_STRIP: 0x0005

  защищено 
  TRIANGLE_FAN: 0x0006

  защищено 
  ZERO: 0

  защищено 
  ONE: 1

  защищено 
  SRC_COLOR: 0x0300

  защищено 
  ONE_MINUS_SRC_COLOR: 0x0301

  защищено 
  SRC_ALPHA: 0x0302

  защищено 
  ONE_MINUS_SRC_ALPHA: 0x0303

  защищено 
  DST_ALPHA: 0x0304

  защищено 
  ONE_MINUS_DST_ALPHA: 0x0305

  защищено 
  DST_COLOR: 0x0306

  защищено 
  ONE_MINUS_DST_COLOR: 0x0307

  защищено 
  SRC_ALPHA_SATURATE: 0x0308

  защищено 
  FUNC_ADD: 0x8006

  защищено 
  BLEND_EQUATION: 0x8009

  защищено 
  BLEND_EQUATION_RGB: 0x8009

  защищено 
  BLEND_EQUATION_ALPHA: 0x883D

  защищено 
  FUNC_SUBTRACT: 0x800A

  защищено 
  FUNC_REVERSE_SUBTRACT: 0x800B

  защищено 
  BLEND_DST_RGB: 0x80C8

  защищено 
  BLEND_SRC_RGB: 0x80C9

  защищено 
  BLEND_DST_ALPHA: 0x80CA

  защищено 
  BLEND_SRC_ALPHA: 0x80CB

  защищено 
  CONSTANT_COLOR: 0x8001

  защищено 
  ONE_MINUS_CONSTANT_COLOR: 0x8002

  защищено 
  CONSTANT_ALPHA: 0x8003

  защищено 
  ONE_MINUS_CONSTANT_ALPHA: 0x8004

  защищено 
  BLEND_COLOR: 0x8005

  защищено 
  ARRAY_BUFFER: 0x8892

  защищено 
  ELEMENT_ARRAY_BUFFER: 0x8893

  защищено 
  ARRAY_BUFFER_BINDING: 0x8894

  защищено 
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895

  защищено 
  STREAM_DRAW: 0x88E0

  защищено 
  STATIC_DRAW: 0x88E4

  защищено 
  DYNAMIC_DRAW: 0x88E8

  защищено 
  BUFFER_SIZE: 0x8764

  защищено 
  BUFFER_USAGE: 0x8765

  защищено 
  CURRENT_VERTEX_ATTRIB: 0x8626

  защищено 
  FRONT: 0x0404

  защищено 
  BACK: 0x0405

  защищено 
  FRONT_AND_BACK: 0x0408

  защищено 
  CULL_FACE: 0x0B44

  защищено 
  BLEND: 0x0BE2

  защищено 
  DITHER: 0x0BD0

  защищено 
  STENCIL_TEST: 0x0B90

  защищено 
  DEPTH_TEST: 0x0B71

  защищено 
  SCISSOR_TEST: 0x0C11

  защищено 
  POLYGON_OFFSET_FILL: 0x8037

  защищено 
  SAMPLE_ALPHA_TO_COVERAGE: 0x809E

  защищено 
  SAMPLE_COVERAGE: 0x80A0

  защищено 
  NO_ERROR: 0

  защищено 
  INVALID_ENUM: 0x0500

  защищено 
  INVALID_VALUE: 0x0501

  защищено 
  INVALID_OPERATION: 0x0502

  защищено 
  OUT_OF_MEMORY: 0x0505

  защищено 
  CW: 0x0900

  защищено 
  CCW: 0x0901

  защищено 
  LINE_WIDTH: 0x0B21

  защищено 
  ALIASED_POINT_SIZE_RANGE: 0x846D

  защищено 
  ALIASED_LINE_WIDTH_RANGE: 0x846E

  защищено 
  CULL_FACE_MODE: 0x0B45

  защищено 
  FRONT_FACE: 0x0B46

  защищено 
  DEPTH_RANGE: 0x0B70

  защищено 
  DEPTH_WRITEMASK: 0x0B72

  защищено 
  DEPTH_CLEAR_VALUE: 0x0B73

  защищено 
  DEPTH_FUNC: 0x0B74

  защищено 
  STENCIL_CLEAR_VALUE: 0x0B91

  защищено 
  STENCIL_FUNC: 0x0B92

  защищено 
  STENCIL_FAIL: 0x0B94

  защищено 
  STENCIL_PASS_DEPTH_FAIL: 0x0B95

  защищено 
  STENCIL_PASS_DEPTH_PASS: 0x0B96

  защищено 
  STENCIL_REF: 0x0B97

  защищено 
  STENCIL_VALUE_MASK: 0x0B93

  защищено 
  STENCIL_WRITEMASK: 0x0B98

  защищено 
  STENCIL_BACK_FUNC: 0x8800

  защищено 
  STENCIL_BACK_FAIL: 0x8801

  защищено 
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802

  защищено 
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803

  защищено 
  STENCIL_BACK_REF: 0x8CA3

  защищено 
  STENCIL_BACK_VALUE_MASK: 0x8CA4

  защищено 
  STENCIL_BACK_WRITEMASK: 0x8CA5

  защищено 
  VIEWPORT: 0x0BA2

  защищено 
  SCISSOR_BOX: 0x0C10

  защищено 
  COLOR_CLEAR_VALUE: 0x0C22

  защищено 
  COLOR_WRITEMASK: 0x0C23

  защищено 
  UNPACK_ALIGNMENT: 0x0CF5

  защищено 
  PACK_ALIGNMENT: 0x0D05

  защищено 
  MAX_TEXTURE_SIZE: 0x0D33

  защищено 
  MAX_VIEWPORT_DIMS: 0x0D3A

  защищено 
  SUBPIXEL_BITS: 0x0D50

  защищено 
  RED_BITS: 0x0D52

  защищено 
  GREEN_BITS: 0x0D53

  защищено 
  BLUE_BITS: 0x0D54

  защищено 
  ALPHA_BITS: 0x0D55

  защищено 
  DEPTH_BITS: 0x0D56

  защищено 
  STENCIL_BITS: 0x0D57

  защищено 
  POLYGON_OFFSET_UNITS: 0x2A00

  защищено 
  POLYGON_OFFSET_FACTOR: 0x8038

  защищено 
  TEXTURE_BINDING_2D: 0x8069

  защищено 
  SAMPLE_BUFFERS: 0x80A8

  защищено 
  SAMPLES: 0x80A9

  защищено 
  SAMPLE_COVERAGE_VALUE: 0x80AA

  защищено 
  SAMPLE_COVERAGE_INVERT: 0x80AB

  защищено 
  COMPRESSED_TEXTURE_FORMATS: 0x86A3

  защищено 
  DONT_CARE: 0x1100

  защищено 
  FASTEST: 0x1101

  защищено 
  NICEST: 0x1102

  защищено 
  GENERATE_MIPMAP_HINT: 0x8192

  защищено 
  BYTE: 0x1400

  защищено 
  UNSIGNED_BYTE: 0x1401

  защищено 
  SHORT: 0x1402

  защищено 
  UNSIGNED_SHORT: 0x1403

  защищено 
  INT: 0x1404

  защищено 
  UNSIGNED_INT: 0x1405

  защищено 
  FLOAT: 0x1406

  защищено 
  DEPTH_COMPONENT: 0x1902

  защищено 
  ALPHA: 0x1906

  защищено 
  RGB: 0x1907

  защищено 
  RGBA: 0x1908

  защищено 
  LUMINANCE: 0x1909

  защищено 
  LUMINANCE_ALPHA: 0x190A

  защищено 
  UNSIGNED_SHORT_4_4_4_4: 0x8033

  защищено 
  UNSIGNED_SHORT_5_5_5_1: 0x8034

  защищено 
  UNSIGNED_SHORT_5_6_5: 0x8363

  защищено 
  FRAGMENT_SHADER: 0x8B30

  защищено 
  VERTEX_SHADER: 0x8B31

  защищено 
  MAX_VERTEX_ATTRIBS: 0x8869

  защищено 
  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB

  защищено 
  MAX_VARYING_VECTORS: 0x8DFC

  защищено 
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D

  защищено 
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C

  защищено 
  MAX_TEXTURE_IMAGE_UNITS: 0x8872

  защищено 
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD

  защищено 
  SHADER_TYPE: 0x8B4F

  защищено 
  DELETE_STATUS: 0x8B80

  защищено 
  LINK_STATUS: 0x8B82

  защищено 
  VALIDATE_STATUS: 0x8B83

  защищено 
  ATTACHED_SHADERS: 0x8B85

  защищено 
  ACTIVE_UNIFORMS: 0x8B86

  защищено 
  ACTIVE_ATTRIBUTES: 0x8B89

  защищено 
  SHADING_LANGUAGE_VERSION: 0x8B8C

  защищено 
  CURRENT_PROGRAM: 0x8B8D

  защищено 
  NEVER: 0x0200

  защищено 
  LESS: 0x0201

  защищено 
  EQUAL: 0x0202

  защищено 
  LEQUAL: 0x0203

  защищено 
  GREATER: 0x0204

  защищено 
  NOTEQUAL: 0x0205

  защищено 
  GEQUAL: 0x0206

  защищено 
  ALWAYS: 0x0207

  защищено 
  KEEP: 0x1E00

  защищено 
  REPLACE: 0x1E01

  защищено 
  INCR: 0x1E02

  защищено 
  DECR: 0x1E03

  защищено 
  INVERT: 0x150A

  защищено 
  INCR_WRAP: 0x8507

  защищено 
  DECR_WRAP: 0x8508

  защищено 
  VENDOR: 0x1F00

  защищено 
  RENDERER: 0x1F01

  защищено 
  VERSION: 0x1F02

  защищено 
  NEAREST: 0x2600

  защищено 
  LINEAR: 0x2601

  защищено 
  NEAREST_MIPMAP_NEAREST: 0x2700

  защищено 
  LINEAR_MIPMAP_NEAREST: 0x2701

  защищено 
  NEAREST_MIPMAP_LINEAR: 0x2702

  защищено 
  LINEAR_MIPMAP_LINEAR: 0x2703

  защищено 
  TEXTURE_MAG_FILTER: 0x2800

  защищено 
  TEXTURE_MIN_FILTER: 0x2801

  защищено 
  TEXTURE_WRAP_S: 0x2802

  защищено 
  TEXTURE_WRAP_T: 0x2803

  защищено 
  TEXTURE_2D: 0x0DE1

  защищено 
  TEXTURE: 0x1702

  защищено 
  TEXTURE_CUBE_MAP: 0x8513

  защищено 
  TEXTURE_BINDING_CUBE_MAP: 0x8514

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518

  защищено 
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519

  защищено 
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A

  защищено 
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C

  защищено 
  TEXTURE0: 0x84C0

  защищено 
  TEXTURE1: 0x84C1

  защищено 
  TEXTURE2: 0x84C2

  защищено 
  TEXTURE3: 0x84C3

  защищено 
  TEXTURE4: 0x84C4

  защищено 
  TEXTURE5: 0x84C5

  защищено 
  TEXTURE6: 0x84C6

  защищено 
  TEXTURE7: 0x84C7

  защищено 
  TEXTURE8: 0x84C8

  защищено 
  TEXTURE9: 0x84C9

  защищено 
  TEXTURE10: 0x84CA

  защищено 
  TEXTURE11: 0x84CB

  защищено 
  TEXTURE12: 0x84CC

  защищено 
  TEXTURE13: 0x84CD

  защищено 
  TEXTURE14: 0x84CE

  защищено 
  TEXTURE15: 0x84CF

  защищено 
  TEXTURE16: 0x84D0

  защищено 
  TEXTURE17: 0x84D1

  защищено 
  TEXTURE18: 0x84D2

  защищено 
  TEXTURE19: 0x84D3

  защищено 
  TEXTURE20: 0x84D4

  защищено 
  TEXTURE21: 0x84D5

  защищено 
  TEXTURE22: 0x84D6

  защищено 
  TEXTURE23: 0x84D7

  защищено 
  TEXTURE24: 0x84D8

  защищено 
  TEXTURE25: 0x84D9

  защищено 
  TEXTURE26: 0x84DA

  защищено 
  TEXTURE27: 0x84DB

  защищено 
  TEXTURE28: 0x84DC

  защищено 
  TEXTURE29: 0x84DD

  защищено 
  TEXTURE30: 0x84DE

  защищено 
  TEXTURE31: 0x84DF

  защищено 
  ACTIVE_TEXTURE: 0x84E0

  защищено 
  REPEAT: 0x2901

  защищено 
  CLAMP_TO_EDGE: 0x812F

  защищено 
  MIRRORED_REPEAT: 0x8370

  защищено 
  FLOAT_VEC2: 0x8B50

  защищено 
  FLOAT_VEC3: 0x8B51

  защищено 
  FLOAT_VEC4: 0x8B52

  защищено 
  INT_VEC2: 0x8B53

  защищено 
  INT_VEC3: 0x8B54

  защищено 
  INT_VEC4: 0x8B55

  защищено 
  BOOL: 0x8B56

  защищено 
  BOOL_VEC2: 0x8B57

  защищено 
  BOOL_VEC3: 0x8B58

  защищено 
  BOOL_VEC4: 0x8B59

  защищено 
  FLOAT_MAT2: 0x8B5A

  защищено 
  FLOAT_MAT3: 0x8B5B

  защищено 
  FLOAT_MAT4: 0x8B5C

  защищено 
  SAMPLER_2D: 0x8B5E

  защищено 
  SAMPLER_CUBE: 0x8B60

  защищено 
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622

  защищено 
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623

  защищено 
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624

  защищено 
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625

  защищено 
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A

  защищено 
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645

  защищено 
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F

  защищено 
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A

  защищено 
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B

  защищено 
  COMPILE_STATUS: 0x8B81

  защищено 
  LOW_FLOAT: 0x8DF0

  защищено 
  MEDIUM_FLOAT: 0x8DF1

  защищено 
  HIGH_FLOAT: 0x8DF2

  защищено 
  LOW_INT: 0x8DF3

  защищено 
  MEDIUM_INT: 0x8DF4

  защищено 
  HIGH_INT: 0x8DF5

  защищено 
  FRAMEBUFFER: 0x8D40

  защищено 
  RENDERBUFFER: 0x8D41

  защищено 
  RGBA4: 0x8056

  защищено 
  RGB5_A1: 0x8057

  защищено 
  RGB565: 0x8D62

  защищено 
  DEPTH_COMPONENT16: 0x81A5

  защищено 
  STENCIL_INDEX8: 0x8D48

  защищено 
  DEPTH_STENCIL: 0x84F9

  защищено 
  RENDERBUFFER_WIDTH: 0x8D42

  защищено 
  RENDERBUFFER_HEIGHT: 0x8D43

  защищено 
  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44

  защищено 
  RENDERBUFFER_RED_SIZE: 0x8D50

  защищено 
  RENDERBUFFER_GREEN_SIZE: 0x8D51

  защищено 
  RENDERBUFFER_BLUE_SIZE: 0x8D52

  защищено 
  RENDERBUFFER_ALPHA_SIZE: 0x8D53

  защищено 
  RENDERBUFFER_DEPTH_SIZE: 0x8D54

  защищено 
  RENDERBUFFER_STENCIL_SIZE: 0x8D55

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0

  защищено 
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2

  защищено 
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3

  защищено 
  COLOR_ATTACHMENT0: 0x8CE0

  защищено 
  DEPTH_ATTACHMENT: 0x8D00

  защищено 
  STENCIL_ATTACHMENT: 0x8D20

  защищено 
  DEPTH_STENCIL_ATTACHMENT: 0x821A

  защищено 
  NONE: 0

  защищено 
  FRAMEBUFFER_COMPLETE: 0x8CD5

  защищено 
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6

  защищено 
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7

  защищено 
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9

  защищено 
  FRAMEBUFFER_UNSUPPORTED: 0x8CDD

  защищено 
  FRAMEBUFFER_BINDING: 0x8CA6

  защищено 
  RENDERBUFFER_BINDING: 0x8CA7

  защищено 
  MAX_RENDERBUFFER_SIZE: 0x84E8

  защищено 
  INVALID_FRAMEBUFFER_OPERATION: 0x0506

  защищено 
  UNPACK_FLIP_Y_WEBGL: 0x9240

  защищено 
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241

  защищено 
  CONTEXT_LOST_WEBGL: 0x9242

  защищено 
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243

  защищено 
  BROWSER_DEFAULT_WEBGL: 0x9244
}


тип WebGLRenderingContextOverloads = интерфейс
{
  операция bufferData(target: GLenum, size: GLsizeiptr, usage: GLenum)

  операция bufferData(target: GLenum, data: BufferSource?, usage: GLenum)

  операция bufferSubData(target: GLenum, offset: GLintptr, data: BufferSource)

  операция compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView)

  операция compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView)

  операция readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, pixels: ArrayBufferView?)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei, border: GLint, format: GLenum, type`: GLenum, pixels: ArrayBufferView?)

  операция texImage2D(target: GLenum, level: GLint, internalformat: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, type`: GLenum, pixels: ArrayBufferView?)

  операция texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, format: GLenum, type`: GLenum, source: TexImageSource)

  операция uniform1fv(location: WebGLUniformLocation?, v: Float32List)

  операция uniform1iv(location: WebGLUniformLocation?, v: Int32List)

  операция uniform2fv(location: WebGLUniformLocation?, v: Float32List)

  операция uniform2iv(location: WebGLUniformLocation?, v: Int32List)

  операция uniform3fv(location: WebGLUniformLocation?, v: Float32List)

  операция uniform3iv(location: WebGLUniformLocation?, v: Int32List)

  операция uniform4fv(location: WebGLUniformLocation?, v: Float32List)

  операция uniform4iv(location: WebGLUniformLocation?, v: Int32List)

  операция uniformMatrix2fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List)

  операция uniformMatrix3fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List)

  операция uniformMatrix4fv(location: WebGLUniformLocation?, transpose: GLboolean, value: Float32List)
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSampler) */

тип WebGLSampler = интерфейс
{

}


внешнее
/*(!) var */ WebGLSampler: объект { prototype: WebGLSampler; при создании(): WebGLSampler }


/**
* The WebGLShader is part of the WebGL API and can either be a vertex or a fragment shader. A WebGLProgram requires both types of shaders.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShader)
*/

тип WebGLShader = интерфейс
{

}


внешнее
/*(!) var */ WebGLShader: объект { prototype: WebGLShader; при создании(): WebGLShader }


/**
* Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getShaderPrecisionFormat() method.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLShaderPrecisionFormat)
*/

тип WebGLShaderPrecisionFormat = интерфейс
{
  защищено 
  precision: GLint

  защищено 
  rangeMax: GLint

  защищено 
  rangeMin: GLint
}


внешнее
/*(!) var */ WebGLShaderPrecisionFormat: объект { prototype: WebGLShaderPrecisionFormat; при создании(): WebGLShaderPrecisionFormat }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLSync) */

тип WebGLSync = интерфейс
{

}


внешнее
/*(!) var */ WebGLSync: объект { prototype: WebGLSync; при создании(): WebGLSync }


/**
* Part of the WebGL API and represents an opaque texture object providing storage and state for texturing operations.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTexture)
*/

тип WebGLTexture = интерфейс
{

}


внешнее
/*(!) var */ WebGLTexture: объект { prototype: WebGLTexture; при создании(): WebGLTexture }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLTransformFeedback) */

тип WebGLTransformFeedback = интерфейс
{

}


внешнее
/*(!) var */ WebGLTransformFeedback: объект { prototype: WebGLTransformFeedback; при создании(): WebGLTransformFeedback }


/**
* Part of the WebGL API and represents the location of a uniform variable in a shader program.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLUniformLocation)
*/

тип WebGLUniformLocation = интерфейс
{

}


внешнее
/*(!) var */ WebGLUniformLocation: объект { prototype: WebGLUniformLocation; при создании(): WebGLUniformLocation }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObject) */

тип WebGLVertexArrayObject = интерфейс
{

}


внешнее
/*(!) var */ WebGLVertexArrayObject: объект { prototype: WebGLVertexArrayObject; при создании(): WebGLVertexArrayObject }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebGLVertexArrayObjectOES) */

тип WebGLVertexArrayObjectOES = интерфейс
{

}


тип WebSocketEventMap = интерфейс
{
  "close": CloseEvent

  "error": Event

  "message": MessageEvent

  "open": Event
}


/**
* Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)
*/

тип WebSocket = интерфейс на основе EventTarget
{
  binaryType: BinaryType

  защищено 
  bufferedAmount: Число

  защищено 
  extensions: Текст

  onclose: (операция(this: WebSocket, ev: CloseEvent): /*(!) any */ Объект?)?

  onerror: (операция(this: WebSocket, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: WebSocket, ev: MessageEvent): /*(!) any */ Объект?)?

  onopen: (операция(this: WebSocket, ev: Event): /*(!) any */ Объект?)?

  защищено 
  protocol: Текст

  защищено 
  readyState: Число

  защищено 
  url: Текст

  операция close(code: Число? = пусто, reason: Текст? = пусто)

  операция send(data: Объект? /*(!)Текст | ArrayBufferLike | Blob | ArrayBufferView*/)

  защищено 
  CONNECTING: 0

  защищено 
  OPEN: 1

  защищено 
  CLOSING: 2

  защищено 
  CLOSED: 3

  операция addEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type`: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof WebSocketEventMap */ Объект?>(type`: K, listener: операция(this: WebSocket, ev: /*(!) WebSocketEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ WebSocket: объект { prototype: WebSocket; при создании(url: Объект? /*(!)Текст | URL*/, protocols: Объект? /*(!)Текст | Список<Текст> | пусто*/ = пусто): WebSocket; защищено  CONNECTING: 0; защищено  OPEN: 1; защищено  CLOSING: 2; защищено  CLOSED: 3 }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransport)
*/

тип WebTransport = интерфейс
{
  защищено 
  closed: Promise<WebTransportCloseInfo>

  защищено 
  datagrams: WebTransportDatagramDuplexStream

  защищено 
  incomingBidirectionalStreams: ReadableStream

  защищено 
  incomingUnidirectionalStreams: ReadableStream

  защищено 
  ready: Promise<пусто>

  операция close(closeInfo: WebTransportCloseInfo? = пусто)

  операция createBidirectionalStream(options: WebTransportSendStreamOptions? = пусто): Promise<WebTransportBidirectionalStream>

  операция createUnidirectionalStream(options: WebTransportSendStreamOptions? = пусто): Promise<WritableStream>
}


внешнее
/*(!) var */ WebTransport: объект { prototype: WebTransport; при создании(url: Объект? /*(!)Текст | URL*/, options: WebTransportOptions? = пусто): WebTransport }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportBidirectionalStream)
*/

тип WebTransportBidirectionalStream = интерфейс
{
  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportBidirectionalStream: объект { prototype: WebTransportBidirectionalStream; при создании(): WebTransportBidirectionalStream }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportDatagramDuplexStream)
*/

тип WebTransportDatagramDuplexStream = интерфейс
{
  incomingHighWaterMark: Число

  incomingMaxAge: Число

  защищено 
  maxDatagramSize: Число

  outgoingHighWaterMark: Число

  outgoingMaxAge: Число

  защищено 
  readable: ReadableStream

  защищено 
  writable: WritableStream
}


внешнее
/*(!) var */ WebTransportDatagramDuplexStream: объект { prototype: WebTransportDatagramDuplexStream; при создании(): WebTransportDatagramDuplexStream }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebTransportError)
*/

тип WebTransportError = интерфейс на основе DOMException
{
  защищено 
  source: WebTransportErrorSource

  защищено 
  streamErrorCode: Число?
}


внешнее
/*(!) var */ WebTransportError: объект { prototype: WebTransportError; при создании(message: Текст? = пусто, options: WebTransportErrorOptions? = пусто): WebTransportError }


/**
* Events that occur due to the user moving a mouse wheel or similar input device.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WheelEvent)
*/

тип WheelEvent = интерфейс на основе MouseEvent
{
  защищено 
  deltaMode: Число

  защищено 
  deltaX: Число

  защищено 
  deltaY: Число

  защищено 
  deltaZ: Число

  защищено 
  DOM_DELTA_PIXEL: 0x00

  защищено 
  DOM_DELTA_LINE: 0x01

  защищено 
  DOM_DELTA_PAGE: 0x02
}


внешнее
/*(!) var */ WheelEvent: объект { prototype: WheelEvent; при создании(type`: Текст, eventInitDict: WheelEventInit? = пусто): WheelEvent; защищено  DOM_DELTA_PIXEL: 0x00; защищено  DOM_DELTA_LINE: 0x01; защищено  DOM_DELTA_PAGE: 0x02 }


тип WindowEventMap = интерфейс на основе GlobalEventHandlersEventMap, WindowEventHandlersEventMap
{
  "DOMContentLoaded": Event

  "devicemotion": DeviceMotionEvent

  "deviceorientation": DeviceOrientationEvent

  "gamepadconnected": GamepadEvent

  "gamepaddisconnected": GamepadEvent

  "orientationchange": Event
}


/**
* A window containing a DOM document; the document property points to the DOM document loaded in that window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window)
*/

тип Window = интерфейс на основе EventTarget, AnimationFrameProvider, GlobalEventHandlers, WindowEventHandlers, WindowLocalStorage, WindowOrWorkerGlobalScope, WindowSessionStorage
{
  операция location(href: Объект? /*(!)Текст | Location*/): /*(!) no_type */ Объект?

  операция postMessage(message: /*(!) any */ Объект?, options: WindowPostMessageOptions? = пусто)

  операция scroll(x: Число, y: Число)

  операция scrollBy(x: Число, y: Число)

  операция scrollTo(x: Число, y: Число)

  операция addEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type`: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type`: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  /*(!) [index: number]: Window*/
}


внешнее
/*(!) var */ Window: объект { prototype: Window; при создании(): Window }


тип WindowEventHandlersEventMap = интерфейс
{
  "afterprint": Event

  "beforeprint": Event

  "beforeunload": BeforeUnloadEvent

  "gamepadconnected": GamepadEvent

  "gamepaddisconnected": GamepadEvent

  "hashchange": HashChangeEvent

  "languagechange": Event

  "message": MessageEvent

  "messageerror": MessageEvent

  "offline": Event

  "online": Event

  "pagehide": PageTransitionEvent

  "pageshow": PageTransitionEvent

  "popstate": PopStateEvent

  "rejectionhandled": PromiseRejectionEvent

  "storage": StorageEvent

  "unhandledrejection": PromiseRejectionEvent

  "unload": Event
}


тип WindowEventHandlers = интерфейс
{
  onafterprint: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  onbeforeprint: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  onbeforeunload: (операция(this: WindowEventHandlers, ev: BeforeUnloadEvent): /*(!) any */ Объект?)?

  ongamepadconnected: (операция(this: WindowEventHandlers, ev: GamepadEvent): /*(!) any */ Объект?)?

  ongamepaddisconnected: (операция(this: WindowEventHandlers, ev: GamepadEvent): /*(!) any */ Объект?)?

  onhashchange: (операция(this: WindowEventHandlers, ev: HashChangeEvent): /*(!) any */ Объект?)?

  onlanguagechange: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  onmessage: (операция(this: WindowEventHandlers, ev: MessageEvent): /*(!) any */ Объект?)?

  onmessageerror: (операция(this: WindowEventHandlers, ev: MessageEvent): /*(!) any */ Объект?)?

  onoffline: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  ononline: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  onpagehide: (операция(this: WindowEventHandlers, ev: PageTransitionEvent): /*(!) any */ Объект?)?

  onpageshow: (операция(this: WindowEventHandlers, ev: PageTransitionEvent): /*(!) any */ Объект?)?

  onpopstate: (операция(this: WindowEventHandlers, ev: PopStateEvent): /*(!) any */ Объект?)?

  onrejectionhandled: (операция(this: WindowEventHandlers, ev: PromiseRejectionEvent): /*(!) any */ Объект?)?

  onstorage: (операция(this: WindowEventHandlers, ev: StorageEvent): /*(!) any */ Объект?)?

  onunhandledrejection: (операция(this: WindowEventHandlers, ev: PromiseRejectionEvent): /*(!) any */ Объект?)?

  onunload: (операция(this: WindowEventHandlers, ev: Event): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof WindowEventHandlersEventMap */ Объект?>(type`: K, listener: операция(this: WindowEventHandlers, ev: /*(!) WindowEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof WindowEventHandlersEventMap */ Объект?>(type`: K, listener: операция(this: WindowEventHandlers, ev: /*(!) WindowEventHandlersEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


тип WindowLocalStorage = интерфейс
{
  защищено 
  localStorage: Storage
}


тип WindowOrWorkerGlobalScope = интерфейс
{
  защищено 
  caches: CacheStorage

  защищено 
  crossOriginIsolated: ДаНет

  защищено 
  crypto: Crypto

  защищено 
  indexedDB: IDBFactory

  защищено 
  isSecureContext: ДаНет

  защищено 
  origin: Текст

  защищено 
  performance: Performance

  операция atob(data: Текст): Текст

  операция btoa(data: Текст): Текст

  операция clearInterval(id: Число?)

  операция clearTimeout(id: Число?)

  операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = пусто): Promise<ImageBitmap>

  операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions? = пусто): Promise<ImageBitmap>

  операция fetch(input: Объект? /*(!)RequestInfo | URL*/, init: RequestInit? = пусто): Promise<Response>

  операция queueMicrotask(callback: VoidFunction)

  операция reportError(e: /*(!) any */ Объект?)

  #js.МассивПараметров
  операция setInterval(handler: TimerHandler, timeout: Число? = пусто, arguments: Список</*(!) any */ Объект?>): Число

  #js.МассивПараметров
  операция setTimeout(handler: TimerHandler, timeout: Число? = пусто, arguments: Список</*(!) any */ Объект?>): Число

  операция structuredClone<T>(value: T, options: StructuredSerializeOptions? = пусто): T
}


тип WindowSessionStorage = интерфейс
{
  защищено 
  sessionStorage: Storage
}


тип WorkerEventMap = интерфейс на основе AbstractWorkerEventMap
{
  "message": MessageEvent

  "messageerror": MessageEvent
}


/**
* This Web Workers API interface represents a background task that can be easily created and can send messages back to its creator. Creating a worker is as simple as calling the Worker() constructor and specifying a script to be run in the worker thread.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Worker)
*/

тип Worker = интерфейс на основе EventTarget, AbstractWorker
{
  onmessage: (операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект?)?

  onmessageerror: (операция(this: Worker, ev: MessageEvent): /*(!) any */ Объект?)?

  операция postMessage(message: /*(!) any */ Объект?, transfer: Список<Transferable>)

  операция postMessage(message: /*(!) any */ Объект?, options: StructuredSerializeOptions? = пусто)

  операция terminate()

  операция addEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type`: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof WorkerEventMap */ Объект?>(type`: K, listener: операция(this: Worker, ev: /*(!) WorkerEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ Worker: объект { prototype: Worker; при создании(scriptURL: Объект? /*(!)Текст | URL*/, options: WorkerOptions? = пусто): Worker }


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Worklet)
*/

тип Worklet = интерфейс
{
  операция addModule(moduleURL: Объект? /*(!)Текст | URL*/, options: WorkletOptions? = пусто): Promise<Ничего>
}


внешнее
/*(!) var */ Worklet: объект { prototype: Worklet; при создании(): Worklet }


/**
* This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)
*/

тип WritableStream<W> = интерфейс
{
  защищено 
  locked: ДаНет

  операция abort(reason: /*(!) any */ Объект? = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция getWriter(): WritableStreamDefaultWriter<W>
}


внешнее
/*(!) var */ WritableStream: объект { prototype: WritableStream; при создании(underlyingSink: UnderlyingSink<W>? = пусто, strategy: QueuingStrategy<W>? = пусто): WritableStream<W> }


/**
* This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)
*/

тип WritableStreamDefaultController = интерфейс
{
  защищено 
  signal: AbortSignal

  операция error`(e: /*(!) any */ Объект? = пусто)
}


внешнее
/*(!) var */ WritableStreamDefaultController: объект { prototype: WritableStreamDefaultController; при создании(): WritableStreamDefaultController }


/**
* This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the < writer to the WritableStream ensuring that no other streams can write to the underlying sink.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)
*/

тип WritableStreamDefaultWriter<W> = интерфейс
{
  защищено 
  closed: Promise<пусто>

  защищено 
  desiredSize: Число?

  защищено 
  ready: Promise<пусто>

  операция abort(reason: /*(!) any */ Объект? = пусто): Promise<Ничего>

  операция close(): Promise<Ничего>

  операция releaseLock()

  операция write(chunk: W? = пусто): Promise<Ничего>
}


внешнее
/*(!) var */ WritableStreamDefaultWriter: объект { prototype: WritableStreamDefaultWriter; при создании(stream: WritableStream<W>): WritableStreamDefaultWriter<W> }


/**
* An XML document. It inherits from the generic Document and does not add any specific methods or properties to it: nevertheless, several algorithms behave differently with the two types of documents.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLDocument)
*/

тип XMLDocument = интерфейс на основе Document
{
  операция addEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type`: K, listener: операция(this: XMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof DocumentEventMap */ Объект?>(type`: K, listener: операция(this: XMLDocument, ev: /*(!) DocumentEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ XMLDocument: объект { prototype: XMLDocument; при создании(): XMLDocument }


тип XMLHttpRequestEventMap = интерфейс на основе XMLHttpRequestEventTargetEventMap
{
  "readystatechange": Event
}


/**
* Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequest)
*/

тип XMLHttpRequest = интерфейс на основе XMLHttpRequestEventTarget
{
  onreadystatechange: (операция(this: XMLHttpRequest, ev: Event): /*(!) any */ Объект?)?

  защищено 
  readyState: Число

  защищено 
  response: /*(!) any */ Объект?

  защищено 
  responseText: Текст

  responseType: XMLHttpRequestResponseType

  защищено 
  responseURL: Текст

  защищено 
  responseXML: Document?

  защищено 
  status: Число

  защищено 
  statusText: Текст

  timeout: Число

  защищено 
  upload: XMLHttpRequestUpload

  withCredentials: ДаНет

  операция abort()

  операция getAllResponseHeaders(): Текст

  операция getResponseHeader(name: Текст): Текст?

  операция open(method: Текст, url: Объект? /*(!)Текст | URL*/)

  операция open(method: Текст, url: Объект? /*(!)Текст | URL*/, async: ДаНет, username: Текст? = пусто, password: Текст? = пусто)

  операция overrideMimeType(mime: Текст)

  операция send(body: Объект? /*(!)Document | XMLHttpRequestBodyInit | пусто | пусто*/ = пусто)

  операция setRequestHeader(name: Текст, value: Текст)

  защищено 
  UNSENT: 0

  защищено 
  OPENED: 1

  защищено 
  HEADERS_RECEIVED: 2

  защищено 
  LOADING: 3

  защищено 
  DONE: 4

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequest, ev: /*(!) XMLHttpRequestEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ XMLHttpRequest: объект { prototype: XMLHttpRequest; при создании(): XMLHttpRequest; защищено  UNSENT: 0; защищено  OPENED: 1; защищено  HEADERS_RECEIVED: 2; защищено  LOADING: 3; защищено  DONE: 4 }


тип XMLHttpRequestEventTargetEventMap = интерфейс
{
  "abort": ProgressEvent<XMLHttpRequestEventTarget>

  "error": ProgressEvent<XMLHttpRequestEventTarget>

  "load": ProgressEvent<XMLHttpRequestEventTarget>

  "loadend": ProgressEvent<XMLHttpRequestEventTarget>

  "loadstart": ProgressEvent<XMLHttpRequestEventTarget>

  "progress": ProgressEvent<XMLHttpRequestEventTarget>

  "timeout": ProgressEvent<XMLHttpRequestEventTarget>
}


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestEventTarget) */

тип XMLHttpRequestEventTarget = интерфейс на основе EventTarget
{
  onabort: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  onerror: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  onload: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  onloadend: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  onloadstart: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  onprogress: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  ontimeout: (операция(this: XMLHttpRequest, ev: ProgressEvent): /*(!) any */ Объект?)?

  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequestEventTarget, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestEventTarget: объект { prototype: XMLHttpRequestEventTarget; при создании(): XMLHttpRequestEventTarget }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLHttpRequestUpload) */

тип XMLHttpRequestUpload = интерфейс на основе XMLHttpRequestEventTarget
{
  операция addEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

  операция removeEventListener<K = /*(!) keyof XMLHttpRequestEventTargetEventMap */ Объект?>(type`: K, listener: операция(this: XMLHttpRequestUpload, ev: /*(!) XMLHttpRequestEventTargetEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

  операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)
}


внешнее
/*(!) var */ XMLHttpRequestUpload: объект { prototype: XMLHttpRequestUpload; при создании(): XMLHttpRequestUpload }


/**
* Provides the serializeToString() method to construct an XML string representing a DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XMLSerializer)
*/

тип XMLSerializer = интерфейс
{
  операция serializeToString(root: Node): Текст
}


внешнее
/*(!) var */ XMLSerializer: объект { prototype: XMLSerializer; при создании(): XMLSerializer }


/**
* The XPathEvaluator interface allows to compile and evaluate XPath expressions.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathEvaluator)
*/

тип XPathEvaluator = интерфейс на основе XPathEvaluatorBase
{

}


внешнее
/*(!) var */ XPathEvaluator: объект { prototype: XPathEvaluator; при создании(): XPathEvaluator }


тип XPathEvaluatorBase = интерфейс
{
  операция createExpression(expression: Текст, resolver: XPathNSResolver? = пусто): XPathExpression

  операция createNSResolver(nodeResolver: Node): Node

  операция evaluate(expression: Текст, contextNode: Node, resolver: XPathNSResolver? = пусто, type`: Число? = пусто, result: XPathResult? = пусто): XPathResult
}


/**
* This interface is a compiled XPath expression that can be evaluated on a document or specific node to return information its DOM tree.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathExpression)
*/

тип XPathExpression = интерфейс
{
  операция evaluate(contextNode: Node, type`: Число? = пусто, result: XPathResult? = пусто): XPathResult
}


внешнее
/*(!) var */ XPathExpression: объект { prototype: XPathExpression; при создании(): XPathExpression }


/**
* The results generated by evaluating an XPath expression within the context of a given node.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XPathResult)
*/

тип XPathResult = интерфейс
{
  защищено 
  booleanValue: ДаНет

  защищено 
  invalidIteratorState: ДаНет

  защищено 
  numberValue: Число

  защищено 
  resultType: Число

  защищено 
  singleNodeValue: Node?

  защищено 
  snapshotLength: Число

  защищено 
  stringValue: Текст

  операция iterateNext(): Node?

  операция snapshotItem(index: Число): Node?

  защищено 
  ANY_TYPE: 0

  защищено 
  NUMBER_TYPE: 1

  защищено 
  STRING_TYPE: 2

  защищено 
  BOOLEAN_TYPE: 3

  защищено 
  UNORDERED_NODE_ITERATOR_TYPE: 4

  защищено 
  ORDERED_NODE_ITERATOR_TYPE: 5

  защищено 
  UNORDERED_NODE_SNAPSHOT_TYPE: 6

  защищено 
  ORDERED_NODE_SNAPSHOT_TYPE: 7

  защищено 
  ANY_UNORDERED_NODE_TYPE: 8

  защищено 
  FIRST_ORDERED_NODE_TYPE: 9
}


внешнее
/*(!) var */ XPathResult: объект { prototype: XPathResult; при создании(): XPathResult; защищено  ANY_TYPE: 0; защищено  NUMBER_TYPE: 1; защищено  STRING_TYPE: 2; защищено  BOOLEAN_TYPE: 3; защищено  UNORDERED_NODE_ITERATOR_TYPE: 4; защищено  ORDERED_NODE_ITERATOR_TYPE: 5; защищено  UNORDERED_NODE_SNAPSHOT_TYPE: 6; защищено  ORDERED_NODE_SNAPSHOT_TYPE: 7; защищено  ANY_UNORDERED_NODE_TYPE: 8; защищено  FIRST_ORDERED_NODE_TYPE: 9 }


/**
* An XSLTProcessor applies an XSLT stylesheet transformation to an XML document to produce a new XML document as output. It has methods to load the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to apply the transformation to documents.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/XSLTProcessor)
*/

тип XSLTProcessor = интерфейс
{
  операция clearParameters()

  операция getParameter(namespaceURI: Текст?, localName: Текст): /*(!) any */ Объект?

  операция importStylesheet(style: Node)

  операция removeParameter(namespaceURI: Текст?, localName: Текст)

  операция reset()

  операция setParameter(namespaceURI: Текст?, localName: Текст, value: /*(!) any */ Объект?)

  операция transformToDocument(source: Node): Document

  операция transformToFragment(source: Node, output: Document): DocumentFragment
}


внешнее
/*(!) var */ XSLTProcessor: объект { prototype: XSLTProcessor; при создании(): XSLTProcessor }


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */

тип Console = интерфейс
{
  #js.МассивПараметров
  операция assert(condition: ДаНет? = пусто, data: Список</*(!) any */ Объект?>)

  операция clear()

  операция count(label: Текст? = пусто)

  операция countReset(label: Текст? = пусто)

  #js.МассивПараметров
  операция debug(data: Список</*(!) any */ Объект?>)

  операция dir(item: /*(!) any */ Объект? = пусто, options: /*(!) any */ Объект? = пусто)

  #js.МассивПараметров
  операция dirxml(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция error`(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция group(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция groupCollapsed(data: Список</*(!) any */ Объект?>)

  операция groupEnd()

  #js.МассивПараметров
  операция info(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция log(data: Список</*(!) any */ Объект?>)

  операция table(tabularData: /*(!) any */ Объект? = пусто, properties: Список<Текст>? = пусто)

  операция time(label: Текст? = пусто)

  операция timeEnd(label: Текст? = пусто)

  #js.МассивПараметров
  операция timeLog(label: Текст? = пусто, data: Список</*(!) any */ Объект?>)

  операция timeStamp(label: Текст? = пусто)

  #js.МассивПараметров
  операция trace(data: Список</*(!) any */ Объект?>)

  #js.МассивПараметров
  операция warn(data: Список</*(!) any */ Объект?>)
}


внешнее
/*(!) var */ console: Console


/** Holds useful CSS-related methods. No object with this interface are implemented: it contains only static methods and therefore is a utilitarian interface. */

внешнее /*(!) CSS */
{
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция Hz(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция Q(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция ch(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cm(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqb(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqh(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqmax(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqmin(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция cqw(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция deg(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dpcm(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dpi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dppx(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvb(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvh(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvmax(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvmin(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция dvw(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция em(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/escape_static) */

  операция escape(ident: Текст): Текст

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция ex(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция fr(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция grad(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция kHz(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvb(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvh(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvmax(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvmin(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция lvw(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция mm(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция ms(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция number(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция pc(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция percent(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция pt(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция px(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция rad(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/registerProperty_static) */

  операция registerProperty(definition: PropertyDefinition)

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция rem(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция s(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/supports_static) */

  операция supports(property: Текст, value: Текст): ДаНет

  операция supports(conditionText: Текст): ДаНет

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svb(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svh(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svmax(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svmin(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция svw(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция turn(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vb(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vh(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vi(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vmax(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vmin(value: Число): CSSUnitValue

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/CSS/factory_functions_static) */

  операция vw(value: Число): CSSUnitValue}

внешнее /*(!) WebAssembly */
{
  тип CompileError = интерфейс на основе Error
  {

  }


  /*(!) var */ CompileError: объект { prototype: CompileError; при создании(message: Текст? = пусто): CompileError; /*(!) (message?: string): CompileError*/ }


  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Global) */

  тип Global<T = ValueType> = интерфейс
  {
    value: /*(!) ValueTypeMap[T] */ Объект?

    операция valueOf(): /*(!) ValueTypeMap[T] */ Объект?
  }


  /*(!) var */ Global: объект { prototype: Global; при создании(descriptor: GlobalDescriptor<T>, v: /*(!) ValueTypeMap[T] */ Объект? = пусто): Global<T> }


  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance) */

  тип Instance = интерфейс
  {
    защищено 
    exports: Exports
  }


  /*(!) var */ Instance: объект { prototype: Instance; при создании(module: Module, importObject: Imports? = пусто): Instance }


  тип LinkError = интерфейс на основе Error
  {

  }


  /*(!) var */ LinkError: объект { prototype: LinkError; при создании(message: Текст? = пусто): LinkError; /*(!) (message?: string): LinkError*/ }


  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory) */

  тип Memory = интерфейс
  {
    защищено 
    buffer: ArrayBuffer

    операция grow(delta: Число): Число
  }


  /*(!) var */ Memory: объект { prototype: Memory; при создании(descriptor: MemoryDescriptor): Memory }


  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) */

  тип Module = интерфейс
  {

  }


  /*(!) var */ Module: объект { prototype: Module; при создании(bytes: BufferSource): Module; операция customSections(moduleObject: Module, sectionName: Текст): Список<ArrayBuffer>; операция exports(moduleObject: Module): Список<ModuleExportDescriptor>; операция imports(moduleObject: Module): Список<ModuleImportDescriptor> }


  тип RuntimeError = интерфейс на основе Error
  {

  }


  /*(!) var */ RuntimeError: объект { prototype: RuntimeError; при создании(message: Текст? = пусто): RuntimeError; /*(!) (message?: string): RuntimeError*/ }


  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Table) */

  тип Table = интерфейс
  {
    защищено 
    length: Число

    операция get(index: Число): /*(!) any */ Объект?

    операция grow(delta: Число, value: /*(!) any */ Объект? = пусто): Число

    операция set(index: Число, value: /*(!) any */ Объект? = пусто)
  }


  /*(!) var */ Table: объект { prototype: Table; при создании(descriptor: TableDescriptor, value: /*(!) any */ Объект? = пусто): Table }


  тип GlobalDescriptor<T = ValueType> = интерфейс
  {
    mutable: ДаНет

    value: T
  }


  тип MemoryDescriptor = интерфейс
  {
    initial: Число

    maximum: Число

    shared: ДаНет
  }


  тип ModuleExportDescriptor = интерфейс
  {
    kind: ImportExportKind

    name: Текст
  }


  тип ModuleImportDescriptor = интерфейс
  {
    kind: ImportExportKind

    module: Текст

    name: Текст
  }


  тип TableDescriptor = интерфейс
  {
    element: TableKind

    initial: Число

    maximum: Число
  }


  тип ValueTypeMap = интерфейс
  {
    anyfunc: Function

    externref: /*(!) any */ Объект?

    f32: Число

    f64: Число

    i32: Число

    i64: bigint

    v128: Никогда
  }


  тип WebAssemblyInstantiatedSource = интерфейс
  {
    instance: Instance

    module: Module
  }


  тип ImportExportKind = Объект? /*(!)"function" | "global" | "memory" | "table"*/

  тип TableKind = Объект? /*(!)"anyfunc" | "externref"*/

  тип ExportValue = Объект? /*(!)Function | Global | Memory | Table*/

  тип Exports = Record<Текст, ExportValue>

  тип ImportValue = Объект? /*(!)ExportValue | Число*/

  тип Imports = Record<Текст, ModuleImports>

  тип ModuleImports = Record<Текст, ImportValue>

  тип ValueType = /*(!) keyof ValueTypeMap */ Объект?

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile) */

  операция compile(bytes: BufferSource): Promise<Module>

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compileStreaming) */

  операция compileStreaming(source: Объект? /*(!)Response | PromiseLike<Response>*/): Promise<Module>

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate) */

  операция instantiate(bytes: BufferSource, importObject: Imports? = пусто): Promise<WebAssemblyInstantiatedSource>

  операция instantiate(moduleObject: Module, importObject: Imports? = пусто): Promise<Instance>

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming) */

  операция instantiateStreaming(source: Объект? /*(!)Response | PromiseLike<Response>*/, importObject: Imports? = пусто): Promise<WebAssemblyInstantiatedSource>

  /** [MDN Reference](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/validate) */

  операция validate(bytes: BufferSource): ДаНет}

тип BlobCallback = интерфейс
{
  /*(!) (blob: Blob | null): void*/
}


тип CustomElementConstructor = интерфейс
{
  #js.МассивПараметров
  при создании(params: Список</*(!) any */ Объект?>): HTMLElement
}


тип DecodeErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип DecodeSuccessCallback = интерфейс
{
  /*(!) (decodedData: AudioBuffer): void*/
}


тип EncodedVideoChunkOutputCallback = интерфейс
{
  /*(!) (chunk: EncodedVideoChunk, metadata?: EncodedVideoChunkMetadata): void*/
}


тип ErrorCallback = интерфейс
{
  /*(!) (err: DOMException): void*/
}


тип FileCallback = интерфейс
{
  /*(!) (file: File): void*/
}


тип FileSystemEntriesCallback = интерфейс
{
  /*(!) (entries: FileSystemEntry[]): void*/
}


тип FileSystemEntryCallback = интерфейс
{
  /*(!) (entry: FileSystemEntry): void*/
}


тип FrameRequestCallback = интерфейс
{
  /*(!) (time: DOMHighResTimeStamp): void*/
}


тип FunctionStringCallback = интерфейс
{
  /*(!) (data: string): void*/
}


тип IdleRequestCallback = интерфейс
{
  /*(!) (deadline: IdleDeadline): void*/
}


тип IntersectionObserverCallback = интерфейс
{
  /*(!) (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void*/
}


тип LockGrantedCallback = интерфейс
{
  /*(!) (lock: Lock | null): any*/
}


тип MediaSessionActionHandler = интерфейс
{
  /*(!) (details: MediaSessionActionDetails): void*/
}


тип MutationCallback = интерфейс
{
  /*(!) (mutations: MutationRecord[], observer: MutationObserver): void*/
}


тип NotificationPermissionCallback = интерфейс
{
  /*(!) (permission: NotificationPermission): void*/
}


тип OnBeforeUnloadEventHandlerNonNull = интерфейс
{
  /*(!) (event: Event): string | null*/
}


тип OnErrorEventHandlerNonNull = интерфейс
{
  /*(!) (event: Event | string, source?: string, lineno?: number, colno?: number, error?: Error): any*/
}


тип PerformanceObserverCallback = интерфейс
{
  /*(!) (entries: PerformanceObserverEntryList, observer: PerformanceObserver): void*/
}


тип PositionCallback = интерфейс
{
  /*(!) (position: GeolocationPosition): void*/
}


тип PositionErrorCallback = интерфейс
{
  /*(!) (positionError: GeolocationPositionError): void*/
}


тип QueuingStrategySize<T> = интерфейс
{
  /*(!) (chunk: T): number*/
}


тип RTCPeerConnectionErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип RTCSessionDescriptionCallback = интерфейс
{
  /*(!) (description: RTCSessionDescriptionInit): void*/
}


тип RemotePlaybackAvailabilityCallback = интерфейс
{
  /*(!) (available: boolean): void*/
}


тип ReportingObserverCallback = интерфейс
{
  /*(!) (reports: Report[], observer: ReportingObserver): void*/
}


тип ResizeObserverCallback = интерфейс
{
  /*(!) (entries: ResizeObserverEntry[], observer: ResizeObserver): void*/
}


тип TransformerFlushCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип TransformerStartCallback<O> = интерфейс
{
  /*(!) (controller: TransformStreamDefaultController<O>): any*/
}


тип TransformerTransformCallback<I, O> = интерфейс
{
  /*(!) (chunk: I, controller: TransformStreamDefaultController<O>): void | PromiseLike<void>*/
}


тип UnderlyingSinkAbortCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSinkCloseCallback = интерфейс
{
  /*(!) (): void | PromiseLike<void>*/
}


тип UnderlyingSinkStartCallback = интерфейс
{
  /*(!) (controller: WritableStreamDefaultController): any*/
}


тип UnderlyingSinkWriteCallback<W> = интерфейс
{
  /*(!) (chunk: W, controller: WritableStreamDefaultController): void | PromiseLike<void>*/
}


тип UnderlyingSourceCancelCallback = интерфейс
{
  /*(!) (reason?: any): void | PromiseLike<void>*/
}


тип UnderlyingSourcePullCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): void | PromiseLike<void>*/
}


тип UnderlyingSourceStartCallback<R> = интерфейс
{
  /*(!) (controller: ReadableStreamController<R>): any*/
}


тип VideoFrameOutputCallback = интерфейс
{
  /*(!) (output: VideoFrame): void*/
}


тип VideoFrameRequestCallback = интерфейс
{
  /*(!) (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadata): void*/
}


тип VoidFunction = интерфейс
{
  /*(!) (): void*/
}


тип WebCodecsErrorCallback = интерфейс
{
  /*(!) (error: DOMException): void*/
}


тип HTMLElementTagNameMap = интерфейс
{
  "a": HTMLAnchorElement

  "abbr": HTMLElement

  "address": HTMLElement

  "area": HTMLAreaElement

  "article": HTMLElement

  "aside": HTMLElement

  "audio": HTMLAudioElement

  "b": HTMLElement

  "base": HTMLBaseElement

  "bdi": HTMLElement

  "bdo": HTMLElement

  "blockquote": HTMLQuoteElement

  "body": HTMLBodyElement

  "br": HTMLBRElement

  "button": HTMLButtonElement

  "canvas": HTMLCanvasElement

  "caption": HTMLTableCaptionElement

  "cite": HTMLElement

  "code": HTMLElement

  "col": HTMLTableColElement

  "colgroup": HTMLTableColElement

  "data": HTMLDataElement

  "datalist": HTMLDataListElement

  "dd": HTMLElement

  "del": HTMLModElement

  "details": HTMLDetailsElement

  "dfn": HTMLElement

  "dialog": HTMLDialogElement

  "div": HTMLDivElement

  "dl": HTMLDListElement

  "dt": HTMLElement

  "em": HTMLElement

  "embed": HTMLEmbedElement

  "fieldset": HTMLFieldSetElement

  "figcaption": HTMLElement

  "figure": HTMLElement

  "footer": HTMLElement

  "form": HTMLFormElement

  "h1": HTMLHeadingElement

  "h2": HTMLHeadingElement

  "h3": HTMLHeadingElement

  "h4": HTMLHeadingElement

  "h5": HTMLHeadingElement

  "h6": HTMLHeadingElement

  "head": HTMLHeadElement

  "header": HTMLElement

  "hgroup": HTMLElement

  "hr": HTMLHRElement

  "html": HTMLHtmlElement

  "i": HTMLElement

  "iframe": HTMLIFrameElement

  "img": HTMLImageElement

  "input": HTMLInputElement

  "ins": HTMLModElement

  "kbd": HTMLElement

  "label": HTMLLabelElement

  "legend": HTMLLegendElement

  "li": HTMLLIElement

  "link": HTMLLinkElement

  "main": HTMLElement

  "map": HTMLMapElement

  "mark": HTMLElement

  "menu": HTMLMenuElement

  "meta": HTMLMetaElement

  "meter": HTMLMeterElement

  "nav": HTMLElement

  "noscript": HTMLElement

  "object": HTMLObjectElement

  "ol": HTMLOListElement

  "optgroup": HTMLOptGroupElement

  "option": HTMLOptionElement

  "output": HTMLOutputElement

  "p": HTMLParagraphElement

  "picture": HTMLPictureElement

  "pre": HTMLPreElement

  "progress": HTMLProgressElement

  "q": HTMLQuoteElement

  "rp": HTMLElement

  "rt": HTMLElement

  "ruby": HTMLElement

  "s": HTMLElement

  "samp": HTMLElement

  "script": HTMLScriptElement

  "search": HTMLElement

  "section": HTMLElement

  "select": HTMLSelectElement

  "slot": HTMLSlotElement

  "small": HTMLElement

  "source": HTMLSourceElement

  "span": HTMLSpanElement

  "strong": HTMLElement

  "style": HTMLStyleElement

  "sub": HTMLElement

  "summary": HTMLElement

  "sup": HTMLElement

  "table": HTMLTableElement

  "tbody": HTMLTableSectionElement

  "td": HTMLTableCellElement

  "template": HTMLTemplateElement

  "textarea": HTMLTextAreaElement

  "tfoot": HTMLTableSectionElement

  "th": HTMLTableCellElement

  "thead": HTMLTableSectionElement

  "time": HTMLTimeElement

  "title": HTMLTitleElement

  "tr": HTMLTableRowElement

  "track": HTMLTrackElement

  "u": HTMLElement

  "ul": HTMLUListElement

  "var": HTMLElement

  "video": HTMLVideoElement

  "wbr": HTMLElement
}


тип HTMLElementDeprecatedTagNameMap = интерфейс
{
  "acronym": HTMLElement

  "applet": HTMLUnknownElement

  "basefont": HTMLElement

  "bgsound": HTMLUnknownElement

  "big": HTMLElement

  "blink": HTMLUnknownElement

  "center": HTMLElement

  "dir": HTMLDirectoryElement

  "font": HTMLFontElement

  "frame": HTMLFrameElement

  "frameset": HTMLFrameSetElement

  "isindex": HTMLUnknownElement

  "keygen": HTMLUnknownElement

  "listing": HTMLPreElement

  "marquee": HTMLMarqueeElement

  "menuitem": HTMLElement

  "multicol": HTMLUnknownElement

  "nextid": HTMLUnknownElement

  "nobr": HTMLElement

  "noembed": HTMLElement

  "noframes": HTMLElement

  "param": HTMLParamElement

  "plaintext": HTMLElement

  "rb": HTMLElement

  "rtc": HTMLElement

  "spacer": HTMLUnknownElement

  "strike": HTMLElement

  "tt": HTMLElement

  "xmp": HTMLPreElement
}


тип SVGElementTagNameMap = интерфейс
{
  "a": SVGAElement

  "animate": SVGAnimateElement

  "animateMotion": SVGAnimateMotionElement

  "animateTransform": SVGAnimateTransformElement

  "circle": SVGCircleElement

  "clipPath": SVGClipPathElement

  "defs": SVGDefsElement

  "desc": SVGDescElement

  "ellipse": SVGEllipseElement

  "feBlend": SVGFEBlendElement

  "feColorMatrix": SVGFEColorMatrixElement

  "feComponentTransfer": SVGFEComponentTransferElement

  "feComposite": SVGFECompositeElement

  "feConvolveMatrix": SVGFEConvolveMatrixElement

  "feDiffuseLighting": SVGFEDiffuseLightingElement

  "feDisplacementMap": SVGFEDisplacementMapElement

  "feDistantLight": SVGFEDistantLightElement

  "feDropShadow": SVGFEDropShadowElement

  "feFlood": SVGFEFloodElement

  "feFuncA": SVGFEFuncAElement

  "feFuncB": SVGFEFuncBElement

  "feFuncG": SVGFEFuncGElement

  "feFuncR": SVGFEFuncRElement

  "feGaussianBlur": SVGFEGaussianBlurElement

  "feImage": SVGFEImageElement

  "feMerge": SVGFEMergeElement

  "feMergeNode": SVGFEMergeNodeElement

  "feMorphology": SVGFEMorphologyElement

  "feOffset": SVGFEOffsetElement

  "fePointLight": SVGFEPointLightElement

  "feSpecularLighting": SVGFESpecularLightingElement

  "feSpotLight": SVGFESpotLightElement

  "feTile": SVGFETileElement

  "feTurbulence": SVGFETurbulenceElement

  "filter": SVGFilterElement

  "foreignObject": SVGForeignObjectElement

  "g": SVGGElement

  "image": SVGImageElement

  "line": SVGLineElement

  "linearGradient": SVGLinearGradientElement

  "marker": SVGMarkerElement

  "mask": SVGMaskElement

  "metadata": SVGMetadataElement

  "mpath": SVGMPathElement

  "path": SVGPathElement

  "pattern": SVGPatternElement

  "polygon": SVGPolygonElement

  "polyline": SVGPolylineElement

  "radialGradient": SVGRadialGradientElement

  "rect": SVGRectElement

  "script": SVGScriptElement

  "set": SVGSetElement

  "stop": SVGStopElement

  "style": SVGStyleElement

  "svg": SVGSVGElement

  "switch": SVGSwitchElement

  "symbol": SVGSymbolElement

  "text": SVGTextElement

  "textPath": SVGTextPathElement

  "title": SVGTitleElement

  "tspan": SVGTSpanElement

  "use": SVGUseElement

  "view": SVGViewElement
}


тип MathMLElementTagNameMap = интерфейс
{
  "annotation": MathMLElement

  "annotation-xml": MathMLElement

  "maction": MathMLElement

  "math": MathMLElement

  "merror": MathMLElement

  "mfrac": MathMLElement

  "mi": MathMLElement

  "mmultiscripts": MathMLElement

  "mn": MathMLElement

  "mo": MathMLElement

  "mover": MathMLElement

  "mpadded": MathMLElement

  "mphantom": MathMLElement

  "mprescripts": MathMLElement

  "mroot": MathMLElement

  "mrow": MathMLElement

  "ms": MathMLElement

  "mspace": MathMLElement

  "msqrt": MathMLElement

  "mstyle": MathMLElement

  "msub": MathMLElement

  "msubsup": MathMLElement

  "msup": MathMLElement

  "mtable": MathMLElement

  "mtd": MathMLElement

  "mtext": MathMLElement

  "mtr": MathMLElement

  "munder": MathMLElement

  "munderover": MathMLElement

  "semantics": MathMLElement
}


внешнее
/*(!) var */ Audio: объект { при создании(src: Текст? = пусто): HTMLAudioElement }


внешнее
/*(!) var */ Image: объект { при создании(width: Число? = пусто, height: Число? = пусто): HTMLImageElement }


внешнее
/*(!) var */ Option: объект { при создании(text: Текст? = пусто, value: Текст? = пусто, defaultSelected: ДаНет? = пусто, selected: ДаНет? = пусто): HTMLOptionElement }


/**
* Returns true if the window has been closed, false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/closed)
*/

внешнее
/*(!) var */ closed: ДаНет


/**
* Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/customElements)
*/

внешнее
/*(!) var */ customElements: CustomElementRegistry


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/devicePixelRatio) */

внешнее
/*(!) var */ devicePixelRatio: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/document) */

внешнее
/*(!) var */ document: Document


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/frameElement) */

внешнее
/*(!) var */ frameElement: Element?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/frames) */

внешнее
/*(!) var */ frames: WindowProxy


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/history) */

внешнее
/*(!) var */ history: History


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/innerHeight) */

внешнее
/*(!) var */ innerHeight: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/innerWidth) */

внешнее
/*(!) var */ innerWidth: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/length) */

внешнее
/*(!) var */ length: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/location) */

внешнее
/*(!) var */ location: Location


/**
* Returns true if the location bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/locationbar)
*/

внешнее
/*(!) var */ locationbar: BarProp


/**
* Returns true if the menu bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/menubar)
*/

внешнее
/*(!) var */ menubar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/name) */

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/navigator) */

внешнее
/*(!) var */ navigator: Navigator


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/devicemotion_event)
*/

внешнее
/*(!) var */ ondevicemotion: (операция(this: Window, ev: DeviceMotionEvent): /*(!) any */ Объект?)?


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/deviceorientation_event)
*/

внешнее
/*(!) var */ ondeviceorientation: (операция(this: Window, ev: DeviceOrientationEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/opener) */

внешнее
/*(!) var */ opener: /*(!) any */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/outerHeight) */

внешнее
/*(!) var */ outerHeight: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/outerWidth) */

внешнее
/*(!) var */ outerWidth: Число


/**
* Refers to either the parent WindowProxy, or itself.
*
* It can rarely be null e.g. for contentWindow of an iframe that is already removed from the parent.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/parent)
*/

внешнее
/*(!) var */ parent: WindowProxy


/**
* Returns true if the personal bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/personalbar)
*/

внешнее
/*(!) var */ personalbar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screen) */

внешнее
/*(!) var */ screen: Screen


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenLeft) */

внешнее
/*(!) var */ screenLeft: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenTop) */

внешнее
/*(!) var */ screenTop: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenX) */

внешнее
/*(!) var */ screenX: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/screenY) */

внешнее
/*(!) var */ screenY: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollX) */

внешнее
/*(!) var */ scrollX: Число


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollY) */

внешнее
/*(!) var */ scrollY: Число


/**
* Returns true if the scrollbars are visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollbars)
*/

внешнее
/*(!) var */ scrollbars: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/self) */

внешнее
/*(!) var */ self: /*(!) Window & typeof globalThis */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/speechSynthesis) */

внешнее
/*(!) var */ speechSynthesis: SpeechSynthesis


/**
* Returns true if the status bar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/statusbar)
*/

внешнее
/*(!) var */ statusbar: BarProp


/**
* Returns true if the toolbar is visible; otherwise, returns false.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/toolbar)
*/

внешнее
/*(!) var */ toolbar: BarProp


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/top) */

внешнее
/*(!) var */ top: WindowProxy?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/visualViewport) */

внешнее
/*(!) var */ visualViewport: VisualViewport?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/window) */

внешнее
/*(!) var */ window: /*(!) Window & typeof globalThis */ Объект?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/alert) */

внешнее
операция alert(message: /*(!) any */ Объект? = пусто)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/blur) */

внешнее
операция blur()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/cancelIdleCallback) */

внешнее
операция cancelIdleCallback(handle: Число)

/**
* Closes the window.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/close)
*/

внешнее
операция close()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/confirm) */

внешнее
операция confirm(message: Текст? = пусто): ДаНет

/**
* Moves the focus to the window's browsing context, if any.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/focus)
*/

внешнее
операция focus()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/getComputedStyle) */

внешнее
операция getComputedStyle(elt: Element, pseudoElt: Текст? = пусто): CSSStyleDeclaration

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/getSelection) */

внешнее
операция getSelection(): Selection?

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/matchMedia) */

внешнее
операция matchMedia(query: Текст): MediaQueryList

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/moveBy) */

внешнее
операция moveBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/moveTo) */

внешнее
операция moveTo(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/open) */

внешнее
операция open(url: Объект? /*(!)Текст | URL | пусто*/ = пусто, target: Текст? = пусто, features: Текст? = пусто): WindowProxy?

/**
* Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
*
* Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
*
* A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
*
* If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
*
* Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/postMessage)
*/

внешнее
операция postMessage(message: /*(!) any */ Объект?, targetOrigin: Текст, transfer: Список<Transferable>? = пусто)

внешнее
операция postMessage(message: /*(!) any */ Объект?, options: WindowPostMessageOptions? = пусто)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/print) */

внешнее
операция print()

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/prompt) */

внешнее
операция prompt(message: Текст? = пусто, _default: Текст? = пусто): Текст?

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/requestIdleCallback) */

внешнее
операция requestIdleCallback(callback: IdleRequestCallback, options: IdleRequestOptions? = пусто): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/resizeBy) */

внешнее
операция resizeBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/resizeTo) */

внешнее
операция resizeTo(width: Число, height: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scroll) */

внешнее
операция scroll(options: ScrollToOptions? = пусто)

внешнее
операция scroll(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollBy) */

внешнее
операция scrollBy(options: ScrollToOptions? = пусто)

внешнее
операция scrollBy(x: Число, y: Число)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/scrollTo) */

внешнее
операция scrollTo(options: ScrollToOptions? = пусто)

внешнее
операция scrollTo(x: Число, y: Число)

/**
* Cancels the document load.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/stop)
*/

внешнее
операция stop()

внешнее
операция toString(): Текст

/**
* Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
*/

внешнее
операция dispatchEvent(event: Event): ДаНет

внешнее
операция cancelAnimationFrame(handle: Число)

внешнее
операция requestAnimationFrame(callback: FrameRequestCallback): Число

/**
* Fires when the user aborts the download.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/abort_event)
*/

внешнее
/*(!) var */ onabort: (операция(this: Window, ev: UIEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationcancel_event) */

внешнее
/*(!) var */ onanimationcancel: (операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationend_event) */

внешнее
/*(!) var */ onanimationend: (операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationiteration_event) */

внешнее
/*(!) var */ onanimationiteration: (операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/animationstart_event) */

внешнее
/*(!) var */ onanimationstart: (операция(this: Window, ev: AnimationEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/auxclick_event) */

внешнее
/*(!) var */ onauxclick: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/beforeinput_event) */

внешнее
/*(!) var */ onbeforeinput: (операция(this: Window, ev: InputEvent): /*(!) any */ Объект?)?


/**
* Fires when the object loses the input focus.
* @param ev The focus event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/blur_event)
*/

внешнее
/*(!) var */ onblur: (операция(this: Window, ev: FocusEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement/cancel_event) */

внешнее
/*(!) var */ oncancel: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when playback is possible, but would require further buffering.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/canplay_event)
*/

внешнее
/*(!) var */ oncanplay: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/canplaythrough_event) */

внешнее
/*(!) var */ oncanplaythrough: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the contents of the object or selection have changed.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/change_event)
*/

внешнее
/*(!) var */ onchange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the user clicks the left mouse button on the object
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/click_event)
*/

внешнее
/*(!) var */ onclick: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDialogElement/close_event) */

внешнее
/*(!) var */ onclose: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the user clicks the right mouse button in the client area, opening the context menu.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/contextmenu_event)
*/

внешнее
/*(!) var */ oncontextmenu: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/copy_event) */

внешнее
/*(!) var */ oncopy: (операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLTrackElement/cuechange_event) */

внешнее
/*(!) var */ oncuechange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/cut_event) */

внешнее
/*(!) var */ oncut: (операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект?)?


/**
* Fires when the user double-clicks the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/dblclick_event)
*/

внешнее
/*(!) var */ ondblclick: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/**
* Fires on the source object continuously during a drag operation.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/drag_event)
*/

внешнее
/*(!) var */ ondrag: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Fires on the source object when the user releases the mouse at the close of a drag operation.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragend_event)
*/

внешнее
/*(!) var */ ondragend: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Fires on the target element when the user drags the object to a valid drop target.
* @param ev The drag event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragenter_event)
*/

внешнее
/*(!) var */ ondragenter: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.
* @param ev The drag event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragleave_event)
*/

внешнее
/*(!) var */ ondragleave: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Fires on the target element continuously while the user drags the object over a valid drop target.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragover_event)
*/

внешнее
/*(!) var */ ondragover: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Fires on the source object when the user starts to drag a text selection or selected object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/dragstart_event)
*/

внешнее
/*(!) var */ ondragstart: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/drop_event) */

внешнее
/*(!) var */ ondrop: (операция(this: Window, ev: DragEvent): /*(!) any */ Объект?)?


/**
* Occurs when the duration attribute is updated.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/durationchange_event)
*/

внешнее
/*(!) var */ ondurationchange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the media element is reset to its initial state.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/emptied_event)
*/

внешнее
/*(!) var */ onemptied: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the end of playback is reached.
* @param ev The event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/ended_event)
*/

внешнее
/*(!) var */ onended: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when an error occurs during object loading.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/error_event)
*/

внешнее
/*(!) var */ onerror: OnErrorEventHandler


/**
* Fires when the object receives focus.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/focus_event)
*/

внешнее
/*(!) var */ onfocus: (операция(this: Window, ev: FocusEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/formdata_event) */

внешнее
/*(!) var */ onformdata: (операция(this: Window, ev: FormDataEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/gotpointercapture_event) */

внешнее
/*(!) var */ ongotpointercapture: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLElement/input_event) */

внешнее
/*(!) var */ oninput: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement/invalid_event) */

внешнее
/*(!) var */ oninvalid: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the user presses a key.
* @param ev The keyboard event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/keydown_event)
*/

внешнее
/*(!) var */ onkeydown: (операция(this: Window, ev: KeyboardEvent): /*(!) any */ Объект?)?


/**
* Fires when the user releases a key.
* @param ev The keyboard event
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/keyup_event)
*/

внешнее
/*(!) var */ onkeyup: (операция(this: Window, ev: KeyboardEvent): /*(!) any */ Объект?)?


/**
* Fires immediately after the browser loads the object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SVGElement/load_event)
*/

внешнее
/*(!) var */ onload: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when media data is loaded at the current playback position.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadeddata_event)
*/

внешнее
/*(!) var */ onloadeddata: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the duration and dimensions of the media have been determined.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadedmetadata_event)
*/

внешнее
/*(!) var */ onloadedmetadata: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when Internet Explorer begins looking for media data.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/loadstart_event)
*/

внешнее
/*(!) var */ onloadstart: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/lostpointercapture_event) */

внешнее
/*(!) var */ onlostpointercapture: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/**
* Fires when the user clicks the object with either mouse button.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mousedown_event)
*/

внешнее
/*(!) var */ onmousedown: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseenter_event) */

внешнее
/*(!) var */ onmouseenter: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseleave_event) */

внешнее
/*(!) var */ onmouseleave: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/**
* Fires when the user moves the mouse over the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mousemove_event)
*/

внешнее
/*(!) var */ onmousemove: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/**
* Fires when the user moves the mouse pointer outside the boundaries of the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseout_event)
*/

внешнее
/*(!) var */ onmouseout: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/**
* Fires when the user moves the mouse pointer into the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseover_event)
*/

внешнее
/*(!) var */ onmouseover: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/**
* Fires when the user releases a mouse button while the mouse is over the object.
* @param ev The mouse event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/mouseup_event)
*/

внешнее
/*(!) var */ onmouseup: (операция(this: Window, ev: MouseEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/paste_event) */

внешнее
/*(!) var */ onpaste: (операция(this: Window, ev: ClipboardEvent): /*(!) any */ Объект?)?


/**
* Occurs when playback is paused.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/pause_event)
*/

внешнее
/*(!) var */ onpause: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the play method is requested.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/play_event)
*/

внешнее
/*(!) var */ onplay: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the audio or video has started playing.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/playing_event)
*/

внешнее
/*(!) var */ onplaying: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointercancel_event) */

внешнее
/*(!) var */ onpointercancel: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerdown_event) */

внешнее
/*(!) var */ onpointerdown: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerenter_event) */

внешнее
/*(!) var */ onpointerenter: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerleave_event) */

внешнее
/*(!) var */ onpointerleave: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointermove_event) */

внешнее
/*(!) var */ onpointermove: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerout_event) */

внешнее
/*(!) var */ onpointerout: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerover_event) */

внешнее
/*(!) var */ onpointerover: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/pointerup_event) */

внешнее
/*(!) var */ onpointerup: (операция(this: Window, ev: PointerEvent): /*(!) any */ Объект?)?


/**
* Occurs to indicate progress while downloading media data.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/progress_event)
*/

внешнее
/*(!) var */ onprogress: (операция(this: Window, ev: ProgressEvent): /*(!) any */ Объект?)?


/**
* Occurs when the playback rate is increased or decreased.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/ratechange_event)
*/

внешнее
/*(!) var */ onratechange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the user resets a form.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/reset_event)
*/

внешнее
/*(!) var */ onreset: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement/resize_event) */

внешнее
/*(!) var */ onresize: (операция(this: Window, ev: UIEvent): /*(!) any */ Объект?)?


/**
* Fires when the user repositions the scroll box in the scroll bar on the object.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/scroll_event)
*/

внешнее
/*(!) var */ onscroll: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/scrollend_event) */

внешнее
/*(!) var */ onscrollend: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/securitypolicyviolation_event) */

внешнее
/*(!) var */ onsecuritypolicyviolation: (операция(this: Window, ev: SecurityPolicyViolationEvent): /*(!) any */ Объект?)?


/**
* Occurs when the seek operation ends.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/seeked_event)
*/

внешнее
/*(!) var */ onseeked: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the current playback position is moved.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/seeking_event)
*/

внешнее
/*(!) var */ onseeking: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Fires when the current selection changes.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLInputElement/select_event)
*/

внешнее
/*(!) var */ onselect: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Document/selectionchange_event) */

внешнее
/*(!) var */ onselectionchange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node/selectstart_event) */

внешнее
/*(!) var */ onselectstart: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLSlotElement/slotchange_event) */

внешнее
/*(!) var */ onslotchange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when the download has stopped.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/stalled_event)
*/

внешнее
/*(!) var */ onstalled: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLFormElement/submit_event) */

внешнее
/*(!) var */ onsubmit: (операция(this: Window, ev: SubmitEvent): /*(!) any */ Объект?)?


/**
* Occurs if the load operation has been intentionally halted.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/suspend_event)
*/

внешнее
/*(!) var */ onsuspend: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs to indicate the current playback position.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/timeupdate_event)
*/

внешнее
/*(!) var */ ontimeupdate: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLDetailsElement/toggle_event) */

внешнее
/*(!) var */ ontoggle: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchcancel_event) */

внешнее
/*(!) var */ ontouchcancel: (операция(this: Window, ev: TouchEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchend_event) */

внешнее
/*(!) var */ ontouchend: (операция(this: Window, ev: TouchEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchmove_event) */

внешнее
/*(!) var */ ontouchmove: (операция(this: Window, ev: TouchEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/touchstart_event) */

внешнее
/*(!) var */ ontouchstart: (операция(this: Window, ev: TouchEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitioncancel_event) */

внешнее
/*(!) var */ ontransitioncancel: (операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionend_event) */

внешнее
/*(!) var */ ontransitionend: (операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionrun_event) */

внешнее
/*(!) var */ ontransitionrun: (операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/transitionstart_event) */

внешнее
/*(!) var */ ontransitionstart: (операция(this: Window, ev: TransitionEvent): /*(!) any */ Объект?)?


/**
* Occurs when the volume is changed, or playback is muted or unmuted.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/volumechange_event)
*/

внешнее
/*(!) var */ onvolumechange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/**
* Occurs when playback stops because the next frame of a video resource is not available.
* @param ev The event.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/HTMLMediaElement/waiting_event)
*/

внешнее
/*(!) var */ onwaiting: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Element/wheel_event) */

внешнее
/*(!) var */ onwheel: (операция(this: Window, ev: WheelEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/afterprint_event) */

внешнее
/*(!) var */ onafterprint: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/beforeprint_event) */

внешнее
/*(!) var */ onbeforeprint: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/beforeunload_event) */

внешнее
/*(!) var */ onbeforeunload: (операция(this: Window, ev: BeforeUnloadEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/gamepadconnected_event) */

внешнее
/*(!) var */ ongamepadconnected: (операция(this: Window, ev: GamepadEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/gamepaddisconnected_event) */

внешнее
/*(!) var */ ongamepaddisconnected: (операция(this: Window, ev: GamepadEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/hashchange_event) */

внешнее
/*(!) var */ onhashchange: (операция(this: Window, ev: HashChangeEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/languagechange_event) */

внешнее
/*(!) var */ onlanguagechange: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/message_event) */

внешнее
/*(!) var */ onmessage: (операция(this: Window, ev: MessageEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/messageerror_event) */

внешнее
/*(!) var */ onmessageerror: (операция(this: Window, ev: MessageEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/offline_event) */

внешнее
/*(!) var */ onoffline: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/online_event) */

внешнее
/*(!) var */ ononline: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/pagehide_event) */

внешнее
/*(!) var */ onpagehide: (операция(this: Window, ev: PageTransitionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/pageshow_event) */

внешнее
/*(!) var */ onpageshow: (операция(this: Window, ev: PageTransitionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/popstate_event) */

внешнее
/*(!) var */ onpopstate: (операция(this: Window, ev: PopStateEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/rejectionhandled_event) */

внешнее
/*(!) var */ onrejectionhandled: (операция(this: Window, ev: PromiseRejectionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/storage_event) */

внешнее
/*(!) var */ onstorage: (операция(this: Window, ev: StorageEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/unhandledrejection_event) */

внешнее
/*(!) var */ onunhandledrejection: (операция(this: Window, ev: PromiseRejectionEvent): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/unload_event) */

внешнее
/*(!) var */ onunload: (операция(this: Window, ev: Event): /*(!) any */ Объект?)?


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/localStorage) */

внешнее
/*(!) var */ localStorage: Storage


/**
* Available only in secure contexts.
*
* [MDN Reference](https://developer.mozilla.org/docs/Web/API/caches)
*/

внешнее
/*(!) var */ caches: CacheStorage


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crossOriginIsolated) */

внешнее
/*(!) var */ crossOriginIsolated: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/crypto_property) */

внешнее
/*(!) var */ crypto: Crypto


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/indexedDB) */

внешнее
/*(!) var */ indexedDB: IDBFactory


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/isSecureContext) */

внешнее
/*(!) var */ isSecureContext: ДаНет


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/origin) */

внешнее
/*(!) var */ origin: Текст


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/performance_property) */

внешнее
/*(!) var */ performance: Performance


/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/atob) */

внешнее
операция atob(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/btoa) */

внешнее
операция btoa(data: Текст): Текст

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearInterval) */

внешнее
операция clearInterval(id: Число?)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/clearTimeout) */

внешнее
операция clearTimeout(id: Число?)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/createImageBitmap) */

внешнее
операция createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions? = пусто): Promise<ImageBitmap>

внешнее
операция createImageBitmap(image: ImageBitmapSource, sx: Число, sy: Число, sw: Число, sh: Число, options: ImageBitmapOptions? = пусто): Promise<ImageBitmap>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/fetch) */

внешнее
операция fetch(input: Объект? /*(!)RequestInfo | URL*/, init: RequestInit? = пусто): Promise<Response>

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/queueMicrotask) */

внешнее
операция queueMicrotask(callback: VoidFunction)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/reportError) */

внешнее
операция reportError(e: /*(!) any */ Объект?)

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setInterval) */

внешнее
#js.МассивПараметров
операция setInterval(handler: TimerHandler, timeout: Число? = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/setTimeout) */

внешнее
#js.МассивПараметров
операция setTimeout(handler: TimerHandler, timeout: Число? = пусто, arguments: Список</*(!) any */ Объект?>): Число

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/structuredClone) */

внешнее
операция structuredClone<T>(value: T, options: StructuredSerializeOptions? = пусто): T

/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage) */

внешнее
/*(!) var */ sessionStorage: Storage


внешнее
операция addEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type`: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

внешнее
операция addEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | AddEventListenerOptions | пусто*/ = пусто)

внешнее
операция removeEventListener<K = /*(!) keyof WindowEventMap */ Объект?>(type`: K, listener: операция(this: Window, ev: /*(!) WindowEventMap[K] */ Объект?): /*(!) any */ Объект?, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

внешнее
операция removeEventListener(type`: Текст, listener: EventListenerOrEventListenerObject, options: Объект? /*(!)ДаНет | EventListenerOptions | пусто*/ = пусто)

тип AlgorithmIdentifier = Объект? /*(!)Algorithm | Текст*/

тип AllowSharedBufferSource = Объект? /*(!)ArrayBuffer | ArrayBufferView*/

тип AutoFill = Объект? /*(!)AutoFillBase | /*(!) `${OptionalPrefixToken<AutoFillSection>}${OptionalPrefixToken<AutoFillAddressKind>}${AutoFillField}${OptionalPostfixToken<AutoFillCredentialField>}` */ Объект?*/

тип AutoFillField = Объект? /*(!)AutoFillNormalField | /*(!) `${OptionalPrefixToken<AutoFillContactKind>}${AutoFillContactField}` */ Объект?*/

тип AutoFillSection = /*(!) `section-${string}` */ Объект?

тип BigInteger = Uint8Array

тип BinaryData = Объект? /*(!)ArrayBuffer | ArrayBufferView*/

тип BlobPart = Объект? /*(!)BufferSource | Blob | Текст*/

тип BodyInit = Объект? /*(!)ReadableStream | XMLHttpRequestBodyInit*/

тип BufferSource = Объект? /*(!)ArrayBufferView | ArrayBuffer*/

тип COSEAlgorithmIdentifier = Число

тип CSSKeywordish = Объект? /*(!)Текст | CSSKeywordValue*/

тип CSSNumberish = Объект? /*(!)Число | CSSNumericValue*/

тип CSSPerspectiveValue = Объект? /*(!)CSSNumericValue | CSSKeywordish*/

тип CSSUnparsedSegment = Объект? /*(!)Текст | CSSVariableReferenceValue*/

тип CanvasImageSource = Объект? /*(!)HTMLOrSVGImageElement | HTMLVideoElement | HTMLCanvasElement | ImageBitmap | OffscreenCanvas | VideoFrame*/

тип ClipboardItemData = Promise<Объект? /*(!)Текст | Blob*/>

тип ClipboardItems = Список<ClipboardItem>

тип ConstrainBoolean = Объект? /*(!)ДаНет | ConstrainBooleanParameters*/

тип ConstrainDOMString = Объект? /*(!)Текст | Список<Текст> | ConstrainDOMStringParameters*/

тип ConstrainDouble = Объект? /*(!)Число | ConstrainDoubleRange*/

тип ConstrainULong = Объект? /*(!)Число | ConstrainULongRange*/

тип DOMHighResTimeStamp = Число

тип EpochTimeStamp = Число

тип EventListenerOrEventListenerObject = Объект? /*(!)EventListener | EventListenerObject*/

тип FileSystemWriteChunkType = Объект? /*(!)BufferSource | Blob | Текст | WriteParams*/

тип Float32List = Объект? /*(!)Float32Array | Список<GLfloat>*/

тип FormDataEntryValue = Объект? /*(!)File | Текст*/

тип GLbitfield = Число

тип GLboolean = ДаНет

тип GLclampf = Число

тип GLenum = Число

тип GLfloat = Число

тип GLint = Число

тип GLint64 = Число

тип GLintptr = Число

тип GLsizei = Число

тип GLsizeiptr = Число

тип GLuint = Число

тип GLuint64 = Число

тип HTMLOrSVGImageElement = Объект? /*(!)HTMLImageElement | SVGImageElement*/

тип HTMLOrSVGScriptElement = Объект? /*(!)HTMLScriptElement | SVGScriptElement*/

тип HashAlgorithmIdentifier = AlgorithmIdentifier

тип HeadersInit = Объект? /*(!)Список<объект { _0: Текст, _1: Текст }> | Record<Текст, Текст> | Headers*/

тип IDBValidKey = Объект? /*(!)Число | Текст | Date | BufferSource | Список<IDBValidKey>*/

тип ImageBitmapSource = Объект? /*(!)CanvasImageSource | Blob | ImageData*/

тип Int32List = Объект? /*(!)Int32Array | Список<GLint>*/

тип LineAndPositionSetting = Объект? /*(!)Число | AutoKeyword*/

тип MediaProvider = Объект? /*(!)MediaStream | MediaSource | Blob*/

тип MessageEventSource = Объект? /*(!)WindowProxy | MessagePort | ServiceWorker*/

тип MutationRecordType = Объект? /*(!)"attributes" | "characterData" | "childList"*/

тип NamedCurve = Текст

тип OffscreenRenderingContext = Объект? /*(!)OffscreenCanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext*/

тип OnBeforeUnloadEventHandler = OnBeforeUnloadEventHandlerNonNull?

тип OnErrorEventHandler = OnErrorEventHandlerNonNull?

тип OptionalPostfixToken<T = Текст> = Объект? /*(!)/*(!) ` ${T}` */ Объект? | ""*/

тип OptionalPrefixToken<T = Текст> = Объект? /*(!)/*(!) `${T} ` */ Объект? | ""*/

тип PerformanceEntryList = Список<PerformanceEntry>

тип ReadableStreamController<T> = Объект? /*(!)ReadableStreamDefaultController<T> | ReadableByteStreamController*/

тип ReadableStreamReadResult<T> = Объект? /*(!)ReadableStreamReadValueResult<T> | ReadableStreamReadDoneResult<T>*/

тип ReadableStreamReader<T> = Объект? /*(!)ReadableStreamDefaultReader<T> | ReadableStreamBYOBReader*/

тип RenderingContext = Объект? /*(!)CanvasRenderingContext2D | ImageBitmapRenderingContext | WebGLRenderingContext | WebGL2RenderingContext*/

тип ReportList = Список<Report>

тип RequestInfo = Объект? /*(!)Request | Текст*/

тип TexImageSource = Объект? /*(!)ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | OffscreenCanvas | VideoFrame*/

тип TimerHandler = Объект? /*(!)Текст | Function*/

тип Transferable = Объект? /*(!)OffscreenCanvas | ImageBitmap | MessagePort | ReadableStream | WritableStream | TransformStream | VideoFrame | ArrayBuffer*/

тип Uint32List = Объект? /*(!)Uint32Array | Список<GLuint>*/

тип VibratePattern = Объект? /*(!)Число | Список<Число>*/

тип WindowProxy = Window

тип XMLHttpRequestBodyInit = Объект? /*(!)Blob | BufferSource | FormData | URLSearchParams | Текст*/

тип AlignSetting = Объект? /*(!)"center" | "end" | "left" | "right" | "start"*/

тип AlphaOption = Объект? /*(!)"discard" | "keep"*/

тип AnimationPlayState = Объект? /*(!)"finished" | "idle" | "paused" | "running"*/

тип AnimationReplaceState = Объект? /*(!)"active" | "persisted" | "removed"*/

тип AppendMode = Объект? /*(!)"segments" | "sequence"*/

тип AttestationConveyancePreference = Объект? /*(!)"direct" | "enterprise" | "indirect" | "none"*/

тип AudioContextLatencyCategory = Объект? /*(!)"balanced" | "interactive" | "playback"*/

тип AudioContextState = Объект? /*(!)"closed" | "running" | "suspended"*/

тип AuthenticatorAttachment = Объект? /*(!)"cross-platform" | "platform"*/

тип AuthenticatorTransport = Объект? /*(!)"ble" | "hybrid" | "internal" | "nfc" | "usb"*/

тип AutoFillAddressKind = Объект? /*(!)"billing" | "shipping"*/

тип AutoFillBase = Объект? /*(!)"" | "off" | "on"*/

тип AutoFillContactField = Объект? /*(!)"email" | "tel" | "tel-area-code" | "tel-country-code" | "tel-extension" | "tel-local" | "tel-local-prefix" | "tel-local-suffix" | "tel-national"*/

тип AutoFillContactKind = Объект? /*(!)"home" | "mobile" | "work"*/

тип AutoFillCredentialField = "webauthn"

тип AutoFillNormalField = Объект? /*(!)"additional-name" | "address-level1" | "address-level2" | "address-level3" | "address-level4" | "address-line1" | "address-line2" | "address-line3" | "bday-day" | "bday-month" | "bday-year" | "cc-csc" | "cc-exp" | "cc-exp-month" | "cc-exp-year" | "cc-family-name" | "cc-given-name" | "cc-name" | "cc-number" | "cc-type" | "country" | "country-name" | "current-password" | "family-name" | "given-name" | "honorific-prefix" | "honorific-suffix" | "name" | "new-password" | "one-time-code" | "organization" | "postal-code" | "street-address" | "transaction-amount" | "transaction-currency" | "username"*/

тип AutoKeyword = "auto"

тип AutomationRate = Объект? /*(!)"a-rate" | "k-rate"*/

тип AvcBitstreamFormat = Объект? /*(!)"annexb" | "avc"*/

тип BinaryType = Объект? /*(!)"arraybuffer" | "blob"*/

тип BiquadFilterType = Объект? /*(!)"allpass" | "bandpass" | "highpass" | "highshelf" | "lowpass" | "lowshelf" | "notch" | "peaking"*/

тип CSSMathOperator = Объект? /*(!)"clamp" | "invert" | "max" | "min" | "negate" | "product" | "sum"*/

тип CSSNumericBaseType = Объект? /*(!)"angle" | "flex" | "frequency" | "length" | "percent" | "resolution" | "time"*/

тип CanPlayTypeResult = Объект? /*(!)"" | "maybe" | "probably"*/

тип CanvasDirection = Объект? /*(!)"inherit" | "ltr" | "rtl"*/

тип CanvasFillRule = Объект? /*(!)"evenodd" | "nonzero"*/

тип CanvasFontKerning = Объект? /*(!)"auto" | "none" | "normal"*/

тип CanvasFontStretch = Объект? /*(!)"condensed" | "expanded" | "extra-condensed" | "extra-expanded" | "normal" | "semi-condensed" | "semi-expanded" | "ultra-condensed" | "ultra-expanded"*/

тип CanvasFontVariantCaps = Объект? /*(!)"all-petite-caps" | "all-small-caps" | "normal" | "petite-caps" | "small-caps" | "titling-caps" | "unicase"*/

тип CanvasLineCap = Объект? /*(!)"butt" | "round" | "square"*/

тип CanvasLineJoin = Объект? /*(!)"bevel" | "miter" | "round"*/

тип CanvasTextAlign = Объект? /*(!)"center" | "end" | "left" | "right" | "start"*/

тип CanvasTextBaseline = Объект? /*(!)"alphabetic" | "bottom" | "hanging" | "ideographic" | "middle" | "top"*/

тип CanvasTextRendering = Объект? /*(!)"auto" | "geometricPrecision" | "optimizeLegibility" | "optimizeSpeed"*/

тип ChannelCountMode = Объект? /*(!)"clamped-max" | "explicit" | "max"*/

тип ChannelInterpretation = Объект? /*(!)"discrete" | "speakers"*/

тип ClientTypes = Объект? /*(!)"all" | "sharedworker" | "window" | "worker"*/

тип CodecState = Объект? /*(!)"closed" | "configured" | "unconfigured"*/

тип ColorGamut = Объект? /*(!)"p3" | "rec2020" | "srgb"*/

тип ColorSpaceConversion = Объект? /*(!)"default" | "none"*/

тип CompositeOperation = Объект? /*(!)"accumulate" | "add" | "replace"*/

тип CompositeOperationOrAuto = Объект? /*(!)"accumulate" | "add" | "auto" | "replace"*/

тип CompressionFormat = Объект? /*(!)"deflate" | "deflate-raw" | "gzip"*/

тип CredentialMediationRequirement = Объект? /*(!)"conditional" | "optional" | "required" | "silent"*/

тип DOMParserSupportedType = Объект? /*(!)"application/xhtml+xml" | "application/xml" | "image/svg+xml" | "text/html" | "text/xml"*/

тип DirectionSetting = Объект? /*(!)"" | "lr" | "rl"*/

тип DisplayCaptureSurfaceType = Объект? /*(!)"browser" | "monitor" | "window"*/

тип DistanceModelType = Объект? /*(!)"exponential" | "inverse" | "linear"*/

тип DocumentReadyState = Объект? /*(!)"complete" | "interactive" | "loading"*/

тип DocumentVisibilityState = Объект? /*(!)"hidden" | "visible"*/

тип EncodedVideoChunkType = Объект? /*(!)"delta" | "key"*/

тип EndOfStreamError = Объект? /*(!)"decode" | "network"*/

тип EndingType = Объект? /*(!)"native" | "transparent"*/

тип FileSystemHandleKind = Объект? /*(!)"directory" | "file"*/

тип FillMode = Объект? /*(!)"auto" | "backwards" | "both" | "forwards" | "none"*/

тип FontDisplay = Объект? /*(!)"auto" | "block" | "fallback" | "optional" | "swap"*/

тип FontFaceLoadStatus = Объект? /*(!)"error" | "loaded" | "loading" | "unloaded"*/

тип FontFaceSetLoadStatus = Объект? /*(!)"loaded" | "loading"*/

тип FullscreenNavigationUI = Объект? /*(!)"auto" | "hide" | "show"*/

тип GamepadHapticActuatorType = "vibration"

тип GamepadHapticEffectType = "dual-rumble"

тип GamepadHapticsResult = Объект? /*(!)"complete" | "preempted"*/

тип GamepadMappingType = Объект? /*(!)"" | "standard" | "xr-standard"*/

тип GlobalCompositeOperation = Объект? /*(!)"color" | "color-burn" | "color-dodge" | "copy" | "darken" | "destination-atop" | "destination-in" | "destination-out" | "destination-over" | "difference" | "exclusion" | "hard-light" | "hue" | "lighten" | "lighter" | "luminosity" | "multiply" | "overlay" | "saturation" | "screen" | "soft-light" | "source-atop" | "source-in" | "source-out" | "source-over" | "xor"*/

тип HardwareAcceleration = Объект? /*(!)"no-preference" | "prefer-hardware" | "prefer-software"*/

тип HdrMetadataType = Объект? /*(!)"smpteSt2086" | "smpteSt2094-10" | "smpteSt2094-40"*/

тип IDBCursorDirection = Объект? /*(!)"next" | "nextunique" | "prev" | "prevunique"*/

тип IDBRequestReadyState = Объект? /*(!)"done" | "pending"*/

тип IDBTransactionDurability = Объект? /*(!)"default" | "relaxed" | "strict"*/

тип IDBTransactionMode = Объект? /*(!)"readonly" | "readwrite" | "versionchange"*/

тип ImageOrientation = Объект? /*(!)"flipY" | "from-image" | "none"*/

тип ImageSmoothingQuality = Объект? /*(!)"high" | "low" | "medium"*/

тип InsertPosition = Объект? /*(!)"afterbegin" | "afterend" | "beforebegin" | "beforeend"*/

тип IterationCompositeOperation = Объект? /*(!)"accumulate" | "replace"*/

тип KeyFormat = Объект? /*(!)"jwk" | "pkcs8" | "raw" | "spki"*/

тип KeyType = Объект? /*(!)"private" | "public" | "secret"*/

тип KeyUsage = Объект? /*(!)"decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey"*/

тип LatencyMode = Объект? /*(!)"quality" | "realtime"*/

тип LineAlignSetting = Объект? /*(!)"center" | "end" | "start"*/

тип LockMode = Объект? /*(!)"exclusive" | "shared"*/

тип MIDIPortConnectionState = Объект? /*(!)"closed" | "open" | "pending"*/

тип MIDIPortDeviceState = Объект? /*(!)"connected" | "disconnected"*/

тип MIDIPortType = Объект? /*(!)"input" | "output"*/

тип MediaDecodingType = Объект? /*(!)"file" | "media-source" | "webrtc"*/

тип MediaDeviceKind = Объект? /*(!)"audioinput" | "audiooutput" | "videoinput"*/

тип MediaEncodingType = Объект? /*(!)"record" | "webrtc"*/

тип MediaKeyMessageType = Объект? /*(!)"individualization-request" | "license-release" | "license-renewal" | "license-request"*/

тип MediaKeySessionClosedReason = Объект? /*(!)"closed-by-application" | "hardware-context-reset" | "internal-error" | "release-acknowledged" | "resource-evicted"*/

тип MediaKeySessionType = Объект? /*(!)"persistent-license" | "temporary"*/

тип MediaKeyStatus = Объект? /*(!)"expired" | "internal-error" | "output-downscaled" | "output-restricted" | "released" | "status-pending" | "usable" | "usable-in-future"*/

тип MediaKeysRequirement = Объект? /*(!)"not-allowed" | "optional" | "required"*/

тип MediaSessionAction = Объект? /*(!)"nexttrack" | "pause" | "play" | "previoustrack" | "seekbackward" | "seekforward" | "seekto" | "skipad" | "stop"*/

тип MediaSessionPlaybackState = Объект? /*(!)"none" | "paused" | "playing"*/

тип MediaStreamTrackState = Объект? /*(!)"ended" | "live"*/

тип NavigationTimingType = Объект? /*(!)"back_forward" | "navigate" | "prerender" | "reload"*/

тип NotificationDirection = Объект? /*(!)"auto" | "ltr" | "rtl"*/

тип NotificationPermission = Объект? /*(!)"default" | "denied" | "granted"*/

тип OffscreenRenderingContextId = Объект? /*(!)"2d" | "bitmaprenderer" | "webgl" | "webgl2" | "webgpu"*/

тип OrientationType = Объект? /*(!)"landscape-primary" | "landscape-secondary" | "portrait-primary" | "portrait-secondary"*/

тип OscillatorType = Объект? /*(!)"custom" | "sawtooth" | "sine" | "square" | "triangle"*/

тип OverSampleType = Объект? /*(!)"2x" | "4x" | "none"*/

тип PanningModelType = Объект? /*(!)"HRTF" | "equalpower"*/

тип PaymentComplete = Объект? /*(!)"fail" | "success" | "unknown"*/

тип PermissionName = Объект? /*(!)"geolocation" | "notifications" | "persistent-storage" | "push" | "screen-wake-lock" | "xr-spatial-tracking"*/

тип PermissionState = Объект? /*(!)"denied" | "granted" | "prompt"*/

тип PlaybackDirection = Объект? /*(!)"alternate" | "alternate-reverse" | "normal" | "reverse"*/

тип PositionAlignSetting = Объект? /*(!)"auto" | "center" | "line-left" | "line-right"*/

тип PredefinedColorSpace = Объект? /*(!)"display-p3" | "srgb"*/

тип PremultiplyAlpha = Объект? /*(!)"default" | "none" | "premultiply"*/

тип PresentationStyle = Объект? /*(!)"attachment" | "inline" | "unspecified"*/

тип PublicKeyCredentialType = "public-key"

тип PushEncryptionKeyName = Объект? /*(!)"auth" | "p256dh"*/

тип RTCBundlePolicy = Объект? /*(!)"balanced" | "max-bundle" | "max-compat"*/

тип RTCDataChannelState = Объект? /*(!)"closed" | "closing" | "connecting" | "open"*/

тип RTCDegradationPreference = Объект? /*(!)"balanced" | "maintain-framerate" | "maintain-resolution"*/

тип RTCDtlsTransportState = Объект? /*(!)"closed" | "connected" | "connecting" | "failed" | "new"*/

тип RTCEncodedVideoFrameType = Объект? /*(!)"delta" | "empty" | "key"*/

тип RTCErrorDetailType = Объект? /*(!)"data-channel-failure" | "dtls-failure" | "fingerprint-failure" | "hardware-encoder-error" | "hardware-encoder-not-available" | "sctp-failure" | "sdp-syntax-error"*/

тип RTCIceCandidateType = Объект? /*(!)"host" | "prflx" | "relay" | "srflx"*/

тип RTCIceComponent = Объект? /*(!)"rtcp" | "rtp"*/

тип RTCIceConnectionState = Объект? /*(!)"checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new"*/

тип RTCIceGathererState = Объект? /*(!)"complete" | "gathering" | "new"*/

тип RTCIceGatheringState = Объект? /*(!)"complete" | "gathering" | "new"*/

тип RTCIceProtocol = Объект? /*(!)"tcp" | "udp"*/

тип RTCIceTcpCandidateType = Объект? /*(!)"active" | "passive" | "so"*/

тип RTCIceTransportPolicy = Объект? /*(!)"all" | "relay"*/

тип RTCIceTransportState = Объект? /*(!)"checking" | "closed" | "completed" | "connected" | "disconnected" | "failed" | "new"*/

тип RTCPeerConnectionState = Объект? /*(!)"closed" | "connected" | "connecting" | "disconnected" | "failed" | "new"*/

тип RTCPriorityType = Объект? /*(!)"high" | "low" | "medium" | "very-low"*/

тип RTCRtcpMuxPolicy = "require"

тип RTCRtpTransceiverDirection = Объект? /*(!)"inactive" | "recvonly" | "sendonly" | "sendrecv" | "stopped"*/

тип RTCSctpTransportState = Объект? /*(!)"closed" | "connected" | "connecting"*/

тип RTCSdpType = Объект? /*(!)"answer" | "offer" | "pranswer" | "rollback"*/

тип RTCSignalingState = Объект? /*(!)"closed" | "have-local-offer" | "have-local-pranswer" | "have-remote-offer" | "have-remote-pranswer" | "stable"*/

тип RTCStatsIceCandidatePairState = Объект? /*(!)"failed" | "frozen" | "in-progress" | "inprogress" | "succeeded" | "waiting"*/

тип RTCStatsType = Объект? /*(!)"candidate-pair" | "certificate" | "codec" | "data-channel" | "inbound-rtp" | "local-candidate" | "media-source" | "outbound-rtp" | "peer-connection" | "remote-candidate" | "remote-inbound-rtp" | "remote-outbound-rtp" | "transport"*/

тип ReadableStreamReaderMode = "byob"

тип ReadableStreamType = "bytes"

тип ReadyState = Объект? /*(!)"closed" | "ended" | "open"*/

тип RecordingState = Объект? /*(!)"inactive" | "paused" | "recording"*/

тип ReferrerPolicy = Объект? /*(!)"" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url"*/

тип RemotePlaybackState = Объект? /*(!)"connected" | "connecting" | "disconnected"*/

тип RequestCache = Объект? /*(!)"default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload"*/

тип RequestCredentials = Объект? /*(!)"include" | "omit" | "same-origin"*/

тип RequestDestination = Объект? /*(!)"" | "audio" | "audioworklet" | "document" | "embed" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt"*/

тип RequestMode = Объект? /*(!)"cors" | "navigate" | "no-cors" | "same-origin"*/

тип RequestRedirect = Объект? /*(!)"error" | "follow" | "manual"*/

тип ResidentKeyRequirement = Объект? /*(!)"discouraged" | "preferred" | "required"*/

тип ResizeObserverBoxOptions = Объект? /*(!)"border-box" | "content-box" | "device-pixel-content-box"*/

тип ResizeQuality = Объект? /*(!)"high" | "low" | "medium" | "pixelated"*/

тип ResponseType = Объект? /*(!)"basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect"*/

тип ScrollBehavior = Объект? /*(!)"auto" | "instant" | "smooth"*/

тип ScrollLogicalPosition = Объект? /*(!)"center" | "end" | "nearest" | "start"*/

тип ScrollRestoration = Объект? /*(!)"auto" | "manual"*/

тип ScrollSetting = Объект? /*(!)"" | "up"*/

тип SecurityPolicyViolationEventDisposition = Объект? /*(!)"enforce" | "report"*/

тип SelectionMode = Объект? /*(!)"end" | "preserve" | "select" | "start"*/

тип ServiceWorkerState = Объект? /*(!)"activated" | "activating" | "installed" | "installing" | "parsed" | "redundant"*/

тип ServiceWorkerUpdateViaCache = Объект? /*(!)"all" | "imports" | "none"*/

тип ShadowRootMode = Объект? /*(!)"closed" | "open"*/

тип SlotAssignmentMode = Объект? /*(!)"manual" | "named"*/

тип SpeechSynthesisErrorCode = Объект? /*(!)"audio-busy" | "audio-hardware" | "canceled" | "interrupted" | "invalid-argument" | "language-unavailable" | "network" | "not-allowed" | "synthesis-failed" | "synthesis-unavailable" | "text-too-long" | "voice-unavailable"*/

тип TextTrackKind = Объект? /*(!)"captions" | "chapters" | "descriptions" | "metadata" | "subtitles"*/

тип TextTrackMode = Объект? /*(!)"disabled" | "hidden" | "showing"*/

тип TouchType = Объект? /*(!)"direct" | "stylus"*/

тип TransferFunction = Объект? /*(!)"hlg" | "pq" | "srgb"*/

тип UserVerificationRequirement = Объект? /*(!)"discouraged" | "preferred" | "required"*/

тип VideoColorPrimaries = Объект? /*(!)"bt470bg" | "bt709" | "smpte170m"*/

тип VideoEncoderBitrateMode = Объект? /*(!)"constant" | "quantizer" | "variable"*/

тип VideoFacingModeEnum = Объект? /*(!)"environment" | "left" | "right" | "user"*/

тип VideoMatrixCoefficients = Объект? /*(!)"bt470bg" | "bt709" | "rgb" | "smpte170m"*/

тип VideoPixelFormat = Объект? /*(!)"BGRA" | "BGRX" | "I420" | "I420A" | "I422" | "I444" | "NV12" | "RGBA" | "RGBX"*/

тип VideoTransferCharacteristics = Объект? /*(!)"bt709" | "iec61966-2-1" | "smpte170m"*/

тип WakeLockType = "screen"

тип WebGLPowerPreference = Объект? /*(!)"default" | "high-performance" | "low-power"*/

тип WebTransportCongestionControl = Объект? /*(!)"default" | "low-latency" | "throughput"*/

тип WebTransportErrorSource = Объект? /*(!)"session" | "stream"*/

тип WorkerType = Объект? /*(!)"classic" | "module"*/

тип WriteCommandType = Объект? /*(!)"seek" | "truncate" | "write"*/

тип XMLHttpRequestResponseType = Объект? /*(!)"" | "arraybuffer" | "blob" | "document" | "json" | "text"*/
